import { LngLat as He } from "maplibre-gl";
function x() {
  return x = Object.assign ? Object.assign.bind() : function(r) {
    for (var t = 1; t < arguments.length; t++) {
      var e = arguments[t];
      for (var i in e) ({}).hasOwnProperty.call(e, i) && (r[i] = e[i]);
    }
    return r;
  }, x.apply(null, arguments);
}
var b;
(function(r) {
  r.Commit = "commit", r.Provisional = "provisional", r.Finish = "finish";
})(b || (b = {}));
const k = { SELECTED: "selected", MID_POINT: "midPoint", SELECTION_POINT_FEATURE_ID: "selectionPointFeatureId", SELECTION_POINT: "selectionPoint" }, S = { MODE: "mode", CURRENTLY_DRAWING: "currentlyDrawing", EDITED: "edited", CLOSING_POINT: "closingPoint", SNAPPING_POINT: "snappingPoint", COORDINATE_POINT: "coordinatePoint", COORDINATE_POINT_FEATURE_ID: "coordinatePointFeatureId", COORDINATE_POINT_IDS: "coordinatePointIds", PROVISIONAL_COORDINATE_COUNT: "provisionalCoordinateCount", COMMITTED_COORDINATE_COUNT: "committedCoordinateCount" }, j = 10;
function Et(r) {
  return !!(r && typeof r == "object" && r !== null && !Array.isArray(r));
}
function Zt(r) {
  return !!(r && typeof r == "object" && "properties" in r && typeof r.properties == "object" && r.properties !== null && "mode" in r.properties);
}
function Qt(r) {
  return !!(function(t) {
    return typeof t == "number" && !isNaN(new Date(t).valueOf());
  })(r);
}
const Je = "Feature mode property does not match the mode being added to";
var H;
(function(r) {
  r.Drawing = "drawing", r.Select = "select", r.Static = "static", r.Render = "render";
})(H || (H = {}));
const qe = { rightClick: !0, contextMenu: !1, leftClick: !0, onDragStart: !0, onDrag: !0, onDragEnd: !0 };
class A {
  get state() {
    return this._state;
  }
  set state(t) {
    throw new Error("Please use the modes lifecycle methods");
  }
  get styles() {
    return this._styles;
  }
  set styles(t) {
    if (typeof t != "object") throw new Error("Styling must be an object");
    this.onStyleChange && this.onStyleChange([], "styling"), this._styles = t;
  }
  registerBehaviors(t) {
  }
  constructor(t, e = !1) {
    this._state = "unregistered", this._styles = {}, this.pointerEvents = qe, this.behaviors = [], this.validate = void 0, this.pointerDistance = 40, this.coordinatePrecision = void 0, this.onStyleChange = void 0, this.store = void 0, this.projection = "web-mercator", this.setDoubleClickToZoom = void 0, this.unproject = void 0, this.project = void 0, this.setCursor = void 0, this.type = H.Drawing, this.mode = "base", e || this.updateOptions(t);
  }
  updateOptions(t) {
    t != null && t.styles && (this.styles = x({}, this._styles, t.styles)), t != null && t.pointerDistance && (this.pointerDistance = t.pointerDistance), t != null && t.validation && (this.validate = t && t.validation), t != null && t.projection && (this.projection = t.projection), t?.pointerEvents !== void 0 && (this.pointerEvents = t.pointerEvents);
  }
  allowPointerEvent(t, e) {
    return typeof t == "boolean" ? t : typeof t != "function" || t(e);
  }
  setDrawing() {
    if (this._state !== "started") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "drawing";
  }
  setStarted() {
    if (this._state !== "stopped" && this._state !== "registered" && this._state !== "drawing" && this._state !== "selecting") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "started", this.setDoubleClickToZoom(!1);
  }
  setStopped() {
    if (this._state !== "started") throw new Error("Mode must be started to be stopped");
    this._state = "stopped", this.setDoubleClickToZoom(!0);
  }
  register(t) {
    if (this._state !== "unregistered") throw new Error("Can not register unless mode is unregistered");
    this._state = "registered", this.store = t.store, this.store.registerOnChange(t.onChange), this.setDoubleClickToZoom = t.setDoubleClickToZoom, this.project = t.project, this.unproject = t.unproject, this.onSelect = t.onSelect, this.onDeselect = t.onDeselect, this.setCursor = t.setCursor, this.onStyleChange = t.onChange, this.onFinish = t.onFinish, this.coordinatePrecision = t.coordinatePrecision, this.registerBehaviors({ mode: t.mode, store: this.store, project: this.project, unproject: this.unproject, pointerDistance: this.pointerDistance, coordinatePrecision: t.coordinatePrecision, projection: this.projection });
  }
  validateFeature(t) {
    return this.performFeatureValidation(t);
  }
  afterFeatureAdded(t) {
  }
  afterFeatureUpdated(t) {
  }
  performFeatureValidation(t) {
    if (this._state === "unregistered") throw new Error("Mode must be registered");
    const e = (function(i, o) {
      let s;
      if (Et(i)) if (i.id == null) s = "Feature has no id";
      else if (typeof i.id != "string" && typeof i.id != "number") s = "Feature must be string or number as per GeoJSON spec";
      else if (o(i.id)) if (Et(i.geometry)) if (Et(i.properties)) if (typeof i.geometry.type == "string" && ["Polygon", "LineString", "Point"].includes(i.geometry.type)) if (Array.isArray(i.geometry.coordinates)) {
        if (!i.properties.mode || typeof i.properties.mode != "string") return { valid: !1, reason: "Feature does not have a valid mode property" };
      } else s = "Feature coordinates is not an array";
      else s = "Feature is not Point, LineString or Polygon";
      else s = "Feature has no properties";
      else s = "Feature has no geometry";
      else s = "Feature must match the id strategy (default is UUID4)";
      else s = "Feature is not object";
      return s ? { valid: !1, reason: s } : { valid: !0 };
    })(t, this.store.idStrategy.isValidId);
    if (this.validate) {
      const i = this.validate(t, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Provisional });
      return { valid: e.valid && i.valid, reason: i.reason };
    }
    return { valid: e.valid, reason: e.reason };
  }
  validateModeFeature(t, e) {
    const i = this.performFeatureValidation(t);
    return i.valid ? t.properties.mode !== this.mode ? { valid: !1, reason: Je } : e(t) : { valid: !1, reason: i.reason };
  }
  onFinish(t, e) {
  }
  onDeselect(t) {
  }
  onSelect(t) {
  }
  onKeyDown(t) {
  }
  onKeyUp(t) {
  }
  onMouseMove(t) {
  }
  onClick(t) {
  }
  onDragStart(t, e) {
  }
  onDrag(t, e) {
  }
  onDragEnd(t, e) {
  }
  getHexColorStylingValue(t, e, i) {
    return this.getStylingValue(t, e, i);
  }
  getNumericStylingValue(t, e, i) {
    return this.getStylingValue(t, e, i);
  }
  getStylingValue(t, e, i) {
    return t === void 0 ? e : typeof t == "function" ? t(i) : t;
  }
}
let Ze = class extends A {
  constructor(...t) {
    super(...t), this.type = H.Select;
  }
};
function U(r, t) {
  const e = (d) => d * Math.PI / 180, i = e(r[1]), o = e(r[0]), s = e(t[1]), n = s - i, a = e(t[0]) - o, l = Math.sin(n / 2) * Math.sin(n / 2) + Math.cos(i) * Math.cos(s) * Math.sin(a / 2) * Math.sin(a / 2);
  return 2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)) * 6371e3 / 1e3;
}
const Ie = 63710088e-1;
function D(r) {
  return r % 360 * Math.PI / 180;
}
function xe(r) {
  return r / 6371.0088;
}
function V(r) {
  return r % (2 * Math.PI) * 180 / Math.PI;
}
function w(r, t = 9) {
  const e = Math.pow(10, t);
  return Math.round(r * e) / e;
}
const te = 57.29577951308232, ee = 0.017453292519943295, St = 6378137, O = (r, t) => ({ x: r === 0 ? 0 : r * ee * St, y: t === 0 ? 0 : Math.log(Math.tan(Math.PI / 4 + t * ee / 2)) * St }), R = (r, t) => ({ lng: r === 0 ? 0 : te * (r / St), lat: t === 0 ? 0 : (2 * Math.atan(Math.exp(t / St)) - Math.PI / 2) * te });
function Qe(r, t, e) {
  const i = D(r[0]), o = D(r[1]), s = D(e), n = xe(t), a = Math.asin(Math.sin(o) * Math.cos(n) + Math.cos(o) * Math.sin(n) * Math.cos(s));
  return [V(i + Math.atan2(Math.sin(s) * Math.sin(n) * Math.cos(o), Math.cos(n) - Math.sin(o) * Math.sin(a))), V(a)];
}
function ie(r) {
  const { center: t, radiusKilometers: e, coordinatePrecision: i } = r, o = r.steps ? r.steps : 64, s = [];
  for (let n = 0; n < o; n++) {
    const a = Qe(t, e, -360 * n / o);
    s.push([w(a[0], i), w(a[1], i)]);
  }
  return s.push(s[0]), { type: "Feature", geometry: { type: "Polygon", coordinates: [s] }, properties: {} };
}
function Bt(r) {
  let t;
  if (r.geometry.type === "Polygon") t = r.geometry.coordinates;
  else {
    if (r.geometry.type !== "LineString") throw new Error("Self intersects only accepts Polygons and LineStrings");
    t = [r.geometry.coordinates];
  }
  const e = [];
  for (let s = 0; s < t.length; s++) for (let n = 0; n < t[s].length - 1; n++) for (let a = 0; a < t.length; a++) for (let l = 0; l < t[a].length - 1; l++) o(s, n, a, l);
  return e.length > 0;
  function i(s) {
    return s < 0 || s > 1;
  }
  function o(s, n, a, l) {
    const d = t[s][n], c = t[s][n + 1], h = t[a][l], u = t[a][l + 1], p = (function(m, v, C, f) {
      if (gt(m, C) || gt(m, f) || gt(v, C) || gt(f, C)) return null;
      const P = m[0], I = m[1], E = v[0], L = v[1], M = C[0], N = C[1], _ = f[0], T = f[1], $ = (P - E) * (N - T) - (I - L) * (M - _);
      return $ === 0 ? null : [((P * L - I * E) * (M - _) - (P - E) * (M * T - N * _)) / $, ((P * L - I * E) * (N - T) - (I - L) * (M * T - N * _)) / $];
    })(d, c, h, u);
    if (p === null) return;
    let g, y;
    g = c[0] !== d[0] ? (p[0] - d[0]) / (c[0] - d[0]) : (p[1] - d[1]) / (c[1] - d[1]), y = u[0] !== h[0] ? (p[0] - h[0]) / (u[0] - h[0]) : (p[1] - h[1]) / (u[1] - h[1]), i(g) || i(y) || (p.toString(), e.push(p));
  }
}
function gt(r, t) {
  return r[0] === t[0] && r[1] === t[1];
}
function Ot(r, t) {
  return oe(r[0]) <= t && oe(r[1]) <= t;
}
function jt(r) {
  return r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number" && r[0] !== 1 / 0 && r[1] !== 1 / 0 && (e = r[0]) >= -180 && e <= 180 && (t = r[1]) >= -90 && t <= 90;
  var t, e;
}
function oe(r) {
  let t = 1, e = 0;
  for (; Math.round(r * t) / t !== r; ) t *= 10, e++;
  return e;
}
const ti = "Feature has holes", ei = "Feature has less than 4 coordinates", ii = "Feature has invalid coordinates", oi = "Feature coordinates are not closed";
function bt(r, t) {
  if (r.geometry.type !== "Polygon") return { valid: !1, reason: "Feature is not a Polygon" };
  if (r.geometry.coordinates.length !== 1) return { valid: !1, reason: ti };
  if (r.geometry.coordinates[0].length < 4) return { valid: !1, reason: ei };
  for (let o = 0; o < r.geometry.coordinates[0].length; o++) {
    if (!jt(r.geometry.coordinates[0][o])) return { valid: !1, reason: ii };
    if (!Ot(r.geometry.coordinates[0][o], t)) return { valid: !1, reason: "Feature has coordinates with excessive precision" };
  }
  return (e = r.geometry.coordinates[0][0])[0] !== (i = r.geometry.coordinates[0][r.geometry.coordinates[0].length - 1])[0] || e[1] !== i[1] ? { valid: !1, reason: oi } : { valid: !0 };
  var e, i;
}
function ut(r, t) {
  const e = bt(r, t);
  return e.valid ? Bt(r) ? { valid: !1, reason: "Feature intersects itself" } : { valid: !0 } : e;
}
const si = { cancel: "Escape", finish: "Enter" }, ri = { start: "crosshair" };
let Oe = class extends A {
  constructor(t) {
    super(t, !0), this.mode = "circle", this.center = void 0, this.clickCount = 0, this.currentCircleId = void 0, this.keyEvents = si, this.cursors = ri, this.startingRadiusKilometers = 1e-5, this.cursorMovedAfterInitialCursorDown = !1, this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors)), t?.keyEvents === null ? this.keyEvents = { cancel: null, finish: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents)), t != null && t.startingRadiusKilometers && (this.startingRadiusKilometers = t.startingRadiusKilometers);
  }
  close() {
    if (this.currentCircleId === void 0) return;
    this.store.updateProperty([{ id: this.currentCircleId, property: S.CURRENTLY_DRAWING, value: void 0 }]);
    const t = this.currentCircleId;
    if (this.validate && t) {
      const e = this.store.getGeometryCopy(t);
      if (!this.validate({ type: "Feature", id: t, geometry: e, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Finish }).valid) return;
    }
    this.cursorMovedAfterInitialCursorDown = !1, this.center = void 0, this.currentCircleId = void 0, this.clickCount = 0, this.state === "drawing" && this.setStarted(), this.onFinish(t, { mode: this.mode, action: "draw" });
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(t) {
    if (t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t)) if (this.clickCount === 0) {
      this.center = [t.lng, t.lat];
      const e = ie({ center: this.center, radiusKilometers: this.startingRadiusKilometers, coordinatePrecision: this.coordinatePrecision }), [i] = this.store.create([{ geometry: e.geometry, properties: { mode: this.mode, radiusKilometers: this.startingRadiusKilometers, [S.CURRENTLY_DRAWING]: !0 } }]);
      this.currentCircleId = i, this.clickCount++, this.cursorMovedAfterInitialCursorDown = !1, this.setDrawing();
    } else this.clickCount === 1 && this.center && this.currentCircleId !== void 0 && this.cursorMovedAfterInitialCursorDown && this.updateCircle(t), this.close();
  }
  onMouseMove(t) {
    this.cursorMovedAfterInitialCursorDown = !0, this.updateCircle(t);
  }
  onKeyDown() {
  }
  onKeyUp(t) {
    t.key === this.keyEvents.cancel ? this.cleanUp() : t.key === this.keyEvents.finish && this.close();
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  cleanUp() {
    const t = this.currentCircleId;
    this.center = void 0, this.currentCircleId = void 0, this.clickCount = 0, this.state === "drawing" && this.setStarted();
    try {
      t !== void 0 && this.store.delete([t]);
    } catch {
    }
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    return t.type === "Feature" && t.geometry.type === "Polygon" && t.properties.mode === this.mode && (e.polygonFillColor = this.getHexColorStylingValue(this.styles.fillColor, e.polygonFillColor, t), e.polygonOutlineColor = this.getHexColorStylingValue(this.styles.outlineColor, e.polygonOutlineColor, t), e.polygonOutlineWidth = this.getNumericStylingValue(this.styles.outlineWidth, e.polygonOutlineWidth, t), e.polygonFillOpacity = this.getNumericStylingValue(this.styles.fillOpacity, e.polygonFillOpacity, t), e.zIndex = j), e;
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => ut(e, this.coordinatePrecision));
  }
  updateCircle(t) {
    if (this.clickCount === 1 && this.center && this.currentCircleId) {
      const e = U(this.center, [t.lng, t.lat]);
      let i;
      if (this.projection === "web-mercator") {
        const o = (function(s, n) {
          const a = 1e3 * U(s, n);
          if (a === 0) return 1;
          const { x: l, y: d } = O(s[0], s[1]), { x: c, y: h } = O(n[0], n[1]);
          return Math.sqrt(Math.pow(c - l, 2) + Math.pow(h - d, 2)) / a;
        })(this.center, [t.lng, t.lat]);
        i = (function(s) {
          const { center: n, radiusKilometers: a, coordinatePrecision: l } = s, d = s.steps ? s.steps : 64, c = 1e3 * a, [h, u] = n, { x: p, y: g } = O(h, u), y = [];
          for (let m = 0; m < d; m++) {
            const v = 360 * m / d * Math.PI / 180, C = c * Math.cos(v), f = c * Math.sin(v), [P, I] = [p + C, g + f], { lng: E, lat: L } = R(P, I);
            y.push([w(E, l), w(L, l)]);
          }
          return y.push(y[0]), { type: "Feature", geometry: { type: "Polygon", coordinates: [y] }, properties: {} };
        })({ center: this.center, radiusKilometers: e * o, coordinatePrecision: this.coordinatePrecision });
      } else {
        if (this.projection !== "globe") throw new Error("Invalid projection");
        i = ie({ center: this.center, radiusKilometers: e, coordinatePrecision: this.coordinatePrecision });
      }
      if (this.validate && !this.validate({ type: "Feature", id: this.currentCircleId, geometry: i.geometry, properties: { radiusKilometers: e } }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Provisional }).valid) return;
      this.store.updateGeometry([{ id: this.currentCircleId, geometry: i.geometry }]), this.store.updateProperty([{ id: this.currentCircleId, property: "radiusKilometers", value: e }]);
    }
  }
  afterFeatureUpdated(t) {
    this.currentCircleId === t.id && (this.cursorMovedAfterInitialCursorDown = !1, this.center = void 0, this.currentCircleId = void 0, this.clickCount = 0, this.state === "drawing" && this.setStarted());
  }
};
const F = (r, t) => {
  const { x: e, y: i } = r, { x: o, y: s } = t, n = o - e, a = s - i;
  return Math.sqrt(a * a + n * n);
};
function pt(r) {
  if (!(function(e) {
    const i = e.coordinates[0];
    let o = 0;
    for (let s = 0; s < i.length - 1; s++) {
      const [n, a] = i[s], [l, d] = i[s + 1];
      o += (l - n) * (d + a);
    }
    return o < 0;
  })(r)) return { type: "Polygon", coordinates: [r.coordinates[0].reverse()] };
}
const ni = { cancel: "Escape", finish: "Enter" }, ai = { start: "crosshair", close: "pointer" };
class be extends A {
  constructor(t) {
    super(t, !0), this.mode = "freehand", this.startingClick = !1, this.currentId = void 0, this.closingPointId = void 0, this.minDistance = 20, this.keyEvents = ni, this.cursors = ai, this.preventPointsNearClose = !0, this.autoClose = !1, this.autoCloseTimeout = 500, this.hasLeftStartingPoint = !1, this.preventNewFeature = !1, this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.minDistance && (this.minDistance = t.minDistance), t?.preventPointsNearClose !== void 0 && (this.preventPointsNearClose = t.preventPointsNearClose), t?.autoClose !== void 0 && (this.autoClose = t.autoClose), t != null && t.autoCloseTimeout && (this.autoCloseTimeout = t.autoCloseTimeout), t?.keyEvents === null ? this.keyEvents = { cancel: null, finish: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents)), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors));
  }
  close() {
    if (this.currentId === void 0) return;
    if (this.currentId) {
      const e = pt(this.store.getGeometryCopy(this.currentId));
      e && this.store.updateGeometry([{ id: this.currentId, geometry: e }]), this.store.updateProperty([{ id: this.currentId, property: S.CURRENTLY_DRAWING, value: void 0 }]);
    }
    const t = this.currentId;
    if (this.validate && t) {
      const e = this.store.getGeometryCopy(t);
      if (!this.validate({ type: "Feature", id: t, geometry: e, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Finish }).valid) return;
    }
    this.closingPointId && this.store.delete([this.closingPointId]), this.startingClick = !1, this.currentId = void 0, this.closingPointId = void 0, this.hasLeftStartingPoint = !1, this.state === "drawing" && this.setStarted(), this.onFinish(t, { mode: this.mode, action: "draw" });
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(t) {
    if (this.currentId === void 0 || this.startingClick === !1) return void this.setCursor(this.cursors.start);
    const e = this.store.getGeometryCopy(this.currentId), i = e.coordinates[0].length - 2, [o, s] = e.coordinates[0][i], { x: n, y: a } = this.project(o, s), l = F({ x: n, y: a }, { x: t.containerX, y: t.containerY }), [d, c] = e.coordinates[0][0], { x: h, y: u } = this.project(d, c);
    if (F({ x: h, y: u }, { x: t.containerX, y: t.containerY }) < this.pointerDistance) {
      if (this.autoClose && this.hasLeftStartingPoint && (this.preventNewFeature = !0, setTimeout(() => {
        this.preventNewFeature = !1;
      }, this.autoCloseTimeout), this.close()), this.setCursor(this.cursors.close), this.preventPointsNearClose) return;
    } else this.hasLeftStartingPoint = !0, this.setCursor(this.cursors.start);
    if (l < this.minDistance) return;
    e.coordinates[0].pop();
    const p = { type: "Polygon", coordinates: [[...e.coordinates[0], [t.lng, t.lat], e.coordinates[0][0]]] };
    this.validate && !this.validate({ type: "Feature", id: this.currentId, geometry: p, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Provisional }).valid || this.store.updateGeometry([{ id: this.currentId, geometry: p }]);
  }
  onClick(t) {
    if (t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t)) {
      if (this.preventNewFeature) return;
      if (this.startingClick === !1) {
        const [e, i] = this.store.create([{ geometry: { type: "Polygon", coordinates: [[[t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat]]] }, properties: { mode: this.mode, [S.CURRENTLY_DRAWING]: !0 } }, { geometry: { type: "Point", coordinates: [t.lng, t.lat] }, properties: { mode: this.mode, [S.CLOSING_POINT]: !0 } }]);
        return this.currentId = e, this.closingPointId = i, this.startingClick = !0, void (this.state !== "drawing" && this.setDrawing());
      }
      this.close();
    }
  }
  onKeyDown() {
  }
  onKeyUp(t) {
    t.key === this.keyEvents.cancel ? this.cleanUp() : t.key === this.keyEvents.finish && this.startingClick === !0 && this.close();
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  cleanUp() {
    const t = this.currentId, e = this.closingPointId;
    this.closingPointId = void 0, this.currentId = void 0, this.startingClick = !1, this.state === "drawing" && this.setStarted();
    try {
      t !== void 0 && this.store.delete([t]), e !== void 0 && this.store.delete([e]);
    } catch {
    }
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    return t.type === "Feature" && t.geometry.type === "Polygon" && t.properties.mode === this.mode ? (e.polygonFillColor = this.getHexColorStylingValue(this.styles.fillColor, e.polygonFillColor, t), e.polygonOutlineColor = this.getHexColorStylingValue(this.styles.outlineColor, e.polygonOutlineColor, t), e.polygonOutlineWidth = this.getNumericStylingValue(this.styles.outlineWidth, e.polygonOutlineWidth, t), e.polygonFillOpacity = this.getNumericStylingValue(this.styles.fillOpacity, e.polygonFillOpacity, t), e.zIndex = j, e) : (t.type === "Feature" && t.geometry.type === "Point" && t.properties.mode === this.mode && (e.pointWidth = this.getNumericStylingValue(this.styles.closingPointWidth, e.pointWidth, t), e.pointColor = this.getHexColorStylingValue(this.styles.closingPointColor, e.pointColor, t), e.pointOutlineColor = this.getHexColorStylingValue(this.styles.closingPointOutlineColor, e.pointOutlineColor, t), e.pointOutlineWidth = this.getNumericStylingValue(this.styles.closingPointOutlineWidth, 2, t), e.zIndex = 50), e);
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => bt(e, this.coordinatePrecision));
  }
  afterFeatureUpdated(t) {
    this.currentId === t.id && (this.closingPointId && this.store.delete([this.closingPointId]), this.startingClick = !1, this.currentId = void 0, this.closingPointId = void 0, this.hasLeftStartingPoint = !1);
  }
}
let B = class {
  constructor({ store: t, mode: e, project: i, unproject: o, pointerDistance: s, coordinatePrecision: n, projection: a }) {
    this.store = void 0, this.mode = void 0, this.project = void 0, this.unproject = void 0, this.pointerDistance = void 0, this.coordinatePrecision = void 0, this.projection = void 0, this.store = t, this.mode = e, this.project = i, this.unproject = o, this.pointerDistance = s, this.coordinatePrecision = n, this.projection = a;
  }
};
function Ee({ unproject: r, point: t, pointerDistance: e }) {
  const i = e / 2, { x: o, y: s } = t;
  return { type: "Feature", properties: {}, geometry: { type: "Polygon", coordinates: [[r(o - i, s - i), r(o + i, s - i), r(o + i, s + i), r(o - i, s + i), r(o - i, s - i)].map((n) => [n.lng, n.lat])] } };
}
class dt extends B {
  constructor(t) {
    super(t);
  }
  create(t) {
    const { containerX: e, containerY: i } = t;
    return Ee({ unproject: this.unproject, point: { x: e, y: i }, pointerDistance: this.pointerDistance });
  }
}
class ct extends B {
  constructor(t) {
    super(t);
  }
  measure(t, e) {
    const { x: i, y: o } = this.project(e[0], e[1]);
    return F({ x: i, y: o }, { x: t.containerX, y: t.containerY });
  }
}
let It = class extends B {
  constructor(t, e, i) {
    super(t), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (o) => this.getSnappable(o, (s) => !!(s.properties && s.properties.mode === this.mode)).coordinate, this.getSnappableCoordinate = (o, s) => this.getSnappable(o, (n) => !!(n.properties && n.properties.mode === this.mode && n.id !== s)).coordinate, this.config = t, this.pixelDistance = e, this.clickBoundingBox = i;
  }
  getSnappable(t, e) {
    const i = this.clickBoundingBox.create(t), o = this.store.search(i, e), s = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDist: 1 / 0 };
    return o.forEach((n) => {
      let a;
      if (n.geometry.type === "Polygon") a = n.geometry.coordinates[0];
      else {
        if (n.geometry.type !== "LineString") return;
        a = n.geometry.coordinates;
      }
      a.forEach((l, d) => {
        const c = this.pixelDistance.measure(t, l);
        c < s.minDist && c < this.pointerDistance && (s.coordinate = l, s.minDist = c, s.featureId = n.id, s.featureCoordinateIndex = d);
      });
    }), s;
  }
};
function se(r, t, e) {
  const i = D(r[0]), o = D(r[1]), s = D(e), n = xe(t), a = Math.asin(Math.sin(o) * Math.cos(n) + Math.cos(o) * Math.sin(n) * Math.cos(s));
  return [V(i + Math.atan2(Math.sin(s) * Math.sin(n) * Math.cos(o), Math.cos(n) - Math.sin(o) * Math.sin(a))), V(a)];
}
function ht({ x: r, y: t }, e, i) {
  const o = D(i);
  return { x: r + e * Math.cos(o), y: t + e * Math.sin(o) };
}
function re(r, t) {
  const e = D(r[0]), i = D(t[0]), o = D(r[1]), s = D(t[1]), n = Math.sin(i - e) * Math.cos(s), a = Math.cos(o) * Math.sin(s) - Math.sin(o) * Math.cos(s) * Math.cos(i - e);
  return V(Math.atan2(n, a));
}
function G({ x: r, y: t }, { x: e, y: i }) {
  const o = e - r, s = i - t;
  if (o === 0 && s === 0) return 0;
  let n = Math.atan2(s, o);
  return n *= 180 / Math.PI, n > 180 ? n -= 360 : n < -180 && (n += 360), n;
}
function X(r) {
  return (r + 360) % 360;
}
function li(r, t, e) {
  const i = [], o = r.length;
  let s, n, a, l = 0;
  for (let c = 0; c < r.length && !(t >= l && c === r.length - 1); c++) {
    if (l > t && i.length === 0) {
      if (s = t - l, !s) return i.push(r[c]), i;
      n = re(r[c], r[c - 1]) - 180, a = se(r[c], s, n), i.push(a);
    }
    if (l >= e) return s = e - l, s ? (n = re(r[c], r[c - 1]) - 180, a = se(r[c], s, n), i.push(a), i) : (i.push(r[c]), i);
    if (l >= t && i.push(r[c]), c === r.length - 1) return i;
    l += U(r[c], r[c + 1]);
  }
  if (l < t && r.length === o) throw new Error("Start position is beyond line");
  const d = r[r.length - 1];
  return [d, d];
}
function yt(r) {
  return r * (Math.PI / 180);
}
function ne(r) {
  return r * (180 / Math.PI);
}
class di extends B {
  constructor(t) {
    super(t), this.config = void 0, this.config = t;
  }
  generateInsertionCoordinates(t, e, i) {
    const o = [t, e];
    let s = 0;
    for (let d = 0; d < o.length - 1; d++) s += U(o[0], o[1]);
    if (s <= i) return o;
    let n = s / i - 1;
    Number.isInteger(n) || (n = Math.floor(n) + 1);
    const a = [];
    for (let d = 0; d < n; d++) {
      const c = li(o, i * d, i * (d + 1));
      a.push(c);
    }
    const l = [];
    for (let d = 0; d < a.length; d++) l.push(a[d][1]);
    return this.limitCoordinates(l);
  }
  generateInsertionGeodesicCoordinates(t, e, i) {
    const o = U(t, e), s = (function(n, a, l) {
      const d = [], c = yt(n[1]), h = yt(n[0]), u = yt(a[1]), p = yt(a[0]);
      l += 1;
      const g = 2 * Math.asin(Math.sqrt(Math.sin((u - c) / 2) ** 2 + Math.cos(c) * Math.cos(u) * Math.sin((p - h) / 2) ** 2));
      if (g === 0 || isNaN(g)) return d;
      for (let y = 0; y <= l; y++) {
        const m = y / l, v = Math.sin((1 - m) * g) / Math.sin(g), C = Math.sin(m * g) / Math.sin(g), f = v * Math.cos(c) * Math.cos(h) + C * Math.cos(u) * Math.cos(p), P = v * Math.cos(c) * Math.sin(h) + C * Math.cos(u) * Math.sin(p), I = v * Math.sin(c) + C * Math.sin(u);
        if (isNaN(f) || isNaN(P) || isNaN(I)) continue;
        const E = Math.atan2(I, Math.sqrt(f ** 2 + P ** 2)), L = Math.atan2(P, f);
        isNaN(E) || isNaN(L) || d.push([ne(L), ne(E)]);
      }
      return d.slice(1, -1);
    })(t, e, Math.floor(o / i));
    return this.limitCoordinates(s);
  }
  limitCoordinates(t) {
    return t.map((e) => [w(e[0], this.config.coordinatePrecision), w(e[1], this.config.coordinatePrecision)]);
  }
}
function tt(r, t) {
  return r[0] === t[0] && r[1] === t[1];
}
function At(r, t) {
  if (r.geometry.type !== "LineString") return { valid: !1, reason: "Feature is not a LineString" };
  if (r.geometry.coordinates.length < 2) return { valid: !1, reason: "Feature has less than 2 coordinates" };
  for (let e = 0; e < r.geometry.coordinates.length; e++) {
    if (!jt(r.geometry.coordinates[e])) return { valid: !1, reason: "Feature has invalid coordinates" };
    if (!Ot(r.geometry.coordinates[e], t)) return { valid: !1, reason: "Feature has coordinates with excessive precision" };
  }
  return { valid: !0 };
}
function ae(r) {
  return Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2));
}
function Y(r, t) {
  const e = (function(i, o) {
    const [s, n, a] = i, [l, d, c] = o;
    return s * l + n * d + a * c;
  })(r, t) / (ae(r) * ae(t));
  return Math.acos(Math.min(Math.max(e, -1), 1));
}
function wt(r) {
  const t = D(r[1]), e = D(r[0]);
  return [Math.cos(t) * Math.cos(e), Math.cos(t) * Math.sin(e), Math.sin(t)];
}
function K(r) {
  const [t, e, i] = r, o = V(Math.asin(i));
  return [V(Math.atan2(e, t)), o];
}
function ci(r, t, e) {
  const i = wt(r), o = wt(t), s = wt(e), [n, a, l] = s, [d, c, h] = (function(T, $) {
    const [Yt, Kt, Xt] = T, [Ht, Jt, qt] = $;
    return [Kt * qt - Xt * Jt, Xt * Ht - Yt * qt, Yt * Jt - Kt * Ht];
  })(i, o), u = c * l - h * a, p = h * n - d * l, g = d * a - c * n, y = g * c - p * h, m = u * h - g * d, v = p * d - u * c, C = 1 / Math.sqrt(Math.pow(y, 2) + Math.pow(m, 2) + Math.pow(v, 2)), f = [y * C, m * C, v * C], P = [-1 * y * C, -1 * m * C, -1 * v * C], I = Y(i, o), E = Y(i, f), L = Y(o, f), M = Y(i, P), N = Y(o, P);
  let _;
  return _ = E < M && E < N || L < M && L < N ? f : P, Y(i, _) > I || Y(o, _) > I ? U(K(_), K(i)) <= U(K(_), K(o)) ? [K(i), !0, !1] : [K(o), !1, !0] : [K(_), !1, !1];
}
function hi(r, t, e) {
  const i = t.x - r.x, o = t.y - r.y, s = Math.max(0, Math.min(1, ((e.x - r.x) * i + (e.y - r.y) * o) / (i * i + o * o)));
  return { x: r.x + s * i, y: r.y + s * o };
}
class Rt extends B {
  constructor(t, e, i) {
    super(t), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (o) => {
      const s = this.getSnappable(o, (n) => !!(n.properties && n.properties.mode === this.mode));
      return s.coordinate ? [w(s.coordinate[0], this.config.coordinatePrecision), w(s.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.getSnappableCoordinate = (o, s) => {
      const n = this.getSnappable(o, (a) => !!(a.properties && a.properties.mode === this.mode && a.id !== s));
      return n.coordinate ? [w(n.coordinate[0], this.config.coordinatePrecision), w(n.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.config = t, this.pixelDistance = e, this.clickBoundingBox = i;
  }
  getSnappable(t, e) {
    const i = this.clickBoundingBox.create(t), o = this.store.search(i, e), s = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDistance: 1 / 0 };
    return o.forEach((n) => {
      let a;
      if (n.geometry.type === "Polygon") a = n.geometry.coordinates[0];
      else {
        if (n.geometry.type !== "LineString") return;
        a = n.geometry.coordinates;
      }
      const l = [];
      for (let u = 0; u < a.length - 1; u++) l.push([a[u], a[u + 1]]);
      let d;
      const c = [t.lng, t.lat];
      if (this.config.projection === "web-mercator" ? d = (function(u, p) {
        let g = [1 / 0, 1 / 0], y = 1 / 0, m = 0;
        for (let v of p) {
          const C = v[0], f = v[1];
          let P, I = 1 / 0;
          const E = O(C[0], C[1]), L = O(f[0], f[1]), M = O(u[0], u[1]);
          if (C[0] === u[0] && C[1] === u[1]) P = C;
          else if (f[0] === u[0] && f[1] === u[1]) P = f;
          else {
            const { x: N, y: _ } = hi(E, L, M), { lng: T, lat: $ } = R(N, _);
            P = [T, $];
          }
          P && (I = F(M, O(P[0], P[1])), I < y && (g = P, y = I, m = p.indexOf(v)));
        }
        return y === 1 / 0 ? void 0 : { coordinate: g, lineIndex: m, distance: y };
      })(c, l) : this.config.projection === "globe" && (d = (function(u, p) {
        let g = [1 / 0, 1 / 0], y = 1 / 0, m = 0;
        for (let v of p) {
          const C = v[0], f = v[1];
          let P, I = 1 / 0;
          C[0] === u[0] && C[1] === u[1] ? P = C : f[0] === u[0] && f[1] === u[1] ? P = f : [P] = ci(C, f, u), P && (I = U(u, P), I < y && (g = P, y = I, m = p.indexOf(v)));
        }
        return y === 1 / 0 ? void 0 : { coordinate: g, distance: y, lineIndex: m };
      })(c, l)), !d) return;
      const h = this.pixelDistance.measure(t, d.coordinate);
      h < s.minDistance && h < this.pointerDistance && (s.featureId = n.id, s.coordinate = [w(d.coordinate[0], this.config.coordinatePrecision), w(d.coordinate[1], this.config.coordinatePrecision)], s.featureCoordinateIndex = d.lineIndex, s.minDistance = h);
    }), s;
  }
}
const ui = { cancel: "Escape", finish: "Enter" }, pi = { start: "crosshair", close: "pointer", dragStart: "grabbing", dragEnd: "crosshair" };
class Gt extends A {
  constructor(t) {
    super(t, !0), this.mode = "linestring", this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.keyEvents = ui, this.snapping = void 0, this.cursors = pi, this.mouseMove = !1, this.insertCoordinates = void 0, this.lastCommittedCoordinates = void 0, this.snappedPointId = void 0, this.lastMouseMoveEvent = void 0, this.editable = !1, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinateSnapping = void 0, this.insertPoint = void 0, this.lineSnapping = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors)), t != null && t.snapping && (this.snapping = t.snapping), t?.keyEvents === null ? this.keyEvents = { cancel: null, finish: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents)), t != null && t.insertCoordinates && (this.insertCoordinates = t.insertCoordinates), t && t.editable && (this.editable = t.editable);
  }
  updateSnappedCoordinate(t) {
    const e = this.snapCoordinate(t);
    if (e) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: "Point", coordinates: e } }]);
      else {
        const [i] = this.store.create([{ geometry: { type: "Point", coordinates: e }, properties: { mode: this.mode, [S.SNAPPING_POINT]: !0 } }]);
        this.snappedPointId = i;
      }
      t.lng = e[0], t.lat = e[1];
    } else this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    return e;
  }
  close() {
    if (this.currentId === void 0) return;
    const t = this.store.getGeometryCopy(this.currentId);
    t.coordinates.pop(), this.updateGeometries([...t.coordinates], void 0, b.Commit), this.store.updateProperty([{ id: this.currentId, property: S.CURRENTLY_DRAWING, value: void 0 }]);
    const e = this.currentId;
    this.closingPointId && this.store.delete([this.closingPointId]), this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.snappedPointId = void 0, this.lastCommittedCoordinates = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(e, { mode: this.mode, action: "draw" });
  }
  updateGeometries(t, e, i) {
    if (!this.currentId) return;
    const o = { type: "LineString", coordinates: t };
    if (this.validate && !this.validate({ type: "Feature", geometry: o }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: i }).valid) return;
    const s = [{ id: this.currentId, geometry: o }];
    this.closingPointId && e && s.push({ id: this.closingPointId, geometry: { type: "Point", coordinates: e } }), i === "commit" && (this.lastCommittedCoordinates = o.coordinates), this.store.updateGeometry(s);
  }
  generateInsertCoordinates(t, e) {
    if (!this.insertCoordinates || !this.lastCommittedCoordinates) throw new Error("Not able to insert coordinates");
    if (this.insertCoordinates.strategy !== "amount") throw new Error("Strategy does not exist");
    const i = U(t, e) / (this.insertCoordinates.value + 1);
    let o = [];
    return this.projection === "globe" ? o = this.insertPoint.generateInsertionGeodesicCoordinates(t, e, i) : this.projection === "web-mercator" && (o = this.insertPoint.generateInsertionCoordinates(t, e, i)), o;
  }
  createLine(t) {
    const [e] = this.store.create([{ geometry: { type: "LineString", coordinates: [t, t] }, properties: { mode: this.mode, [S.CURRENTLY_DRAWING]: !0 } }]);
    this.lastCommittedCoordinates = [t, t], this.currentId = e, this.currentCoordinate++, this.setDrawing();
  }
  firstUpdateToLine(t) {
    if (!this.currentId) return;
    const e = this.store.getGeometryCopy(this.currentId).coordinates, [i] = this.store.create([{ geometry: { type: "Point", coordinates: [...t] }, properties: { mode: this.mode, [S.CLOSING_POINT]: !0 } }]);
    this.closingPointId = i, this.setCursor(this.cursors.close);
    const o = [...e, t];
    this.updateGeometries(o, void 0, b.Commit), this.currentCoordinate++;
  }
  updateToLine(t, e) {
    if (!this.currentId) return;
    const i = this.store.getGeometryCopy(this.currentId).coordinates, [o, s] = this.lastCommittedCoordinates ? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1] : i[i.length - 2], { x: n, y: a } = this.project(o, s);
    if (F({ x: n, y: a }, { x: e.x, y: e.y }) < this.pointerDistance) return void this.close();
    this.setCursor(this.cursors.close);
    const l = [...i, t];
    this.updateGeometries(l, i[i.length - 1], b.Commit), this.currentCoordinate++;
  }
  registerBehaviors(t) {
    this.coordinateSnapping = new It(t, new ct(t), new dt(t)), this.insertPoint = new di(t), this.clickBoundingBox = new dt(t), this.pixelDistance = new ct(t), this.lineSnapping = new Rt(t, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new It(t, this.pixelDistance, this.clickBoundingBox);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(t) {
    this.mouseMove = !0, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = t;
    const e = this.updateSnappedCoordinate(t) || [t.lng, t.lat];
    if (this.currentId === void 0 || this.currentCoordinate === 0) return;
    const i = this.store.getGeometryCopy(this.currentId).coordinates;
    if (i.pop(), this.closingPointId) {
      const [s, n] = i[i.length - 1], { x: a, y: l } = this.project(s, n);
      F({ x: a, y: l }, { x: t.containerX, y: t.containerY }) < this.pointerDistance && this.setCursor(this.cursors.close);
    }
    let o = [...i, e];
    if (this.insertCoordinates && this.currentId && this.lastCommittedCoordinates) {
      const s = this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1], n = e;
      if (!tt(s, n)) {
        const a = this.generateInsertCoordinates(s, n);
        o = [...this.lastCommittedCoordinates.slice(0, -1), ...a, e];
      }
    }
    this.updateGeometries(o, void 0, b.Provisional);
  }
  onRightClick(t) {
    if (!this.editable || this.state !== "started") return;
    const { featureId: e, featureCoordinateIndex: i } = this.coordinateSnapping.getSnappable(t, (n) => this.lineStringFilter(n));
    if (!e || i === void 0) return;
    const o = this.store.getGeometryCopy(e);
    let s;
    if (o.type === "LineString" && (s = o.coordinates, !(s.length <= 2))) {
      if (s.splice(i, 1), this.validate && !this.validate({ id: e, type: "Feature", geometry: o, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Commit }).valid) return;
      this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: e, geometry: o }]), this.onFinish(e, { mode: this.mode, action: "edit" });
    }
  }
  onLeftClick(t) {
    this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    const e = this.snapCoordinate(t) || [t.lng, t.lat];
    this.currentCoordinate === 0 ? this.createLine(e) : this.currentCoordinate === 1 && this.currentId ? this.firstUpdateToLine(e) : this.currentId && this.updateToLine(e, { x: t.containerX, y: t.containerY });
  }
  onClick(t) {
    (t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t)) && (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(t), this.mouseMove = !1, t.button === "right" ? this.onRightClick(t) : t.button === "left" && this.onLeftClick(t));
  }
  onKeyDown() {
  }
  onKeyUp(t) {
    t.key === this.keyEvents.cancel && this.cleanUp(), t.key === this.keyEvents.finish && this.close();
  }
  onDragStart(t, e) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, t) || !this.editable) return;
    let i;
    if (this.state === "started") {
      const o = this.lineSnapping.getSnappable(t, (n) => this.lineStringFilter(n));
      o.coordinate && (this.editedSnapType = "line", this.editedFeatureCoordinateIndex = o.featureCoordinateIndex, this.editedFeatureId = o.featureId, i = o.coordinate);
      const s = this.coordinateSnapping.getSnappable(t, (n) => this.lineStringFilter(n));
      s.coordinate && (this.editedSnapType = "coordinate", this.editedFeatureCoordinateIndex = s.featureCoordinateIndex, this.editedFeatureId = s.featureId, i = s.coordinate);
    }
    if (this.editedFeatureId && i) {
      if (!this.editedPointId) {
        const [o] = this.store.create([{ geometry: { type: "Point", coordinates: i }, properties: { mode: this.mode, [S.EDITED]: !0 } }]);
        this.editedPointId = o;
      }
      this.setCursor(this.cursors.dragStart), e(!1);
    }
  }
  onDrag(t, e) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, t) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    const i = this.store.getGeometryCopy(this.editedFeatureId);
    this.editedSnapType === "coordinate" || this.editedSnapType === "line" && this.editedInsertIndex !== void 0 ? i.coordinates[this.editedFeatureCoordinateIndex] = [t.lng, t.lat] : this.editedSnapType === "line" && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, i.coordinates.splice(this.editedInsertIndex, 0, [t.lng, t.lat]), this.editedFeatureCoordinateIndex++);
    const o = { type: "LineString", coordinates: i.coordinates };
    this.validate && !this.validate({ type: "Feature", geometry: o, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: o }]), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: "Point", coordinates: [t.lng, t.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: S.EDITED, value: !0 }]));
  }
  onDragEnd(t, e) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, t) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0), this.store.updateProperty([{ id: this.editedFeatureId, property: S.EDITED, value: !1 }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, e(!0));
  }
  cleanUp() {
    const t = this.currentId, e = this.closingPointId, i = this.snappedPointId;
    this.closingPointId = void 0, this.snappedPointId = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
    try {
      t !== void 0 && this.store.delete([t]), i !== void 0 && this.store.delete([i]), e !== void 0 && this.store.delete([e]);
    } catch {
    }
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (t.type === "Feature" && t.geometry.type === "LineString" && t.properties.mode === this.mode) return e.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, e.lineStringColor, t), e.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, e.lineStringWidth, t), e.zIndex = j, e;
    if (t.type === "Feature" && t.geometry.type === "Point" && t.properties.mode === this.mode) {
      const i = t.properties[S.CLOSING_POINT];
      return e.pointColor = this.getHexColorStylingValue(i ? this.styles.closingPointColor : this.styles.snappingPointColor, e.pointColor, t), e.pointWidth = this.getNumericStylingValue(i ? this.styles.closingPointWidth : this.styles.snappingPointWidth, e.pointWidth, t), e.pointOutlineColor = this.getHexColorStylingValue(i ? this.styles.closingPointOutlineColor : this.styles.snappingPointOutlineColor, "#ffffff", t), e.pointOutlineWidth = this.getNumericStylingValue(i ? this.styles.closingPointOutlineWidth : this.styles.snappingPointOutlineWidth, 2, t), e.zIndex = 50, e;
    }
    return e;
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => At(e, this.coordinatePrecision));
  }
  lineStringFilter(t) {
    return !!(t.geometry.type === "LineString" && t.properties && t.properties.mode === this.mode);
  }
  snapCoordinate(t) {
    var e, i, o;
    let s;
    if ((e = this.snapping) != null && e.toLine) {
      let n;
      n = this.currentId ? this.lineSnapping.getSnappableCoordinate(t, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(t), n && (s = n);
    }
    return (i = this.snapping) != null && i.toCoordinate && (s = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(t, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(t)), (o = this.snapping) != null && o.toCustom && (s = this.snapping.toCustom(t, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), s;
  }
  afterFeatureUpdated(t) {
    this.editedFeatureId === t.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === t.id && (this.closingPointId && (this.store.delete([this.closingPointId]), this.closingPointId = void 0), this.currentCoordinate = 0, this.currentId = void 0, this.state === "drawing" && this.setStarted());
  }
}
const gi = "Feature is not a Point", yi = "Feature has invalid coordinates", fi = "Feature has coordinates with excessive precision";
function we(r, t) {
  return r.geometry.type !== "Point" ? { valid: !1, reason: gi } : jt(r.geometry.coordinates) ? Ot(r.geometry.coordinates, t) ? { valid: !0 } : { valid: !1, reason: fi } : { valid: !1, reason: yi };
}
const mi = { create: "crosshair", dragStart: "grabbing", dragEnd: "crosshair" };
class Ut extends A {
  constructor(t) {
    super(t, !0), this.mode = "point", this.cursors = mi, this.editable = !1, this.editedFeatureId = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors)), t != null && t.editable && (this.editable = t.editable);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.create);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(t) {
    t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t) ? this.onRightClick(t) : t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) && this.onLeftClick(t);
  }
  onMouseMove() {
  }
  onKeyDown() {
  }
  onKeyUp() {
  }
  cleanUp() {
    this.editedFeatureId = void 0;
  }
  onDragStart(t, e) {
    if (this.allowPointerEvent(this.pointerEvents.onDragStart, t)) {
      if (this.editable) {
        const i = this.getNearestPointFeature(t);
        this.editedFeatureId = i?.id;
      }
      this.editedFeatureId && (this.setCursor(this.cursors.dragStart), e(!1));
    }
  }
  onDrag(t, e) {
    this.allowPointerEvent(this.pointerEvents.onDrag, t) && this.editedFeatureId !== void 0 && (this.validate && !this.validate({ type: "Feature", geometry: { type: "Point", coordinates: [t.lng, t.lat] }, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Finish }).valid || (this.store.updateGeometry([{ id: this.editedFeatureId, geometry: { type: "Point", coordinates: [t.lng, t.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: S.EDITED, value: !0 }])));
  }
  onDragEnd(t, e) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, t) && this.editedFeatureId !== void 0 && (this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.setCursor(this.cursors.dragEnd), this.store.updateProperty([{ id: this.editedFeatureId, property: S.EDITED, value: !1 }]), this.editedFeatureId = void 0, e(!0));
  }
  registerBehaviors(t) {
    this.pixelDistance = new ct(t), this.clickBoundingBox = new dt(t);
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (t.type === "Feature" && t.geometry.type === "Point" && t.properties.mode === this.mode) {
      const i = !!(t.id && this.editedFeatureId === t.id);
      e.pointWidth = this.getNumericStylingValue(i ? this.styles.editedPointWidth : this.styles.pointWidth, e.pointWidth, t), e.pointColor = this.getHexColorStylingValue(i ? this.styles.editedPointColor : this.styles.pointColor, e.pointColor, t), e.pointOutlineColor = this.getHexColorStylingValue(i ? this.styles.editedPointOutlineColor : this.styles.pointOutlineColor, e.pointOutlineColor, t), e.pointOutlineWidth = this.getNumericStylingValue(i ? this.styles.editedPointOutlineWidth : this.styles.pointOutlineWidth, 2, t), e.zIndex = 30;
    }
    return e;
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => we(e, this.coordinatePrecision));
  }
  onLeftClick(t) {
    const e = { type: "Point", coordinates: [t.lng, t.lat] }, i = { mode: this.mode };
    if (this.validate && !this.validate({ type: "Feature", geometry: e, properties: i }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Finish }).valid) return;
    const [o] = this.store.create([{ geometry: e, properties: i }]);
    this.onFinish(o, { mode: this.mode, action: "draw" });
  }
  onRightClick(t) {
    if (!this.editable) return;
    const e = this.getNearestPointFeature(t);
    e && this.store.delete([e.id]);
  }
  getNearestPointFeature(t) {
    const e = this.clickBoundingBox.create(t), i = this.store.search(e);
    let o, s = 1 / 0;
    for (let n = 0; n < i.length; n++) {
      const a = i[n];
      if (a.geometry.type !== "Point" || a.properties.mode !== this.mode) continue;
      const l = this.pixelDistance.measure(t, a.geometry.coordinates);
      l > s || l > this.pointerDistance || (s = l, o = a);
    }
    return o;
  }
  afterFeatureUpdated(t) {
    this.editedFeatureId === t.id && (this.editedFeatureId = void 0, this.setCursor(this.cursors.create));
  }
}
class vi extends B {
  constructor(t, e) {
    super(t), this.config = void 0, this.pixelDistance = void 0, this._startEndPoints = [], this.config = t, this.pixelDistance = e;
  }
  get ids() {
    return this._startEndPoints.concat();
  }
  set ids(t) {
  }
  create(t, e) {
    if (this.ids.length) throw new Error("Opening and closing points already created");
    if (t.length <= 3) throw new Error("Requires at least 4 coordinates");
    this._startEndPoints = this.store.create([{ geometry: { type: "Point", coordinates: t[0] }, properties: { mode: e, [S.CLOSING_POINT]: !0 } }, { geometry: { type: "Point", coordinates: t[t.length - 2] }, properties: { mode: e, [S.CLOSING_POINT]: !0 } }]);
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._startEndPoints = []);
  }
  update(t) {
    if (this.ids.length !== 2) throw new Error("No closing points to update");
    this.store.updateGeometry([{ id: this.ids[0], geometry: { type: "Point", coordinates: t[0] } }, { id: this.ids[1], geometry: { type: "Point", coordinates: t[t.length - 3] } }]);
  }
  isClosingPoint(t) {
    const e = this.store.getGeometryCopy(this.ids[0]), i = this.store.getGeometryCopy(this.ids[1]), o = this.pixelDistance.measure(t, e.coordinates), s = this.pixelDistance.measure(t, i.coordinates);
    return { isClosing: o < this.pointerDistance, isPreviousClosing: s < this.pointerDistance };
  }
}
class Le extends B {
  constructor(t) {
    super(t);
  }
  createOrUpdate(t) {
    const e = this.store.getGeometryCopy(t), i = this.store.getPropertiesCopy(t);
    let o;
    if (e.type === "Polygon") o = e.coordinates[0].slice(0, -1);
    else {
      if (e.type !== "LineString") return;
      o = e.coordinates;
    }
    const s = this.store.getPropertiesCopy(t), n = s.coordinatePointIds;
    if (n) if (n && n.every((a) => this.store.has(a))) {
      const a = s.coordinatePointIds, l = a.map((d) => this.store.getGeometryCopy(d).coordinates);
      if (a.length !== o.length) {
        this.deleteCoordinatePoints(a);
        const d = this.createPoints(o, i.mode, t);
        this.setFeatureCoordinatePoints(t, d);
      } else o.forEach((d, c) => {
        d[0] === l[c][0] && d[1] === l[c][1] || this.store.updateGeometry([{ id: a[c], geometry: { type: "Point", coordinates: d } }]);
      });
    } else {
      const a = n.filter((d) => this.store.has(d));
      a.length && this.deleteCoordinatePoints(a);
      const l = this.createPoints(o, i.mode, t);
      this.setFeatureCoordinatePoints(t, l);
    }
    else {
      const a = this.createPoints(o, i.mode, t);
      this.setFeatureCoordinatePoints(t, a);
    }
  }
  deletePointsByFeatureIds(t) {
    for (const e of t) this.deleteIfPresent(e);
  }
  getUpdated(t, e) {
    const i = this.store.getPropertiesCopy(t);
    if (i.coordinatePointIds) return i.coordinatePointIds.map((o, s) => ({ id: o, geometry: x({}, this.store.getGeometryCopy(o), { coordinates: e[s] }) }));
  }
  createPoints(t, e, i) {
    return this.store.create(t.map((o, s) => ({ geometry: { type: "Point", coordinates: o }, properties: { mode: e, [S.COORDINATE_POINT]: !0, [S.COORDINATE_POINT_FEATURE_ID]: i, index: s } })));
  }
  setFeatureCoordinatePoints(t, e) {
    this.store.updateProperty([{ id: t, property: S.COORDINATE_POINT_IDS, value: e }]);
  }
  deleteCoordinatePoints(t) {
    const e = t.filter((i) => this.store.has(i));
    this.store.delete(e);
  }
  deleteIfPresent(t) {
    const e = this.store.getPropertiesCopy(t).coordinatePointIds;
    e && (this.deleteCoordinatePoints(e), this.setFeatureCoordinatePoints(t, null));
  }
}
const Ci = { cancel: "Escape", finish: "Enter" }, Pi = { start: "crosshair", close: "pointer", dragStart: "grabbing", dragEnd: "crosshair" };
class Fe extends A {
  constructor(t) {
    super(t, !0), this.mode = "polygon", this.currentCoordinate = 0, this.currentId = void 0, this.keyEvents = Ci, this.cursors = Pi, this.mouseMove = !1, this.showCoordinatePoints = !1, this.lastMouseMoveEvent = void 0, this.snapping = void 0, this.snappedPointId = void 0, this.editable = !1, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinatePoints = void 0, this.lineSnapping = void 0, this.coordinateSnapping = void 0, this.pixelDistance = void 0, this.closingPoints = void 0, this.clickBoundingBox = void 0, this.updateOptions(t);
  }
  updateOptions(t) {
    if (super.updateOptions(t), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors)), t?.keyEvents === null ? this.keyEvents = { cancel: null, finish: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents)), t != null && t.snapping && (this.snapping = t.snapping), t?.editable !== void 0 && (this.editable = t.editable), t?.pointerEvents !== void 0 && (this.pointerEvents = t.pointerEvents), t?.showCoordinatePoints !== void 0) {
      if (this.showCoordinatePoints = t.showCoordinatePoints, this.coordinatePoints && t.showCoordinatePoints === !0) this.store.copyAllWhere((e) => e.mode === this.mode).map((e) => e.id).forEach((e) => {
        this.coordinatePoints.createOrUpdate(e);
      });
      else if (this.coordinatePoints && this.showCoordinatePoints === !1) {
        const e = this.store.copyAllWhere((i) => i.mode === this.mode && !!i[S.COORDINATE_POINT_IDS]);
        this.coordinatePoints.deletePointsByFeatureIds(e.map((i) => i.id));
      }
    }
  }
  close() {
    if (this.currentId === void 0) return;
    const t = this.store.getGeometryCopy(this.currentId).coordinates[0];
    if (t.length < 5 || !this.updatePolygonGeometry([...t.slice(0, -2), t[0]], b.Finish)) return;
    const e = this.currentId;
    if (this.currentId) {
      const i = pt(this.store.getGeometryCopy(this.currentId));
      i && (this.store.updateGeometry([{ id: this.currentId, geometry: i }]), this.showCoordinatePoints && this.coordinatePoints.createOrUpdate(this.currentId)), this.store.updateProperty([{ id: this.currentId, property: S.CURRENTLY_DRAWING, value: void 0 }, { id: this.currentId, property: S.COMMITTED_COORDINATE_COUNT, value: void 0 }, { id: this.currentId, property: S.PROVISIONAL_COORDINATE_COUNT, value: void 0 }]);
    }
    this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.snappedPointId = void 0, this.closingPoints.delete(), this.state === "drawing" && this.setStarted(), this.onFinish(e, { mode: this.mode, action: "draw" });
  }
  registerBehaviors(t) {
    this.clickBoundingBox = new dt(t), this.pixelDistance = new ct(t), this.lineSnapping = new Rt(t, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new It(t, this.pixelDistance, this.clickBoundingBox), this.closingPoints = new vi(t, this.pixelDistance), this.coordinatePoints = new Le(t);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  updateSnappedCoordinate(t) {
    const e = this.snapCoordinate(t);
    if (e) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: "Point", coordinates: e } }]);
      else {
        const [i] = this.store.create([{ geometry: { type: "Point", coordinates: e }, properties: { mode: this.mode, [S.SNAPPING_POINT]: !0 } }]);
        this.snappedPointId = i;
      }
      t.lng = e[0], t.lat = e[1];
    } else this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
  }
  onMouseMove(t) {
    if (this.mouseMove = !0, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = t, this.updateSnappedCoordinate(t), this.currentId === void 0 || this.currentCoordinate === 0) return;
    const e = this.store.getGeometryCopy(this.currentId).coordinates[0];
    let i;
    if (this.currentCoordinate === 1) {
      const o = 1 / Math.pow(10, this.coordinatePrecision - 1), s = Math.max(1e-6, o);
      i = [e[0], [t.lng, t.lat], [t.lng, t.lat - s], e[0]];
    } else if (this.currentCoordinate === 2) i = [e[0], e[1], [t.lng, t.lat], e[0]];
    else {
      const { isClosing: o, isPreviousClosing: s } = this.closingPoints.isClosingPoint(t);
      s || o ? (this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.setCursor(this.cursors.close), i = [...e.slice(0, -2), e[0], e[0]]) : i = [...e.slice(0, -2), [t.lng, t.lat], e[0]];
    }
    this.store.updateProperty([{ id: this.currentId, property: S.PROVISIONAL_COORDINATE_COUNT, value: this.currentCoordinate + 1 }]), this.updatePolygonGeometry(i, b.Provisional);
  }
  updatePolygonGeometry(t, e) {
    if (!this.currentId) return !1;
    const i = { type: "Polygon", coordinates: [t] };
    return !(this.validate && !this.validate({ type: "Feature", geometry: i }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: e }).valid || (this.store.updateGeometry([{ id: this.currentId, geometry: i }]), this.showCoordinatePoints && this.coordinatePoints.createOrUpdate(this.currentId), 0));
  }
  snapCoordinate(t) {
    var e, i, o;
    let s;
    if ((e = this.snapping) != null && e.toLine) {
      let n;
      n = this.currentId ? this.lineSnapping.getSnappableCoordinate(t, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(t), n && (s = n);
    }
    if ((i = this.snapping) != null && i.toCoordinate) {
      let n;
      n = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(t, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(t), n && (s = n);
    }
    return (o = this.snapping) != null && o.toCustom && (s = this.snapping.toCustom(t, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), s;
  }
  polygonFilter(t) {
    return !!(t.geometry.type === "Polygon" && t.properties && t.properties.mode === this.mode);
  }
  onRightClick(t) {
    if (!this.editable || this.state !== "started") return;
    const { featureId: e, featureCoordinateIndex: i } = this.coordinateSnapping.getSnappable(t, (n) => this.polygonFilter(n));
    if (!e || i === void 0) return;
    const o = this.store.getGeometryCopy(e);
    let s;
    o.type === "Polygon" && (s = o.coordinates[0], s.length <= 4 || (o.type !== "Polygon" || i !== 0 && i !== s.length - 1 ? s.splice(i, 1) : (s.shift(), s.pop(), s.push([s[0][0], s[0][1]])), (!this.validate || this.validate({ id: e, type: "Feature", geometry: o, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Commit }).valid) && (this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: e, geometry: o }]), this.showCoordinatePoints && this.coordinatePoints.createOrUpdate(e), this.onFinish(e, { mode: this.mode, action: "edit" }))));
  }
  onLeftClick(t) {
    if (this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.currentCoordinate === 0) {
      const e = this.snapCoordinate(t);
      e && (t.lng = e[0], t.lat = e[1]);
      const [i] = this.store.create([{ geometry: { type: "Polygon", coordinates: [[[t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat]]] }, properties: { mode: this.mode, [S.CURRENTLY_DRAWING]: !0, [S.COMMITTED_COORDINATE_COUNT]: this.currentCoordinate + 1, [S.PROVISIONAL_COORDINATE_COUNT]: this.currentCoordinate + 1 } }]);
      this.currentId = i, this.currentCoordinate++, this.showCoordinatePoints && this.coordinatePoints.createOrUpdate(i), this.setDrawing();
    } else if (this.currentCoordinate === 1 && this.currentId) {
      const e = this.snapCoordinate(t);
      e && (t.lng = e[0], t.lat = e[1]);
      const i = this.store.getGeometryCopy(this.currentId);
      if (tt([t.lng, t.lat], i.coordinates[0][0]) || !this.updatePolygonGeometry([i.coordinates[0][0], [t.lng, t.lat], [t.lng, t.lat], i.coordinates[0][0]], b.Commit)) return;
      this.store.updateProperty([{ id: this.currentId, property: S.COMMITTED_COORDINATE_COUNT, value: this.currentCoordinate + 1 }]), this.currentCoordinate++;
    } else if (this.currentCoordinate === 2 && this.currentId) {
      const e = this.snapCoordinate(t);
      e && (t.lng = e[0], t.lat = e[1]);
      const i = this.store.getGeometryCopy(this.currentId).coordinates[0];
      if (tt([t.lng, t.lat], i[1]) || !this.updatePolygonGeometry([i[0], i[1], [t.lng, t.lat], [t.lng, t.lat], i[0]], b.Commit)) return;
      this.currentCoordinate === 2 && this.closingPoints.create(i, "polygon"), this.store.updateProperty([{ id: this.currentId, property: S.COMMITTED_COORDINATE_COUNT, value: this.currentCoordinate + 1 }]), this.currentCoordinate++;
    } else if (this.currentId) {
      const e = this.store.getGeometryCopy(this.currentId).coordinates[0], { isClosing: i, isPreviousClosing: o } = this.closingPoints.isClosingPoint(t);
      if (o || i) this.close();
      else {
        const s = this.snapCoordinate(t);
        if (s && (t.lng = s[0], t.lat = s[1]), tt([t.lng, t.lat], e[this.currentCoordinate - 1])) return;
        const n = /* @__PURE__ */ (function(a = [[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]]) {
          return { type: "Feature", geometry: { type: "Polygon", coordinates: a }, properties: {} };
        })([[...e.slice(0, -1), [t.lng, t.lat], e[0]]]);
        if (!this.updatePolygonGeometry(n.geometry.coordinates[0], b.Commit)) return;
        this.store.updateProperty([{ id: this.currentId, property: S.COMMITTED_COORDINATE_COUNT, value: this.currentCoordinate + 1 }]), this.currentCoordinate++, this.closingPoints.ids.length && this.closingPoints.update(n.geometry.coordinates[0]);
      }
    }
  }
  onClick(t) {
    this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(t), this.mouseMove = !1, t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t) ? this.onRightClick(t) : t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) && this.onLeftClick(t);
  }
  onKeyUp(t) {
    t.key === this.keyEvents.cancel ? this.cleanUp() : t.key === this.keyEvents.finish && this.close();
  }
  onKeyDown() {
  }
  onDragStart(t, e) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, t) || !this.editable) return;
    let i;
    if (this.state === "started") {
      const o = this.lineSnapping.getSnappable(t, (n) => this.polygonFilter(n));
      o.coordinate && (this.editedSnapType = "line", this.editedFeatureCoordinateIndex = o.featureCoordinateIndex, this.editedFeatureId = o.featureId, i = o.coordinate);
      const s = this.coordinateSnapping.getSnappable(t, (n) => this.polygonFilter(n));
      s.coordinate && (this.editedSnapType = "coordinate", this.editedFeatureCoordinateIndex = s.featureCoordinateIndex, this.editedFeatureId = s.featureId, i = s.coordinate);
    }
    if (this.editedFeatureId && i) {
      if (!this.editedPointId) {
        const [o] = this.store.create([{ geometry: { type: "Point", coordinates: i }, properties: { mode: this.mode, [S.EDITED]: !0 } }]);
        this.editedPointId = o;
      }
      this.setCursor(this.cursors.dragStart), e(!1);
    }
  }
  onDrag(t, e) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, t) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    const i = this.store.getGeometryCopy(this.editedFeatureId), o = i.coordinates[0];
    this.editedSnapType === "coordinate" || this.editedSnapType === "line" && this.editedInsertIndex !== void 0 ? this.editedFeatureCoordinateIndex === 0 || this.editedFeatureCoordinateIndex === i.coordinates[0].length - 1 ? (o[0] = [t.lng, t.lat], o[o.length - 1] = [t.lng, t.lat]) : o[this.editedFeatureCoordinateIndex] = [t.lng, t.lat] : this.editedSnapType === "line" && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, i.coordinates[0].splice(this.editedInsertIndex, 0, [t.lng, t.lat]), this.editedFeatureCoordinateIndex++);
    const s = { type: "Polygon", coordinates: i.coordinates };
    this.validate && !this.validate({ type: "Feature", geometry: s, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: s }]), this.showCoordinatePoints && this.coordinatePoints.createOrUpdate(this.editedFeatureId), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: "Point", coordinates: [t.lng, t.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: S.EDITED, value: !0 }]));
  }
  onDragEnd(t, e) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, t) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0), this.store.updateProperty([{ id: this.editedFeatureId, property: S.EDITED, value: !1 }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, e(!0));
  }
  cleanUp() {
    const t = this.currentId, e = this.snappedPointId, i = this.editedPointId;
    this.currentId = void 0, this.snappedPointId = void 0, this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
    try {
      t && this.coordinatePoints.deletePointsByFeatureIds([t]), t !== void 0 && this.store.delete([t]), i !== void 0 && this.store.delete([i]), e !== void 0 && this.store.delete([e]), this.closingPoints.ids.length && this.closingPoints.delete();
    } catch {
    }
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (t.properties.mode === this.mode) {
      if (t.geometry.type === "Polygon") return e.polygonFillColor = this.getHexColorStylingValue(this.styles.fillColor, e.polygonFillColor, t), e.polygonOutlineColor = this.getHexColorStylingValue(this.styles.outlineColor, e.polygonOutlineColor, t), e.polygonOutlineWidth = this.getNumericStylingValue(this.styles.outlineWidth, e.polygonOutlineWidth, t), e.polygonFillOpacity = this.getNumericStylingValue(this.styles.fillOpacity, e.polygonFillOpacity, t), e.zIndex = j, e;
      if (t.geometry.type === "Point") {
        const i = t.properties[S.EDITED], o = t.properties[S.COORDINATE_POINT], s = i ? "editedPoint" : t.properties[S.CLOSING_POINT] ? "closingPoint" : t.properties[S.SNAPPING_POINT] ? "snappingPoint" : o ? "coordinatePoint" : void 0;
        if (!s) return e;
        const n = { editedPoint: { width: this.styles.editedPointOutlineWidth, color: this.styles.editedPointColor, outlineColor: this.styles.editedPointOutlineColor, outlineWidth: this.styles.editedPointOutlineWidth }, closingPoint: { width: this.styles.closingPointWidth, color: this.styles.closingPointColor, outlineColor: this.styles.closingPointOutlineColor, outlineWidth: this.styles.closingPointOutlineWidth }, snappingPoint: { width: this.styles.snappingPointWidth, color: this.styles.snappingPointColor, outlineColor: this.styles.snappingPointOutlineColor, outlineWidth: this.styles.snappingPointOutlineWidth }, coordinatePoint: { width: this.styles.coordinatePointWidth, color: this.styles.coordinatePointColor, outlineColor: this.styles.coordinatePointOutlineColor, outlineWidth: this.styles.coordinatePointOutlineWidth } };
        return e.pointWidth = this.getNumericStylingValue(n[s].width, e.pointWidth, t), e.pointColor = this.getHexColorStylingValue(n[s].color, e.pointColor, t), e.pointOutlineColor = this.getHexColorStylingValue(n[s].outlineColor, e.pointOutlineColor, t), e.pointOutlineWidth = this.getNumericStylingValue(n[s].outlineWidth, 2, t), e.zIndex = i ? 40 : o ? 20 : 30, e;
      }
    }
    return e;
  }
  afterFeatureAdded(t) {
    this.showCoordinatePoints && this.coordinatePoints.createOrUpdate(t.id);
  }
  afterFeatureUpdated(t) {
    this.showCoordinatePoints && this.coordinatePoints.createOrUpdate(t.id), this.editedFeatureId === t.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === t.id && (this.currentCoordinate = 0, this.currentId = void 0, this.closingPoints.delete(), this.state === "drawing" && this.setStarted());
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => bt(e, this.coordinatePrecision));
  }
}
const Si = { cancel: "Escape", finish: "Enter" }, Ii = { start: "crosshair" };
class Me extends A {
  constructor(t) {
    super(t, !0), this.mode = "rectangle", this.center = void 0, this.clickCount = 0, this.currentRectangleId = void 0, this.keyEvents = Si, this.cursors = Ii, this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors)), t?.keyEvents === null ? this.keyEvents = { cancel: null, finish: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents));
  }
  updateRectangle(t, e) {
    if (this.clickCount === 1 && this.center && this.currentRectangleId) {
      const i = this.store.getGeometryCopy(this.currentRectangleId).coordinates[0][0], o = { type: "Polygon", coordinates: [[i, [t.lng, i[1]], [t.lng, t.lat], [i[0], t.lat], i]] };
      if (this.validate && !this.validate({ id: this.currentRectangleId, geometry: o }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: e }).valid) return;
      this.store.updateGeometry([{ id: this.currentRectangleId, geometry: o }]);
    }
  }
  close() {
    const t = this.currentRectangleId;
    if (t) {
      const e = pt(this.store.getGeometryCopy(t));
      e && this.store.updateGeometry([{ id: t, geometry: e }]), this.store.updateProperty([{ id: t, property: S.CURRENTLY_DRAWING, value: void 0 }]);
    }
    this.center = void 0, this.currentRectangleId = void 0, this.clickCount = 0, this.state === "drawing" && this.setStarted(), t !== void 0 && this.onFinish(t, { mode: this.mode, action: "draw" });
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(t) {
    if (t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t)) if (this.clickCount === 0) {
      this.center = [t.lng, t.lat];
      const [e] = this.store.create([{ geometry: { type: "Polygon", coordinates: [[[t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat]]] }, properties: { mode: this.mode, [S.CURRENTLY_DRAWING]: !0 } }]);
      this.currentRectangleId = e, this.clickCount++, this.setDrawing();
    } else this.updateRectangle(t, b.Finish), this.close();
  }
  onMouseMove(t) {
    this.updateRectangle(t, b.Provisional);
  }
  onKeyDown() {
  }
  onKeyUp(t) {
    t.key === this.keyEvents.cancel ? this.cleanUp() : t.key === this.keyEvents.finish && this.close();
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  cleanUp() {
    const t = this.currentRectangleId;
    this.center = void 0, this.currentRectangleId = void 0, this.clickCount = 0, this.state === "drawing" && this.setStarted(), t !== void 0 && this.store.delete([t]);
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    return t.type === "Feature" && t.geometry.type === "Polygon" && t.properties.mode === this.mode && (e.polygonFillColor = this.getHexColorStylingValue(this.styles.fillColor, e.polygonFillColor, t), e.polygonOutlineColor = this.getHexColorStylingValue(this.styles.outlineColor, e.polygonOutlineColor, t), e.polygonOutlineWidth = this.getNumericStylingValue(this.styles.outlineWidth, e.polygonOutlineWidth, t), e.polygonFillOpacity = this.getNumericStylingValue(this.styles.fillOpacity, e.polygonFillOpacity, t), e.zIndex = j), e;
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => ut(e, this.coordinatePrecision));
  }
  afterFeatureUpdated(t) {
    this.currentRectangleId === t.id && (this.center = void 0, this.currentRectangleId = void 0, this.clickCount = 0, this.state === "drawing" && this.setStarted());
  }
}
class Q extends A {
  constructor(t) {
    if (!t.modeName) throw new Error("Mode name is required for TerraDrawRenderMode");
    super(t, !0), this.type = H.Render, this.mode = "render", this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.modeName && (this.mode = t.modeName);
  }
  registerBehaviors(t) {
    this.mode = t.mode;
  }
  start() {
    this.setStarted();
  }
  stop() {
    this.setStopped();
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature(t) {
    return { pointColor: this.getHexColorStylingValue(this.styles.pointColor, "#3f97e0", t), pointWidth: this.getNumericStylingValue(this.styles.pointWidth, 6, t), pointOutlineColor: this.getHexColorStylingValue(this.styles.pointOutlineColor, "#ffffff", t), pointOutlineWidth: this.getNumericStylingValue(this.styles.pointOutlineWidth, 0, t), polygonFillColor: this.getHexColorStylingValue(this.styles.polygonFillColor, "#3f97e0", t), polygonFillOpacity: this.getNumericStylingValue(this.styles.polygonFillOpacity, 0.3, t), polygonOutlineColor: this.getHexColorStylingValue(this.styles.polygonOutlineColor, "#3f97e0", t), polygonOutlineWidth: this.getNumericStylingValue(this.styles.polygonOutlineWidth, 4, t), lineStringWidth: this.getNumericStylingValue(this.styles.lineStringWidth, 4, t), lineStringColor: this.getHexColorStylingValue(this.styles.lineStringColor, "#3f97e0", t), zIndex: this.getNumericStylingValue(this.styles.zIndex, 0, t) };
  }
  validateFeature(t) {
    const e = super.validateFeature(t);
    if (e.valid) {
      const i = t, o = we(i, this.coordinatePrecision).valid || bt(i, this.coordinatePrecision).valid || At(i, this.coordinatePrecision).valid;
      return o ? { valid: !0 } : { valid: o, reason: "Feature is not a valid Point, Polygon or LineString feature" };
    }
    return e;
  }
}
function _t(r, t) {
  const e = r, i = t, o = D(e[1]), s = D(i[1]);
  let n = D(i[0] - e[0]);
  n > Math.PI && (n -= 2 * Math.PI), n < -Math.PI && (n += 2 * Math.PI);
  const a = Math.log(Math.tan(s / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)), l = (V(Math.atan2(n, a)) + 360) % 360;
  return l > 180 ? -(360 - l) : l;
}
function De(r, t, e) {
  let i = t;
  t < 0 && (i = -Math.abs(i));
  const o = i / Ie, s = r[0] * Math.PI / 180, n = D(r[1]), a = D(e), l = o * Math.cos(a);
  let d = n + l;
  Math.abs(d) > Math.PI / 2 && (d = d > 0 ? Math.PI - d : -Math.PI - d);
  const c = Math.log(Math.tan(d / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4)), h = Math.abs(c) > 1e-11 ? l / c : Math.cos(n), u = [(180 * (s + o * Math.sin(a) / h) / Math.PI + 540) % 360 - 180, 180 * d / Math.PI];
  return u[0] += u[0] - r[0] > 180 ? -360 : r[0] - u[0] > 180 ? 360 : 0, u;
}
function _e(r, t, e, i, o) {
  const s = i(r[0], r[1]), n = i(t[0], t[1]), { lng: a, lat: l } = o((s.x + n.x) / 2, (s.y + n.y) / 2);
  return [w(a, e), w(l, e)];
}
function xi(r, t, e) {
  const i = De(r, 1e3 * U(r, t) / 2, _t(r, t));
  return [w(i[0], e), w(i[1], e)];
}
function le({ featureCoords: r, precision: t, unproject: e, project: i, projection: o }) {
  const s = [];
  for (let n = 0; n < r.length - 1; n++) {
    let a;
    if (o === "web-mercator") a = _e(r[n], r[n + 1], t, i, e);
    else {
      if (o !== "globe") throw new Error("Invalid projection");
      a = xi(r[n], r[n + 1], t);
    }
    s.push(a);
  }
  return s;
}
class Oi extends B {
  constructor(t, e, i) {
    super(t), this.config = void 0, this.selectionPointBehavior = void 0, this.coordinatePointBehavior = void 0, this._midPoints = [], this.config = t, this.selectionPointBehavior = e, this.coordinatePointBehavior = i;
  }
  get ids() {
    return this._midPoints.concat();
  }
  set ids(t) {
  }
  insert(t, e, i) {
    const o = this.store.getGeometryCopy(e), { midPointFeatureId: s, midPointSegment: n } = this.store.getPropertiesCopy(e), a = this.store.getGeometryCopy(s), l = a.type === "Polygon" ? a.coordinates[0] : a.coordinates;
    l.splice(n + 1, 0, o.coordinates), a.coordinates = a.type === "Polygon" ? [l] : l, this.store.updateGeometry([{ id: s, geometry: a }]), this.store.getPropertiesCopy(t)[S.COORDINATE_POINT_IDS] && this.coordinatePointBehavior.createOrUpdate(t), this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]), this.create(l, s, i), this.selectionPointBehavior.create(l, a.type, s);
  }
  create(t, e, i) {
    if (!this.store.has(e)) throw new Error("Store does not have feature with this id");
    this._midPoints = this.store.create((function(o, s, n, a, l, d) {
      return le({ featureCoords: o, precision: n, project: a, unproject: l, projection: d }).map((c, h) => ({ geometry: { type: "Point", coordinates: c }, properties: s(h) }));
    })(t, (o) => ({ mode: this.mode, [k.MID_POINT]: !0, midPointSegment: o, midPointFeatureId: e }), i, this.config.project, this.config.unproject, this.projection));
  }
  delete() {
    this._midPoints.length && (this.store.delete(this._midPoints), this._midPoints = []);
  }
  getUpdated(t) {
    if (this._midPoints.length !== 0) return le({ featureCoords: t, precision: this.coordinatePrecision, project: this.config.project, unproject: this.config.unproject, projection: this.config.projection }).map((e, i) => ({ id: this._midPoints[i], geometry: { type: "Point", coordinates: e } }));
  }
}
class bi extends B {
  constructor(t) {
    super(t), this._selectionPoints = [];
  }
  get ids() {
    return this._selectionPoints.concat();
  }
  set ids(t) {
  }
  create(t, e, i) {
    this._selectionPoints = this.store.create((function(o, s, n) {
      const a = [], l = s === "Polygon" ? o.length - 1 : o.length;
      for (let d = 0; d < l; d++) a.push({ geometry: { type: "Point", coordinates: o[d] }, properties: n(d) });
      return a;
    })(t, e, (o) => ({ mode: this.mode, index: o, [k.SELECTION_POINT]: !0, [k.SELECTION_POINT_FEATURE_ID]: i })));
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._selectionPoints = []);
  }
  getUpdated(t) {
    if (this._selectionPoints.length !== 0) return this._selectionPoints.map((e, i) => ({ id: e, geometry: { type: "Point", coordinates: t[i] } }));
  }
  getOneUpdated(t, e) {
    if (this._selectionPoints[t] !== void 0) return { id: this._selectionPoints[t], geometry: { type: "Point", coordinates: e } };
  }
}
function ke(r, t) {
  let e = !1;
  for (let n = 0, a = t.length; n < a; n++) {
    const l = t[n];
    for (let d = 0, c = l.length, h = c - 1; d < c; h = d++) (o = l[d])[1] > (i = r)[1] != (s = l[h])[1] > i[1] && i[0] < (s[0] - o[0]) * (i[1] - o[1]) / (s[1] - o[1]) + o[0] && (e = !e);
  }
  var i, o, s;
  return e;
}
const kt = (r, t, e) => {
  const i = (s) => s * s, o = (s, n) => i(s.x - n.x) + i(s.y - n.y);
  return Math.sqrt(((s, n, a) => {
    const l = o(n, a);
    if (l === 0) return o(s, n);
    let d = ((s.x - n.x) * (a.x - n.x) + (s.y - n.y) * (a.y - n.y)) / l;
    return d = Math.max(0, Math.min(1, d)), o(s, { x: n.x + d * (a.x - n.x), y: n.y + d * (a.y - n.y) });
  })(r, t, e));
};
class Ei extends B {
  constructor(t, e, i) {
    super(t), this.config = void 0, this.createClickBoundingBox = void 0, this.pixelDistance = void 0, this.config = t, this.createClickBoundingBox = e, this.pixelDistance = i;
  }
  find(t, e) {
    let i, o, s, n, a = 1 / 0, l = 1 / 0, d = 1 / 0;
    const c = this.createClickBoundingBox.create(t), h = this.store.search(c);
    for (let u = 0; u < h.length; u++) {
      const p = h[u], g = p.geometry;
      if (g.type === "Point") {
        if (p.properties.selectionPoint || p.properties.coordinatePoint || !e && p.properties[k.MID_POINT]) continue;
        const y = this.pixelDistance.measure(t, g.coordinates);
        p.properties[k.MID_POINT] && y < this.pointerDistance && y < d ? (d = y, s = p) : !p.properties[k.MID_POINT] && y < this.pointerDistance && y < a && (a = y, i = p);
      } else if (g.type === "LineString") {
        if (i) continue;
        for (let y = 0; y < g.coordinates.length - 1; y++) {
          const m = g.coordinates[y], v = g.coordinates[y + 1], C = kt({ x: t.containerX, y: t.containerY }, this.project(m[0], m[1]), this.project(v[0], v[1]));
          C < this.pointerDistance && C < l && (l = C, o = p);
        }
      } else if (g.type === "Polygon") {
        if (i || o) continue;
        ke([t.lng, t.lat], g.coordinates) && (n = p);
      }
    }
    return { clickedFeature: i || o || n, clickedMidPoint: s };
  }
}
class wi extends B {
  constructor(t, e, i, o, s) {
    super(t), this.config = void 0, this.featuresAtCursorEvent = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.draggedFeatureId = null, this.dragPosition = void 0, this.config = t, this.featuresAtCursorEvent = e, this.selectionPoints = i, this.midPoints = o, this.coordinatePoints = s;
  }
  startDragging(t, e) {
    this.draggedFeatureId = e, this.dragPosition = [t.lng, t.lat];
  }
  stopDragging() {
    this.draggedFeatureId = null, this.dragPosition = void 0;
  }
  isDragging() {
    return this.draggedFeatureId !== null;
  }
  canDrag(t, e) {
    const { clickedFeature: i } = this.featuresAtCursorEvent.find(t, !0);
    return !(!i || i.id !== e);
  }
  drag(t, e) {
    if (!this.draggedFeatureId) return;
    const i = this.store.getGeometryCopy(this.draggedFeatureId), o = [t.lng, t.lat];
    if (i.type === "Polygon" || i.type === "LineString") {
      let s, n;
      if (i.type === "Polygon" ? (s = i.coordinates[0], n = s.length - 1) : (s = i.coordinates, n = s.length), !this.dragPosition) return !1;
      for (let c = 0; c < n; c++) {
        const h = s[c];
        let u, p;
        if (this.config.projection === "web-mercator") {
          const g = O(this.dragPosition[0], this.dragPosition[1]), y = O(o[0], o[1]), m = O(h[0], h[1]), v = { x: g.x - y.x, y: g.y - y.y }, C = m.x - v.x, f = m.y - v.y, { lng: P, lat: I } = R(C, f);
          u = P, p = I;
        } else {
          const g = [this.dragPosition[0] - o[0], this.dragPosition[1] - o[1]];
          u = h[0] - g[0], p = h[1] - g[1];
        }
        if (u = w(u, this.config.coordinatePrecision), p = w(p, this.config.coordinatePrecision), u > 180 || u < -180 || p > 90 || p < -90) return !1;
        s[c] = [u, p];
      }
      i.type === "Polygon" && (s[s.length - 1] = [s[0][0], s[0][1]]);
      const a = this.selectionPoints.getUpdated(s) || [], l = this.midPoints.getUpdated(s) || [], d = this.coordinatePoints.getUpdated(this.draggedFeatureId, s) || [];
      if (e && !e({ type: "Feature", id: this.draggedFeatureId, geometry: i, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: b.Provisional }).valid) return !1;
      this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: i }, ...a, ...l, ...d]), this.dragPosition = [t.lng, t.lat];
    } else i.type === "Point" && (this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: { type: "Point", coordinates: o } }]), this.dragPosition = [t.lng, t.lat]);
  }
}
class Li extends B {
  constructor(t, e, i, o, s, n, a) {
    super(t), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.coordinateSnapping = void 0, this.lineSnapping = void 0, this.draggedCoordinate = { id: null, index: -1 }, this.config = t, this.pixelDistance = e, this.selectionPoints = i, this.midPoints = o, this.coordinatePoints = s, this.coordinateSnapping = n, this.lineSnapping = a;
  }
  getClosestCoordinate(t, e) {
    const i = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: !1 };
    let o;
    if (e.type === "LineString") o = e.coordinates;
    else {
      if (e.type !== "Polygon") return i;
      o = e.coordinates[0];
    }
    for (let s = 0; s < o.length; s++) {
      const n = this.pixelDistance.measure(t, o[s]);
      if (n < this.pointerDistance && n < i.dist) {
        const a = e.type === "Polygon" && (s === o.length - 1 || s === 0);
        i.dist = n, i.index = a ? 0 : s, i.isFirstOrLastPolygonCoord = a;
      }
    }
    return i;
  }
  getDraggableIndex(t, e) {
    const i = this.store.getGeometryCopy(e), o = this.getClosestCoordinate(t, i);
    return o.index === -1 ? -1 : o.index;
  }
  snapCoordinate(t, e, i) {
    let o = [t.lng, t.lat];
    const s = (n) => !!(n.properties && n.properties.mode === i.properties.mode && n.id !== this.draggedCoordinate.id);
    if (e != null && e.toLine) {
      let n;
      n = this.lineSnapping.getSnappable(t, s).coordinate, n && (o = n);
    }
    if (e.toCoordinate) {
      let n;
      n = this.coordinateSnapping.getSnappable(t, s).coordinate, n && (o = n);
    }
    if (e != null && e.toCustom) {
      let n;
      n = e.toCustom(t, { currentCoordinate: this.draggedCoordinate.index, currentId: i.id, getCurrentGeometrySnapshot: i.id ? () => this.store.getGeometryCopy(i.id) : () => null, project: this.project, unproject: this.unproject }), n && (o = n);
    }
    return o;
  }
  drag(t, e, i, o) {
    const s = this.draggedCoordinate.id;
    if (s === null) return !1;
    const n = this.draggedCoordinate.index, a = this.store.getGeometryCopy(s), l = this.store.getPropertiesCopy(s), d = a.type === "LineString" ? a.coordinates : a.coordinates[0], c = a.type === "Polygon" && (n === d.length - 1 || n === 0), h = { type: "Feature", id: s, geometry: a, properties: l }, u = this.snapCoordinate(t, o, h);
    if (t.lng > 180 || t.lng < -180 || t.lat > 90 || t.lat < -90) return !1;
    if (c) {
      const v = d.length - 1;
      d[0] = u, d[v] = u;
    } else d[n] = u;
    const p = this.selectionPoints.getOneUpdated(n, u), g = p ? [p] : [], y = this.midPoints.getUpdated(d) || [], m = this.coordinatePoints.getUpdated(s, d) || [];
    return !(a.type !== "Point" && !e && Bt({ geometry: a }) || i && !i(h, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: b.Provisional }).valid || (this.store.updateGeometry([{ id: s, geometry: a }, ...g, ...y, ...m]), 0));
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(t, e) {
    this.draggedCoordinate = { id: t, index: e };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
}
function de(r) {
  let t = 0, e = 0, i = 0;
  return (r.geometry.type === "Polygon" ? r.geometry.coordinates[0].slice(0, -1) : r.geometry.coordinates).forEach((o) => {
    t += o[0], e += o[1], i++;
  }, !0), [t / i, e / i];
}
const Ne = (r, t) => {
  if (t === 0 || t === 360 || t === -360) return r;
  const e = 0.017453292519943295 * t, i = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map(([n, a]) => O(n, a)), o = i.reduce((n, a) => ({ x: n.x + a.x, y: n.y + a.y }), { x: 0, y: 0 });
  o.x /= i.length, o.y /= i.length;
  const s = i.map((n) => ({ x: o.x + (n.x - o.x) * Math.cos(e) - (n.y - o.y) * Math.sin(e), y: o.y + (n.x - o.x) * Math.sin(e) + (n.y - o.y) * Math.cos(e) })).map(({ x: n, y: a }) => [R(n, a).lng, R(n, a).lat]);
  return r.geometry.type === "Polygon" ? r.geometry.coordinates[0] = s : r.geometry.coordinates = s, r;
};
function Nt(r) {
  const t = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map((e) => {
    const { x: i, y: o } = O(e[0], e[1]);
    return [i, o];
  });
  return r.geometry.type === "Polygon" ? (function(e) {
    let i = 0, o = 0, s = 0;
    const n = e.length;
    for (let a = 0; a < n - 1; a++) {
      const [l, d] = e[a], [c, h] = e[a + 1], u = l * h - c * d;
      i += u, o += (l + c) * u, s += (d + h) * u;
    }
    return i /= 2, o /= 6 * i, s /= 6 * i, { x: o, y: s };
  })(t) : (function(e) {
    const i = e.length;
    let o = 0, s = 0;
    for (let n = 0; n < i; n++) {
      const [a, l] = e[n];
      o += a, s += l;
    }
    return { x: o / i, y: s / i };
  })(t);
}
class Fi extends B {
  constructor(t, e, i, o) {
    super(t), this.config = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryCentroid = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.config = t, this.selectionPoints = e, this.midPoints = i, this.coordinatePoints = o;
  }
  reset() {
    this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.selectedGeometryCentroid = void 0;
  }
  rotate(t, e, i) {
    this.selectedGeometry || (this.selectedGeometry = this.store.getGeometryCopy(e));
    const o = this.selectedGeometry;
    if (o.type !== "Polygon" && o.type !== "LineString") return;
    const s = [t.lng, t.lat];
    let n;
    const a = { type: "Feature", geometry: o, properties: {} };
    if (this.config.projection === "web-mercator") {
      this.selectedGeometryWebMercatorCentroid || (this.selectedGeometryWebMercatorCentroid = Nt(a));
      const u = O(t.lng, t.lat);
      if (n = G(this.selectedGeometryWebMercatorCentroid, u), n === 0) return;
      if (!this.lastBearing) return void (this.lastBearing = n);
      Ne(a, -(this.lastBearing - n));
    } else {
      if (this.config.projection !== "globe") throw new Error("Unsupported projection");
      if (this.selectedGeometryCentroid || (this.selectedGeometryCentroid = de({ geometry: o })), n = _t(this.selectedGeometryCentroid, s), !this.lastBearing) return void (this.lastBearing = n + 180);
      (function(u, p) {
        if (p === 0 || p === 360 || p === -360) return u;
        const g = de(u);
        (u.geometry.type === "Polygon" ? u.geometry.coordinates[0] : u.geometry.coordinates).forEach((y) => {
          const m = _t(g, y) + p, v = (function(f, P) {
            f[0] += f[0] - P[0] > 180 ? -360 : P[0] - f[0] > 180 ? 360 : 0;
            const I = Ie, E = P[1] * Math.PI / 180, L = f[1] * Math.PI / 180, M = L - E;
            let N = Math.abs(f[0] - P[0]) * Math.PI / 180;
            N > Math.PI && (N -= 2 * Math.PI);
            const _ = Math.log(Math.tan(L / 2 + Math.PI / 4) / Math.tan(E / 2 + Math.PI / 4)), T = Math.abs(_) > 1e-11 ? M / _ : Math.cos(E);
            return Math.sqrt(M * M + T * T * N * N) * I;
          })(g, y), C = De(g, v, m);
          y[0] = C[0], y[1] = C[1];
        });
      })(a, -(this.lastBearing - (n + 180)));
    }
    const l = o.type === "Polygon" ? o.coordinates[0] : o.coordinates;
    l.forEach((u) => {
      u[0] = w(u[0], this.coordinatePrecision), u[1] = w(u[1], this.coordinatePrecision);
    });
    const d = this.midPoints.getUpdated(l) || [], c = this.selectionPoints.getUpdated(l) || [], h = this.coordinatePoints.getUpdated(e, l) || [];
    if (i && !i({ id: e, type: "Feature", geometry: o, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: b.Provisional })) return !1;
    this.store.updateGeometry([{ id: e, geometry: o }, ...c, ...d, ...h]), this.projection === "web-mercator" ? this.lastBearing = n : this.projection === "globe" && (this.lastBearing = n + 180);
  }
}
class Mi extends B {
  constructor(t, e) {
    super(t), this.config = void 0, this.dragCoordinateResizeBehavior = void 0, this.config = t, this.dragCoordinateResizeBehavior = e;
  }
  scale(t, e, i) {
    if (!this.dragCoordinateResizeBehavior.isDragging()) {
      const o = this.dragCoordinateResizeBehavior.getDraggableIndex(t, e);
      this.dragCoordinateResizeBehavior.startDragging(e, o);
    }
    this.dragCoordinateResizeBehavior.drag(t, "center-fixed", i);
  }
  reset() {
    this.dragCoordinateResizeBehavior.stopDragging();
  }
}
function Te({ coordinates: r, originX: t, originY: e, xScale: i, yScale: o }) {
  i === 1 && o === 1 || r.forEach((s) => {
    const { x: n, y: a } = O(s[0], s[1]), l = t + (n - t) * i, d = e + (a - e) * o, { lng: c, lat: h } = R(l, d);
    s[0] = c, s[1] = h;
  });
}
class Di extends B {
  constructor(t, e, i, o, s) {
    super(t), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.minimumScale = 1e-4, this.draggedCoordinate = { id: null, index: -1 }, this.boundingBoxMaps = { opposite: { 0: 4, 1: 5, 2: 6, 3: 7, 4: 0, 5: 1, 6: 2, 7: 3 } }, this.config = t, this.pixelDistance = e, this.selectionPoints = i, this.midPoints = o, this.coordinatePoints = s;
  }
  getClosestCoordinate(t, e) {
    const i = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: !1 };
    let o;
    if (e.type === "LineString") o = e.coordinates;
    else {
      if (e.type !== "Polygon") return i;
      o = e.coordinates[0];
    }
    for (let s = 0; s < o.length; s++) {
      const n = this.pixelDistance.measure(t, o[s]);
      if (n < this.pointerDistance && n < i.dist) {
        const a = e.type === "Polygon" && (s === o.length - 1 || s === 0);
        i.dist = n, i.index = a ? 0 : s, i.isFirstOrLastPolygonCoord = a;
      }
    }
    return i;
  }
  isValidDragWebMercator(t, e, i) {
    switch (t) {
      case 0:
        if (e <= 0 || i >= 0) return !1;
        break;
      case 1:
        if (i >= 0) return !1;
        break;
      case 2:
        if (e >= 0 || i >= 0) return !1;
        break;
      case 3:
        if (e >= 0) return !1;
        break;
      case 4:
        if (e >= 0 || i <= 0) return !1;
        break;
      case 5:
        if (i <= 0) return !1;
        break;
      case 6:
        if (e <= 0 || i <= 0) return !1;
        break;
      case 7:
        if (e <= 0) return !1;
    }
    return !0;
  }
  getSelectedFeatureDataWebMercator() {
    if (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) return null;
    const t = this.getFeature(this.draggedCoordinate.id);
    if (!t) return null;
    const e = this.getNormalisedCoordinates(t.geometry);
    return { boundingBox: this.getBBoxWebMercator(e), feature: t, updatedCoords: e, selectedCoordinate: e[this.draggedCoordinate.index] };
  }
  centerWebMercatorDrag(t) {
    const e = this.getSelectedFeatureDataWebMercator();
    if (!e) return null;
    const { feature: i, boundingBox: o, updatedCoords: s, selectedCoordinate: n } = e, a = Nt(i);
    if (!a) return null;
    const l = O(n[0], n[1]), { closestBBoxIndex: d } = this.getIndexesWebMercator(o, l), c = O(t.lng, t.lat);
    return this.scaleWebMercator({ closestBBoxIndex: d, updatedCoords: s, webMercatorCursor: c, webMercatorSelected: l, webMercatorOrigin: a }), s;
  }
  centerFixedWebMercatorDrag(t) {
    const e = this.getSelectedFeatureDataWebMercator();
    if (!e) return null;
    const { feature: i, boundingBox: o, updatedCoords: s, selectedCoordinate: n } = e, a = Nt(i);
    if (!a) return null;
    const l = O(n[0], n[1]), { closestBBoxIndex: d } = this.getIndexesWebMercator(o, l), c = O(t.lng, t.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: d, updatedCoords: s, webMercatorCursor: c, webMercatorSelected: l, webMercatorOrigin: a }), s;
  }
  scaleFixedWebMercator({ closestBBoxIndex: t, webMercatorOrigin: e, webMercatorSelected: i, webMercatorCursor: o, updatedCoords: s }) {
    if (!this.isValidDragWebMercator(t, e.x - o.x, e.y - o.y)) return null;
    let n = F(e, o) / F(e, i);
    return n < 0 && (n = this.minimumScale), Te({ coordinates: s, originX: e.x, originY: e.y, xScale: n, yScale: n }), s;
  }
  oppositeFixedWebMercatorDrag(t) {
    const e = this.getSelectedFeatureDataWebMercator();
    if (!e) return null;
    const { boundingBox: i, updatedCoords: o, selectedCoordinate: s } = e, n = O(s[0], s[1]), { oppositeBboxIndex: a, closestBBoxIndex: l } = this.getIndexesWebMercator(i, n), d = { x: i[a][0], y: i[a][1] }, c = O(t.lng, t.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: l, updatedCoords: o, webMercatorCursor: c, webMercatorSelected: n, webMercatorOrigin: d }), o;
  }
  oppositeWebMercatorDrag(t) {
    const e = this.getSelectedFeatureDataWebMercator();
    if (!e) return null;
    const { boundingBox: i, updatedCoords: o, selectedCoordinate: s } = e, n = O(s[0], s[1]), { oppositeBboxIndex: a, closestBBoxIndex: l } = this.getIndexesWebMercator(i, n), d = { x: i[a][0], y: i[a][1] }, c = O(t.lng, t.lat);
    return this.scaleWebMercator({ closestBBoxIndex: l, updatedCoords: o, webMercatorCursor: c, webMercatorSelected: n, webMercatorOrigin: d }), o;
  }
  scaleWebMercator({ closestBBoxIndex: t, webMercatorOrigin: e, webMercatorSelected: i, webMercatorCursor: o, updatedCoords: s }) {
    const n = e.x - o.x, a = e.y - o.y;
    if (!this.isValidDragWebMercator(t, n, a)) return null;
    let l = 1;
    n !== 0 && t !== 1 && t !== 5 && (l = 1 - (e.x - i.x - n) / n);
    let d = 1;
    return a !== 0 && t !== 3 && t !== 7 && (d = 1 - (e.y - i.y - a) / a), this.validateScale(l, d) ? (l < 0 && (l = this.minimumScale), d < 0 && (d = this.minimumScale), this.performWebMercatorScale(s, e.x, e.y, l, d), s) : null;
  }
  getFeature(t) {
    if (this.draggedCoordinate.id === null) return null;
    const e = this.store.getGeometryCopy(t);
    return e.type !== "Polygon" && e.type !== "LineString" ? null : { id: t, type: "Feature", geometry: e, properties: {} };
  }
  getNormalisedCoordinates(t) {
    return t.type === "Polygon" ? t.coordinates[0] : t.coordinates;
  }
  validateScale(t, e) {
    const i = !isNaN(t) && e < Number.MAX_SAFE_INTEGER, o = !isNaN(e) && e < Number.MAX_SAFE_INTEGER;
    return i && o;
  }
  performWebMercatorScale(t, e, i, o, s) {
    t.forEach((n) => {
      const { x: a, y: l } = O(n[0], n[1]), d = e + (a - e) * o, c = i + (l - i) * s, { lng: h, lat: u } = R(d, c);
      n[0] = h, n[1] = u;
    });
  }
  getBBoxWebMercator(t) {
    const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    (t = t.map((a) => {
      const { x: l, y: d } = O(a[0], a[1]);
      return [l, d];
    })).forEach(([a, l]) => {
      a < e[0] && (e[0] = a), l < e[1] && (e[1] = l), a > e[2] && (e[2] = a), l > e[3] && (e[3] = l);
    });
    const [i, o, s, n] = e;
    return [[i, n], [(i + s) / 2, n], [s, n], [s, n + (o - n) / 2], [s, o], [(i + s) / 2, o], [i, o], [i, n + (o - n) / 2]];
  }
  getIndexesWebMercator(t, e) {
    let i, o = 1 / 0;
    for (let s = 0; s < t.length; s++) {
      const n = F({ x: e.x, y: e.y }, { x: t[s][0], y: t[s][1] });
      n < o && (i = s, o = n);
    }
    if (i === void 0) throw new Error("No closest coordinate found");
    return { oppositeBboxIndex: this.boundingBoxMaps.opposite[i], closestBBoxIndex: i };
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(t, e) {
    this.draggedCoordinate = { id: t, index: e };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
  getDraggableIndex(t, e) {
    const i = this.store.getGeometryCopy(e), o = this.getClosestCoordinate(t, i);
    return o.index === -1 ? -1 : o.index;
  }
  drag(t, e, i) {
    if (!this.draggedCoordinate.id) return !1;
    const o = this.getFeature(this.draggedCoordinate.id);
    if (!o) return !1;
    let s = null;
    if (e === "center" ? s = this.centerWebMercatorDrag(t) : e === "opposite" ? s = this.oppositeWebMercatorDrag(t) : e === "center-fixed" ? s = this.centerFixedWebMercatorDrag(t) : e === "opposite-fixed" && (s = this.oppositeFixedWebMercatorDrag(t)), !s) return !1;
    for (let c = 0; c < s.length; c++) {
      const h = s[c];
      if (h[0] = w(h[0], this.coordinatePrecision), h[1] = w(h[1], this.coordinatePrecision), !Ot(h, this.coordinatePrecision)) return !1;
    }
    const n = this.midPoints.getUpdated(s) || [], a = this.selectionPoints.getUpdated(s) || [], l = this.coordinatePoints.getUpdated(o.id, s) || [], d = { type: o.geometry.type, coordinates: o.geometry.type === "Polygon" ? [s] : s };
    return !(i && !i({ id: this.draggedCoordinate.id, type: "Feature", geometry: d, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: b.Provisional }).valid || (this.store.updateGeometry([{ id: this.draggedCoordinate.id, geometry: d }, ...a, ...n, ...l]), 0));
  }
}
const _i = { deselect: "Escape", delete: "Delete", rotate: ["Control", "r"], scale: ["Control", "s"] }, ce = { pointerOver: "move", dragStart: "move", dragEnd: "move", insertMidpoint: "crosshair" };
class zt extends Ze {
  constructor(t) {
    super(t, !0), this.mode = "select", this.allowManualDeselection = !0, this.dragEventThrottle = 5, this.dragEventCount = 0, this.selected = [], this.flags = {}, this.keyEvents = _i, this.cursors = ce, this.validations = {}, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinateSnap = void 0, this.featuresAtMouseEvent = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.dragFeature = void 0, this.dragCoordinate = void 0, this.rotateFeature = void 0, this.scaleFeature = void 0, this.dragCoordinateResizeFeature = void 0, this.coordinatePoints = void 0, this.lineSnap = void 0, this.updateOptions(t);
  }
  updateOptions(t) {
    if (super.updateOptions(t), this.cursors = t && t.cursors ? x({}, this.cursors, t.cursors) : ce, t?.keyEvents === null ? this.keyEvents = { deselect: null, delete: null, rotate: null, scale: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents)), t?.dragEventThrottle !== void 0 && (this.dragEventThrottle = t.dragEventThrottle), t?.allowManualDeselection !== void 0 && (this.allowManualDeselection = t.allowManualDeselection), t != null && t.flags) {
      this.flags = x({}, this.flags, t.flags), this.validations = {};
      for (const e in this.flags) {
        const i = this.flags[e].feature;
        i && i.validation && (this.validations[e] = i.validation);
      }
    }
  }
  selectFeature(t) {
    this.select(t, !1);
  }
  setSelecting() {
    if (this._state !== "started") throw new Error("Mode must be started to move to selecting state");
    this._state = "selecting";
  }
  registerBehaviors(t) {
    this.pixelDistance = new ct(t), this.clickBoundingBox = new dt(t), this.featuresAtMouseEvent = new Ei(t, this.clickBoundingBox, this.pixelDistance), this.selectionPoints = new bi(t), this.coordinatePoints = new Le(t), this.midPoints = new Oi(t, this.selectionPoints, this.coordinatePoints), this.coordinateSnap = new It(t, this.pixelDistance, this.clickBoundingBox), this.lineSnap = new Rt(t, this.pixelDistance, this.clickBoundingBox), this.rotateFeature = new Fi(t, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragFeature = new wi(t, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragCoordinate = new Li(t, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints, this.coordinateSnap, this.lineSnap), this.dragCoordinateResizeFeature = new Di(t, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints), this.scaleFeature = new Mi(t, this.dragCoordinateResizeFeature);
  }
  deselectFeature() {
    this.deselect();
  }
  deselect() {
    const t = this.selected.filter((e) => this.store.has(e)).map((e) => ({ id: e, property: k.SELECTED, value: !1 }));
    this.store.updateProperty(t), this.onDeselect(this.selected[0]), this.selected = [], this.selectionPoints.delete(), this.midPoints.delete();
  }
  deleteSelected() {
    this.store.delete(this.selected), this.selected = [];
  }
  onRightClick(t) {
    if (!this.selectionPoints.ids.length) return;
    let e, i = 1 / 0;
    if (this.selectionPoints.ids.forEach((u) => {
      const p = this.store.getGeometryCopy(u), g = this.pixelDistance.measure(t, p.coordinates);
      g < this.pointerDistance && g < i && (i = g, e = this.store.getPropertiesCopy(u));
    }), !e) return;
    const o = e.selectionPointFeatureId, s = e.index, n = this.store.getPropertiesCopy(o), a = this.flags[n.mode], l = this.validations[n.mode];
    if (!(a && a.feature && a.feature.coordinates && a.feature.coordinates.deletable)) return;
    const d = this.store.getGeometryCopy(o);
    let c;
    if (d.type === "Polygon") {
      if (c = d.coordinates[0], c.length <= 4) return;
    } else if (d.type === "LineString" && (c = d.coordinates, c.length <= 2)) return;
    if (!c || (d.type !== "Polygon" || s !== 0 && s !== c.length - 1 ? c.splice(s, 1) : (c.shift(), c.pop(), c.push([c[0][0], c[0][1]])), l && !l({ id: o, type: "Feature", geometry: d, properties: n }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Commit }).valid)) return;
    const h = [...this.midPoints.ids, ...this.selectionPoints.ids];
    this.store.delete(h), this.store.updateGeometry([{ id: o, geometry: d }]), n.coordinatePointIds && this.coordinatePoints.createOrUpdate(o), this.selectionPoints.create(c, d.type, o), a && a.feature && a.feature.coordinates && a.feature.coordinates.midpoints && this.midPoints.create(c, o, this.coordinatePrecision);
  }
  select(t, e = !0) {
    if (this.selected[0] === t) return;
    const { mode: i } = this.store.getPropertiesCopy(t), o = this.flags[i];
    if (!o || !o.feature) return;
    const s = this.selected[0];
    if (s) {
      if (s === t) return;
      this.deselect();
    }
    e && this.setCursor(this.cursors.pointerOver), this.selected = [t], this.store.updateProperty([{ id: t, property: k.SELECTED, value: !0 }]), this.onSelect(t);
    const { type: n, coordinates: a } = this.store.getGeometryCopy(t);
    if (n !== "LineString" && n !== "Polygon") return;
    const l = n === "LineString" ? a : a[0];
    l && o && o.feature.coordinates && (this.selectionPoints.create(l, n, t), o.feature.coordinates.midpoints && this.midPoints.create(l, t, this.coordinatePrecision));
  }
  onLeftClick(t) {
    const { clickedFeature: e, clickedMidPoint: i } = this.featuresAtMouseEvent.find(t, this.selected.length > 0);
    if (this.selected.length && i) this.midPoints.insert(this.selected[0], i.id, this.coordinatePrecision);
    else if (e && e.id) this.select(e.id, !0);
    else if (this.selected.length && this.allowManualDeselection) return void this.deselect();
  }
  start() {
    this.setStarted(), this.setSelecting();
  }
  stop() {
    this.cleanUp(), this.setStarted(), this.setStopped();
  }
  onClick(t) {
    t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t) ? this.onRightClick(t) : t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) && this.onLeftClick(t);
  }
  canScale(t) {
    return this.keyEvents.scale && this.keyEvents.scale.every((e) => t.heldKeys.includes(e));
  }
  canRotate(t) {
    return this.keyEvents.rotate && this.keyEvents.rotate.every((e) => t.heldKeys.includes(e));
  }
  preventDefaultKeyEvent(t) {
    const e = this.canRotate(t), i = this.canScale(t);
    (e || i) && t.preventDefault();
  }
  onKeyDown(t) {
    this.preventDefaultKeyEvent(t);
  }
  onKeyUp(t) {
    if (this.preventDefaultKeyEvent(t), this.keyEvents.delete && t.key === this.keyEvents.delete) {
      if (!this.selected.length) return;
      const e = this.selected[0];
      this.onDeselect(this.selected[0]), this.coordinatePoints.deletePointsByFeatureIds([e]), this.deleteSelected(), this.selectionPoints.delete(), this.midPoints.delete();
    } else this.keyEvents.deselect && t.key === this.keyEvents.deselect && this.cleanUp();
  }
  cleanUp() {
    this.selected.length && this.deselect();
  }
  onDragStart(t, e) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, t) || !this.selected.length) return;
    const i = this.store.getPropertiesCopy(this.selected[0]), o = this.flags[i.mode];
    if (!(o && o.feature && (o.feature.draggable || o.feature.coordinates && o.feature.coordinates.draggable || o.feature.coordinates && o.feature.coordinates.resizable || o.feature.coordinates && typeof o.feature.coordinates.midpoints == "object" && o.feature.coordinates.midpoints.draggable))) return;
    this.dragEventCount = 0;
    const s = this.selected[0], n = this.dragCoordinate.getDraggableIndex(t, s);
    if (o && o.feature && o.feature.coordinates && (o.feature.coordinates.draggable || o.feature.coordinates.resizable) && n !== -1) return this.setCursor(this.cursors.dragStart), o.feature.coordinates.resizable ? this.dragCoordinateResizeFeature.startDragging(s, n) : this.dragCoordinate.startDragging(s, n), void e(!1);
    if (o && o.feature && o.feature.coordinates && typeof o.feature.coordinates.midpoints == "object" && o.feature.coordinates.midpoints.draggable) {
      const { clickedMidPoint: a } = this.featuresAtMouseEvent.find(t, this.selected.length > 0);
      if (this.selected.length && a) {
        this.midPoints.insert(s, a.id, this.coordinatePrecision);
        const l = this.dragCoordinate.getDraggableIndex(t, s);
        return this.dragCoordinate.startDragging(s, l), void e(!1);
      }
    }
    return o && o.feature && o.feature.draggable && this.dragFeature.canDrag(t, s) ? (this.setCursor(this.cursors.dragStart), this.dragFeature.startDragging(t, s), void e(!1)) : void 0;
  }
  onDrag(t, e) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, t)) return;
    const i = this.selected[0];
    if (!i) return;
    const o = this.store.getPropertiesCopy(i), s = this.flags[o.mode], n = (s && s.feature && s.feature.selfIntersectable) === !0;
    if (this.dragEventCount++, this.dragEventCount % this.dragEventThrottle == 0) return;
    const a = this.validations[o.mode];
    if (s && s.feature && s.feature.rotateable && this.canRotate(t)) return e(!1), void this.rotateFeature.rotate(t, i, a);
    if (s && s.feature && s.feature.scaleable && this.canScale(t)) return e(!1), void this.scaleFeature.scale(t, i, a);
    if (this.dragCoordinateResizeFeature.isDragging() && s.feature && s.feature.coordinates && s.feature.coordinates.resizable) {
      if (this.projection === "globe") throw new Error("Globe is currently unsupported projection for resizable");
      return e(!1), void this.dragCoordinateResizeFeature.drag(t, s.feature.coordinates.resizable, a);
    }
    if (this.dragCoordinate.isDragging()) {
      var l;
      const d = (l = s.feature) == null || (l = l.coordinates) == null ? void 0 : l.snappable;
      let c = { toCoordinate: !1 };
      return d === !0 ? c = { toCoordinate: !0 } : typeof d == "object" && (c = d), void this.dragCoordinate.drag(t, n, a, c);
    }
    this.dragFeature.isDragging() ? this.dragFeature.drag(t, a) : e(!0);
  }
  onDragEnd(t, e) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, t) && (this.setCursor(this.cursors.dragEnd), this.dragCoordinate.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinate" }) : this.dragFeature.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragFeature" }) : this.dragCoordinateResizeFeature.isDragging() && this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinateResize" }), this.dragCoordinate.stopDragging(), this.dragFeature.stopDragging(), this.dragCoordinateResizeFeature.stopDragging(), this.rotateFeature.reset(), this.scaleFeature.reset(), e(!0));
  }
  onMouseMove(t) {
    if (!this.selected.length) return void this.setCursor("unset");
    if (this.dragFeature.isDragging()) return;
    let e = !1;
    this.midPoints.ids.forEach((s) => {
      if (e) return;
      const n = this.store.getGeometryCopy(s);
      this.pixelDistance.measure(t, n.coordinates) < this.pointerDistance && (e = !0);
    });
    let i = !1;
    if (this.selectionPoints.ids.forEach((s) => {
      const n = this.store.getGeometryCopy(s);
      this.pixelDistance.measure(t, n.coordinates) < this.pointerDistance && (e = !1, i = !0);
    }), e) return void this.setCursor(this.cursors.insertMidpoint);
    const { clickedFeature: o } = this.featuresAtMouseEvent.find(t, !0);
    this.setCursor(this.selected.length > 0 && (o && o.id === this.selected[0] || i) ? this.cursors.pointerOver : "unset");
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (t.properties.mode === this.mode && t.geometry.type === "Point") {
      if (t.properties.selectionPoint) return e.pointColor = this.getHexColorStylingValue(this.styles.selectionPointColor, e.pointColor, t), e.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectionPointOutlineColor, e.pointOutlineColor, t), e.pointWidth = this.getNumericStylingValue(this.styles.selectionPointWidth, e.pointWidth, t), e.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectionPointOutlineWidth, 2, t), e.zIndex = 30, e;
      if (t.properties.midPoint) return e.pointColor = this.getHexColorStylingValue(this.styles.midPointColor, e.pointColor, t), e.pointOutlineColor = this.getHexColorStylingValue(this.styles.midPointOutlineColor, e.pointOutlineColor, t), e.pointWidth = this.getNumericStylingValue(this.styles.midPointWidth, 4, t), e.pointOutlineWidth = this.getNumericStylingValue(this.styles.midPointOutlineWidth, 2, t), e.zIndex = 50, e;
    } else if (t.properties[k.SELECTED]) {
      if (t.geometry.type === "Polygon") return e.polygonFillColor = this.getHexColorStylingValue(this.styles.selectedPolygonColor, e.polygonFillColor, t), e.polygonOutlineWidth = this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth, e.polygonOutlineWidth, t), e.polygonOutlineColor = this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor, e.polygonOutlineColor, t), e.polygonFillOpacity = this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity, e.polygonFillOpacity, t), e.zIndex = j, e;
      if (t.geometry.type === "LineString") return e.lineStringColor = this.getHexColorStylingValue(this.styles.selectedLineStringColor, e.lineStringColor, t), e.lineStringWidth = this.getNumericStylingValue(this.styles.selectedLineStringWidth, e.lineStringWidth, t), e.zIndex = j, e;
      if (t.geometry.type === "Point") return e.pointWidth = this.getNumericStylingValue(this.styles.selectedPointWidth, e.pointWidth, t), e.pointColor = this.getHexColorStylingValue(this.styles.selectedPointColor, e.pointColor, t), e.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectedPointOutlineColor, e.pointOutlineColor, t), e.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectedPointOutlineWidth, e.pointOutlineWidth, t), e.zIndex = j, e;
    }
    return e;
  }
  afterFeatureUpdated(t) {
    if (this.selected.length && t.id === this.selected[0]) {
      var e, i;
      const o = this.flags[t.properties.mode];
      if (o == null || (e = o.feature) == null || !e.coordinates) return;
      const s = t.geometry.type, n = t.id;
      let a;
      if (this.selectionPoints.delete(), this.midPoints.delete(), s === "Polygon") a = t.geometry.coordinates[0];
      else {
        if (s !== "LineString") return;
        a = t.geometry.coordinates;
      }
      this.selectionPoints.create(a, s, n), o != null && (i = o.feature) != null && (i = i.coordinates) != null && i.midpoints && this.midPoints.create(s === "Polygon" ? t.geometry.coordinates[0] : t.geometry.coordinates, n, this.coordinatePrecision);
    }
  }
}
class ki extends A {
  constructor(...t) {
    super(...t), this.type = H.Static, this.mode = "static";
  }
  start() {
  }
  stop() {
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature() {
    return x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
  }
}
function We(r, t, e, i, o) {
  for (; i > e; ) {
    if (i - e > 600) {
      const l = i - e + 1, d = t - e + 1, c = Math.log(l), h = 0.5 * Math.exp(2 * c / 3), u = 0.5 * Math.sqrt(c * h * (l - h) / l) * (d - l / 2 < 0 ? -1 : 1);
      We(r, t, Math.max(e, Math.floor(t - d * h / l + u)), Math.min(i, Math.floor(t + (l - d) * h / l + u)), o);
    }
    const s = r[t];
    let n = e, a = i;
    for (it(r, e, t), o(r[i], s) > 0 && it(r, e, i); n < a; ) {
      for (it(r, n, a), n++, a--; o(r[n], s) < 0; ) n++;
      for (; o(r[a], s) > 0; ) a--;
    }
    o(r[e], s) === 0 ? it(r, e, a) : (a++, it(r, a, i)), a <= t && (e = a + 1), t <= a && (i = a - 1);
  }
}
function it(r, t, e) {
  const i = r[t];
  r[t] = r[e], r[e] = i;
}
function J(r, t) {
  nt(r, 0, r.children.length, t, r);
}
function nt(r, t, e, i, o) {
  o || (o = Z([])), o.minX = 1 / 0, o.minY = 1 / 0, o.maxX = -1 / 0, o.maxY = -1 / 0;
  for (let s = t; s < e; s++) {
    const n = r.children[s];
    at(o, r.leaf ? i(n) : n);
  }
  return o;
}
function at(r, t) {
  return r.minX = Math.min(r.minX, t.minX), r.minY = Math.min(r.minY, t.minY), r.maxX = Math.max(r.maxX, t.maxX), r.maxY = Math.max(r.maxY, t.maxY), r;
}
function Ni(r, t) {
  return r.minX - t.minX;
}
function Ti(r, t) {
  return r.minY - t.minY;
}
function Lt(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function ft(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function Wi(r, t) {
  const e = Math.max(r.minX, t.minX), i = Math.max(r.minY, t.minY), o = Math.min(r.maxX, t.maxX), s = Math.min(r.maxY, t.maxY);
  return Math.max(0, o - e) * Math.max(0, s - i);
}
function Ft(r, t) {
  return r.minX <= t.minX && r.minY <= t.minY && t.maxX <= r.maxX && t.maxY <= r.maxY;
}
function mt(r, t) {
  return t.minX <= r.maxX && t.minY <= r.maxY && t.maxX >= r.minX && t.maxY >= r.minY;
}
function Z(r) {
  return { children: r, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function he(r, t, e, i, o) {
  const s = [t, e];
  for (; s.length; ) {
    if ((e = s.pop()) - (t = s.pop()) <= i) continue;
    const n = t + Math.ceil((e - t) / i / 2) * i;
    We(r, n, t, e, o), s.push(t, n, n, e);
  }
}
class Bi {
  constructor(t) {
    this._maxEntries = void 0, this._minEntries = void 0, this.data = void 0, this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
  }
  search(t) {
    let e = this.data;
    const i = [];
    if (!mt(t, e)) return i;
    const o = this.toBBox, s = [];
    for (; e; ) {
      for (let n = 0; n < e.children.length; n++) {
        const a = e.children[n], l = e.leaf ? o(a) : a;
        mt(t, l) && (e.leaf ? i.push(a) : Ft(t, l) ? this._all(a, i) : s.push(a));
      }
      e = s.pop();
    }
    return i;
  }
  collides(t) {
    let e = this.data;
    if (mt(t, e)) {
      const i = [];
      for (; e; ) {
        for (let o = 0; o < e.children.length; o++) {
          const s = e.children[o], n = e.leaf ? this.toBBox(s) : s;
          if (mt(t, n)) {
            if (e.leaf || Ft(t, n)) return !0;
            i.push(s);
          }
        }
        e = i.pop();
      }
    }
    return !1;
  }
  load(t) {
    if (t.length < this._minEntries) {
      for (let i = 0; i < t.length; i++) this.insert(t[i]);
      return;
    }
    let e = this._build(t.slice(), 0, t.length - 1, 0);
    if (this.data.children.length) if (this.data.height === e.height) this._splitRoot(this.data, e);
    else {
      if (this.data.height < e.height) {
        const i = this.data;
        this.data = e, e = i;
      }
      this._insert(e, this.data.height - e.height - 1, !0);
    }
    else this.data = e;
  }
  insert(t) {
    this._insert(t, this.data.height - 1);
  }
  clear() {
    this.data = Z([]);
  }
  remove(t) {
    let e = this.data;
    const i = this.toBBox(t), o = [], s = [];
    let n, a, l = !1;
    for (; e || o.length; ) {
      if (e || (e = o.pop(), a = o[o.length - 1], n = s.pop(), l = !0), e.leaf) {
        const d = e.children.indexOf(t);
        d !== -1 && (e.children.splice(d, 1), o.push(e), this._condense(o));
      }
      l || e.leaf || !Ft(e, i) ? a ? (n++, e = a.children[n], l = !1) : e = null : (o.push(e), s.push(n), n = 0, a = e, e = e.children[0]);
    }
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, e) {
    return t.minX - e.minX;
  }
  compareMinY(t, e) {
    return t.minY - e.minY;
  }
  _all(t, e) {
    const i = [];
    for (; t; ) t.leaf ? e.push(...t.children) : i.push(...t.children), t = i.pop();
    return e;
  }
  _build(t, e, i, o) {
    const s = i - e + 1;
    let n, a = this._maxEntries;
    if (s <= a) return n = Z(t.slice(e, i + 1)), J(n, this.toBBox), n;
    o || (o = Math.ceil(Math.log(s) / Math.log(a)), a = Math.ceil(s / Math.pow(a, o - 1))), n = Z([]), n.leaf = !1, n.height = o;
    const l = Math.ceil(s / a), d = l * Math.ceil(Math.sqrt(a));
    he(t, e, i, d, this.compareMinX);
    for (let c = e; c <= i; c += d) {
      const h = Math.min(c + d - 1, i);
      he(t, c, h, l, this.compareMinY);
      for (let u = c; u <= h; u += l) {
        const p = Math.min(u + l - 1, h);
        n.children.push(this._build(t, u, p, o - 1));
      }
    }
    return J(n, this.toBBox), n;
  }
  _chooseSubtree(t, e, i, o) {
    for (; o.push(e), !e.leaf && o.length - 1 !== i; ) {
      let a, l = 1 / 0, d = 1 / 0;
      for (let c = 0; c < e.children.length; c++) {
        const h = e.children[c], u = Lt(h), p = (s = t, n = h, (Math.max(n.maxX, s.maxX) - Math.min(n.minX, s.minX)) * (Math.max(n.maxY, s.maxY) - Math.min(n.minY, s.minY)) - u);
        p < d ? (d = p, l = u < l ? u : l, a = h) : p === d && u < l && (l = u, a = h);
      }
      e = a || e.children[0];
    }
    var s, n;
    return e;
  }
  _insert(t, e, i) {
    const o = i ? t : this.toBBox(t), s = [], n = this._chooseSubtree(o, this.data, e, s);
    for (n.children.push(t), at(n, o); e >= 0 && s[e].children.length > this._maxEntries; ) this._split(s, e), e--;
    this._adjustParentBBoxes(o, s, e);
  }
  _split(t, e) {
    const i = t[e], o = i.children.length, s = this._minEntries;
    this._chooseSplitAxis(i, s, o);
    const n = this._chooseSplitIndex(i, s, o), a = Z(i.children.splice(n, i.children.length - n));
    a.height = i.height, a.leaf = i.leaf, J(i, this.toBBox), J(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(i, a);
  }
  _splitRoot(t, e) {
    this.data = Z([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, J(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, e, i) {
    let o, s = 1 / 0, n = 1 / 0;
    for (let a = e; a <= i - e; a++) {
      const l = nt(t, 0, a, this.toBBox), d = nt(t, a, i, this.toBBox), c = Wi(l, d), h = Lt(l) + Lt(d);
      c < s ? (s = c, o = a, n = h < n ? h : n) : c === s && h < n && (n = h, o = a);
    }
    return o || i - e;
  }
  _chooseSplitAxis(t, e, i) {
    const o = t.leaf ? this.compareMinX : Ni, s = t.leaf ? this.compareMinY : Ti;
    this._allDistMargin(t, e, i, o) < this._allDistMargin(t, e, i, s) && t.children.sort(o);
  }
  _allDistMargin(t, e, i, o) {
    t.children.sort(o);
    const s = this.toBBox, n = nt(t, 0, e, s), a = nt(t, i - e, i, s);
    let l = ft(n) + ft(a);
    for (let d = e; d < i - e; d++) {
      const c = t.children[d];
      at(n, t.leaf ? s(c) : c), l += ft(n);
    }
    for (let d = i - e - 1; d >= e; d--) {
      const c = t.children[d];
      at(a, t.leaf ? s(c) : c), l += ft(a);
    }
    return l;
  }
  _adjustParentBBoxes(t, e, i) {
    for (let o = i; o >= 0; o--) at(e[o], t);
  }
  _condense(t) {
    for (let e, i = t.length - 1; i >= 0; i--) t[i].children.length === 0 ? i > 0 ? (e = t[i - 1].children, e.splice(e.indexOf(t[i]), 1)) : this.clear() : J(t[i], this.toBBox);
  }
}
class ji {
  constructor(t) {
    this.tree = void 0, this.idToNode = void 0, this.nodeToId = void 0, this.tree = new Bi(t && t.maxEntries ? t.maxEntries : 9), this.idToNode = /* @__PURE__ */ new Map(), this.nodeToId = /* @__PURE__ */ new Map();
  }
  setMaps(t, e) {
    this.idToNode.set(t.id, e), this.nodeToId.set(e, t.id);
  }
  toBBox(t) {
    const e = [], i = [];
    let o;
    if (t.geometry.type === "Polygon") o = t.geometry.coordinates[0];
    else if (t.geometry.type === "LineString") o = t.geometry.coordinates;
    else {
      if (t.geometry.type !== "Point") throw new Error("Not a valid feature to turn into a bounding box");
      o = [t.geometry.coordinates];
    }
    for (let a = 0; a < o.length; a++) i.push(o[a][1]), e.push(o[a][0]);
    const s = Math.min(...i), n = Math.max(...i);
    return { minX: Math.min(...e), minY: s, maxX: Math.max(...e), maxY: n };
  }
  insert(t) {
    if (this.idToNode.get(String(t.id))) throw new Error("Feature already exists");
    const e = this.toBBox(t);
    this.setMaps(t, e), this.tree.insert(e);
  }
  load(t) {
    const e = [], i = /* @__PURE__ */ new Set();
    t.forEach((o) => {
      const s = this.toBBox(o);
      if (this.setMaps(o, s), i.has(String(o.id))) throw new Error(`Duplicate feature ID found ${o.id}`);
      i.add(String(o.id)), e.push(s);
    }), this.tree.load(e);
  }
  update(t) {
    this.remove(t.id);
    const e = this.toBBox(t);
    this.setMaps(t, e), this.tree.insert(e);
  }
  remove(t) {
    const e = this.idToNode.get(t);
    if (!e) throw new Error(`${t} not inserted into the spatial index`);
    this.tree.remove(e);
  }
  clear() {
    this.tree.clear();
  }
  search(t) {
    return this.tree.search(this.toBBox(t)).map((e) => this.nodeToId.get(e));
  }
  collides(t) {
    return this.tree.collides(this.toBBox(t));
  }
}
const Ai = { getId: () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
  const t = 16 * Math.random() | 0;
  return (r == "x" ? t : 3 & t | 8).toString(16);
}), isValidId: (r) => typeof r == "string" && r.length === 36 };
class Ri {
  constructor(t) {
    this.idStrategy = void 0, this.tracked = void 0, this.spatialIndex = void 0, this.store = void 0, this._onChange = () => {
    }, this.store = {}, this.spatialIndex = new ji(), this.tracked = !t || t.tracked !== !1, this.idStrategy = t && t.idStrategy ? t.idStrategy : Ai;
  }
  clone(t) {
    return JSON.parse(JSON.stringify(t));
  }
  getId() {
    return this.idStrategy.getId();
  }
  has(t) {
    return !!this.store[t];
  }
  load(t, e, i, o) {
    if (t.length === 0) return [];
    let s = this.clone(t);
    const n = [], a = [];
    s = s.filter((d) => {
      d.id == null && (d.id = this.idStrategy.getId());
      const c = d.id;
      if (e) {
        const h = e(d);
        if (!h.valid) return n.push({ id: c, valid: !1, reason: h.reason }), !1;
      }
      if (this.tracked) {
        if (d.properties.createdAt) {
          if (!Qt(d.properties.createdAt)) return n.push({ id: d.id, valid: !1, reason: "createdAt is not a valid numeric timestamp" }), !1;
        } else d.properties.createdAt = +/* @__PURE__ */ new Date();
        if (d.properties.updatedAt) {
          if (!Qt(d.properties.updatedAt)) return n.push({ id: d.id, valid: !1, reason: "updatedAt is not a valid numeric timestamp" }), !1;
        } else d.properties.updatedAt = +/* @__PURE__ */ new Date();
      }
      return this.has(c) ? (n.push({ id: c, valid: !1, reason: `Feature already exists with this id: ${c}` }), !1) : (this.store[c] = d, a.push(d), n.push({ id: c, valid: !0 }), !0);
    }), this.spatialIndex.load(s);
    const l = a.map(({ id: d }) => d);
    return l.length > 0 && (this._onChange(l, "create", o), i && a.forEach((d) => {
      i(d);
    })), n;
  }
  search(t, e) {
    const i = this.spatialIndex.search(t).map((o) => this.store[o]);
    return this.clone(e ? i.filter(e) : i);
  }
  registerOnChange(t) {
    this._onChange = (e, i, o) => {
      t(e, i, o);
    };
  }
  getGeometryCopy(t) {
    const e = this.store[t];
    if (!e) throw new Error(`No feature with this id (${t}), can not get geometry copy`);
    return this.clone(e.geometry);
  }
  getPropertiesCopy(t) {
    const e = this.store[t];
    if (!e) throw new Error(`No feature with this id (${t}), can not get properties copy`);
    return this.clone(e.properties);
  }
  updateProperty(t, e) {
    const i = [];
    t.forEach(({ id: o, property: s, value: n }) => {
      const a = this.store[o];
      if (!a) throw new Error(`No feature with this (${o}), can not update geometry`);
      i.push(o), n === void 0 ? delete a.properties[s] : a.properties[s] = n, this.tracked && (a.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(i, "update", e);
  }
  updateGeometry(t, e) {
    const i = [];
    t.forEach(({ id: o, geometry: s }) => {
      i.push(o);
      const n = this.store[o];
      if (!n) throw new Error(`No feature with this (${o}), can not update geometry`);
      n.geometry = this.clone(s), this.spatialIndex.update(n), this.tracked && (n.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(i, "update", e);
  }
  create(t, e) {
    const i = [];
    return t.forEach(({ geometry: o, properties: s }) => {
      let n, a = x({}, s);
      this.tracked && (n = +/* @__PURE__ */ new Date(), s ? (a.createdAt = typeof s.createdAt == "number" ? s.createdAt : n, a.updatedAt = typeof s.updatedAt == "number" ? s.updatedAt : n) : a = { createdAt: n, updatedAt: n });
      const l = this.getId(), d = { id: l, type: "Feature", geometry: o, properties: a };
      this.store[l] = d, this.spatialIndex.insert(d), i.push(l);
    }), this._onChange && this._onChange([...i], "create", e), i;
  }
  delete(t, e) {
    t.forEach((i) => {
      if (!this.store[i]) throw new Error(`No feature with id ${i}, can not delete`);
      delete this.store[i], this.spatialIndex.remove(i);
    }), this._onChange && this._onChange([...t], "delete", e);
  }
  copy(t) {
    return this.clone(this.store[t]);
  }
  copyAll() {
    return this.clone(Object.keys(this.store).map((t) => this.store[t]));
  }
  copyAllWhere(t) {
    return this.clone(Object.keys(this.store).map((e) => this.store[e]).filter((e) => e.properties && t(e.properties)));
  }
  clear() {
    this.store = {}, this.spatialIndex.clear();
  }
  size() {
    return Object.keys(this.store).length;
  }
}
const Gi = "Feature is not a Polygon or LineString", Ui = "Feature intersects itself", zi = (r) => r.geometry.type !== "Polygon" && r.geometry.type !== "LineString" ? { valid: !1, reason: Gi } : Bt(r) ? { valid: !1, reason: Ui } : { valid: !0 };
function ue(r, t, e) {
  const i = G(r, t);
  let o = G(t, e) - i;
  return o < 0 && (o += 360), 180 - Math.abs(o - 90 - 90);
}
const Vi = { cancel: "Escape", finish: "Enter" }, $i = { start: "crosshair", close: "pointer" };
class Be extends A {
  constructor(t) {
    super(t, !0), this.mode = "angled-rectangle", this.currentCoordinate = 0, this.currentId = void 0, this.keyEvents = Vi, this.cursors = $i, this.mouseMove = !1, this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors)), t?.keyEvents === null ? this.keyEvents = { cancel: null, finish: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents));
  }
  close() {
    if (this.currentId === void 0) return;
    this.store.updateProperty([{ id: this.currentId, property: S.CURRENTLY_DRAWING, value: void 0 }]);
    const t = this.currentId;
    this.currentCoordinate = 0, this.currentId = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(t, { mode: this.mode, action: "draw" });
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(t) {
    if (this.mouseMove = !0, this.setCursor(this.cursors.start), this.currentId === void 0 || this.currentCoordinate === 0) return;
    const e = this.store.getGeometryCopy(this.currentId).coordinates[0];
    let i;
    if (this.currentCoordinate === 1) {
      const o = 1 / Math.pow(10, this.coordinatePrecision - 1), s = Math.max(1e-6, o);
      i = [e[0], [t.lng, t.lat], [t.lng, t.lat - s], e[0]];
    } else if (this.currentCoordinate === 2) {
      const o = e[0], s = e[1], n = _e(o, s, this.coordinatePrecision, this.project, this.unproject), a = O(o[0], o[1]), l = O(n[0], n[1]), d = O(s[0], s[1]), c = O(t.lng, t.lat), h = F(c, a) < F(c, d), u = ue(a, l, c), p = h ? 90 - u : ue(a, l, c) - 90, g = F(l, c), y = Math.cos(D(p)) * g, m = G(a, d) + ((function(I, E, L) {
        const M = (L.x - E.x) * (I.y - E.y) - (L.y - E.y) * (I.x - E.x);
        return M > 1e-10 ? "left" : M < -1e-10 ? "right" : "left";
      })(a, d, c) === "right" ? -90 : 90), v = ht(a, y, m), C = ht(d, y, m), f = R(v.x, v.y), P = R(C.x, C.y);
      i = [e[0], e[1], [P.lng, P.lat], [f.lng, f.lat], e[0]];
    }
    i && this.updatePolygonGeometry(this.currentId, i, b.Provisional);
  }
  updatePolygonGeometry(t, e, i) {
    const o = { type: "Polygon", coordinates: [e] };
    return !(this.validate && !this.validate({ type: "Feature", geometry: o }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: i }).valid || (this.store.updateGeometry([{ id: t, geometry: o }]), 0));
  }
  onClick(t) {
    if (t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t)) if (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(t), this.mouseMove = !1, this.currentCoordinate === 0) {
      const [e] = this.store.create([{ geometry: { type: "Polygon", coordinates: [[[t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat]]] }, properties: { mode: this.mode, [S.CURRENTLY_DRAWING]: !0 } }]);
      this.currentId = e, this.currentCoordinate++, this.setDrawing();
    } else if (this.currentCoordinate === 1 && this.currentId) {
      const e = this.store.getGeometryCopy(this.currentId);
      if (tt([t.lng, t.lat], e.coordinates[0][0]) || !this.updatePolygonGeometry(this.currentId, [e.coordinates[0][0], [t.lng, t.lat], [t.lng, t.lat], e.coordinates[0][0]], b.Commit)) return;
      this.currentCoordinate++;
    } else this.currentCoordinate === 2 && this.currentId && this.close();
  }
  onKeyUp(t) {
    if (t.key === this.keyEvents.cancel) this.cleanUp();
    else if (t.key === this.keyEvents.finish) {
      if (this.currentCoordinate < 2) return void this.cleanUp();
      this.close();
    }
  }
  onKeyDown() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  cleanUp() {
    try {
      this.currentId && this.store.delete([this.currentId]);
    } catch {
    }
    this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    return t.properties.mode === this.mode && t.geometry.type === "Polygon" && (e.polygonFillColor = this.getHexColorStylingValue(this.styles.fillColor, e.polygonFillColor, t), e.polygonOutlineColor = this.getHexColorStylingValue(this.styles.outlineColor, e.polygonOutlineColor, t), e.polygonOutlineWidth = this.getNumericStylingValue(this.styles.outlineWidth, e.polygonOutlineWidth, t), e.polygonFillOpacity = this.getNumericStylingValue(this.styles.fillOpacity, e.polygonFillOpacity, t), e.zIndex = j), e;
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => ut(e, this.coordinatePrecision));
  }
  afterFeatureUpdated(t) {
    this.currentId === t.id && (this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted());
  }
}
function je(r, t, e) {
  return (t.x - r.x) * (e.y - r.y) - (t.y - r.y) * (e.x - r.x) <= 0;
}
const Yi = { cancel: "Escape", finish: "Enter" }, Ki = { start: "crosshair", close: "pointer" };
class Ae extends A {
  constructor(t) {
    super(t, !0), this.mode = "sector", this.currentCoordinate = 0, this.currentId = void 0, this.keyEvents = Yi, this.direction = void 0, this.arcPoints = 64, this.cursors = Ki, this.mouseMove = !1, this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors)), t?.keyEvents === null ? this.keyEvents = { cancel: null, finish: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents)), t != null && t.arcPoints && (this.arcPoints = t.arcPoints);
  }
  close() {
    if (this.currentId === void 0) return;
    const t = pt(this.store.getGeometryCopy(this.currentId));
    t && this.store.updateGeometry([{ id: this.currentId, geometry: t }]), this.store.updateProperty([{ id: this.currentId, property: S.CURRENTLY_DRAWING, value: void 0 }]);
    const e = this.currentId;
    this.currentCoordinate = 0, this.currentId = void 0, this.direction = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(e, { mode: this.mode, action: "draw" });
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(t) {
    if (this.mouseMove = !0, this.setCursor(this.cursors.start), this.currentId === void 0 || this.currentCoordinate === 0) return;
    const e = this.store.getGeometryCopy(this.currentId).coordinates[0];
    let i;
    if (this.currentCoordinate === 1) {
      const o = 1 / Math.pow(10, this.coordinatePrecision - 1), s = Math.max(1e-6, o);
      i = [e[0], [t.lng, t.lat], [t.lng, t.lat - s], e[0]];
    } else if (this.currentCoordinate === 2) {
      const o = e[0], s = e[1], n = [t.lng, t.lat], a = O(o[0], o[1]), l = O(s[0], s[1]), d = O(n[0], n[1]);
      if (this.direction === void 0) {
        const f = je(a, l, d);
        this.direction = f ? "clockwise" : "anticlockwise";
      }
      const c = F(a, l), h = G(a, l), u = G(a, d), p = this.arcPoints, g = [o], y = X(h), m = X(u);
      let v;
      this.direction === "anticlockwise" ? (v = m - y, v < 0 && (v += 360)) : (v = y - m, v < 0 && (v += 360));
      const C = (this.direction === "anticlockwise" ? 1 : -1) * v / p;
      g.push(s);
      for (let f = 0; f <= p; f++) {
        const P = ht(a, c, y + f * C), { lng: I, lat: E } = R(P.x, P.y), L = [w(I, this.coordinatePrecision), w(E, this.coordinatePrecision)];
        L[0] !== g[g.length - 1][0] && L[1] !== g[g.length - 1][1] && g.push(L);
      }
      g.push(o), i = [...g];
    }
    i && this.updatePolygonGeometry(this.currentId, i, b.Provisional);
  }
  updatePolygonGeometry(t, e, i) {
    const o = { type: "Polygon", coordinates: [e] };
    return !(this.validate && !this.validate({ type: "Feature", geometry: o }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: i }).valid || (this.store.updateGeometry([{ id: t, geometry: o }]), 0));
  }
  onClick(t) {
    if (t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t)) if (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(t), this.mouseMove = !1, this.currentCoordinate === 0) {
      const [e] = this.store.create([{ geometry: { type: "Polygon", coordinates: [[[t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat], [t.lng, t.lat]]] }, properties: { mode: this.mode, [S.CURRENTLY_DRAWING]: !0 } }]);
      this.currentId = e, this.currentCoordinate++, this.setDrawing();
    } else if (this.currentCoordinate === 1 && this.currentId) {
      const e = this.store.getGeometryCopy(this.currentId);
      if (tt([t.lng, t.lat], e.coordinates[0][0]) || !this.updatePolygonGeometry(this.currentId, [e.coordinates[0][0], [t.lng, t.lat], [t.lng, t.lat], e.coordinates[0][0]], b.Commit)) return;
      this.currentCoordinate++;
    } else this.currentCoordinate === 2 && this.currentId && this.close();
  }
  onKeyUp(t) {
    t.key === this.keyEvents.cancel ? this.cleanUp() : t.key === this.keyEvents.finish && this.close();
  }
  onKeyDown() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  cleanUp() {
    try {
      this.currentId && this.store.delete([this.currentId]);
    } catch {
    }
    this.currentId = void 0, this.direction = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    return t.properties.mode === this.mode && t.geometry.type === "Polygon" && (e.polygonFillColor = this.getHexColorStylingValue(this.styles.fillColor, e.polygonFillColor, t), e.polygonOutlineColor = this.getHexColorStylingValue(this.styles.outlineColor, e.polygonOutlineColor, t), e.polygonOutlineWidth = this.getNumericStylingValue(this.styles.outlineWidth, e.polygonOutlineWidth, t), e.polygonFillOpacity = this.getNumericStylingValue(this.styles.fillOpacity, e.polygonFillOpacity, t), e.zIndex = j), e;
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => ut(e, this.coordinatePrecision));
  }
  afterFeatureUpdated(t) {
    this.currentId === t.id && (this.currentId = void 0, this.direction = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted());
  }
}
const Xi = { cancel: "Escape", finish: "Enter" }, Hi = { start: "crosshair", close: "pointer" };
class Re extends A {
  constructor(t) {
    super(t, !0), this.mode = "sensor", this.currentCoordinate = 0, this.currentId = void 0, this.currentInitialArcId = void 0, this.currentStartingPointId = void 0, this.keyEvents = Xi, this.direction = void 0, this.arcPoints = 64, this.cursors = Hi, this.mouseMove = !1, this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors)), t?.keyEvents === null ? this.keyEvents = { cancel: null, finish: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents)), t != null && t.arcPoints && (this.arcPoints = t.arcPoints);
  }
  close() {
    if (this.currentStartingPointId === void 0) return;
    const t = this.currentStartingPointId, e = this.currentInitialArcId, i = this.currentId;
    if (t && this.store.delete([t]), e && this.store.delete([e]), this.currentId) {
      const o = pt(this.store.getGeometryCopy(this.currentId));
      o && this.store.updateGeometry([{ id: this.currentId, geometry: o }]), this.store.updateProperty([{ id: this.currentId, property: S.CURRENTLY_DRAWING, value: void 0 }]);
    }
    this.currentCoordinate = 0, this.currentStartingPointId = void 0, this.currentInitialArcId = void 0, this.currentId = void 0, this.direction = void 0, this.state === "drawing" && this.setStarted(), i && this.onFinish(i, { mode: this.mode, action: "draw" });
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(t) {
    if (this.mouseMove = !0, this.setCursor(this.cursors.start), this.currentInitialArcId !== void 0 && this.currentStartingPointId !== void 0 && this.currentCoordinate !== 0) {
      if (this.currentCoordinate === 2) {
        const e = this.store.getGeometryCopy(this.currentInitialArcId).coordinates, i = this.store.getGeometryCopy(this.currentStartingPointId).coordinates, o = e[0], s = [t.lng, t.lat], n = O(o[0], o[1]), a = O(s[0], s[1]), l = O(i[0], i[1]), d = F(l, n);
        if (this.direction === void 0) {
          const C = je(l, n, a);
          this.direction = C ? "clockwise" : "anticlockwise";
        }
        const c = G(l, n), h = G(l, a), u = this.arcPoints, p = [o], g = X(c), y = X(h);
        let m;
        this.direction === "anticlockwise" ? (m = y - g, m < 0 && (m += 360)) : (m = g - y, m < 0 && (m += 360));
        const v = (this.direction === "anticlockwise" ? 1 : -1) * m / u;
        for (let C = 0; C <= u; C++) {
          const f = ht(l, d, g + C * v), { lng: P, lat: I } = R(f.x, f.y), E = [w(P, this.coordinatePrecision), w(I, this.coordinatePrecision)];
          E[0] !== p[p.length - 1][0] && E[1] !== p[p.length - 1][1] && p.push(E);
        }
        this.updateLineStringGeometry(this.currentInitialArcId, p, b.Provisional);
      } else if (this.currentCoordinate === 3) {
        const e = this.store.getGeometryCopy(this.currentInitialArcId).coordinates;
        if (e.length < 2 || !this.direction) return;
        const i = this.store.getGeometryCopy(this.currentStartingPointId).coordinates, o = e[0], s = e[e.length - 1], n = O(t.lng, t.lat), a = O(o[0], o[1]), l = O(s[0], s[1]), d = O(i[0], i[1]), c = F(d, a), h = F(d, n) < c ? a : n, u = G(d, n), p = G(d, a), g = G(d, l), y = X(p), m = X(g), v = X(u);
        if (this.notInSector({ normalizedCursor: v, normalizedStart: y, normalizedEnd: m, direction: this.direction })) return;
        const C = this.getDeltaBearing(this.direction, y, m), f = this.arcPoints, P = (this.direction === "anticlockwise" ? 1 : -1) * C / f, I = F(d, h), E = [];
        for (let L = 0; L <= f; L++) {
          const M = ht(d, I, y + L * P), { lng: N, lat: _ } = R(M.x, M.y), T = [w(N, this.coordinatePrecision), w(_, this.coordinatePrecision)];
          T[0] !== e[e.length - 1][0] && T[1] !== e[e.length - 1][1] && E.unshift(T);
        }
        e.push(...E), e.push(e[0]), this.currentId ? this.updatePolygonGeometry(this.currentId, e, b.Provisional) : [this.currentId] = this.store.create([{ geometry: { type: "Polygon", coordinates: [e] }, properties: { mode: this.mode, [S.CURRENTLY_DRAWING]: !0 } }]);
      }
    }
  }
  updateLineStringGeometry(t, e, i) {
    const o = { type: "LineString", coordinates: e };
    return !(this.validate && !this.validate({ type: "Feature", geometry: o }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: i }).valid || (this.store.updateGeometry([{ id: t, geometry: o }]), 0));
  }
  updatePolygonGeometry(t, e, i) {
    const o = { type: "Polygon", coordinates: [e] };
    return !(this.validate && !this.validate({ type: "Feature", geometry: o }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: i }).valid || (this.store.updateGeometry([{ id: t, geometry: o }]), 0));
  }
  onClick(t) {
    if (t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t)) if (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(t), this.mouseMove = !1, this.currentCoordinate === 0) {
      const [e] = this.store.create([{ geometry: { type: "Point", coordinates: [t.lng, t.lat] }, properties: { mode: this.mode } }]);
      this.currentStartingPointId = e, this.currentCoordinate++, this.setDrawing();
    } else if (this.currentCoordinate === 1 && this.currentStartingPointId) {
      const [e] = this.store.create([{ geometry: { type: "LineString", coordinates: [[t.lng, t.lat], [t.lng, t.lat]] }, properties: { mode: this.mode } }]);
      this.currentInitialArcId = e, this.currentCoordinate++;
    } else this.currentCoordinate === 2 && this.currentStartingPointId ? this.currentCoordinate++ : this.currentCoordinate === 3 && this.currentStartingPointId && this.close();
  }
  onKeyUp(t) {
    t.key === this.keyEvents.cancel ? this.cleanUp() : t.key === this.keyEvents.finish && this.close();
  }
  onKeyDown() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  cleanUp() {
    try {
      this.currentStartingPointId && this.store.delete([this.currentStartingPointId]), this.currentInitialArcId && this.store.delete([this.currentInitialArcId]), this.currentId && this.store.delete([this.currentId]);
    } catch {
    }
    this.currentStartingPointId = void 0, this.direction = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    return t.properties.mode === this.mode && (t.geometry.type === "Polygon" ? (e.polygonFillColor = this.getHexColorStylingValue(this.styles.fillColor, e.polygonFillColor, t), e.polygonOutlineColor = this.getHexColorStylingValue(this.styles.outlineColor, e.polygonOutlineColor, t), e.polygonOutlineWidth = this.getNumericStylingValue(this.styles.outlineWidth, e.polygonOutlineWidth, t), e.polygonFillOpacity = this.getNumericStylingValue(this.styles.fillOpacity, e.polygonFillOpacity, t), e.zIndex = j) : t.geometry.type === "LineString" ? (e.lineStringColor = this.getHexColorStylingValue(this.styles.outlineColor, e.polygonOutlineColor, t), e.lineStringWidth = this.getNumericStylingValue(this.styles.outlineWidth, e.polygonOutlineWidth, t), e.zIndex = j) : t.geometry.type === "Point" && (e.pointColor = this.getHexColorStylingValue(this.styles.centerPointColor, e.pointColor, t), e.pointWidth = this.getNumericStylingValue(this.styles.centerPointWidth, e.pointWidth, t), e.pointOutlineColor = this.getHexColorStylingValue(this.styles.centerPointOutlineColor, e.pointOutlineColor, t), e.pointOutlineWidth = this.getNumericStylingValue(this.styles.centerPointOutlineWidth, e.pointOutlineWidth, t), e.zIndex = 20)), e;
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => ut(e, this.coordinatePrecision));
  }
  afterFeatureUpdated(t) {
    this.currentId === t.id && (this.currentStartingPointId && this.store.delete([this.currentStartingPointId]), this.currentInitialArcId && this.store.delete([this.currentInitialArcId]), this.currentStartingPointId = void 0, this.direction = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted());
  }
  getDeltaBearing(t, e, i) {
    let o;
    return t === "anticlockwise" ? (o = i - e, o < 0 && (o += 360)) : (o = e - i, o < 0 && (o += 360)), o;
  }
  notInSector({ normalizedCursor: t, normalizedStart: e, normalizedEnd: i, direction: o }) {
    return o === "clockwise" ? e <= i ? t >= e && t <= i : t >= e || t <= i : e >= i ? t <= e && t >= i : t <= e || t >= i;
  }
}
class q {
  constructor({ name: t, callback: e, unregister: i, register: o }) {
    this.name = void 0, this.callback = void 0, this.registered = !1, this.register = void 0, this.unregister = void 0, this.name = t, this.register = () => {
      this.registered || (this.registered = !0, o(e));
    }, this.unregister = () => {
      this.register && (this.registered = !1, i(e));
    }, this.callback = e;
  }
}
var Ji = { __proto__: null, TerraDrawBaseAdapter: class {
  constructor(r) {
    this._nextKeyUpIsContextMenu = !1, this._minPixelDragDistance = void 0, this._minPixelDragDistanceDrawing = void 0, this._minPixelDragDistanceSelecting = void 0, this._lastDrawEvent = void 0, this._coordinatePrecision = void 0, this._heldKeys = /* @__PURE__ */ new Set(), this._listeners = [], this._dragState = "not-dragging", this._currentModeCallbacks = void 0, this._minPixelDragDistance = typeof r.minPixelDragDistance == "number" ? r.minPixelDragDistance : 1, this._minPixelDragDistanceSelecting = typeof r.minPixelDragDistanceSelecting == "number" ? r.minPixelDragDistanceSelecting : 1, this._minPixelDragDistanceDrawing = typeof r.minPixelDragDistanceDrawing == "number" ? r.minPixelDragDistanceDrawing : 8, this._coordinatePrecision = typeof r.coordinatePrecision == "number" ? r.coordinatePrecision : 9;
  }
  getButton(r) {
    return r.button === -1 ? "neither" : r.button === 0 ? "left" : r.button === 1 ? "middle" : r.button === 2 ? "right" : "neither";
  }
  getMapElementXYPosition(r) {
    const t = this.getMapEventElement(), { left: e, top: i } = t.getBoundingClientRect();
    return { containerX: r.clientX - e, containerY: r.clientY - i };
  }
  getDrawEventFromEvent(r, t = !1) {
    const e = this.getLngLatFromEvent(r);
    if (!e) return null;
    const { lng: i, lat: o } = e, { containerX: s, containerY: n } = this.getMapElementXYPosition(r), a = this.getButton(r), l = Array.from(this._heldKeys);
    return { lng: w(i, this._coordinatePrecision), lat: w(o, this._coordinatePrecision), containerX: s, containerY: n, button: a, heldKeys: l, isContextMenu: t };
  }
  register(r) {
    this._currentModeCallbacks = r, this._listeners = this.getAdapterListeners(), this._listeners.forEach((t) => {
      t.register();
    });
  }
  getCoordinatePrecision() {
    return this._coordinatePrecision;
  }
  getAdapterListeners() {
    return [new q({ name: "pointerdown", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      const t = this.getDrawEventFromEvent(r);
      t && (this._dragState = "pre-dragging", this._lastDrawEvent = t);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerdown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerdown", r);
    } }), new q({ name: "pointermove", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      r.preventDefault();
      const t = this.getDrawEventFromEvent(r);
      if (t) if (this._dragState === "not-dragging") this._currentModeCallbacks.onMouseMove(t), this._lastDrawEvent = t;
      else if (this._dragState === "pre-dragging") {
        if (!this._lastDrawEvent) return;
        const e = { x: this._lastDrawEvent.containerX, y: this._lastDrawEvent.containerY }, i = { x: t.containerX, y: t.containerY }, o = this._currentModeCallbacks.getState(), s = F(e, i);
        let n = !1;
        if (n = o === "drawing" ? s < this._minPixelDragDistanceDrawing : o === "selecting" ? s < this._minPixelDragDistanceSelecting : s < this._minPixelDragDistance, n) return;
        this._nextKeyUpIsContextMenu = !1, this._dragState = "dragging", this._currentModeCallbacks.onDragStart(t, (a) => {
          this.setDraggability.bind(this)(a);
        });
      } else this._dragState === "dragging" && this._currentModeCallbacks.onDrag(t, (e) => {
        this.setDraggability.bind(this)(e);
      });
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointermove", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointermove", r);
    } }), new q({ name: "contextmenu", callback: (r) => {
      this._currentModeCallbacks && (r.preventDefault(), this._nextKeyUpIsContextMenu = !0);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("contextmenu", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("contextmenu", r);
    } }), new q({ name: "pointerup", callback: (r) => {
      if (!this._currentModeCallbacks || r.target !== this.getMapEventElement() || !r.isPrimary) return;
      const t = this.getDrawEventFromEvent(r);
      t && (this._dragState === "dragging" ? this._currentModeCallbacks.onDragEnd(t, (e) => {
        this.setDraggability.bind(this)(e);
      }) : this._dragState !== "not-dragging" && this._dragState !== "pre-dragging" || (this._nextKeyUpIsContextMenu && (t.isContextMenu = !0, this._nextKeyUpIsContextMenu = !1), this._currentModeCallbacks.onClick(t)), this._dragState = "not-dragging", this.setDraggability(!0));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerup", r);
    } }), new q({ name: "keyup", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.delete(r.key), this._currentModeCallbacks.onKeyUp({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keyup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keyup", r);
    } }), new q({ name: "keydown", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.add(r.key), this._currentModeCallbacks.onKeyDown({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keydown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keydown", r);
    } })];
  }
  unregister() {
    this._listeners.forEach((r) => {
      r.unregister();
    }), this.clear(), this._currentModeCallbacks = void 0;
  }
} };
const qi = { cancel: "Escape", finish: "Enter" }, Zi = { start: "crosshair", close: "pointer" };
class Ge extends A {
  constructor(t) {
    super(t, !0), this.mode = "freehand-linestring", this.startingClick = !1, this.currentId = void 0, this.closingPointId = void 0, this.minDistance = 20, this.keyEvents = qi, this.cursors = Zi, this.preventNewFeature = !1, this.updateOptions(t);
  }
  updateOptions(t) {
    super.updateOptions(t), t != null && t.minDistance && (this.minDistance = t.minDistance), t?.keyEvents === null ? this.keyEvents = { cancel: null, finish: null } : t != null && t.keyEvents && (this.keyEvents = x({}, this.keyEvents, t.keyEvents)), t != null && t.cursors && (this.cursors = x({}, this.cursors, t.cursors));
  }
  close() {
    if (this.currentId === void 0) return;
    this.currentId && this.store.updateProperty([{ id: this.currentId, property: S.CURRENTLY_DRAWING, value: void 0 }]);
    const t = this.currentId;
    if (this.validate && t) {
      const e = this.store.getGeometryCopy(t);
      if (!this.validate({ type: "Feature", id: t, geometry: e, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Finish }).valid) return;
    }
    this.closingPointId && this.store.delete([this.closingPointId]), this.startingClick = !1, this.currentId = void 0, this.closingPointId = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(t, { mode: this.mode, action: "draw" });
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(t) {
    if (this.currentId === void 0 || this.startingClick === !1) return void this.setCursor(this.cursors.start);
    const e = this.store.getGeometryCopy(this.currentId), i = e.coordinates.length - 2, [o, s] = e.coordinates[i], { x: n, y: a } = this.project(o, s), l = F({ x: n, y: a }, { x: t.containerX, y: t.containerY }), [d, c] = e.coordinates[e.coordinates.length - 1], { x: h, y: u } = this.project(d, c), p = F({ x: h, y: u }, { x: t.containerX, y: t.containerY });
    if (this.setCursor(p < this.pointerDistance ? this.cursors.close : this.cursors.start), l < this.minDistance) return;
    const g = { type: "LineString", coordinates: [...e.coordinates, [t.lng, t.lat]] };
    this.validate && !this.validate({ type: "Feature", id: this.currentId, geometry: g, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: b.Provisional }).valid || (this.store.updateGeometry([{ id: this.currentId, geometry: g }]), this.closingPointId && this.store.updateGeometry([{ id: this.closingPointId, geometry: { type: "Point", coordinates: [t.lng, t.lat] } }]));
  }
  onClick(t) {
    if (t.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, t) || t.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, t) || t.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, t)) {
      if (this.preventNewFeature) return;
      if (this.startingClick === !1) {
        const [e, i] = this.store.create([{ geometry: { type: "LineString", coordinates: [[t.lng, t.lat], [t.lng, t.lat]] }, properties: { mode: this.mode, [S.CURRENTLY_DRAWING]: !0 } }, { geometry: { type: "Point", coordinates: [t.lng, t.lat] }, properties: { mode: this.mode, [S.CLOSING_POINT]: !0 } }]);
        return this.currentId = e, this.closingPointId = i, this.startingClick = !0, void (this.state !== "drawing" && this.setDrawing());
      }
      this.close();
    }
  }
  onKeyDown() {
  }
  onKeyUp(t) {
    t.key === this.keyEvents.cancel ? this.cleanUp() : t.key === this.keyEvents.finish && this.startingClick === !0 && this.close();
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  cleanUp() {
    const t = this.currentId, e = this.closingPointId;
    this.closingPointId = void 0, this.currentId = void 0, this.startingClick = !1, this.state === "drawing" && this.setStarted();
    try {
      t !== void 0 && this.store.delete([t]), e !== void 0 && this.store.delete([e]);
    } catch {
    }
  }
  styleFeature(t) {
    const e = x({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    return t.type === "Feature" && t.geometry.type === "LineString" && t.properties.mode === this.mode ? (e.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, e.lineStringColor, t), e.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, e.lineStringWidth, t), e.zIndex = j, e) : (t.type === "Feature" && t.geometry.type === "Point" && t.properties.mode === this.mode && (e.pointWidth = this.getNumericStylingValue(this.styles.closingPointWidth, e.pointWidth, t), e.pointColor = this.getHexColorStylingValue(this.styles.closingPointColor, e.pointColor, t), e.pointOutlineColor = this.getHexColorStylingValue(this.styles.closingPointOutlineColor, e.pointOutlineColor, t), e.pointOutlineWidth = this.getNumericStylingValue(this.styles.closingPointOutlineWidth, 2, t), e.zIndex = 50), e);
  }
  validateFeature(t) {
    return this.validateModeFeature(t, (e) => At(e, this.coordinatePrecision));
  }
  afterFeatureUpdated(t) {
    this.currentId === t.id && (this.closingPointId && this.store.delete([this.closingPointId]), this.startingClick = !1, this.currentId = void 0, this.closingPointId = void 0);
  }
}
function Tt(r) {
  if (r === null || typeof r == "boolean" || typeof r == "string") return !0;
  if (r === void 0) return !1;
  if (typeof r == "number") return Number.isFinite(r);
  if (typeof r == "bigint" || typeof r == "symbol" || typeof r == "function" || r instanceof RegExp || r instanceof Map || r instanceof Set || r instanceof Date) return !1;
  if (typeof r == "object" && r !== null && !Array.isArray(r)) {
    const t = Object.getPrototypeOf(r);
    if (t !== Object.prototype && t !== null) return !1;
  }
  if (ArrayBuffer.isView(r) && !(r instanceof DataView)) return !1;
  if (Array.isArray(r)) {
    for (const t of r) if (!Tt(t)) return !1;
  }
  return typeof r == "object" && Object.keys(r).every((t) => typeof t == "string" && Tt(r[t]));
}
class Qi {
  constructor(t) {
    this._modes = void 0, this._mode = void 0, this._adapter = void 0, this._enabled = !1, this._store = void 0, this._eventListeners = void 0, this._instanceSelectMode = void 0, this._adapter = t.adapter, this._mode = new ki();
    const e = /* @__PURE__ */ new Set(), i = t.modes.reduce((c, h) => {
      if (e.has(h.mode)) throw new Error(`There is already a ${h.mode} mode provided`);
      return e.add(h.mode), c[h.mode] = h, c;
    }, {}), o = Object.keys(i);
    if (o.length === 0) throw new Error("No modes provided");
    o.forEach((c) => {
      if (i[c].type === H.Select) {
        if (this._instanceSelectMode) throw new Error("only one type of select mode can be provided");
        this._instanceSelectMode = c;
      }
    }), this._modes = x({}, i, { static: this._mode }), this._eventListeners = { change: [], select: [], deselect: [], finish: [], ready: [] }, this._store = new Ri({ tracked: !!t.tracked, idStrategy: t.idStrategy ? t.idStrategy : void 0 });
    const s = (c) => {
      const h = [], u = this._store.copyAll().filter((p) => !c.includes(p.id) || (h.push(p), !1));
      return { changed: h, unchanged: u };
    }, n = (c, h) => {
      this._enabled && this._eventListeners.finish.forEach((u) => {
        u(c, h);
      });
    }, a = (c, h, u) => {
      if (!this._enabled) return;
      this._eventListeners.change.forEach((y) => {
        y(c, h, u);
      });
      const { changed: p, unchanged: g } = s(c);
      h === "create" ? this._adapter.render({ created: p, deletedIds: [], unchanged: g, updated: [] }, this.getModeStyles()) : h === "update" ? this._adapter.render({ created: [], deletedIds: [], unchanged: g, updated: p }, this.getModeStyles()) : h === "delete" ? this._adapter.render({ created: [], deletedIds: c, unchanged: g, updated: [] }, this.getModeStyles()) : h === "styling" && this._adapter.render({ created: [], deletedIds: [], unchanged: g, updated: [] }, this.getModeStyles());
    }, l = (c) => {
      if (!this._enabled) return;
      this._eventListeners.select.forEach((p) => {
        p(c);
      });
      const { changed: h, unchanged: u } = s([c]);
      this._adapter.render({ created: [], deletedIds: [], unchanged: u, updated: h }, this.getModeStyles());
    }, d = (c) => {
      if (!this._enabled) return;
      this._eventListeners.deselect.forEach((p) => {
        p();
      });
      const { changed: h, unchanged: u } = s([c]);
      h && this._adapter.render({ created: [], deletedIds: [], unchanged: u, updated: h }, this.getModeStyles());
    };
    Object.keys(this._modes).forEach((c) => {
      this._modes[c].register({ mode: c, store: this._store, setCursor: this._adapter.setCursor.bind(this._adapter), project: this._adapter.project.bind(this._adapter), unproject: this._adapter.unproject.bind(this._adapter), setDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(this._adapter), onChange: a, onSelect: l, onDeselect: d, onFinish: n, coordinatePrecision: this._adapter.getCoordinatePrecision() });
    });
  }
  checkEnabled() {
    if (!this._enabled) throw new Error("Terra Draw is not enabled");
  }
  getModeStyles() {
    const t = {};
    return Object.keys(this._modes).forEach((e) => {
      t[e] = (i) => this._instanceSelectMode && i.properties[k.SELECTED] ? this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(i) : this._modes[e].styleFeature.bind(this._modes[e])(i);
    }), t;
  }
  featuresAtLocation({ lng: t, lat: e }, i) {
    const o = i && i.pointerDistance !== void 0 ? i.pointerDistance : 30, s = !i || i.ignoreSelectFeatures === void 0 || i.ignoreSelectFeatures, n = !(!i || i.ignoreCoordinatePoints === void 0) && i.ignoreCoordinatePoints, a = !(!i || i.ignoreCurrentlyDrawing === void 0) && i.ignoreCurrentlyDrawing, l = !(!i || i.ignoreClosingPoints === void 0) && i.ignoreClosingPoints, d = this._adapter.unproject.bind(this._adapter), c = this._adapter.project.bind(this._adapter), h = c(t, e), u = Ee({ unproject: d, point: h, pointerDistance: o });
    return this._store.search(u).filter((p) => {
      if (s && (p.properties[k.MID_POINT] || p.properties[k.SELECTION_POINT]) || n && p.properties[S.COORDINATE_POINT] || l && p.properties[S.CLOSING_POINT] || a && p.properties[S.CURRENTLY_DRAWING]) return !1;
      if (p.geometry.type === "Point") {
        const g = p.geometry.coordinates, y = c(g[0], g[1]);
        return F(h, y) < o;
      }
      if (p.geometry.type === "LineString") {
        const g = p.geometry.coordinates;
        for (let y = 0; y < g.length - 1; y++) {
          const m = g[y], v = g[y + 1];
          if (kt(h, c(m[0], m[1]), c(v[0], v[1])) < o) return !0;
        }
        return !1;
      }
      if (ke([t, e], p.geometry.coordinates)) return !0;
      if (i != null && i.includePolygonsWithinPointerDistance) {
        const g = p.geometry.coordinates;
        for (const y of g) for (let m = 0; m < y.length - 1; m++) {
          const v = y[m], C = y[m + 1], f = c(v[0], v[1]), P = c(C[0], C[1]);
          if (kt(h, f, P) < o) return !0;
        }
      }
      return !1;
    }).map((p) => {
      if (i == null || !i.addClosestCoordinateInfoToProperties) return p;
      let g;
      if (p.geometry.type === "Polygon") g = p.geometry.coordinates[0], g.pop();
      else {
        if (p.geometry.type !== "LineString") return p;
        g = p.geometry.coordinates;
      }
      let y, m = -1, v = 1 / 0;
      for (let C = 0; C < g.length; C++) {
        const f = g[C], P = F(c(f[0], f[1]), h);
        P < v && (m = C, v = P, y = f);
      }
      return p.properties.closestCoordinateIndexToEvent = m, p.properties.closestCoordinatePixelDistanceToEvent = v, p.properties.closestCoordinateDistanceKmToEvent = U(y, [t, e]), p;
    });
  }
  getSelectModeOrThrow() {
    const t = this.getSelectMode({ switchToSelectMode: !0 });
    if (!t) throw new Error("No select mode defined in instance");
    return t;
  }
  getSelectMode({ switchToSelectMode: t }) {
    if (this.checkEnabled(), !this._instanceSelectMode) return null;
    const e = this.getMode();
    return t && e !== this._instanceSelectMode && this.setMode(this._instanceSelectMode), this._modes[this._instanceSelectMode];
  }
  isGuidanceFeature(t) {
    return !!(t.properties[k.MID_POINT] || t.properties[k.SELECTION_POINT] || t.properties[S.COORDINATE_POINT] || t.properties[S.SNAPPING_POINT]);
  }
  setModeStyles(t, e) {
    if (this.checkEnabled(), !this._modes[t]) throw new Error("No mode with this name present");
    this._modes[t].styles = e;
  }
  updateModeOptions(t, e) {
    if (this.checkEnabled(), !this._modes[t]) throw new Error("No mode with this name present");
    this._modes[t].updateOptions(e);
  }
  getSnapshot() {
    return this._store.copyAll();
  }
  getSnapshotFeature(t) {
    if (this._store.has(t)) return this._store.copy(t);
  }
  clear() {
    this.checkEnabled(), this._adapter.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    throw new Error("Enabled is read only");
  }
  getMode() {
    return this._mode.mode;
  }
  getModeState() {
    return this._mode.state;
  }
  setMode(t) {
    if (this.checkEnabled(), !this._modes[t]) throw new Error("No mode with this name present");
    this._mode.stop(), this._mode = this._modes[t], this._mode.start();
  }
  removeFeatures(t) {
    this.checkEnabled();
    const e = [];
    t.forEach((i) => {
      if (!this._store.has(i)) throw new Error(`No feature with id ${i}, can not delete`);
      const o = this._store.copy(i);
      o.properties[k.SELECTED] && this.deselectFeature(i), o.properties[S.COORDINATE_POINT_IDS] && e.push(...o.properties[S.COORDINATE_POINT_IDS]);
    }), this._store.delete([...t, ...e], { origin: "api" });
  }
  selectFeature(t) {
    this.getSelectModeOrThrow().selectFeature(t);
  }
  deselectFeature(t) {
    this.getSelectModeOrThrow().deselectFeature(t);
  }
  getFeatureId() {
    return this._store.getId();
  }
  hasFeature(t) {
    return this._store.has(t);
  }
  checkIsReservedProperty(t) {
    return ![...Object.values(k), ...Object.values(S)].includes(t);
  }
  updateFeatureProperties(t, e) {
    if (!this._store.has(t)) throw new Error(`No feature with id ${t} present in store`);
    const i = this._store.copy(t);
    if (this.isGuidanceFeature(i)) throw new Error("Guidance features are not allowed to be updated directly.");
    const o = i.properties.mode;
    if (!this._modes[o]) throw new Error(`No mode with name ${o} present in instance`);
    const s = Object.entries(e);
    s.forEach(([n, a]) => {
      if (!this.checkIsReservedProperty(n)) throw new Error(`You are trying to update a reserved property name: ${n}. Please choose another name.`);
      if (a !== void 0 && !Tt(a)) throw new Error(`Invalid JSON value provided for property ${n}`);
    }), this._store.updateProperty(s.map(([n, a]) => ({ id: i.id, property: n, value: a })), { origin: "api" });
  }
  updateFeatureGeometry(t, e) {
    if (!this._store.has(t)) throw new Error(`No feature with id ${t} present in store`);
    const i = this._store.copy(t);
    if (this.isGuidanceFeature(i)) throw new Error("Guidance features are not allowed to be updated directly.");
    if (!(i && e && e.type && e.coordinates)) throw new Error("Invalid geometry provided");
    if (e.type !== i.geometry.type) throw new Error(`Geometry type mismatch: expected ${i.geometry.type}, got ${e.type}`);
    const o = i.properties.mode, s = this._modes[o];
    if (!s) throw new Error(`No mode with name ${o} present in instance`);
    const n = x({}, i, { geometry: e }), a = s.validateFeature(n);
    if (!a.valid) throw new Error(`Feature validation failed: ${a.reason || "Unknown reason"}`);
    if (this._store.updateGeometry([{ id: i.id, geometry: e }], { origin: "api" }), s.afterFeatureUpdated) {
      s.afterFeatureUpdated(n);
      const l = n.properties[k.SELECTED], d = this.getSelectMode({ switchToSelectMode: !1 });
      d && l && d.afterFeatureUpdated(n);
    }
  }
  transformFeatureGeometry(t, e) {
    if (!this._store.has(t)) throw new Error(`No feature with id ${t} present in store`);
    let i = this._store.copy(t);
    if (this.isGuidanceFeature(i)) throw new Error("Guidance features are not allowed to be updated directly.");
    const o = i.properties.mode, s = this._modes[o];
    if (!s) throw new Error(`No mode with name ${o} present in instance`);
    let n;
    if (i.geometry.type === "Polygon") n = i.geometry.coordinates[0];
    else {
      if (i.geometry.type !== "LineString") throw new Error(`Feature geometry type ${i.geometry.type} is not supported for transformation`);
      n = i.geometry.coordinates;
    }
    if (e.projection != "web-mercator") throw new Error(`Projection ${e.projection} is not currently supported for transformation`);
    if (e.type === "scale") {
      const { x: a, y: l } = O(e.origin[0], e.origin[1]);
      Te({ coordinates: n, originX: a, originY: l, xScale: e.options.xScale || 1, yScale: e.options.yScale || 1 });
    } else e.type === "rotate" && (i = Ne(i, e.options.angle || 0), n = i.geometry.type === "Polygon" ? i.geometry.coordinates[0] : i.geometry.coordinates);
    if (n = n.map((a) => [w(a[0], this._adapter.getCoordinatePrecision()), w(a[1], this._adapter.getCoordinatePrecision())]), i.geometry.coordinates = i.geometry.type === "Polygon" ? [n] : n, this._store.updateGeometry([{ id: i.id, geometry: i.geometry }], { origin: "api" }), s.afterFeatureUpdated) {
      s.afterFeatureUpdated(i);
      const a = i.properties[k.SELECTED], l = this.getSelectMode({ switchToSelectMode: !1 });
      l && a && l.afterFeatureUpdated(i);
    }
  }
  addFeatures(t) {
    return this.checkEnabled(), t.length === 0 ? [] : this._store.load(t, (e) => {
      if (Zt(e)) {
        const i = e.properties.mode, o = this._modes[i];
        if (!o) return { id: e.id, valid: !1, reason: `${i} mode is not in the list of instantiated modes` };
        const s = o.validateFeature.bind(o)(e);
        return { id: e.id, valid: s.valid, reason: s.reason ? s.reason : s.valid ? void 0 : "Feature is invalid" };
      }
      return { id: e.id, valid: !1, reason: "Mode property does not exist" };
    }, (e) => {
      if (Zt(e)) {
        const i = this._modes[e.properties.mode];
        i && i.afterFeatureAdded && i.afterFeatureAdded(e);
      }
    }, { origin: "api" });
  }
  start() {
    this._enabled || (this._enabled = !0, this._adapter.register({ onReady: () => {
      this._eventListeners.ready.forEach((t) => {
        t();
      });
    }, getState: () => this._mode.state, onClick: (t) => {
      this._mode.onClick(t);
    }, onMouseMove: (t) => {
      this._mode.onMouseMove(t);
    }, onKeyDown: (t) => {
      this._mode.onKeyDown(t);
    }, onKeyUp: (t) => {
      this._mode.onKeyUp(t);
    }, onDragStart: (t, e) => {
      this._mode.onDragStart(t, e);
    }, onDrag: (t, e) => {
      this._mode.onDrag(t, e);
    }, onDragEnd: (t, e) => {
      this._mode.onDragEnd(t, e);
    }, onClear: () => {
      this._mode.cleanUp(), this._store.clear();
    } }));
  }
  getFeaturesAtLngLat(t, e) {
    const { lng: i, lat: o } = t;
    return this.featuresAtLocation({ lng: i, lat: o }, e);
  }
  getFeaturesAtPointerEvent(t, e) {
    const i = this._adapter.getLngLatFromEvent.bind(this._adapter)(t);
    return i === null ? [] : this.featuresAtLocation(i, e);
  }
  stop() {
    this._enabled && (this._enabled = !1, this._adapter.unregister());
  }
  on(t, e) {
    const i = this._eventListeners[t];
    i.includes(e) || i.push(e);
  }
  off(t, e) {
    const i = this._eventListeners[t];
    i.includes(e) && i.splice(i.indexOf(e), 1);
  }
}
class to extends Ji.TerraDrawBaseAdapter {
  constructor(t) {
    super(t), this._renderBeforeLayerId = void 0, this._prefixId = void 0, this._initialDragPan = void 0, this._initialDragRotate = void 0, this._nextRender = void 0, this._map = void 0, this._container = void 0, this.changedIds = { deletion: !1, points: !1, linestrings: !1, polygons: !1, styling: !1 }, this._map = t.map, this._container = this._map.getContainer(), this._initialDragRotate = this._map.dragRotate.isEnabled(), this._initialDragPan = this._map.dragPan.isEnabled(), this._renderBeforeLayerId = t.renderBelowLayerId, this._prefixId = t.prefixId || "td";
  }
  _addGeoJSONSource(t, e) {
    this._map.addSource(t, { type: "geojson", data: { type: "FeatureCollection", features: e }, tolerance: 0 });
  }
  _addFillLayer(t) {
    return this._map.addLayer({ id: t, source: t, type: "fill", layout: { "fill-sort-key": ["get", "zIndex"] }, paint: { "fill-color": ["get", "polygonFillColor"], "fill-opacity": ["get", "polygonFillOpacity"] } });
  }
  _addFillOutlineLayer(t) {
    return this._map.addLayer({ id: t + "-outline", source: t, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "polygonOutlineWidth"], "line-color": ["get", "polygonOutlineColor"] } });
  }
  _addLineLayer(t) {
    return this._map.addLayer({ id: t, source: t, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "lineStringWidth"], "line-color": ["get", "lineStringColor"] } });
  }
  _addPointLayer(t) {
    return this._map.addLayer({ id: t, source: t, type: "circle", layout: { "circle-sort-key": ["get", "zIndex"] }, paint: { "circle-stroke-color": ["get", "pointOutlineColor"], "circle-stroke-width": ["get", "pointOutlineWidth"], "circle-radius": ["get", "pointWidth"], "circle-color": ["get", "pointColor"] } });
  }
  _addLayer(t, e) {
    e === "Point" && this._addPointLayer(t), e === "LineString" && this._addLineLayer(t), e === "Polygon" && (this._addFillLayer(t), this._addFillOutlineLayer(t));
  }
  _addGeoJSONLayer(t, e) {
    const i = `${this._prefixId}-${t.toLowerCase()}`;
    return this._addGeoJSONSource(i, e), this._addLayer(i, t), i;
  }
  _setGeoJSONLayerData(t, e) {
    const i = `${this._prefixId}-${t.toLowerCase()}`;
    return this._map.getSource(i).setData({ type: "FeatureCollection", features: e }), i;
  }
  updateChangedIds(t) {
    [...t.updated, ...t.created].forEach((e) => {
      e.geometry.type === "Point" ? this.changedIds.points = !0 : e.geometry.type === "LineString" ? this.changedIds.linestrings = !0 : e.geometry.type === "Polygon" && (this.changedIds.polygons = !0);
    }), t.deletedIds.length > 0 && (this.changedIds.deletion = !0), t.created.length === 0 && t.updated.length === 0 && t.deletedIds.length === 0 && (this.changedIds.styling = !0);
  }
  getLngLatFromEvent(t) {
    const { left: e, top: i } = this._container.getBoundingClientRect();
    return this.unproject(t.clientX - e, t.clientY - i);
  }
  getMapEventElement() {
    return this._map.getCanvas();
  }
  setDraggability(t) {
    t ? (this._initialDragRotate && this._map.dragRotate.enable(), this._initialDragPan && this._map.dragPan.enable()) : (this._initialDragRotate && this._map.dragRotate.disable(), this._initialDragPan && this._map.dragPan.disable());
  }
  project(t, e) {
    const { x: i, y: o } = this._map.project({ lng: t, lat: e });
    return { x: i, y: o };
  }
  unproject(t, e) {
    const { lng: i, lat: o } = this._map.unproject({ x: t, y: e });
    return { lng: i, lat: o };
  }
  setCursor(t) {
    const e = this._map.getCanvas();
    t === "unset" ? e.style.removeProperty("cursor") : e.style.cursor = t;
  }
  setDoubleClickToZoom(t) {
    t ? this._map.doubleClickZoom.enable() : this._map.doubleClickZoom.disable();
  }
  render(t, e) {
    this.updateChangedIds(t), this._nextRender && cancelAnimationFrame(this._nextRender), this._nextRender = requestAnimationFrame(() => {
      if (!this._currentModeCallbacks) return;
      const i = [...t.created, ...t.updated, ...t.unchanged], o = [], s = [], n = [];
      for (let c = 0; c < i.length; c++) {
        const h = i[c], { properties: u } = h, p = e[u.mode](h);
        h.geometry.type === "Point" ? (u.pointColor = p.pointColor, u.pointOutlineColor = p.pointOutlineColor, u.pointOutlineWidth = p.pointOutlineWidth, u.pointWidth = p.pointWidth, u.zIndex = p.zIndex, o.push(h)) : h.geometry.type === "LineString" ? (u.lineStringColor = p.lineStringColor, u.lineStringWidth = p.lineStringWidth, s.push(h)) : h.geometry.type === "Polygon" && (u.polygonFillColor = p.polygonFillColor, u.polygonFillOpacity = p.polygonFillOpacity, u.polygonOutlineColor = p.polygonOutlineColor, u.polygonOutlineWidth = p.polygonOutlineWidth, n.push(h));
      }
      const a = this.changedIds.deletion || this.changedIds.styling, l = a || this.changedIds.linestrings, d = a || this.changedIds.polygons;
      (a || this.changedIds.points) && this._setGeoJSONLayerData("Point", o), l && this._setGeoJSONLayerData("LineString", s), d && this._setGeoJSONLayerData("Polygon", n), this.changedIds = { points: !1, linestrings: !1, polygons: !1, deletion: !1, styling: !1 };
    });
  }
  clear() {
    this._currentModeCallbacks && (this._currentModeCallbacks.onClear(), this._nextRender && (cancelAnimationFrame(this._nextRender), this._nextRender = void 0), this._setGeoJSONLayerData("Point", []), this._setGeoJSONLayerData("LineString", []), this._setGeoJSONLayerData("Polygon", []));
  }
  getCoordinatePrecision() {
    return super.getCoordinatePrecision();
  }
  unregister() {
    super.unregister(), this.changedIds = { points: !1, linestrings: !1, polygons: !1, deletion: !1, styling: !1 }, this._map.removeLayer(`${this._prefixId}-point`), this._map.removeSource(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-linestring`), this._map.removeSource(`${this._prefixId}-linestring`), this._map.removeLayer(`${this._prefixId}-polygon`), this._map.removeLayer(`${this._prefixId}-polygon-outline`), this._map.removeSource(`${this._prefixId}-polygon`);
  }
  register(t) {
    var e;
    super.register(t);
    const i = this._addGeoJSONLayer("Polygon", []), o = this._addGeoJSONLayer("LineString", []), s = this._addGeoJSONLayer("Point", []);
    this._renderBeforeLayerId && (this._map.moveLayer(s, this._renderBeforeLayerId), this._map.moveLayer(o, s), this._map.moveLayer(i + "-outline", o), this._map.moveLayer(i, o)), (e = this._currentModeCallbacks) != null && e.onReady && this._currentModeCallbacks.onReady();
  }
}
const Vo = [
  "render",
  "point",
  "linestring",
  "polygon",
  "rectangle",
  "circle",
  "freehand",
  "freehand-linestring",
  "angled-rectangle",
  "sensor",
  "sector",
  "select",
  "delete-selection",
  "delete",
  "download"
], $o = [
  "render",
  "linestring",
  "point",
  "select",
  "delete-selection",
  "delete",
  "download",
  "settings"
], eo = {
  modes: [
    "render",
    "point",
    "linestring",
    "polygon",
    "rectangle",
    "angled-rectangle",
    "sensor",
    "sector",
    "circle",
    "freehand",
    "freehand-linestring",
    "select",
    "delete-selection",
    "delete",
    "download"
  ],
  open: !1
}, lt = {
  modes: [
    "render",
    "point",
    "linestring",
    "polygon",
    "rectangle",
    "angled-rectangle",
    "sensor",
    "sector",
    "circle",
    "freehand",
    "freehand-linestring",
    "select",
    "delete-selection",
    "delete",
    "download"
  ],
  open: !1,
  // see styling parameters of Terra Draw at https://github.com/JamesLMilner/terra-draw/blob/main/guides/5.STYLING.md
  modeOptions: {
    point: new Ut({
      editable: !0,
      styles: {
        pointColor: "#FFFFFF",
        pointWidth: 5,
        pointOutlineColor: "#666666",
        pointOutlineWidth: 1
      }
    }),
    linestring: new Gt({
      editable: !0,
      styles: {
        lineStringColor: "#666666",
        lineStringWidth: 2,
        closingPointColor: "#FFFFFF",
        closingPointWidth: 3,
        closingPointOutlineColor: "#666666",
        closingPointOutlineWidth: 1
      }
    }),
    polygon: new Fe({
      editable: !0,
      styles: {
        fillColor: "#EDEFF0",
        fillOpacity: 0.7,
        outlineColor: "#666666",
        outlineWidth: 2,
        closingPointColor: "#FAFAFA",
        closingPointWidth: 3,
        closingPointOutlineColor: "#666666",
        closingPointOutlineWidth: 1
      }
    }),
    rectangle: new Me({
      styles: {
        fillColor: "#EDEFF0",
        fillOpacity: 0.7,
        outlineColor: "#666666",
        outlineWidth: 2
      }
    }),
    "angled-rectangle": new Be({
      styles: {
        fillColor: "#EDEFF0",
        fillOpacity: 0.7,
        outlineColor: "#666666",
        outlineWidth: 2
      }
    }),
    circle: new Oe({
      styles: {
        fillColor: "#EDEFF0",
        fillOpacity: 0.7,
        outlineColor: "#666666",
        outlineWidth: 2
      }
    }),
    freehand: new be({
      styles: {
        fillColor: "#EDEFF0",
        fillOpacity: 0.7,
        outlineColor: "#666666",
        outlineWidth: 2,
        closingPointColor: "#FAFAFA",
        closingPointWidth: 3,
        closingPointOutlineColor: "#666666",
        closingPointOutlineWidth: 1
      }
    }),
    "freehand-linestring": new Ge({
      styles: {
        lineStringColor: "#666666",
        lineStringWidth: 2,
        closingPointColor: "#FFFFFF",
        closingPointWidth: 3,
        closingPointOutlineColor: "#666666",
        closingPointOutlineWidth: 1
      }
    }),
    sensor: new Re({
      styles: {
        fillColor: "#EDEFF0",
        fillOpacity: 0.7,
        outlineColor: "#666666",
        outlineWidth: 2,
        centerPointColor: "#FAFAFA",
        centerPointWidth: 3,
        centerPointOutlineColor: "#666666",
        centerPointOutlineWidth: 1
      }
    }),
    sector: new Ae({
      styles: {
        fillColor: "#EDEFF0",
        fillOpacity: 0.7,
        outlineColor: "#666666",
        outlineWidth: 2
      }
    }),
    select: new zt({
      flags: {
        point: {
          feature: {
            draggable: !1
          }
        },
        polygon: {
          feature: {
            draggable: !0,
            rotateable: !0,
            scaleable: !0,
            coordinates: {
              midpoints: !0,
              draggable: !0,
              deletable: !0
            }
          }
        },
        linestring: {
          feature: {
            draggable: !0,
            rotateable: !0,
            scaleable: !0,
            coordinates: {
              midpoints: !0,
              draggable: !0,
              deletable: !0
            }
          }
        },
        freehand: {
          feature: {
            draggable: !0,
            coordinates: {
              midpoints: !0,
              draggable: !0,
              deletable: !0
            }
          }
        },
        "freehand-linestring": {
          feature: {
            draggable: !0,
            rotateable: !0,
            scaleable: !0,
            coordinates: {
              midpoints: !0,
              draggable: !0,
              deletable: !0
            }
          }
        },
        circle: {
          feature: {
            draggable: !0,
            coordinates: {
              midpoints: !0,
              draggable: !0,
              deletable: !0
            }
          }
        },
        rectangle: {
          feature: {
            draggable: !0,
            rotateable: !0,
            scaleable: !0,
            coordinates: {
              midpoints: !0,
              draggable: !0,
              deletable: !0
            }
          }
        },
        "angled-rectangle": {
          feature: {
            draggable: !0,
            rotateable: !0,
            scaleable: !0,
            coordinates: {
              midpoints: !0,
              draggable: !0,
              deletable: !0
            }
          }
        },
        sensor: {
          feature: {
            draggable: !0,
            rotateable: !0,
            scaleable: !0,
            coordinates: {
              midpoints: !0,
              draggable: !0,
              deletable: !0
            }
          }
        },
        sector: {
          feature: {
            draggable: !0,
            rotateable: !0,
            scaleable: !0,
            coordinates: {
              midpoints: !0,
              draggable: !0,
              deletable: !0
            }
          }
        }
      }
    })
  },
  pointLayerLabelSpec: {
    id: "{prefix}-point-label",
    type: "symbol",
    source: "{prefix}-point-source",
    filter: ["all", ["==", "$type", "Point"], ["==", "mode", "point"]],
    layout: {
      "text-field": [
        "case",
        ["all", ["has", "elevation"], [">", ["get", "elevation"], 0]],
        ["concat", "Alt. ", ["to-string", ["floor", ["get", "elevation"]]], " m"],
        ""
      ],
      "symbol-placement": "point",
      "text-size": [
        "interpolate",
        ["linear"],
        ["zoom"],
        5,
        10,
        10,
        12,
        13,
        14,
        14,
        16,
        18,
        18
      ],
      "text-overlap": "always",
      "text-variable-anchor": ["left", "right", "top", "bottom"],
      "text-radial-offset": 0.5,
      "text-justify": "center",
      "text-letter-spacing": 0.05
    },
    paint: {
      "text-halo-color": "#F7F7F7",
      "text-halo-width": 2,
      "text-color": "#232E3D"
    }
  },
  lineLayerLabelSpec: {
    id: "{prefix}-line-label",
    type: "symbol",
    source: "{prefix}-line-source",
    filter: ["==", "$type", "Point"],
    layout: {
      "text-field": [
        "concat",
        ["to-string", ["get", "distance"]],
        " ",
        ["get", "unit"],
        [
          "case",
          ["==", ["get", "total"], 0],
          "",
          ["concat", `
(`, ["to-string", ["get", "total"]], " ", ["get", "totalUnit"], ")"]
        ],
        [
          "case",
          ["all", ["has", "elevation"], [">", ["get", "elevation"], 0]],
          ["concat", `
Alt. `, ["to-string", ["floor", ["get", "elevation"]]], " m"],
          ""
        ]
      ],
      "symbol-placement": "point",
      "text-size": [
        "interpolate",
        ["linear"],
        ["zoom"],
        5,
        10,
        10,
        12,
        13,
        14,
        14,
        16,
        18,
        18
      ],
      "text-overlap": "always",
      "text-variable-anchor": ["left", "right", "top", "bottom"],
      "text-radial-offset": 0.5,
      "text-justify": "center",
      "text-letter-spacing": 0.05
    },
    paint: {
      "text-halo-color": "#F7F7F7",
      "text-halo-width": 2,
      "text-color": "#232E3D"
    }
  },
  routingLineLayerNodeSpec: {
    id: "{prefix}-line-node",
    type: "circle",
    source: "{prefix}-line-source",
    filter: ["==", "$type", "Point"],
    layout: {},
    paint: {
      "circle-radius": 3,
      "circle-color": "#FFFFFF",
      "circle-stroke-color": "#000000",
      "circle-stroke-width": 1
    }
  },
  polygonLayerSpec: {
    id: "{prefix}-polygon-label",
    type: "symbol",
    source: "{prefix}-polygon-source",
    filter: ["==", "$type", "Point"],
    layout: {
      "text-field": ["concat", ["to-string", ["get", "area"]], " ", ["get", "unit"]],
      "symbol-placement": "point",
      "text-size": [
        "interpolate",
        ["linear"],
        ["zoom"],
        5,
        10,
        10,
        12,
        13,
        14,
        14,
        16,
        18,
        18
      ],
      "text-overlap": "always",
      "text-letter-spacing": 0.05
    },
    paint: {
      "text-halo-color": "#F7F7F7",
      "text-halo-width": 2,
      "text-color": "#232E3D"
    }
  },
  computeElevation: !1,
  terrainSource: {
    url: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png",
    encoding: "terrarium",
    tileSize: 256,
    minzoom: 5,
    maxzoom: 15,
    tms: !1
  },
  distanceUnit: "kilometers",
  distancePrecision: 2,
  forceDistanceUnit: "auto",
  areaUnit: "metric",
  areaPrecision: 2,
  forceAreaUnit: "auto",
  elevationCacheConfig: {
    enabled: !0,
    maxSize: 1e3,
    ttl: 3600 * 1e3,
    // 1 hour
    precision: 9
    // 9 is default precision of terra-draw adapter setting
  },
  adapterOptions: {
    prefixId: "td-measure"
  }
}, z = {
  modes: [
    "render",
    "linestring",
    "point",
    "select",
    "delete-selection",
    "delete",
    "download",
    "settings"
  ],
  open: !1,
  // see styling parameters of Terra Draw at https://github.com/JamesLMilner/terra-draw/blob/main/guides/5.STYLING.md
  modeOptions: {
    point: new Ut({
      editable: !1,
      styles: {
        pointColor: "#FFFFFF",
        pointWidth: 5,
        pointOutlineColor: "#666666",
        pointOutlineWidth: 1
      }
    }),
    linestring: new Gt({
      editable: !1,
      styles: {
        lineStringColor: "#FF0000",
        lineStringWidth: 2,
        closingPointColor: "#FF0000",
        closingPointWidth: 3,
        closingPointOutlineColor: "#666666",
        closingPointOutlineWidth: 1
      }
    }),
    select: new zt({
      flags: {
        point: {
          feature: {
            draggable: !1
          }
        },
        linestring: {
          feature: {
            draggable: !1,
            rotateable: !1,
            scaleable: !1,
            coordinates: {
              midpoints: !1,
              draggable: !1,
              deletable: !1
            }
          }
        }
      }
    }),
    settings: new Q({
      modeName: "settings",
      styles: {}
    })
  },
  valhallaOptions: {
    url: "",
    routingOptions: {
      costingModel: "auto",
      distanceUnit: "kilometers"
    },
    isochroneOptions: {
      contourType: "time",
      costingModel: "auto",
      contours: [
        {
          time: 3,
          distance: 1,
          color: "#ff0000"
        },
        {
          time: 5,
          distance: 2,
          color: "#ffff00"
        },
        {
          time: 10,
          distance: 3,
          color: "#0000ff"
        },
        {
          time: 15,
          distance: 4,
          color: "#ff00ff"
        }
      ]
    }
  },
  adapterOptions: {
    prefixId: "td-valhalla"
  },
  routingLineLayerNodeLabelSpec: {
    id: "{prefix}-routing-node-label",
    type: "symbol",
    source: "{prefix}-routing-source",
    filter: ["==", "$type", "Point"],
    layout: {
      "text-field": [
        "case",
        ["all", ["has", "distance"], ["has", "distance_unit"], ["has", "time"]],
        [
          "concat",
          ["to-string", ["get", "text"]],
          `
`,
          ["to-string", ["/", ["round", ["*", ["get", "distance"], 10]], 10]],
          ["to-string", ["get", "distance_unit"]],
          `
`,
          ["to-string", ["get", "time"]],
          "min"
        ],
        ["all", ["has", "costingModel"]],
        [
          "concat",
          ["to-string", ["get", "text"]],
          `
(`,
          ["to-string", ["get", "costingModel"]],
          ")"
        ],
        ["concat", ["to-string", ["get", "text"]]]
      ],
      "symbol-placement": "point",
      "text-size": [
        "interpolate",
        ["linear"],
        ["zoom"],
        5,
        10,
        10,
        12,
        13,
        14,
        14,
        16,
        18,
        18
      ],
      "text-overlap": "always",
      "text-variable-anchor": ["left", "right", "top", "bottom"],
      "text-radial-offset": 0.5,
      "text-justify": "left",
      "text-letter-spacing": 0.05
    },
    paint: {
      "text-halo-color": "#F7F7F7",
      "text-halo-width": 2,
      "text-color": "#232E3D"
    }
  },
  routingLineLayerNodeSpec: {
    id: "{prefix}-routing-node",
    type: "circle",
    source: "{prefix}-routing-source",
    filter: ["==", "$type", "Point"],
    layout: {},
    paint: {
      "circle-radius": 3,
      "circle-color": [
        "case",
        ["==", ["get", "text"], "Start"],
        "#0000FF",
        ["==", ["get", "text"], "Goal"],
        "#FFFF00",
        "#FFFFFF"
      ],
      "circle-stroke-color": "#000000",
      "circle-stroke-width": 1
    }
  },
  isochronePolygonLayerSpec: {
    id: "{prefix}-isochrone-polygon",
    type: "fill",
    source: "{prefix}-isochrone-source",
    layout: {},
    paint: {
      "fill-color": ["get", "fillColor"],
      "fill-opacity": ["get", "fillOpacity"]
    }
  },
  isochroneLineLayerSpec: {
    id: "{prefix}-isochrone-line",
    type: "line",
    source: "{prefix}-isochrone-source",
    layout: {
      "line-join": "round",
      "line-cap": "round"
    },
    paint: {
      "line-color": ["get", "fillColor"],
      "line-width": 3
    }
  },
  isochroneLabelLayerSpec: {
    id: "{prefix}-isochrone-label",
    type: "symbol",
    source: "{prefix}-isochrone-source",
    layout: {
      "symbol-placement": "line",
      "text-pitch-alignment": "viewport",
      "text-field": [
        "concat",
        ["get", "contour"],
        " ",
        [
          "case",
          ["==", ["get", "metric"], "time"],
          "min",
          ["==", ["get", "metric"], "distance"],
          "km",
          ""
        ]
      ],
      "text-size": 12,
      "symbol-spacing": 100,
      "text-max-angle": 45
    },
    paint: {
      "text-color": "rgb(0, 0, 0)",
      "text-halo-width": 1,
      "text-halo-color": "rgb(255, 255, 255)"
    }
  }
}, io = () => ({
  render: new Q({
    modeName: "render",
    styles: {}
  }),
  point: new Ut({
    editable: !0
  }),
  linestring: new Gt({
    editable: !0
  }),
  polygon: new Fe({
    editable: !0,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    validation: (t, e) => {
      const i = e.updateType;
      return i === "finish" || i === "commit" ? zi(t) : { valid: !0 };
    }
  }),
  rectangle: new Me(),
  "angled-rectangle": new Be(),
  circle: new Oe(),
  freehand: new be(),
  "freehand-linestring": new Ge(),
  sensor: new Re(),
  sector: new Ae(),
  select: new zt({
    flags: {
      point: {
        feature: {
          draggable: !0
        }
      },
      polygon: {
        feature: {
          draggable: !0,
          rotateable: !0,
          scaleable: !0,
          coordinates: {
            midpoints: !0,
            draggable: !0,
            deletable: !0
          }
        }
      },
      linestring: {
        feature: {
          draggable: !0,
          rotateable: !0,
          scaleable: !0,
          coordinates: {
            midpoints: !0,
            draggable: !0,
            deletable: !0
          }
        }
      },
      freehand: {
        feature: {
          draggable: !0,
          coordinates: {
            midpoints: !0,
            draggable: !0,
            deletable: !0
          }
        }
      },
      "freehand-linestring": {
        feature: {
          draggable: !0,
          rotateable: !0,
          scaleable: !0,
          coordinates: {
            midpoints: !0,
            draggable: !0,
            deletable: !0
          }
        }
      },
      circle: {
        feature: {
          draggable: !0,
          coordinates: {
            midpoints: !0,
            draggable: !0,
            deletable: !0
          }
        }
      },
      rectangle: {
        feature: {
          draggable: !0,
          rotateable: !0,
          scaleable: !0,
          coordinates: {
            midpoints: !0,
            draggable: !0,
            deletable: !0
          }
        }
      },
      "angled-rectangle": {
        feature: {
          draggable: !0,
          rotateable: !0,
          scaleable: !0,
          coordinates: {
            midpoints: !0,
            draggable: !0,
            deletable: !0
          }
        }
      },
      sensor: {
        feature: {
          draggable: !0,
          rotateable: !0,
          scaleable: !0,
          coordinates: {
            midpoints: !0,
            draggable: !0,
            deletable: !0
          }
        }
      },
      sector: {
        feature: {
          draggable: !0,
          rotateable: !0,
          scaleable: !0,
          coordinates: {
            midpoints: !0,
            draggable: !0,
            deletable: !0
          }
        }
      }
    }
  }),
  delete: new Q({
    modeName: "delete",
    styles: {}
  }),
  "delete-selection": new Q({
    modeName: "delete-selection",
    styles: {}
  }),
  download: new Q({
    modeName: "download",
    styles: {}
  })
});
var W = 63710088e-1, oo = {
  centimeters: W * 100,
  centimetres: W * 100,
  degrees: 360 / (2 * Math.PI),
  feet: W * 3.28084,
  inches: W * 39.37,
  kilometers: W / 1e3,
  kilometres: W / 1e3,
  meters: W,
  metres: W,
  miles: W / 1609.344,
  millimeters: W * 1e3,
  millimetres: W * 1e3,
  nauticalmiles: W / 1852,
  radians: 1,
  yards: W * 1.0936
};
function so(r, t, e = {}) {
  const i = { type: "Feature" };
  return (e.id === 0 || e.id) && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.properties = t || {}, i.geometry = r, i;
}
function ro(r, t, e = {}) {
  if (!r)
    throw new Error("coordinates is required");
  if (!Array.isArray(r))
    throw new Error("coordinates must be an Array");
  if (r.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!pe(r[0]) || !pe(r[1]))
    throw new Error("coordinates must contain numbers");
  return so({
    type: "Point",
    coordinates: r
  }, t, e);
}
function no(r, t = "kilometers") {
  const e = oo[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return r * e;
}
function vt(r) {
  return r % 360 * Math.PI / 180;
}
function pe(r) {
  return !isNaN(r) && r !== null && !Array.isArray(r);
}
function Ue(r, t, e) {
  if (r !== null)
    for (var i, o, s, n, a, l, d, c = 0, h = 0, u, p = r.type, g = p === "FeatureCollection", y = p === "Feature", m = g ? r.features.length : 1, v = 0; v < m; v++) {
      d = g ? r.features[v].geometry : y ? r.geometry : r, u = d ? d.type === "GeometryCollection" : !1, a = u ? d.geometries.length : 1;
      for (var C = 0; C < a; C++) {
        var f = 0, P = 0;
        if (n = u ? d.geometries[C] : d, n !== null) {
          l = n.coordinates;
          var I = n.type;
          switch (c = I === "Polygon" || I === "MultiPolygon" ? 1 : 0, I) {
            case null:
              break;
            case "Point":
              if (t(
                l,
                h,
                v,
                f,
                P
              ) === !1)
                return !1;
              h++, f++;
              break;
            case "LineString":
            case "MultiPoint":
              for (i = 0; i < l.length; i++) {
                if (t(
                  l[i],
                  h,
                  v,
                  f,
                  P
                ) === !1)
                  return !1;
                h++, I === "MultiPoint" && f++;
              }
              I === "LineString" && f++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (i = 0; i < l.length; i++) {
                for (o = 0; o < l[i].length - c; o++) {
                  if (t(
                    l[i][o],
                    h,
                    v,
                    f,
                    P
                  ) === !1)
                    return !1;
                  h++;
                }
                I === "MultiLineString" && f++, I === "Polygon" && P++;
              }
              I === "Polygon" && f++;
              break;
            case "MultiPolygon":
              for (i = 0; i < l.length; i++) {
                for (P = 0, o = 0; o < l[i].length; o++) {
                  for (s = 0; s < l[i][o].length - c; s++) {
                    if (t(
                      l[i][o][s],
                      h,
                      v,
                      f,
                      P
                    ) === !1)
                      return !1;
                    h++;
                  }
                  P++;
                }
                f++;
              }
              break;
            case "GeometryCollection":
              for (i = 0; i < n.geometries.length; i++)
                if (Ue(n.geometries[i], t) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function ao(r, t) {
  var e, i, o, s, n, a, l, d, c, h, u = 0, p = r.type === "FeatureCollection", g = r.type === "Feature", y = p ? r.features.length : 1;
  for (e = 0; e < y; e++) {
    for (a = p ? r.features[e].geometry : g ? r.geometry : r, d = p ? r.features[e].properties : g ? r.properties : {}, c = p ? r.features[e].bbox : g ? r.bbox : void 0, h = p ? r.features[e].id : g ? r.id : void 0, l = a ? a.type === "GeometryCollection" : !1, n = l ? a.geometries.length : 1, o = 0; o < n; o++) {
      if (s = l ? a.geometries[o] : a, s === null) {
        if (t(
          null,
          u,
          d,
          c,
          h
        ) === !1)
          return !1;
        continue;
      }
      switch (s.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (t(
            s,
            u,
            d,
            c,
            h
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (i = 0; i < s.geometries.length; i++)
            if (t(
              s.geometries[i],
              u,
              d,
              c,
              h
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    u++;
  }
}
function lo(r, t, e) {
  var i = e;
  return ao(
    r,
    function(o, s, n, a, l) {
      s === 0 && e === void 0 ? i = o : i = t(
        i,
        o,
        s,
        n,
        a,
        l
      );
    }
  ), i;
}
function co(r) {
  return lo(
    r,
    (t, e) => t + ho(e),
    0
  );
}
function ho(r) {
  let t = 0, e;
  switch (r.type) {
    case "Polygon":
      return ge(r.coordinates);
    case "MultiPolygon":
      for (e = 0; e < r.coordinates.length; e++)
        t += ge(r.coordinates[e]);
      return t;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function ge(r) {
  let t = 0;
  if (r && r.length > 0) {
    t += Math.abs(ye(r[0]));
    for (let e = 1; e < r.length; e++)
      t -= Math.abs(ye(r[e]));
  }
  return t;
}
var uo = W * W / 2, Mt = Math.PI / 180;
function ye(r) {
  const t = r.length - 1;
  if (t <= 2) return 0;
  let e = 0, i = 0;
  for (; i < t; ) {
    const o = r[i], s = r[i + 1 === t ? 0 : i + 1], n = r[i + 2 >= t ? (i + 2) % t : i + 2], a = o[0] * Mt, l = s[1] * Mt, d = n[0] * Mt;
    e += (d - a) * Math.sin(l), i++;
  }
  return e * uo;
}
var po = co;
const go = (r, t, e = "auto") => {
  const i = ["m2", "km2", "a", "ha"], o = ["ft2", "yd2", "acre", "mi2"];
  let s = e;
  if (e !== "auto") {
    const n = i.includes(e), a = o.includes(e);
    (t === "metric" && !n || t === "imperial" && !a) && (s = "auto");
  }
  return t === "metric" ? s !== "auto" ? ot(r, s) : r >= 1e6 ? ot(r, "km2") : r >= 1e4 ? ot(r, "ha") : r >= 100 ? ot(r, "a") : ot(r, "m2") : s !== "auto" ? st(r, s) : r >= 258998811e-2 ? st(r, "mi2") : r >= 4046.856 ? st(r, "acre") : r >= 0.83612736 ? st(r, "yd2") : st(r, "ft2");
}, ot = (r, t) => {
  let e = r, i = "m²";
  switch (t) {
    case "m2":
      e = r, i = "m²";
      break;
    case "a":
      e = r / 100, i = "a";
      break;
    case "ha":
      e = r / 1e4, i = "ha";
      break;
    case "km2":
      e = r / 1e6, i = "km²";
      break;
  }
  return {
    area: e,
    unit: i
  };
}, st = (r, t) => {
  let e = r / 258998811e-2, i = "m²";
  switch (t) {
    case "ft2":
      e = r / 0.09290304, i = "ft²";
      break;
    case "yd2":
      e = r / 0.83612736, i = "yd²";
      break;
    case "acre":
      e = r / 4046.856, i = "acre";
      break;
    case "mi2":
      e = r / 258998811e-2, i = "mi²";
      break;
  }
  return {
    area: e,
    unit: i
  };
}, fe = (r, t, e, i) => {
  if (r.geometry.type !== "Polygon") return r;
  const o = po(r.geometry), s = go(o, t, i);
  return s.area = parseFloat(s.area.toFixed(e)), r.properties.area = s.area, r.properties.unit = s.unit, r;
};
function me(r) {
  if (!r)
    throw new Error("coord is required");
  if (!Array.isArray(r)) {
    if (r.type === "Feature" && r.geometry !== null && r.geometry.type === "Point")
      return [...r.geometry.coordinates];
    if (r.type === "Point")
      return [...r.coordinates];
  }
  if (Array.isArray(r) && r.length >= 2 && !Array.isArray(r[0]) && !Array.isArray(r[1]))
    return [...r];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function yo(r, t, e = {}) {
  var i = me(r), o = me(t), s = vt(o[1] - i[1]), n = vt(o[0] - i[0]), a = vt(i[1]), l = vt(o[1]), d = Math.pow(Math.sin(s / 2), 2) + Math.pow(Math.sin(n / 2), 2) * Math.cos(a) * Math.cos(l);
  return no(
    2 * Math.atan2(Math.sqrt(d), Math.sqrt(1 - d)),
    e.units
  );
}
var fo = yo;
const Dt = (r, t = "kilometers", e = "auto") => {
  const i = ["cm", "m", "km"], o = ["in", "ft", "mi"];
  let s = e;
  if (e !== "auto") {
    const a = i.includes(e), l = o.includes(e);
    (t === "kilometers" && !a || t === "miles" && !l) && (s = "auto");
  }
  let n = {
    distance: r,
    unit: "km"
  };
  return t === "kilometers" ? n = Ct(r, s) : t === "degrees" ? n.unit = "°" : t === "miles" ? n = Pt(r, s) : t === "radians" && (n.unit = "rad"), n;
}, Ct = (r, t) => {
  let e = {
    distance: r,
    unit: "km"
  };
  switch (t) {
    case "km":
      e.distance = r, e.unit = "km";
      break;
    case "m":
      e.distance = r * 1e3, e.unit = "m";
      break;
    case "cm":
      e.distance = r * 1e5, e.unit = "cm";
      break;
    case "auto":
      r >= 1 ? e = Ct(r, "km") : r * 1e3 >= 1 ? e = Ct(r, "m") : e = Ct(r, "cm");
      break;
    default:
      e.distance = r, e.unit = "km";
      break;
  }
  return e;
}, Pt = (r, t) => {
  let e = {
    distance: r,
    unit: "mi"
  };
  switch (t) {
    case "mi":
      e.distance = r, e.unit = "mi";
      break;
    case "ft":
      e.distance = r * 5280, e.unit = "ft";
      break;
    case "in":
      e.distance = r * 63360, e.unit = "in";
      break;
    case "auto":
      r >= 1 ? e = Pt(r, "mi") : r * 5280 >= 1 ? e = Pt(r, "ft") : e = Pt(r, "in");
      break;
    default:
      e.distance = r, e.unit = "mi";
      break;
  }
  return e;
}, ve = (r, t, e, i, o, s, n) => {
  if (r.geometry.type !== "LineString") return r;
  const a = r.geometry.coordinates;
  let l = 0;
  const d = [];
  for (let h = 0; h < a.length - 1; h++) {
    const u = a[h], p = a[h + 1], g = fo(u, p, { units: t });
    l += g;
    const y = JSON.parse(JSON.stringify(r));
    if (y.id = `${y.id}-${h}`, y.geometry.coordinates = [u, p], y.properties.originalId = r.id, y.properties.distance = g, y.properties.total = l, s === !0 && n === void 0) {
      const m = o?.queryTerrainElevation(u);
      m && (y.properties.elevation_start = m);
      const v = o?.queryTerrainElevation(p);
      v && (y.properties.elevation_end = v);
    }
    d.push(y);
  }
  r.properties.distance = d[d.length - 1].properties.total, r.properties.segments = JSON.parse(JSON.stringify(d));
  const c = Dt(
    r.properties.distance,
    t,
    i
  );
  return r.properties.distance = c.distance, r.properties.unit = c.unit, r.properties.segments.forEach(
    (h) => {
      const u = Dt(
        h.properties.distance,
        t,
        i
      );
      h.properties.distance = u.distance, h.properties.unit = u.unit;
      const p = Dt(
        h.properties.total,
        t,
        i
      );
      h.properties.total = p.distance, h.properties.totalUnit = p.unit;
    }
  ), r.properties.distance = parseFloat(
    r.properties.distance.toFixed(e)
  ), r.properties.segments.forEach(
    (h) => {
      h.properties.distance = parseFloat(
        h.properties.distance.toFixed(e)
      ), h.properties.total = parseFloat(
        h.properties.total.toFixed(e)
      );
    }
  ), r;
}, Ce = (r) => r.charAt(0).toUpperCase() + r.slice(1), et = [
  "{prefix}-point",
  "{prefix}-point-lower",
  "{prefix}-linestring",
  "{prefix}-polygon",
  "{prefix}-polygon-outline"
], Yo = [
  ...et,
  lt.polygonLayerSpec?.source,
  lt.lineLayerLabelSpec?.source,
  lt.pointLayerLabelSpec?.source
], Ko = [
  ...et,
  z.routingLineLayerNodeLabelSpec?.source,
  z.routingLineLayerNodeSpec?.source,
  z.isochronePolygonLayerSpec?.source,
  z.isochroneLineLayerSpec?.source,
  z.isochroneLabelLayerSpec?.source
], Vt = (r, t, e = et, i = "td") => {
  e = e.map((s) => s.replace("{prefix}", i));
  const o = JSON.parse(JSON.stringify(r));
  return t && (t.onlyTerraDrawLayers === !0 ? (o.layers = o.layers.filter((s) => "source" in s && e.includes(s.source)), Object.keys(o.sources).forEach((s) => {
    e.includes(s) || delete o.sources[s];
  })) : t.excludeTerraDrawLayers === !0 && (o.layers = o.layers.filter((s) => "source" in s && !e.includes(s.source) || s.type === "background"), Object.keys(o.sources).forEach((s) => {
    e.includes(s) && delete o.sources[s];
  }))), o;
}, ze = (r, t = 250) => {
  let e;
  return (...i) => {
    clearTimeout(e), e = setTimeout(() => r(...i), t);
  };
};
class Ve {
  cache = /* @__PURE__ */ new Map();
  maxSize;
  ttl;
  constructor(t = 1e3, e) {
    this.maxSize = t, this.ttl = e;
  }
  /**
   * Get a value from the cache. If the item has expired, it will be removed from the cache.
   */
  get(t) {
    const e = this.cache.get(t);
    if (e) {
      if (e.expiry && Date.now() > e.expiry) {
        this.cache.delete(t);
        return;
      }
      return e.value;
    }
  }
  /**
   * set a value in the cache.
   * If the cache size exceeds maxSize, the oldest item will be removed (FIFO).
   * If ttl is set, the item will expire after ttl milliseconds.
   */
  set(t, e) {
    if (this.maxSize === 0) return;
    if (this.cache.size >= this.maxSize) {
      const o = this.cache.keys().next().value;
      o && this.cache.delete(o);
    }
    const i = this.ttl ? Date.now() + this.ttl : void 0;
    this.cache.set(t, { value: e, expiry: i });
  }
  /**
   * Check if a key exists in the cache.
   */
  has(t) {
    return this.get(t) !== void 0;
  }
  /**
   * Delete a key from the cache.
   */
  delete(t) {
    return this.cache.delete(t);
  }
  /**
   * Clear the cache.
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Get the current size of the cache.
   */
  get size() {
    return this.cache.size;
  }
  /**
   * Cleanup expired items from the cache.
   */
  cleanupExpired() {
    if (!this.ttl) return;
    const t = Date.now();
    for (const [e, i] of this.cache.entries())
      i.expiry && t > i.expiry && this.cache.delete(e);
  }
  /**
   * Get cache statistics.
   */
  getStats() {
    return {
      size: this.size,
      maxSize: this.maxSize,
      ttl: this.ttl
    };
  }
}
class mo {
  className;
  dialog;
  title;
  /**
   * Constructor
   * @param className top level CSS class name for the dialog
   * @param title titile of the dialog
   */
  constructor(t, e) {
    this.className = t, this.title = e;
  }
  /**
   * Create a modal dialog content and return content element.
   * @param parentElement parent element to append the dialog
   * @param addConttent callback function to add content to the dialog. The callback receives a content element as an argument and must return the modified content element.
   * @example
   * ```ts
   * const dialog = new ModalDialog('my-dialog', 'My Dialog');
   * dialog.create(document.body, (content) => {
   *   const p = document.createElement('p');
   *   p.textContent = 'This is my dialog content.';
   *   content.appendChild(p);
   *   return content;
   * });
   * dialog.open();
   * ```
   * @returns HTMLDialogElement
   */
  create(t, e) {
    const i = document.getElementsByClassName(this.className);
    i.length > 0 && Array.from(i).forEach((l) => {
      l.remove();
    }), this.dialog = document.createElement("dialog"), this.dialog.classList.add(this.className);
    const o = document.createElement("div");
    o.classList.add("dialog-header");
    const s = document.createElement("h3");
    s.textContent = this.title, s.classList.add("dialog-title"), o.appendChild(s);
    const n = document.createElement("button");
    n.type = "button", n.classList.add("close-button"), n.innerHTML = "×", n.setAttribute("aria-label", "Close dialog"), n.addEventListener("click", () => {
      this.close();
    }), o.appendChild(n), this.dialog.appendChild(o);
    const a = document.createElement("div");
    a.classList.add("content"), this.dialog.appendChild(e(a)), this.dialog.addEventListener("click", (l) => {
      const d = l.target;
      if (!d) return;
      const c = d.getBoundingClientRect();
      (c.left > l.clientX || c.right < l.clientX || c.top > l.clientY || c.bottom < l.clientY) && this.close();
    }), t.appendChild(this.dialog);
  }
  /**
   * Open the modal dialog.
   */
  open() {
    this.dialog?.showModal();
  }
  /**
   * Close the modal dialog.
   */
  close() {
    this.dialog?.close();
  }
  /**
   * Create segment buttons element for the dialog.
   * @param options options for creating segment buttons
   * @param defaultValue default value for the segment buttons
   * @param onClick a callback function to handle click events on the segment buttons
   * @example
   * ```ts
   * const segmentButtons = createSegmentButtons(
   *   [{ value: 'option1', label: 'Option 1' }, { value: 'option2', label: 'Option 2' }],
   *   'option1',
   *   (value) => console.log(`Selected: ${value}`)
   * );
   * document.body.appendChild(segmentButtons);
   * ```
   * @returns
   */
  createSegmentButtons(t, e, i = () => {
  }) {
    const o = document.createElement("div");
    return o.classList.add("segment-buttons"), t.forEach((s) => {
      const n = document.createElement("button");
      n.type = "button", n.classList.add("segment-button"), n.value = s.value, n.textContent = s.label, s.value === e && n.classList.add("active"), n.addEventListener("click", () => {
        o.querySelectorAll(".segment-button").forEach((a) => a.classList.remove("active")), n.classList.add("active"), i(n.value);
      }), o.appendChild(n);
    }), o;
  }
}
const Pe = (r, t, e, i) => {
  if (r.geometry.type !== "Point") return r;
  const o = r.geometry.coordinates;
  if (e === !0 && i === void 0) {
    const s = t?.queryTerrainElevation(o);
    s && (r.properties.elevation = s);
  }
  return r;
};
var vo = Object.defineProperty, Co = (r, t, e) => t in r ? vo(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e, rt = (r, t, e) => Co(r, typeof t != "symbol" ? t + "" : t, e), xt = 2 * Math.PI * 6378137 / 2;
function Po(r) {
  return r = r || 256, 2 * Math.PI * 6378137 / r;
}
function So(r, t, e = { enable: !0, decimal: 1 }) {
  r = $t(r);
  var i = r[0], o = r[1], s = i * xt / 180, n = Math.log(Math.tan((90 + o) * Math.PI / 360)) / (Math.PI / 180);
  return n = n * xt / 180, e.enable && (s = Number(s.toFixed(e.decimal)), n = Number(n.toFixed(e.decimal))), [s, n];
}
function Io(r, t, e) {
  var i = r[0], o = r[1], s = Lo(t, e), n = (i + xt) / s, a = (o + xt) / s;
  return [n, a, t];
}
function $e(r, t, e) {
  r = $t(r);
  var i = So(r), o = Io(i, t);
  return Oo(o);
}
function xo(r, t, e) {
  if (r = $t(r), t === 0)
    return [0, 0, 0];
  var i = $e(r, t);
  return bo(i);
}
function Oo(r, t, e) {
  t = t || 256;
  var i = r[0], o = r[1], s = r[2];
  if (s === 0) return [0, 0, 0];
  Ye(s);
  var n = Math.ceil(i / t) - 1, a = Math.ceil(o / t) - 1;
  return n < 0 && (n = 0), a < 0 && (a = 0), [n, a, s];
}
function bo(r, t) {
  Eo(r);
  var e = r[0], i = r[1], o = r[2];
  if (o === 0)
    return [0, 0, 0];
  var s = e, n = Math.pow(2, o) - 1 - i;
  return [s, n, o];
}
function Eo(r, t) {
  var e = r[0], i = r[1], o = r[2];
  if (o == null) throw new Error("<zoom> is required");
  if (e == null) throw new Error("<x> is required");
  if (i == null) throw new Error("<y> is required");
  return o = Ye(o), r = wo(r), r;
}
function wo(r) {
  var t = r[0], e = r[1], i = r[2], o = Math.pow(2, i);
  return t = t % o, t < 0 && (t = t + o), [t, e, i];
}
function Ye(r) {
  if (r === !1) return r;
  if (r == null)
    throw new Error("<zoom> is required");
  if (r < 0)
    throw new Error("<zoom> cannot be less than 0");
  if (r > 32)
    throw new Error("<zoom> cannot be greater than 32");
  return r;
}
function $t(r, t) {
  var e = Mo(r[0]), i = Fo(r[1]);
  return i > 85 && (i = 85), i < -85 && (i = -85), [e, i];
}
function Lo(r, t) {
  return Po(t) / Math.pow(2, r);
}
function Fo(r) {
  if (r == null) throw new Error("lat is required");
  return (r > 90 || r < -90) && (r = r % 180, r > 90 && (r = -180 + r), r < -90 && (r = 180 + r), r === 0 && (r = 0)), r;
}
function Mo(r) {
  if (r == null) throw new Error("lng is required");
  return (r > 180 || r < -180) && (r = r % 360, r > 180 && (r = -360 + r), r < -180 && (r = 360 + r), r === 0 && (r = 0)), r;
}
class Ke {
  /**
   * Constructor
   * @param url URL for terrain RGB raster tilesets
   * @param tileSize size of tile. 256 or 512
   * @param tms whether it is Tile Map Service
   * @param minzoom minzoom for terrain RGB raster tilesets
   * @param maxzoom maxzoom for terrain RGB raster tilesets
   * @param tms whether it is Tile Map Service
   */
  constructor(t, e, i, o, s) {
    rt(this, "url"), rt(this, "tileSize"), rt(this, "tms"), rt(this, "minzoom"), rt(this, "maxzoom"), this.url = t, this.tileSize = e, this.tms = s, this.minzoom = i, this.maxzoom = o, this.tms = s;
  }
  /**
   * Get the value from target coordinates and zoom level by using certain formula.
   * @param lnglat coordinates
   * @param z  zoom level
   * @returns the value calculated by certain formula
   */
  getValue(t, e) {
    return new Promise(
      (i, o) => {
        const s = t[0], n = t[1];
        let a = e;
        e > this.maxzoom ? a = this.maxzoom : e < this.minzoom && (a = this.minzoom);
        const l = this.tms ? $e([s, n], a) : xo([s, n], a), d = this.url.replace(/{x}/g, l[0].toString()).replace(/{y}/g, l[1].toString()).replace(/{z}/g, l[2].toString());
        let c = this.getUrlExtension(d);
        switch (c || (c = "png"), c) {
          case "png":
          case "webp":
            this.getValueFromRaster(d, l, s, n).then((h) => {
              i(h);
            });
            break;
          default:
            o(new Error(`Invalid file extension: ${c}`));
            break;
        }
      }
    );
  }
  /**
   * Get the value calculated from coordinates on WEBP raster tileset
   * @param url tile URL
   * @param tile tile index info
   * @param lng longitude
   * @param lat latitude
   * @returns the value calculated from coordinates. If tile does not exist returns undefined
   */
  async getValueFromRaster(t, e, i, o) {
    const s = await fetch(t);
    if (!s.ok) {
      if (s.status === 404)
        return;
      throw new Error(`Failed to fetch tile: ${s.statusText}`);
    }
    const n = await s.blob();
    return new Promise((a, l) => {
      const d = new Image();
      d.onload = () => {
        const c = document.createElement("canvas");
        c.width = d.width, c.height = d.height;
        const h = c.getContext("2d");
        if (!h) return l(new Error("Failed to create canvas context"));
        h.drawImage(d, 0, 0);
        const u = h.getImageData(0, 0, d.width, d.height).data, p = this.pixels2rgba(new Uint8Array(u), e, i, o), g = this.calc(p[0], p[1], p[2], p[3]);
        a(g);
      }, d.onerror = () => a(void 0), d.src = URL.createObjectURL(n);
    });
  }
  /**
   * Get RGBA values from coordinates information
   * @param pixels pixels info
   * @param tile tile index info
   * @param lng longitude
   * @param lat latitude
   * @returns RGBA values
   */
  pixels2rgba(t, e, i, o) {
    const s = [];
    for (let d = 0; d < t.length; d += 4) {
      const c = t[d], h = t[d + 1], u = t[d + 2], p = t[d + 3], g = [c, h, u, p];
      s.push(g);
    }
    const n = this.tileToBBOX(e), a = this.getPixelPosition(i, o, n), l = a[0] + a[1] * this.tileSize;
    return s[l];
  }
  /**
   * Get the position in pixel from the coordinates
   * @param lng longitude
   * @param lat latitude
   * @param bbox bbox (minx, miny, maxx, maxy)
   * @returns The position in pixel
   */
  getPixelPosition(t, e, i) {
    const o = this.tileSize, s = this.tileSize, n = i[2] - i[0], a = i[3] - i[1], l = (t - i[0]) / n, d = (e - i[1]) / a, c = Math.floor(o * l), h = Math.floor(s * (1 - d));
    return [c, h];
  }
  /**
   * Get file extenstion name from the URL
   * @param url URL for tilesets
   * @returns file extenstion either png or webp
   */
  getUrlExtension(t) {
    let e = t.split(/[#?]/)[0].split(".").pop();
    return e && (e = e.trim()), e;
  }
  /**
   * Get the bbox of a tile
   * @param {Array<number>} tile
   * @returns {Array<number>} bbox
   * @example
   * var bbox = tileToBBOX([5, 10, 10])
   * //=bbox
   */
  tileToBBOX(t) {
    const e = this.tile2lon(t[0] + 1, t[2]), i = this.tile2lon(t[0], t[2]), o = this.tile2lat(t[1] + 1, t[2]), s = this.tile2lat(t[1], t[2]);
    return [i, o, e, s];
  }
  tile2lon(t, e) {
    return t / Math.pow(2, e) * 360 - 180;
  }
  tile2lat(t, e) {
    const i = 180 / Math.PI, o = Math.PI - 2 * Math.PI * t / Math.pow(2, e);
    return i * Math.atan(0.5 * (Math.exp(o) - Math.exp(-o)));
  }
}
class Do extends Ke {
  /**
   * Constructor
   * @param url URL for terrain RGB raster tilesets
   * @param tileSize size of tile. 256 or 512
   * @param tms whether it is Tile Map Service
   * @param minzoom minzoom for terrain RGB raster tilesets. default is 5
   * @param maxzoom maxzoom for terrain RGB raster tilesets. default is 15
   */
  constructor(t, e, i = 5, o = 15, s = !1) {
    super(t, e, i, o, s);
  }
  /**
   * Get an altitude calculated from terrain RGB information
   * @param lnglat coordinates
   * @param z zoom level
   * @returns an altitude calculated from terrain RGB information
   */
  async getElevation(t, e) {
    return await this.getValue(t, e);
  }
  /**
   * Formula for calculating an elevation from RGB
   * @param r red
   * @param g green
   * @param b blue
   * @returns an elevation calculated
   */
  calc(t, e, i) {
    return -1e4 + (t * 256 * 256 + e * 256 + i) * 0.1;
  }
}
class _o extends Ke {
  /**
   * Constructor
   * @param url URL for terrarium raster tilesets
   * @param tileSize size of tile. 256 or 512
   * @param tms whether it is Tile Map Service
   * @param minzoom minzoom for terrain RGB raster tilesets. default is 5
   * @param maxzoom maxzoom for terrain RGB raster tilesets. default is 15
   */
  constructor(t, e, i = 5, o = 15, s = !1) {
    super(t, e, i, o, s);
  }
  /**
   * Get an altitude calculated from terrain RGB information
   * @param lnglat coordinates
   * @param z zoom level
   * @returns an altitude calculated from terrain RGB information
   */
  async getElevation(t, e) {
    return await this.getValue(t, e);
  }
  /**
   * Formula for calculating an elevation from RGB
   * https://github.com/tilezen/joerd/blob/master/docs/formats.md#terrarium
   * @param r red
   * @param g green
   * @param b blue
   * @returns an elevation calculated
   */
  calc(t, e, i) {
    const o = t * 256 + e + i / 256 - 32768;
    return parseInt(o.toFixed(0));
  }
}
const ko = (r, t = 8) => {
  const [e, i] = r, o = Math.pow(10, t), s = Math.round(e * o) / o, n = Math.round(i * o) / o;
  return `${s},${n}`;
}, Se = async (r, t, e, i) => {
  const o = [], s = {
    enabled: !0,
    maxSize: 1e3,
    ttl: 36e5,
    // 1 hour
    precision: 6,
    ...e
  };
  let n;
  s.enabled && (n = i || new Ve(s.maxSize, s.ttl));
  let a, l = 15;
  if (t) {
    const d = t.url, c = t.encoding ?? "mapbox", h = t.tileSize ?? 512, u = t.minzoom ?? 5;
    l = t.maxzoom ?? 15;
    const p = t.tms ?? !1;
    a = c === "mapbox" ? new Do(d, h, u, l, p) : new _o(d, h, u, l, p);
  }
  for (const d of r)
    o.push(
      new Promise((c) => {
        d.geometry.type !== "Point" && c(d);
        const h = d.geometry.coordinates, u = ko(h, s.precision);
        if (n) {
          const p = n.get(u);
          if (p !== void 0) {
            isNaN(p) || (d.properties.elevation = p), c(d);
            return;
          }
        }
        a ? a.getElevation(d.geometry.coordinates, l).then((p) => {
          p != null && typeof p == "number" && (n && n.set(u, p), d.properties.elevation = p), c(d);
        }).catch(() => {
          n && n.has(u) && n.delete(u), c(d);
        }) : c(d);
      })
    );
  return await Promise.all(o);
}, Xo = (r, t = 9) => {
  function e(o) {
    return [Number(o[0].toFixed(t)), Number(o[1].toFixed(t))];
  }
  function i(o) {
    const s = o.type;
    let n = o.coordinates;
    switch (s) {
      case "Point":
        n = e(n);
        break;
      case "LineString":
      case "MultiPoint":
        n = n.map(e);
        break;
      case "Polygon":
      case "MultiLineString":
        n = n.map((a) => a.map(e));
        break;
      case "MultiPolygon":
        n = n.map(
          (a) => a.map((l) => l.map(e))
        );
        break;
    }
    return {
      ...o,
      coordinates: n
    };
  }
  return r.map((o) => ({
    ...o,
    geometry: i(o.geometry)
  }));
}, No = [
  { value: "time", label: "Time" },
  { value: "distance", label: "Distance" }
];
class To {
  url;
  /**
   * Constructor
   * @param url URL for terrain RGB raster tilesets
   */
  constructor(t) {
    this.url = t;
  }
  /**
   * Calculate isochrone by given parameters from Valhalla API
   * @param lon Longitude
   * @param lat Latitude
   * @param contourType the type of contour either time or distance
   * @param costingModel costing model either auto, bicycle or pedestrian
   * @param contours Optional. the list of contour. If skipped, default value is used.
   * @returns GeoJSON Feature Collection object
   */
  async calcIsochrone(t, e, i, o, s) {
    const n = JSON.parse(JSON.stringify(s));
    n.forEach((h) => {
      i === "time" ? delete h.distance : delete h.time;
    });
    const a = {
      locations: [{ lat: e, lon: t }],
      costing: o,
      contours: n.map((h) => (h.color = h.color.replace("#", ""), h)),
      polygons: !0
    }, l = `${this.url}/isochrone?json=${JSON.stringify(a)}`;
    return await (await fetch(l)).json();
  }
}
const Wt = [
  { value: "pedestrian", label: "Pedestrian" },
  { value: "bicycle", label: "Bicycle" },
  { value: "auto", label: "Car" }
], Wo = [
  { value: "kilometers", label: "km" },
  { value: "miles", label: "mile" }
];
class Bo {
  tripData = [];
  /**
   * get the raw trip data from the valhalla routing API.
   * @returns tripData
   */
  getTripData() {
    return this.tripData;
  }
  /**
   * Valhalla API URL
   */
  url;
  /**
   * Trip summary from routing API.
   */
  tripSummary;
  /**
   * Get the trip summary from the routing API.
   * @returns tripSummary
   */
  getTripSummary() {
    return this.tripSummary;
  }
  /**
   * Constructor
   * @param url URL for terrain RGB raster tilesets
   */
  constructor(t) {
    this.url = t;
  }
  /**
   * Clear the trip data and summary.
   */
  clearFeatures() {
    this.tripData = [], this.tripSummary = void 0;
  }
  /**
   * Calculate the route using Valhalla routing API.
   * @param tripData array of LngLat coordinates for the trip
   * @param costingModel means of transport for Valhalla routing API.
   * @param distanceUnit distance unit for Valhalla routing API.
   * @returns returns a feature with LineString geometry and point features for the trip data
   * @throws Error if the trip data is invalid or if the Valhalla API returns
   */
  async calcRoute(t, e, i) {
    if (this.tripData = t, !this.tripData || this.tripData && this.tripData.length < 2) {
      this.tripSummary = void 0;
      return;
    }
    const o = `${this.url}/route`, s = {
      locations: this.tripData.map((f) => ({ lon: f.lng, lat: f.lat })),
      costing: e,
      costing_options: { auto: { country_crossing_penalty: 2e3 } },
      units: i,
      id: "my_work_route"
    }, n = `${o}?json=${JSON.stringify(s)}`, l = await (await fetch(n)).json();
    if ("error" in l)
      throw this.tripData.pop(), new Error(`${l.status} (${l.status_code}): ${l.error} (${l.error_code})`);
    const d = l.trip.legs.map((f) => this.decodeShape(f.shape));
    let c = [];
    d.forEach((f) => {
      c = [...c, ...f];
    }), this.tripSummary = l.trip.summary, this.tripSummary.length = Number(this.tripSummary.length.toFixed(2)), this.tripSummary.time = Number((this.tripSummary.time / 60).toFixed());
    const h = [];
    let u = 0, p = 0;
    const g = [], y = this.geoPoint(this.tripData.map((f) => [f.lng, f.lat]));
    l.trip.legs.forEach((f, P) => {
      const I = this.decodeShape(f.shape);
      h.push(...I), u += Number(f.summary.length.toFixed(2)), p += Number((f.summary.time / 60).toFixed()), g.push(...f.maneuvers);
      const E = y.features[P + 1];
      E.properties = {
        ...E.properties,
        distance: u,
        distance_unit: i === "kilometers" ? "km" : "mi",
        time: p,
        maneuvers: f.maneuvers
      };
    });
    const m = Wt.find((f) => f.value === e)?.label, v = this.geoLineString(h, {
      costingModel: m,
      distance: u,
      distance_unit: i === "kilometers" ? "km" : "mi",
      time: p,
      maneuvers: g
    }), C = y.features[0];
    return C.properties = {
      ...C.properties,
      costingModel: m
    }, { feature: v, pointFeatures: y };
  }
  /**
   * create a GeoJSON Feature with LineString geometry.
   * @param coordinates array of coordinates
   * @param props properties to set for the feature
   * @returns GeoJSON Feature with LineString geometry
   */
  geoLineString(t = [], e = {}) {
    return {
      type: "Feature",
      properties: e,
      geometry: {
        type: "LineString",
        coordinates: t
      }
    };
  }
  /**
   * Create a GeoJSON FeatureCollection with Point features.
   * @param coordinates array of coordinates
   * @returns GeoJSON FeatureCollection
   */
  geoPoint(t = []) {
    return {
      type: "FeatureCollection",
      features: t.map((e, i) => {
        let o = (i + 1).toString();
        return i === 0 ? o = "Start" : i === t.length - 1 ? o = "Goal" : o = `No.${o}`, {
          type: "Feature",
          id: `node-${i}`,
          properties: {
            sequence: i,
            text: o
          },
          geometry: {
            type: "Point",
            coordinates: e
          }
        };
      })
    };
  }
  /**
   * decode a shape string from Valhalla routing API to convert it to an array of coordinates.
   * @param value encoded shape object from Valhalla routing API
   * @param precision coordinate precision, default is 6
   * @returns the list of coordinates as [lng, lat] pairs
   */
  decodeShape(t, e = 6) {
    let i = 0, o = 0, s = 0, n = [], a = 0, l = 0, d = null, c, h, u = Math.pow(10, e || 6);
    for (; i < t.length; ) {
      d = null, a = 0, l = 0;
      do
        d = t.charCodeAt(i++) - 63, l |= (d & 31) << a, a += 5;
      while (d >= 32);
      c = l & 1 ? ~(l >> 1) : l >> 1, a = l = 0;
      do
        d = t.charCodeAt(i++) - 63, l |= (d & 31) << a, a += 5;
      while (d >= 32);
      h = l & 1 ? ~(l >> 1) : l >> 1, o += c, s += h, n.push([s / u, o / u]);
    }
    return n;
  }
}
class Xe {
  controlContainer;
  map;
  modeButtons = {};
  _isExpanded = !1;
  _cssPrefix = "";
  /**
   * get the state of whether the control is expanded or collapsed
   */
  get isExpanded() {
    return this._isExpanded;
  }
  /**
   * CSS prefix for the control buttons.
   * Default is empty string
   */
  get cssPrefix() {
    return this._cssPrefix;
  }
  /**
   * set the state of the control either expanded or collapsed.
   * terradraw mode will be reset if the state is changed.
   * either `expanded` or `collapsed` event is dispatched when changed
   */
  set isExpanded(t) {
    this._isExpanded = t;
    const e = document.getElementsByClassName(
      `maplibregl-terradraw-${this.cssPrefix}add-control`
    );
    for (let o = 0; o < e.length; o++) {
      const s = e.item(o);
      s && (this.isExpanded ? s.classList.remove("hidden") : s.classList.add("hidden"));
    }
    const i = document.getElementsByClassName(
      `maplibregl-terradraw-${this.cssPrefix}render-button`
    );
    i && i.length > 0 && (this.isExpanded ? i.item(0)?.classList.add("enabled") : (i.item(0)?.classList.remove("enabled"), this.resetActiveMode())), this.toggleDeleteSelectionButton(), this.toggleButtonsWhenNoFeature(), this.isExpanded ? this.dispatchEvent("expanded") : this.dispatchEvent("collapsed");
  }
  terradraw;
  options = eo;
  events = {};
  defaultMode = "render";
  /**
   * Constructor
   * @param options Plugin control options
   */
  constructor(t) {
    this.modeButtons = {}, t && (this.options = Object.assign(this.options, t));
    const e = this.options.adapterOptions?.prefixId ?? "td";
    this.options.adapterOptions || (this.options.adapterOptions = {}), this.options.adapterOptions?.prefixId || (this.options.adapterOptions.prefixId = e);
  }
  /**
   * Get the default control position
   * @returns default control position. Default is 'top-right'
   */
  getDefaultPosition() {
    return "top-right";
  }
  /**
   * add the plugin control to maplibre
   * @param map Maplibre Map object
   * @returns HTML Element
   */
  onAdd(t) {
    if (this.options && this.options.modes && this.options.modes.length === 0)
      throw new Error("At least a mode must be enabled.");
    this.map = t;
    const e = io(), i = [];
    return this.options?.modes?.forEach((o) => {
      if (this.options.modeOptions && this.options.modeOptions[o]) {
        const s = this.options.modeOptions[o];
        if (o === "select") {
          const n = e[o];
          if (n) {
            const a = n.flags;
            Object.keys(a).forEach((l) => {
              s.flags[l] || (s.flags[l] = a[l]);
            });
          }
        }
        i.push(s);
      } else e[o] && i.push(e[o]);
    }), i.forEach((o) => {
      o.state !== "unregistered" && (o._state = "unregistered");
    }), this.options?.modes?.includes("render") || (i.push(
      new Q({
        modeName: "default",
        styles: {}
      })
    ), this.defaultMode = "default"), this.isExpanded = this.options.open === !0, this.terradraw = new Qi({
      adapter: new to({ map: t, ...this.options.adapterOptions }),
      modes: i
    }), this.map?.loaded() ? this.terradraw.start() : this.map?.once("load", () => {
      this.terradraw?.start();
    }), this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("maplibregl-ctrl"), this.controlContainer.classList.add("maplibregl-ctrl-group"), i.forEach((o) => {
      o.mode !== "default" && this.addTerradrawButton(o.mode);
    }), Object.values(this.modeButtons).forEach((o) => {
      this.controlContainer?.appendChild(o);
    }), this.terradraw?.on("change", this.toggleButtonsWhenNoFeature.bind(this)), this.toggleButtonsWhenNoFeature(), this.controlContainer;
  }
  /**
   * Remove the plugin control from maplibre
   * @returns void
   */
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || (this.deactivate(), this.modeButtons = {}, this.terradraw = void 0, this.map = void 0, this.controlContainer.parentNode.removeChild(this.controlContainer));
  }
  /**
   * Register an event for the plugin
   * @param event event type
   * @param callback
   */
  on(t, e) {
    this.events[t] ? this.events[t].push(e) : this.events[t] = [e];
  }
  /**
   * Unregister an event for the plugin
   * @param event event type
   * @param callback
   * @returns
   */
  off(t, e) {
    if (!this.events[t]) return;
    const i = this.events[t].findIndex((o) => o === e);
    i !== -1 && this.events[t].splice(i, 1);
  }
  /**
   * Dispatch an event. Pass the current snapshot of features and mode
   * @param event event type
   * @param args additional arguments
   */
  dispatchEvent(t, e) {
    this.events[t] && this.events[t].forEach((i) => {
      const s = this.terradraw?.getSnapshot()?.filter((n) => n.properties.selected === !0);
      i({
        feature: s,
        mode: this.terradraw?.getMode(),
        ...e
      });
    });
  }
  /**
   * Activate Terra Draw to start drawing
   */
  activate() {
    this.terradraw && (this.terradraw.enabled || this.terradraw.start());
  }
  /**
   * Deactivate Terra Draw to stop drawing
   */
  deactivate() {
    this.terradraw && this.terradraw.enabled && (this.resetActiveMode(), this.dispatchEvent("mode-changed"), this.terradraw.stop());
  }
  /**
   * Get the Terra Draw instance.
   * For the Terra Draw API, please refer to https://terradraw.io/#/api
   * @returns Terra Draw instance
   */
  getTerraDrawInstance() {
    return this.terradraw;
  }
  /**
   * Toggle editor control
   */
  toggleEditor() {
    this.terradraw && (this.isExpanded = !this.isExpanded);
  }
  /**
   * Reset active mode to back to render mode
   */
  resetActiveMode() {
    if (!this.terradraw) return;
    this.terradraw.enabled || this.terradraw.start();
    const t = document.getElementsByClassName(
      `maplibregl-terradraw-${this.cssPrefix}add-control`
    );
    for (let e = 0; e < t.length; e++) {
      const i = t.item(e);
      i && i.classList.remove("active");
    }
    this.terradraw?.setMode(this.defaultMode);
  }
  /**
   * Add Terra Draw drawing mode button
   * @param mode Terra Draw mode name
   */
  addTerradrawButton(t) {
    const e = document.createElement("button");
    e.type = "button", this.modeButtons[t] = e, t === "render" ? (e.classList.add(`maplibregl-terradraw-${this.cssPrefix}${t}-button`), this.isExpanded && e.classList.add("enabled"), e.type = "button", e.title = Ce("expand or collapse drawing tool"), e.addEventListener("click", this.toggleEditor.bind(this))) : (e.classList.add(`maplibregl-terradraw-${this.cssPrefix}add-control`), this.isExpanded || e.classList.add("hidden"), e.title = Ce(t.replace(/-/g, " ")), t === "delete" ? (e.classList.add(`maplibregl-terradraw-${this.cssPrefix}${t}-button`), e.addEventListener("click", () => {
      this.terradraw && this.terradraw.enabled && (this.terradraw.clear(), this.deactivate(), this.toggleDeleteSelectionButton(), this.toggleButtonsWhenNoFeature(), this.dispatchEvent("feature-deleted"));
    })) : t === "delete-selection" ? (e.classList.add(`maplibregl-terradraw-${this.cssPrefix}${t}-button`), e.classList.add("hidden-delete-selection"), e.addEventListener("click", () => {
      if (!this.terradraw || !this.terradraw.enabled) return;
      const o = (this.terradraw?.getSnapshot()).filter((s) => s.properties.selected === !0);
      if (o.length > 0) {
        const s = o.map((n) => n.id);
        this.terradraw.removeFeatures(s);
        for (const n of s)
          this.terradraw.deselectFeature(n);
        this.dispatchEvent("feature-deleted", { deletedIds: s });
      }
      this.toggleDeleteSelectionButton(), this.toggleButtonsWhenNoFeature();
    })) : t === "download" ? (e.classList.add(`maplibregl-terradraw-${this.cssPrefix}${t}-button`), e.addEventListener("click", this.handleDownload.bind(this))) : (e.classList.add(`maplibregl-terradraw-${this.cssPrefix}add-${t}-button`), e.addEventListener("click", () => {
      if (!this.terradraw) return;
      const i = e.classList.contains("active");
      this.activate(), this.resetActiveMode(), i || (this.terradraw.setMode(t), e.classList.add("active")), this.dispatchEvent("mode-changed"), this.toggleDeleteSelectionButton(), this.toggleButtonsWhenNoFeature();
    })));
  }
  /**
   * get GeoJSON features
   * @param onlySelected If true, returns only selected features. Default is false.
   * @returns FeatureCollection in GeoJSON format
   */
  getFeatures(t = !1) {
    if (!this.terradraw) return;
    const o = {
      type: "FeatureCollection",
      features: (this.terradraw?.getSnapshot()).filter((s) => s.properties.mode !== "select")
    };
    return t !== !0 || (o.features = o.features.filter((s) => s.properties.selected === !0)), o;
  }
  /**
   * clean maplibre style to filter only for terradraw related layers or without them.
   * If options are not set, returns original style given to the function.
   *
   * This can be useful incase users only want to get terradraw related layers or without it.
   *
   * Usage:
   * `cleanStyle(map.getStyle, { excludeTerraDrawLayers: true})`
   * `cleanStyle(map.getStyle, { onlyTerraDrawLayers: true})`
   *
   * @param style maplibre style spec
   * @param options.excludeTerraDrawLayers return maplibre style without terradraw layers and sources
   * @param options.onlyTerraDrawLayers return maplibre style with only terradraw layers and sources
   * @returns
   */
  cleanStyle(t, e) {
    return Vt(
      t,
      e,
      et,
      this.options.adapterOptions?.prefixId
    );
  }
  /**
   * Download button click event handler
   */
  handleDownload() {
    const t = this.getFeatures(!1), e = "data:application/json;charset=utf-8," + encodeURIComponent(JSON.stringify(t)), i = document.createElement("a");
    i.setAttribute("href", e), i.setAttribute("download", "data.geojson"), document.body.appendChild(i), i.click(), i.remove();
  }
  /**
   * Toggle the state of buttons when there is no features
   */
  toggleButtonsWhenNoFeature() {
    if (!this.controlContainer) return;
    const t = this.getFeatures(!1), e = !!(t && t.features.length > 0), i = [
      `maplibregl-terradraw-${this.cssPrefix}add-select-button`,
      `maplibregl-terradraw-${this.cssPrefix}download-button`,
      `maplibregl-terradraw-${this.cssPrefix}delete-button`
    ];
    for (const o of i) {
      const s = this.controlContainer.getElementsByClassName(o);
      for (let n = 0; n < s.length; n++) {
        const a = s.item(n);
        a && (a.disabled = !e);
      }
    }
  }
  /**
   * Toggle the state of delete-select button
   */
  toggleDeleteSelectionButton() {
    const t = this.terradraw?.enabled || !1, e = this.terradraw?.getMode(), i = this.getFeatures(!1), o = i && i.features.length > 0, s = o && t && e === "select", n = document.getElementsByClassName(
      `maplibregl-terradraw-${this.cssPrefix}delete-selection-button`
    );
    for (let a = 0; a < n.length; a++) {
      const l = n.item(a);
      l && (s ? l.classList.remove("hidden-delete-selection") : l.classList.add("hidden-delete-selection"));
    }
    if (!o) {
      const a = document.getElementsByClassName(
        `maplibregl-terradraw-${this.cssPrefix}add-select-button`
      );
      for (let l = 0; l < a.length; l++) {
        const d = a.item(l);
        d && d.classList.remove("active");
      }
    }
  }
  /**
   * Clear GeoJSON feature related to extended control such as measure and valhalla by TerraDraw feature ID
   * @param sourceIds the array of source ID to delete
   * @param ids the array of feature ID. Optional, if undefined, delete all labels for source
   * @returns void
   */
  clearExtendedFeatures(t, e = void 0) {
    if (this.map)
      for (const i of t) {
        const o = this.map.getStyle().sources[i];
        o && typeof o.data != "string" && o.data.type === "FeatureCollection" && (e === void 0 ? o.data.features = [] : o.data.features = o.data.features.filter((s) => s.properties?.originalId ? !e.includes(s.properties.originalId) : !e.includes(s.id)), this.map.getSource(i)?.setData(o.data));
      }
  }
}
function jo(r, t = {}) {
  let e = 0, i = 0, o = 0;
  return Ue(
    r,
    function(s) {
      e += s[0], i += s[1], o++;
    }
  ), ro([e / o, i / o], t.properties);
}
class Ho extends Xe {
  measureOptions;
  elevationCache;
  /**
   * The unit of distance can be degrees, radians, miles, or kilometers (default 'kilometers')
   * The measuring result will be recalculated once new value is set
   */
  get distanceUnit() {
    return this.measureOptions.distanceUnit ?? "kilometers";
  }
  set distanceUnit(t) {
    const e = this.measureOptions.distanceUnit === t;
    this.measureOptions.distanceUnit = t, e || this.recalc();
  }
  /**
   * The precision of distance value. It will be set different value when distance unit is changed. Using setter to override the value if you want.
   */
  get distancePrecision() {
    let t = 2;
    return this.measureOptions.distanceUnit === "degrees" && (t = 6), this.measureOptions.distancePrecision ?? t;
  }
  set distancePrecision(t) {
    const e = this.measureOptions.distancePrecision === t;
    this.measureOptions.distancePrecision = t, e || this.recalc();
  }
  /**
   * Default is `auto`. If `auto` is set, the unit is converted automatically based on the value.
   * If a specific unit is specified (e.g., 'km', 'm', 'cm', 'mi', 'ft', 'in'), the value is always returned in that unit.
   * This property is only effective when `distanceUnit` is set to 'kilometers' or 'miles'.
   * If `distanceUnit` is set to other values (e.g., 'degrees', 'radians'), it will be ignored, and `auto` will be applied.
   * If you need to force other unit type, please use DistanceUnit property.
   */
  get forceDistanceUnit() {
    return this.measureOptions.forceDistanceUnit ?? "auto";
  }
  set forceDistanceUnit(t) {
    const e = this.measureOptions.forceDistanceUnit === t;
    this.measureOptions.forceDistanceUnit = t, e || this.recalc();
  }
  /**
   * The unit of area can be metric (m², ha, km²) or imperial (yd², acre, mi²). Default is metric.
   * The measuring result will be recalculated once new value is set
   */
  get areaUnit() {
    return this.measureOptions.areaUnit ?? "metric";
  }
  set areaUnit(t) {
    const e = this.measureOptions.areaUnit === t;
    this.measureOptions.areaUnit = t, e || this.recalc();
  }
  /**
   * The precision of area value. Using setter to override the value if you want.
   */
  get areaPrecision() {
    return this.measureOptions.areaPrecision ?? 2;
  }
  set areaPrecision(t) {
    const e = this.measureOptions.areaPrecision === t;
    this.measureOptions.areaPrecision = t, e || this.recalc();
  }
  /**
   * Default is `auto`. If `auto` is set, unit is converted depending on the value and selection of area unit. If a specific unit is specified, it returns the value always the same. If a selected unit is not the same type of unit either metric of imperial, it will be ignored, and `auto` will be applied.
   */
  get forceAreaUnit() {
    return this.measureOptions.forceAreaUnit ?? "auto";
  }
  set forceAreaUnit(t) {
    const e = this.measureOptions.forceAreaUnit === t;
    this.measureOptions.forceAreaUnit = t, e || this.recalc();
  }
  /**
   * The flag of whether computing elevation. Default is false.
   * Using setter to override the value if you want.
   */
  get computeElevation() {
    return this.measureOptions.computeElevation ?? !1;
  }
  set computeElevation(t) {
    const e = this.measureOptions.computeElevation === t;
    this.measureOptions.computeElevation = t, e || this.recalc();
  }
  /**
   * Get/Set font glyph for measure control layers
   *
   * As default, this maesure control uses maplibre's default font glyphs(`Open Sans Regular,Arial Unicode MS Regular`) described at https://maplibre.org/maplibre-style-spec/layers/#text-font
   *
   * If you are using your own maplibre style or different map privider, you probably need to set the font glyphs to match your maplibre style.
   *
   * Font glyph availability depends on what types of glyphs are supported by your maplibre style (e.g., Carto, Openmap tiles, Protomap, Maptiler, etc.)
   * Please make sure the font glyphs are available in your maplibre style.
   *
   * Usage:
   *
   * ```js
   * const drawControl = new MaplibreMeasureControl()
   * drawControl.fontGlyphs = ['Open Sans Italic']
   * map.addControl(drawControl)
   * ```
   */
  get fontGlyphs() {
    const e = [
      this.measureOptions.pointLayerLabelSpec,
      this.measureOptions.lineLayerLabelSpec,
      this.measureOptions.polygonLayerSpec
    ][0];
    return e && e.layout && e.layout["text-font"];
  }
  set fontGlyphs(t) {
    const e = [
      this.measureOptions.pointLayerLabelSpec,
      this.measureOptions.lineLayerLabelSpec,
      this.measureOptions.polygonLayerSpec
    ];
    for (const i of e)
      i && i.layout && (i.layout["text-font"] = t), this.map && i && this.map.getLayer(i.id) && this.map.setLayoutProperty(i.id, "text-font", t);
  }
  /**
   * Constructor
   * @param options Plugin control options
   */
  constructor(t) {
    let e = {
      ...JSON.parse(JSON.stringify(lt)),
      modeOptions: { ...lt.modeOptions }
    };
    t && (e = Object.assign(e, t));
    const i = e.adapterOptions?.prefixId ?? "td-measure";
    e.adapterOptions && !e.adapterOptions?.prefixId && (e.adapterOptions.prefixId = i), e.pointLayerLabelSpec.id = e.pointLayerLabelSpec?.id.replace("{prefix}", i), e.pointLayerLabelSpec.source = e.pointLayerLabelSpec?.source.replace("{prefix}", i), e.routingLineLayerNodeSpec.id = e.routingLineLayerNodeSpec?.id.replace("{prefix}", i), e.routingLineLayerNodeSpec.source = e.routingLineLayerNodeSpec?.source.replace("{prefix}", i), e.lineLayerLabelSpec.id = e.lineLayerLabelSpec?.id.replace("{prefix}", i), e.lineLayerLabelSpec.source = e.lineLayerLabelSpec?.source.replace("{prefix}", i), e.polygonLayerSpec.id = e.polygonLayerSpec?.id.replace("{prefix}", i), e.polygonLayerSpec.source = e.polygonLayerSpec?.source.replace("{prefix}", i), super({
      modes: e.modes,
      open: e.open,
      modeOptions: e.modeOptions,
      adapterOptions: e.adapterOptions
    }), this._cssPrefix = "measure-", this.measureOptions = e, this.measureOptions.elevationCacheConfig && this.measureOptions.elevationCacheConfig?.enabled && (this.elevationCache = new Ve(
      this.measureOptions.elevationCacheConfig.maxSize,
      this.measureOptions.elevationCacheConfig.ttl
    ));
  }
  /**
   * add the plugin control to maplibre
   * @param map Maplibre Map object
   * @returns HTML Element
   */
  onAdd(t) {
    return this.controlContainer = super.onAdd(t), this.controlContainer;
  }
  /**
   * Remove the plugin control from maplibre
   * @returns void
   */
  onRemove() {
    this.unregisterMesureControl(), super.onRemove();
  }
  /**
   * Activate Terra Draw to start drawing
   */
  activate() {
    super.activate(), this.registerMesureControl();
  }
  /**
   * Recalculate area and distance in TerraDraw snapshot
   *
   * if you use `addFeatures` to restore GeoJSON features to TerraDraw, this recalc method needs to be called to re-measure again.
   *
   * For example, the below code is an example usage.
   * ```
   * drawInstance?.addFeatures(initData);
   * map?.once('idle', ()=>{
   *   drawControl.recalc()
   * })
   * ```
   */
  recalc() {
    const t = this.getTerraDrawInstance();
    if (t) {
      this.registerMesureControl();
      const e = t.getSnapshot();
      for (const i of e) {
        const o = i.id, s = i.geometry.type, n = i.properties.mode;
        ["linestring", "freehand-linestring"].includes(n) && s === "LineString" ? (this.measureLine(o), this.computeElevationByLineFeatureID(o)) : n === "point" && s === "Point" ? (this.measurePoint(o), this.computeElevationByPointFeatureID(o)) : !["point", "linestring", "freehand-linestring", "select", "render"].includes(n) && s === "Polygon" && this.measurePolygon(o);
      }
    }
  }
  /**
   * clean maplibre style to filter only for terradraw related layers or without them.
   * If options are not set, returns original style given to the function.
   *
   * This can be useful incase users only want to get terradraw related layers or without it.
   *
   * Usage:
   * `cleanStyle(map.getStyle, { excludeTerraDrawLayers: true})`
   * `cleanStyle(map.getStyle, { onlyTerraDrawLayers: true})`
   *
   * @param style maplibre style spec
   * @param options.excludeTerraDrawLayers return maplibre style without terradraw layers and sources
   * @param options.onlyTerraDrawLayers return maplibre style with only terradraw layers and sources
   * @returns
   */
  cleanStyle(t, e) {
    const i = et, o = this.measureOptions.polygonLayerSpec?.source;
    o && i.push(o);
    const s = this.measureOptions.lineLayerLabelSpec?.source;
    s && i.push(s);
    const n = this.measureOptions.pointLayerLabelSpec?.source;
    return n && i.push(n), Vt(
      t,
      e,
      i,
      this.measureOptions.adapterOptions?.prefixId
    );
  }
  /**
   * Register  measure control related maplibre sources and layers
   */
  registerMesureControl() {
    if (!this.map) return;
    const t = this.options.modes?.filter(
      (o) => ["linestring", "freehand-linestring"].includes(o)
    );
    this.options.modes?.find((o) => o === "point") && (this.map.getSource(
      this.measureOptions.pointLayerLabelSpec.source
    ) || this.map.addSource(
      this.measureOptions.pointLayerLabelSpec.source,
      {
        type: "geojson",
        data: { type: "FeatureCollection", features: [] }
      }
    ), this.map.getLayer(this.measureOptions.pointLayerLabelSpec.id) || this.map.addLayer(this.measureOptions.pointLayerLabelSpec)), t && t.length > 0 && (this.map.getSource(
      this.measureOptions.lineLayerLabelSpec.source
    ) || this.map.addSource(
      this.measureOptions.lineLayerLabelSpec.source,
      {
        type: "geojson",
        data: { type: "FeatureCollection", features: [] }
      }
    ), this.map.getLayer(
      this.measureOptions.routingLineLayerNodeSpec.id
    ) || this.map.addLayer(this.measureOptions.routingLineLayerNodeSpec), this.map.getLayer(this.measureOptions.lineLayerLabelSpec.id) || this.map.addLayer(this.measureOptions.lineLayerLabelSpec));
    const i = this.options.modes?.filter(
      (o) => [
        "polygon",
        "rectangle",
        "angled-rectangle",
        "circle",
        "sector",
        "sensor",
        "freehand"
      ].includes(o)
    );
    if (i && i.length > 0 && (this.map.getSource(
      this.measureOptions.polygonLayerSpec.source
    ) || this.map.addSource(
      this.measureOptions.polygonLayerSpec.source,
      {
        type: "geojson",
        data: { type: "FeatureCollection", features: [] }
      }
    ), this.map.getLayer(this.measureOptions.polygonLayerSpec.id) || this.map.addLayer(this.measureOptions.polygonLayerSpec)), t && t.length > 0 || i && i.length > 0) {
      const o = this.getTerraDrawInstance();
      o && (o.on("change", this.handleTerradrawFeatureChanged.bind(this)), o.on("finish", this.handleTerradrawFeatureReady.bind(this)), o.on("deselect", this.handleTerradrawDeselect.bind(this)), this.on("feature-deleted", this.onFeatureDeleted.bind(this)));
    }
  }
  /**
   * Handle deselect event of terradraw
   */
  handleTerradrawDeselect = () => {
    if (this.map && this.computeElevation === !0 && this.measureOptions.terrainSource !== void 0) {
      const t = this.getTerraDrawInstance();
      if (!t) return;
      const e = t.getSnapshot(), i = e.filter(
        (s) => s.properties.mode && ["linestring", "freehand-linestring"].includes(s.properties.mode) && s.geometry.type === "LineString"
      );
      if (i.length > 0)
        for (const s of i)
          this.computeElevationByLineFeatureID(s.id);
      const o = e.filter(
        (s) => s.properties.mode === "point" && s.geometry.type === "Point"
      );
      if (o.length > 0)
        for (const s of o)
          this.computeElevationByPointFeatureID(s.id);
    }
  };
  /**
   * Handle finish event of terradraw. It will be called after finishing adding a feature
   * @param id Feature ID
   */
  handleTerradrawFeatureReady = ze((t) => {
    this.map && (this.computeElevationByLineFeatureID(t), this.computeElevationByPointFeatureID(t));
  }, 300);
  /**
   * Handle change event of TerraDraw
   * @param ids Feature IDs
   */
  handleTerradrawFeatureChanged(t, e) {
    if (!this.map || e === "styling") return;
    const o = [
      this.measureOptions.pointLayerLabelSpec,
      this.measureOptions.lineLayerLabelSpec,
      this.measureOptions.routingLineLayerNodeSpec,
      this.measureOptions.polygonLayerSpec
    ].map((a) => a.source);
    if (e === "delete") {
      this.clearExtendedFeatures(o, t);
      return;
    }
    const s = this.getTerraDrawInstance();
    if (!s) return;
    const n = s.getSnapshot();
    for (const a of t) {
      const l = n.find((d) => d.id === a);
      if (l) {
        const d = l.geometry.type, c = l.properties.mode;
        ["linestring", "freehand-linestring"].includes(c) && d === "LineString" ? this.measureLine(a) : c === "point" && d === "Point" ? this.measurePoint(a) : !["point", "linestring", "freehand-linestring", "select", "render"].includes(c) && d === "Polygon" && this.measurePolygon(a);
      } else
        this.clearExtendedFeatures(o, [a]);
    }
  }
  /**
   * Unregister measure control related maplibre sources and layers
   */
  unregisterMesureControl() {
    this.off("feature-deleted", this.onFeatureDeleted.bind(this)), this.map && (this.map.getLayer(this.measureOptions.pointLayerLabelSpec.id) && this.map.removeLayer(
      this.measureOptions.pointLayerLabelSpec.id
    ), this.map.getLayer(this.measureOptions.lineLayerLabelSpec.id) && this.map.removeLayer(this.measureOptions.lineLayerLabelSpec.id), this.map.getLayer(
      this.measureOptions.routingLineLayerNodeSpec.id
    ) && this.map.removeLayer(
      this.measureOptions.routingLineLayerNodeSpec.id
    ), this.map.getLayer(this.measureOptions.polygonLayerSpec.id) && this.map.removeLayer(this.measureOptions.polygonLayerSpec.id), this.map.getSource(
      this.measureOptions.pointLayerLabelSpec.source
    ) && this.map.removeSource(
      this.measureOptions.pointLayerLabelSpec.source
    ), this.map.getSource(
      this.measureOptions.lineLayerLabelSpec.source
    ) && this.map.removeSource(
      this.measureOptions.lineLayerLabelSpec.source
    ), this.map.getSource(this.measureOptions.polygonLayerSpec.source) && this.map.removeSource(
      this.measureOptions.polygonLayerSpec.source
    ));
  }
  /**
   * Replace GeoJSON source with updated features for a given source ID
   * @param updatedFeatures Updated GeoJSON features
   * @param sourceId Source ID to update
   * @param type either 'linestring' or 'point'
   */
  replaceGeoJSONSource(t, e, i) {
    if (!this.map) return;
    const o = this.map.getStyle().sources[e];
    if (o && typeof o.data != "string" && o.data.type === "FeatureCollection") {
      const s = [];
      for (const a of t)
        (this.terradraw?.getSnapshotFeature(a.id) || this.terradraw?.getSnapshotFeature(a.properties.originalId)) && s.push(a);
      const n = s.map((a) => a.id);
      if (typeof o.data != "string" && o.data.type === "FeatureCollection") {
        i === "linestring" ? o.data.features = [
          ...o.data.features = o.data.features.filter(
            (l) => !(n.includes(l.properties?.originalId) && l.geometry.type === "Point")
          ),
          ...s
        ] : i === "point" && (o.data.features = [
          ...o.data.features = o.data.features.filter(
            (l) => !(n.includes(l.id) && l.geometry.type === "Point")
          ),
          ...s
        ]);
        const a = {};
        o.data.features.forEach((l) => {
          const d = l.id;
          a[d] ? !a[d].properties.elevation && l.properties?.elevation && (a[d] = l) : a[d] = l;
        }), o.data.features = Array.from(Object.values(a)), this.map.getSource(e)?.setData(o.data);
      }
    }
  }
  /**
   * Compute elevation by a LineString feature ID
   * @param id FeatureID
   */
  computeElevationByLineFeatureID = async (t) => {
    if (this.map && this.computeElevation === !0) {
      const e = this.map.getStyle().sources[this.measureOptions.lineLayerLabelSpec.source];
      if (e && typeof e.data != "string" && e.data.type === "FeatureCollection") {
        const i = e.data.features.filter(
          (o) => o.properties?.originalId === t && o.geometry.type === "Point"
        );
        if (i && i.length > 0) {
          const o = await Se(
            i,
            this.measureOptions.terrainSource,
            this.measureOptions.elevationCacheConfig,
            this.elevationCache
          );
          this.replaceGeoJSONSource(
            o,
            this.measureOptions.lineLayerLabelSpec.source,
            "linestring"
          );
        }
      }
    }
  };
  /**
   * Compute elevation by a Point feature ID
   * @param id FeatureID
   */
  computeElevationByPointFeatureID = async (t) => {
    if (this.map && this.computeElevation === !0) {
      const e = this.map.getStyle().sources[this.measureOptions.pointLayerLabelSpec.source];
      if (e && typeof e.data != "string" && e.data.type === "FeatureCollection") {
        const i = e.data.features.filter(
          (o) => o.id === t && o.geometry.type === "Point" && o.properties?.mode === "point"
        );
        if (i && i.length > 0) {
          const o = await Se(
            i,
            this.measureOptions.terrainSource,
            this.measureOptions.elevationCacheConfig,
            this.elevationCache
          );
          this.replaceGeoJSONSource(
            o,
            this.measureOptions.pointLayerLabelSpec.source,
            "point"
          );
        }
      }
    }
  };
  /**
   * measure polygon area for given feature ID
   * @param id terradraw feature id
   */
  measurePolygon(t) {
    if (!this.map) return;
    const e = this.getTerraDrawInstance();
    if (!e) return;
    let o = e.getSnapshot()?.find((s) => s.id === t && s.geometry.type === "Polygon");
    if (o) {
      const s = this.map.getStyle().sources[this.measureOptions.polygonLayerSpec.source];
      if (s) {
        typeof s.data != "string" && s.data.type === "FeatureCollection" && (s.data.features = s.data.features.filter(
          (a) => a.properties?.originalId !== t
        ));
        const n = JSON.parse(JSON.stringify(o));
        n.id = n.id + "-area-label", n.geometry = jo(o.geometry).geometry, n.properties.originalId = o.id, o = fe(o, this.areaUnit, this.areaPrecision, this.forceAreaUnit), n.properties.area = o.properties.area, n.properties.unit = o.properties.unit, typeof s.data != "string" && s.data.type === "FeatureCollection" && s.data.features.push(n), this.map.getSource(
          this.measureOptions.polygonLayerSpec.source
        )?.setData(s.data), this.map.moveLayer(this.measureOptions.polygonLayerSpec.id), this.map.getLayer(this.measureOptions.lineLayerLabelSpec.id) && this.map.moveLayer(
          this.measureOptions.lineLayerLabelSpec.id
        ), this.map.getLayer(
          this.measureOptions.routingLineLayerNodeSpec.id
        ) && this.map.moveLayer(
          this.measureOptions.routingLineLayerNodeSpec.id
        ), this.map.getLayer(
          this.measureOptions.pointLayerLabelSpec.id
        ) && this.map.moveLayer(
          this.measureOptions.pointLayerLabelSpec.id
        );
      }
    }
  }
  /**
   * measure line distance for given feature ID
   * @param id terradraw feature id
   */
  measureLine(t) {
    if (!this.map) return;
    const e = this.getTerraDrawInstance();
    if (!e) return;
    let o = e.getSnapshot()?.find((s) => s.id === t && s.geometry.type === "LineString");
    if (o) {
      const s = this.map.getStyle().sources[this.measureOptions.lineLayerLabelSpec.source];
      if (s) {
        typeof s.data != "string" && s.data.type === "FeatureCollection" && (s.data.features = s.data.features.filter(
          (a) => a.properties?.originalId !== t
        )), o = ve(
          o,
          this.distanceUnit,
          this.distancePrecision,
          this.forceDistanceUnit,
          this.map,
          this.computeElevation,
          this.measureOptions.terrainSource
        );
        const n = o.properties.segments;
        for (let a = 0; a < n.length; a++) {
          const l = n[a], d = l.geometry.coordinates, c = d[0], h = d[1];
          if (a === 0) {
            const p = JSON.parse(JSON.stringify(l));
            p.id = `${l.id}-node-${a}`, p.geometry = {
              type: "Point",
              coordinates: c
            }, p.properties.distance = 0, p.properties.total = 0, l.properties.elevation_start && (p.properties.elevation = l.properties.elevation_start), typeof s.data != "string" && s.data.type === "FeatureCollection" && s.data.features.push(p);
          }
          const u = JSON.parse(JSON.stringify(l));
          u.id = `${l.id}-node-${a + 1}`, u.geometry = {
            type: "Point",
            coordinates: h
          }, l.properties.elevation_end && (u.properties.elevation = l.properties.elevation_end), typeof s.data != "string" && s.data.type === "FeatureCollection" && s.data.features.push(u);
        }
        this.map.getSource(
          this.measureOptions.lineLayerLabelSpec.source
        )?.setData(s.data), this.map.getLayer(this.measureOptions.polygonLayerSpec.id) && this.map.moveLayer(this.measureOptions.polygonLayerSpec.id), this.map.moveLayer(this.measureOptions.lineLayerLabelSpec.id), this.map.moveLayer(
          this.measureOptions.routingLineLayerNodeSpec.id
        ), this.map.getLayer(
          this.measureOptions.pointLayerLabelSpec.id
        ) && this.map.moveLayer(
          this.measureOptions.pointLayerLabelSpec.id
        );
      }
    }
  }
  /**
   * measure point elevation for given feature ID
   * @param id terradraw feature id
   */
  measurePoint(t) {
    if (!this.map) return;
    const e = this.getTerraDrawInstance();
    if (!e) return;
    let o = e.getSnapshot()?.find((s) => s.id === t && s.geometry.type === "Point");
    if (o) {
      const s = this.map.getStyle().sources[this.measureOptions.pointLayerLabelSpec.source];
      s && (typeof s.data != "string" && s.data.type === "FeatureCollection" && (s.data.features = s.data.features.filter((n) => n.id !== t)), o = Pe(
        o,
        this.map,
        this.computeElevation,
        this.measureOptions.terrainSource
      ), this.computeElevation === !0 && typeof s.data != "string" && s.data.type === "FeatureCollection" && s.data.features.push(o), this.map.getSource(
        this.measureOptions.pointLayerLabelSpec.source
      )?.setData(s.data), this.map.getLayer(this.measureOptions.polygonLayerSpec.id) && this.map.moveLayer(this.measureOptions.polygonLayerSpec.id), this.map.getLayer(this.measureOptions.lineLayerLabelSpec.id) && (this.map.moveLayer(
        this.measureOptions.lineLayerLabelSpec.id
      ), this.map.moveLayer(
        this.measureOptions.routingLineLayerNodeSpec.id
      )), this.map.moveLayer(
        this.measureOptions.pointLayerLabelSpec.id
      ));
    }
  }
  /**
   * Event definition when feature is deleted by terradraw
   */
  onFeatureDeleted(t) {
    if (!this.map) return;
    if (this.getTerraDrawInstance()) {
      let i = [];
      typeof t == "object" && t !== null && "deletedIds" in t && (i = t.deletedIds);
      const s = [
        this.measureOptions.pointLayerLabelSpec,
        this.measureOptions.lineLayerLabelSpec,
        this.measureOptions.routingLineLayerNodeSpec,
        this.measureOptions.polygonLayerSpec
      ].map((n) => n.source);
      i && i.length > 0 ? this.clearExtendedFeatures(s, i) : this.clearExtendedFeatures(s, void 0);
    }
  }
  /**
   * get GeoJSON features
   * @param onlySelected If true, returns only selected features. Default is false.
   * @returns FeatureCollection in GeoJSON format
   */
  getFeatures(t = !1) {
    const e = super.getFeatures(t);
    if (!e || !this.terradraw) return e;
    for (let i = 0; i < e.features.length; i++) {
      const o = e.features[i];
      if (!this.map || !this.map.loaded()) continue;
      const s = o.geometry.type;
      s === "LineString" ? e.features[i] = ve(
        o,
        this.distanceUnit,
        this.distancePrecision,
        this.forceDistanceUnit,
        this.map,
        this.computeElevation,
        this.measureOptions.terrainSource
      ) : s === "Polygon" ? e.features[i] = fe(o, this.areaUnit, this.areaPrecision, this.forceAreaUnit) : s === "Point" && (e.features[i] = Pe(
        o,
        this.map,
        this.computeElevation,
        this.measureOptions.terrainSource
      ));
    }
    return e;
  }
}
class Jo extends Xe {
  controlOptions;
  valhallaOptions;
  _modalDialog;
  /**
   * Get the URL of Valhalla API
   */
  get valhallaUrl() {
    return this.valhallaOptions.url;
  }
  /**
   * Set the URL of Valhalla API
   * @param value URL of Valhalla API
   */
  set valhallaUrl(t) {
    this.valhallaOptions.url = t;
  }
  /**
   * Get the means of transport for Valhalla routing api
   * @returns costingModelType
   * @example 'pedestrian', 'bicycle', 'auto'
   */
  get routingCostingModel() {
    return this.valhallaOptions.routingOptions?.costingModel;
  }
  /**
   * Set the means of transport for Valhalla routing api
   * @param value costingModelType
   * @example 'pedestrian', 'bicycle', 'auto'
   */
  set routingCostingModel(t) {
    this.valhallaOptions.routingOptions || (this.valhallaOptions.routingOptions = {}), this.valhallaOptions.routingOptions.costingModel = t, this.createSettingsDialog();
  }
  /**
   * Get the distance unit for Valhalla routing api
   * @returns routingDistanceUnitType
   * @example 'kilometers', 'miles'
   */
  get routingDistanceUnit() {
    return this.valhallaOptions.routingOptions?.distanceUnit;
  }
  /**
   * Set the distance unit for Valhalla routing api
   * @param value routingDistanceUnitType
   * @example 'kilometers', 'miles'
   */
  set routingDistanceUnit(t) {
    this.valhallaOptions.routingOptions || (this.valhallaOptions.routingOptions = {}), this.valhallaOptions.routingOptions.distanceUnit = t, this.createSettingsDialog();
  }
  /**
   * Get the contour type for Valhalla isochrone api
   * @returns ContourType
   * @example 'time', 'distance'
   */
  get isochroneContourType() {
    return this.valhallaOptions.isochroneOptions?.contourType;
  }
  /**
   * Set the contour type for Valhalla isochrone api
   * @param value ContourType
   * @example 'time', 'distance'
   */
  set isochroneContourType(t) {
    this.valhallaOptions.isochroneOptions || (this.valhallaOptions.isochroneOptions = {}), this.valhallaOptions.isochroneOptions.contourType = t, this.createSettingsDialog();
  }
  /**
   * Get the means of transport for Valhalla isochrone api
   * @returns isochroneCostingModelType
   * @example 'pedestrian', 'bicycle', 'auto'
   */
  get isochroneCostingModel() {
    return this.valhallaOptions.isochroneOptions?.costingModel;
  }
  /**
   * Set the means of transport for Valhalla isochrone api
   * @param value isochroneCostingModelType
   * @example 'pedestrian', 'bicycle', 'auto'
   */
  set isochroneCostingModel(t) {
    this.valhallaOptions.isochroneOptions || (this.valhallaOptions.isochroneOptions = {}), this.valhallaOptions.isochroneOptions.costingModel = t, this.createSettingsDialog();
  }
  /**
   * Get the list of contours for Valhalla isochrone api
   * @returns Contour[]
   */
  get isochroneContours() {
    return this.valhallaOptions.isochroneOptions?.contours;
  }
  /**
   * Set the list of contours for Valhalla isochrone api
   * @param value Contour[]
   */
  set isochroneContours(t) {
    this.valhallaOptions.isochroneOptions || (this.valhallaOptions.isochroneOptions = {}), this.valhallaOptions.isochroneOptions.contours = t, this.createSettingsDialog();
  }
  /**
   * Get/Set font glyph for valhalla control layers
   *
   * As default, this maesure control uses maplibre's default font glyphs(`Open Sans Regular,Arial Unicode MS Regular`) described at https://maplibre.org/maplibre-style-spec/layers/#text-font
   *
   * If you are using your own maplibre style or different map privider, you probably need to set the font glyphs to match your maplibre style.
   *
   * Font glyph availability depends on what types of glyphs are supported by your maplibre style (e.g., Carto, Openmap tiles, Protomap, Maptiler, etc.)
   * Please make sure the font glyphs are available in your maplibre style.
   *
   * Usage:
   *
   * ```js
   * const drawControl = new MaplibreValhallaControl()
   * drawControl.fontGlyphs = ['Open Sans Italic']
   * map.addControl(drawControl)
   * ```
   */
  get fontGlyphs() {
    const e = [this.controlOptions.routingLineLayerNodeLabelSpec][0];
    return e && e.layout && e.layout["text-font"];
  }
  set fontGlyphs(t) {
    const e = [this.controlOptions.routingLineLayerNodeLabelSpec];
    for (const i of e)
      i && i.layout && (i.layout["text-font"] = t), this.map && i && this.map.getLayer(i.id) && this.map.setLayoutProperty(i.id, "text-font", t);
  }
  /**
   * Get the dialog instance for settings
   */
  get settingDialog() {
    return this._modalDialog;
  }
  /**
   * Set the dialog instance for settings
   */
  set settingDialog(t) {
    this._modalDialog = t;
  }
  /**
   * Constructor
   * @param options Plugin control options
   */
  constructor(t) {
    let e = {
      ...JSON.parse(JSON.stringify(z)),
      modeOptions: { ...z.modeOptions }
    };
    t && (e = Object.assign(e, t), e.valhallaOptions = Object.assign(
      JSON.parse(JSON.stringify(z.valhallaOptions)),
      e.valhallaOptions
    )), e.adapterOptions || (e.adapterOptions = {}), e.adapterOptions.prefixId = e.adapterOptions?.prefixId ?? "td-valhalla";
    const i = e.adapterOptions?.prefixId ?? "td-valhalla";
    if (e.routingLineLayerNodeLabelSpec.id = e.routingLineLayerNodeLabelSpec?.id.replace("{prefix}", i), e.routingLineLayerNodeLabelSpec.source = e.routingLineLayerNodeLabelSpec?.source.replace("{prefix}", i), e.routingLineLayerNodeSpec.id = e.routingLineLayerNodeSpec?.id.replace("{prefix}", i), e.routingLineLayerNodeSpec.source = e.routingLineLayerNodeSpec?.source.replace("{prefix}", i), e.isochronePolygonLayerSpec.id = e.isochronePolygonLayerSpec?.id.replace("{prefix}", i), e.isochronePolygonLayerSpec.source = e.isochronePolygonLayerSpec?.source.replace("{prefix}", i), e.isochroneLineLayerSpec.id = e.isochroneLineLayerSpec?.id.replace("{prefix}", i), e.isochroneLineLayerSpec.source = e.isochroneLineLayerSpec?.source.replace("{prefix}", i), e.isochroneLabelLayerSpec.id = e.isochroneLabelLayerSpec?.id.replace("{prefix}", i), e.isochroneLabelLayerSpec.source = e.isochroneLabelLayerSpec?.source.replace("{prefix}", i), super({
      modes: e.modes,
      open: e.open,
      modeOptions: e.modeOptions,
      adapterOptions: e.adapterOptions
    }), this.valhallaOptions = e.valhallaOptions, !this.valhallaOptions.url)
      throw new Error(
        "Valhalla URL is required for this control. Please set valhallaOptions.url in options."
      );
    this._cssPrefix = "valhalla-", this.controlOptions = e;
  }
  /**
   * add the plugin control to maplibre
   * @param map Maplibre Map object
   * @returns HTML Element
   */
  onAdd(t) {
    return this.controlContainer = super.onAdd(t), this.createSettingsDialog(), this.controlContainer;
  }
  /**
   * Remove the plugin control from maplibre
   * @returns void
   */
  onRemove() {
    this.unregisterValhallaControl(), super.onRemove();
  }
  /**
   * Activate Terra Draw to start drawing
   */
  activate() {
    super.activate(), this.registerValhallaControl();
  }
  /**
   * clean maplibre style to filter only for terradraw related layers or without them.
   * If options are not set, returns original style given to the function.
   *
   * This can be useful incase users only want to get terradraw related layers or without it.
   *
   * Usage:
   * `cleanStyle(map.getStyle, { excludeTerraDrawLayers: true})`
   * `cleanStyle(map.getStyle, { onlyTerraDrawLayers: true})`
   *
   * @param style maplibre style spec
   * @param options.excludeTerraDrawLayers return maplibre style without terradraw layers and sources
   * @param options.onlyTerraDrawLayers return maplibre style with only terradraw layers and sources
   * @returns
   */
  cleanStyle(t, e) {
    const i = et, o = this.controlOptions.routingLineLayerNodeSpec?.source;
    o && i.push(o);
    const s = this.controlOptions.isochronePolygonLayerSpec?.source;
    return s && i.push(s), Vt(t, e, i, this.options.adapterOptions?.prefixId);
  }
  /**
   * Create the settings dialog for Valhalla control
   */
  createSettingsDialog() {
    this.settingDialog = new mo(
      `maplibregl-terradraw-${this.cssPrefix}settings-dialog`,
      "Settings"
    ), this.settingDialog.create(
      this.map?.getContainer().parentElement,
      (t) => {
        const e = document.createElement("div");
        e.classList.add("tab-container");
        const i = document.createElement("div");
        i.classList.add("tab-buttons");
        const o = document.createElement("button");
        o.type = "button", o.classList.add("tab-button", "active"), o.textContent = "Routing", o.addEventListener("click", (d) => {
          d.stopPropagation(), this.switchTab("routing", i, n);
        }), i.appendChild(o);
        const s = document.createElement("button");
        s.type = "button", s.classList.add("tab-button"), s.textContent = "Isochrone", s.addEventListener("click", (d) => {
          d.stopPropagation(), this.switchTab("isochrone", i, n);
        }), i.appendChild(s), e.appendChild(i);
        const n = document.createElement("div");
        n.classList.add("tab-contents");
        const a = this.createRoutingContent();
        a.classList.add("tab-content", "active"), a.setAttribute("data-tab", "routing"), n.appendChild(a);
        const l = this.createIsochroneContent();
        return l.classList.add("tab-content"), l.setAttribute("data-tab", "isochrone"), n.appendChild(l), e.appendChild(n), t.appendChild(e), t;
      }
    );
  }
  /**
   * Switch between tabs
   */
  switchTab(t, e, i) {
    e.querySelectorAll(".tab-button").forEach((o) => o.classList.remove("active")), e.querySelector(`[data-tab="${t}"], :nth-child(${t === "routing" ? "1" : "2"})`)?.classList.add("active"), i.querySelectorAll(".tab-content").forEach((o) => o.classList.remove("active")), i.querySelector(`[data-tab="${t}"]`)?.classList.add("active");
  }
  /**
   * Create routing tab content
   */
  createRoutingContent() {
    const t = document.createElement("div"), e = document.createElement("div");
    e.classList.add("setting-section");
    const i = document.createElement("label");
    i.textContent = "Means of Transport", i.classList.add("setting-label"), e.appendChild(i), e.appendChild(
      this.settingDialog.createSegmentButtons(
        Wt,
        this.routingCostingModel,
        (n) => {
          this.valhallaOptions.routingOptions || (this.valhallaOptions.routingOptions = {}), this.valhallaOptions.routingOptions.costingModel = n, this.dispatchEvent("setting-changed");
        }
      )
    ), t.appendChild(e);
    const o = document.createElement("div");
    o.classList.add("setting-section");
    const s = document.createElement("label");
    return s.textContent = "Distance Unit", s.classList.add("setting-label"), o.appendChild(s), o.appendChild(
      this.settingDialog.createSegmentButtons(
        Wo,
        this.routingDistanceUnit,
        (n) => {
          this.valhallaOptions.routingOptions || (this.valhallaOptions.routingOptions = {}), this.valhallaOptions.routingOptions.distanceUnit = n, this.dispatchEvent("setting-changed");
        }
      )
    ), t.appendChild(o), t;
  }
  /**
   * Create isochrone tab content
   */
  createIsochroneContent() {
    const t = document.createElement("div"), e = document.createElement("div");
    e.classList.add("setting-section");
    const i = document.createElement("label");
    i.textContent = "Contour Type", i.classList.add("setting-label"), e.appendChild(i), e.appendChild(
      this.settingDialog.createSegmentButtons(
        No,
        this.controlOptions.valhallaOptions?.isochroneOptions?.contourType || "time",
        (d) => {
          this.valhallaOptions.isochroneOptions || (this.valhallaOptions.isochroneOptions = {}), this.valhallaOptions.isochroneOptions.contourType = d, this.dispatchEvent("setting-changed");
        }
      )
    ), t.appendChild(e);
    const o = document.createElement("div");
    o.classList.add("setting-section");
    const s = document.createElement("label");
    s.textContent = "Means of Transport", s.classList.add("setting-label"), o.appendChild(s), o.appendChild(
      this.settingDialog.createSegmentButtons(
        Wt,
        this.controlOptions.valhallaOptions?.isochroneOptions?.costingModel || "auto",
        (d) => {
          this.valhallaOptions.isochroneOptions || (this.valhallaOptions.isochroneOptions = {}), this.valhallaOptions.isochroneOptions.costingModel = d, this.dispatchEvent("setting-changed");
        }
      )
    ), t.appendChild(o);
    const n = document.createElement("div");
    n.classList.add("setting-section");
    const a = document.createElement("label");
    a.textContent = "Contours", a.classList.add("setting-label"), n.appendChild(a);
    const l = this.createContoursTable();
    return n.appendChild(l), t.appendChild(n), t;
  }
  /**
   * Create contours table
   */
  createContoursTable() {
    const t = document.createElement("div");
    t.classList.add("contours-table");
    const e = document.createElement("table");
    e.classList.add("contours-table-element");
    const i = document.createElement("thead"), o = document.createElement("tr"), s = document.createElement("th");
    s.textContent = "Color", o.appendChild(s);
    const n = document.createElement("th");
    n.textContent = "Time (min)", o.appendChild(n);
    const a = document.createElement("th");
    a.textContent = "Distance (km)", o.appendChild(a);
    const l = document.createElement("th");
    o.appendChild(l), i.appendChild(o), e.appendChild(i);
    const d = document.createElement("tbody"), c = this.controlOptions.valhallaOptions?.isochroneOptions?.contours;
    c.forEach((u, p) => {
      const g = this.createContourRow(u, p);
      d.appendChild(g);
    }), e.appendChild(d), t.appendChild(e);
    const h = document.createElement("button");
    return h.type = "button", h.classList.add("add-row-button"), h.textContent = "Add Contour", h.hidden = c.length >= 4, h.addEventListener("click", (u) => {
      u.stopPropagation();
      const p = this.valhallaOptions.isochroneOptions?.contours, g = JSON.parse(JSON.stringify(p[p.length - 1])), y = d.children.length, m = this.createContourRow(g, y);
      d.appendChild(m), p.push(g), this.updateAddRowButtonState(), this.dispatchEvent("setting-changed");
    }), t.appendChild(h), t;
  }
  /**
   * Create a single contour row
   */
  createContourRow(t, e) {
    const i = document.createElement("tr");
    i.setAttribute("data-index", e.toString());
    const o = document.createElement("td"), s = document.createElement("input");
    s.type = "color", s.value = t.color, s.classList.add("color-picker"), s.addEventListener("change", (h) => {
      h.stopPropagation(), this.valhallaOptions.isochroneOptions?.contours && (this.valhallaOptions.isochroneOptions.contours[e].color = h.target.value, this.dispatchEvent("setting-changed"));
    }), o.appendChild(s), i.appendChild(o);
    const n = document.createElement("td"), a = document.createElement("input");
    a.type = "number", a.value = t.time.toString(), a.min = "1", a.classList.add("number-input"), a.addEventListener("change", (h) => {
      h.stopPropagation(), this.valhallaOptions.isochroneOptions?.contours && (this.valhallaOptions.isochroneOptions.contours[e].time = parseFloat(
        h.target.value
      ), this.dispatchEvent("setting-changed"));
    }), n.appendChild(a), i.appendChild(n);
    const l = document.createElement("td"), d = document.createElement("input");
    d.type = "number", d.value = t.distance.toString(), d.min = "0.1", d.step = "0.1", d.classList.add("number-input"), d.addEventListener("change", (h) => {
      h.stopPropagation(), this.valhallaOptions.isochroneOptions?.contours && (this.valhallaOptions.isochroneOptions.contours[e].distance = parseFloat(
        h.target.value
      ), this.dispatchEvent("setting-changed"));
    }), l.appendChild(d), i.appendChild(l);
    const c = document.createElement("td");
    if (e > 0) {
      const h = document.createElement("button");
      h.type = "button", h.textContent = "×", h.classList.add("delete-button"), h.addEventListener("click", (u) => {
        u.stopPropagation();
        const p = parseInt(i.getAttribute("data-index") || "0");
        i.remove(), this.valhallaOptions.isochroneOptions?.contours && this.valhallaOptions.isochroneOptions.contours.splice(p, 1);
        const g = i.parentElement;
        g && Array.from(g.children).forEach((y, m) => {
          y.setAttribute("data-index", m.toString());
        }), this.updateAddRowButtonState(), this.dispatchEvent("setting-changed");
      }), c.appendChild(h);
    }
    return i.appendChild(c), i;
  }
  updateAddRowButtonState = () => {
    const t = document.getElementsByClassName("add-row-button");
    if (t && t.length > 0) {
      const e = t.item(0);
      if (e) {
        const i = this.controlOptions.valhallaOptions?.isochroneOptions?.contours;
        e.hidden = i.length >= 4;
      }
    }
  };
  /**
   * Add Terra Draw drawing mode button
   * @param mode Terra Draw mode name
   */
  addTerradrawButton(t) {
    const e = document.createElement("button");
    e.type = "button", this.modeButtons[t] = e, t === "settings" ? (e.classList.add(`maplibregl-terradraw-${this.cssPrefix}add-control`), e.classList.add(`maplibregl-terradraw-${this.cssPrefix}${t}-button`), e.addEventListener("click", this.handleSettingDialog.bind(this))) : super.addTerradrawButton(t);
  }
  /**
   * Handle the click event of the settings button
   */
  handleSettingDialog() {
    this.settingDialog?.open();
  }
  /**
   * Register  measure control related maplibre sources and layers
   */
  registerValhallaControl() {
    if (!this.map) return;
    const t = this.options.modes?.filter((i) => ["linestring"].includes(i));
    t && t.length > 0 && (this.map.getSource(
      this.controlOptions.routingLineLayerNodeSpec.source
    ) || this.map.addSource(
      this.controlOptions.routingLineLayerNodeSpec.source,
      {
        type: "geojson",
        data: { type: "FeatureCollection", features: [] }
      }
    ), this.map.getLayer(
      this.controlOptions.routingLineLayerNodeSpec.id
    ) || this.map.addLayer(this.controlOptions.routingLineLayerNodeSpec), this.map.getLayer(
      this.controlOptions.routingLineLayerNodeLabelSpec.id
    ) || this.map.addLayer(
      this.controlOptions.routingLineLayerNodeLabelSpec
    ));
    const e = this.options.modes?.filter((i) => ["point"].includes(i));
    if (e && e.length > 0 && (this.map.getSource(
      this.controlOptions.isochronePolygonLayerSpec.source
    ) || this.map.addSource(
      this.controlOptions.isochronePolygonLayerSpec.source,
      {
        type: "geojson",
        data: { type: "FeatureCollection", features: [] }
      }
    ), this.map.getLayer(
      this.controlOptions.isochronePolygonLayerSpec.id
    ) || this.map.addLayer(this.controlOptions.isochronePolygonLayerSpec), this.map.getLayer(
      this.controlOptions.isochroneLineLayerSpec.id
    ) || this.map.addLayer(this.controlOptions.isochroneLineLayerSpec), this.map.getLayer(
      this.controlOptions.isochroneLabelLayerSpec.id
    ) || this.map.addLayer(this.controlOptions.isochroneLabelLayerSpec)), (t && t.length > 0 || e && e.length > 0) && this.map) {
      const i = this.getTerraDrawInstance();
      i && (i.on("finish", this.handleTerradrawFeatureReady.bind(this)), this.on("feature-deleted", this.onFeatureDeleted.bind(this)));
    }
  }
  /**
   * Register  measure control related maplibre sources and layers
   */
  unregisterValhallaControl() {
    if (this.off("feature-deleted", this.onFeatureDeleted.bind(this)), !this.map) return;
    this.map.getLayer(
      this.controlOptions.routingLineLayerNodeSpec.id
    ) && this.map.removeLayer(
      this.controlOptions.routingLineLayerNodeSpec.id
    ), this.map.getLayer(
      this.controlOptions.routingLineLayerNodeLabelSpec.id
    ) && this.map.removeLayer(
      this.controlOptions.routingLineLayerNodeLabelSpec.id
    ), this.map.getSource(
      this.controlOptions.routingLineLayerNodeSpec.source
    ) && this.map.removeSource(
      this.controlOptions.routingLineLayerNodeSpec.source
    ), this.map.getLayer(
      this.controlOptions.isochronePolygonLayerSpec.id
    ) && this.map.removeLayer(
      this.controlOptions.isochronePolygonLayerSpec.id
    ), this.map.getLayer(this.controlOptions.isochroneLineLayerSpec.id) && this.map.removeLayer(
      this.controlOptions.isochroneLineLayerSpec.id
    ), this.map.getLayer(
      this.controlOptions.isochroneLabelLayerSpec.id
    ) && this.map.removeLayer(
      this.controlOptions.isochroneLabelLayerSpec.id
    ), this.map.getSource(
      this.controlOptions.isochronePolygonLayerSpec.source
    ) && this.map.removeSource(
      this.controlOptions.isochronePolygonLayerSpec.source
    );
    const t = this.getTerraDrawInstance();
    t && t.off("finish", this.handleTerradrawFeatureReady.bind(this));
  }
  /**
   * Handle finish event of terradraw. It will be called after finishing adding a feature
   * @param id Feature ID
   */
  handleTerradrawFeatureReady = ze((t) => {
    this.map && (this.computeRouteByLineFeatureID(t), this.computeIsochroneByPointFeatureID(t));
  }, 300);
  computeIsochroneByPointFeatureID = async (t) => {
    if (!this.map || !this.valhallaOptions.url) return;
    const e = this.terradraw?.getSnapshotFeature(t);
    if (!e || e && e.geometry.type !== "Point") return;
    const i = e.geometry.coordinates, n = (await new To(this.valhallaUrl).calcIsochrone(
      i[0],
      i[1],
      this.isochroneContourType,
      this.isochroneCostingModel,
      this.isochroneContours
    )).features.map((d) => (d.id = `${t}-${d.properties.contour}`, d.properties.originalId = t, d)), a = {
      contourType: this.isochroneContourType,
      costingModel: this.isochroneCostingModel,
      result: n
    };
    e.properties = {
      ...e.properties,
      ...a
    }, this.terradraw?.updateFeatureProperties(t, a);
    const l = this.map.getStyle().sources[this.controlOptions.isochronePolygonLayerSpec.source];
    l && (typeof l.data != "string" && l.data.type === "FeatureCollection" && (l.data.features = l.data.features.filter(
      (d) => d.properties?.originalId !== t
    )), typeof l.data != "string" && l.data.type === "FeatureCollection" && l.data.features.push(...n), this.map.getSource(
      this.controlOptions.isochronePolygonLayerSpec.source
    )?.setData(l.data), this.map.moveLayer(
      this.controlOptions.isochronePolygonLayerSpec.id
    ), this.map.moveLayer(this.controlOptions.isochroneLineLayerSpec.id), this.map.moveLayer(
      this.controlOptions.isochroneLabelLayerSpec.id
    ));
  };
  /**
   * Compute elevation by a LineString feature ID
   * @param id FeatureID
   */
  computeRouteByLineFeatureID = async (t) => {
    if (!this.map || !this.valhallaOptions.url) return;
    const e = this.terradraw?.getSnapshotFeature(t);
    if (!e || e && e.geometry.type !== "LineString") return;
    const i = new Bo(this.valhallaUrl), o = e.geometry.coordinates.map((c) => {
      const h = c;
      return new He(h[0], h[1]);
    });
    if (!o || o && o.length < 2) return;
    const s = await i.calcRoute(
      o,
      this.routingCostingModel,
      this.routingDistanceUnit
    );
    if (!s || !s.feature) return;
    const n = s?.feature.geometry;
    this.terradraw?.updateFeatureGeometry(t, n), e.geometry = n, e.properties = {
      ...e.properties,
      ...s?.feature.properties
    }, this.terradraw?.updateFeatureProperties(t, s?.feature.properties);
    const l = (s?.pointFeatures).features.map((c) => (c.id = `${t}-${c.id}`, c.properties.originalId = t, c)), d = this.map.getStyle().sources[this.controlOptions.routingLineLayerNodeSpec.source];
    d && (typeof d.data != "string" && d.data.type === "FeatureCollection" && (d.data.features = d.data.features.filter(
      (c) => c.properties?.originalId !== t
    )), typeof d.data != "string" && d.data.type === "FeatureCollection" && d.data.features.push(...l), this.map.getSource(
      this.controlOptions.routingLineLayerNodeSpec.source
    )?.setData(d.data), this.map.moveLayer(
      this.controlOptions.routingLineLayerNodeSpec.id
    ), this.map.moveLayer(
      this.controlOptions.routingLineLayerNodeLabelSpec.id
    ));
  };
  /**
   * Event definition when feature is deleted by terradraw
   */
  onFeatureDeleted(t) {
    if (!this.map) return;
    if (this.getTerraDrawInstance()) {
      let i = [];
      typeof t == "object" && t !== null && "deletedIds" in t && (i = t.deletedIds);
      const s = [
        this.controlOptions.routingLineLayerNodeSpec,
        this.controlOptions.isochronePolygonLayerSpec
      ].map((n) => n.source);
      i && i.length > 0 ? this.clearExtendedFeatures(s, i) : this.clearExtendedFeatures(s, void 0);
    }
  }
  /**
   * get GeoJSON features
   * @param onlySelected If true, returns only selected features. Default is false.
   * @returns FeatureCollection in GeoJSON format
   */
  getFeatures(t = !1) {
    const e = super.getFeatures(t);
    if (!e || !this.terradraw || !this.map) return e;
    const i = this.map.getStyle().sources[this.controlOptions.isochronePolygonLayerSpec.source], o = [];
    for (let s = 0; s < e.features.length; s++) {
      const n = e.features[s];
      if (n.geometry.type === "Point") {
        const l = n.id;
        if (i && typeof i.data != "string" && i.data.type === "FeatureCollection") {
          const d = i.data.features.filter(
            (c) => c.properties?.originalId === l
          );
          o.push(n), d.length > 0 && o.push(...d);
        }
      } else
        o.push(n);
    }
    return {
      type: "FeatureCollection",
      features: o
    };
  }
}
export {
  Vo as AvailableModes,
  $o as AvailableValhallaModes,
  Ho as MaplibreMeasureControl,
  Xe as MaplibreTerradrawControl,
  Jo as MaplibreValhallaControl,
  Ve as MemoryCache,
  mo as ModalDialog,
  Yo as TERRADRAW_MEASURE_SOURCE_IDS,
  et as TERRADRAW_SOURCE_IDS,
  Ko as TERRADRAW_VALHALLA_SOURCE_IDS,
  To as ValhallaIsochrone,
  Bo as ValhallaRouting,
  fe as calcArea,
  ve as calcDistance,
  Ce as capitalize,
  Vt as cleanMaplibreStyle,
  No as contourTypeOptions,
  go as convertAreaUnit,
  Dt as convertDistance,
  Wt as costingModelOptions,
  ze as debounce,
  eo as defaultControlOptions,
  lt as defaultMeasureControlOptions,
  z as defaultValhallaControlOptions,
  io as getDefaultModeOptions,
  Pe as queryElevationByPoint,
  Se as queryElevationFromRasterDEM,
  Xo as roundFeatureCoordinates,
  Wo as routingDistanceUnitOptions
};
//# sourceMappingURL=maplibre-gl-terradraw.es.js.map
