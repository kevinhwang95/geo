{"version":3,"file":"terra-draw-google-maps-adapter.modern.js","sources":["../src/terra-draw-google-maps-adapter.ts"],"sourcesContent":["/**\n * @module terra-draw-google-maps-adapter\n */\nimport {\n\tTerraDrawChanges,\n\tSetCursor,\n\tTerraDrawStylingFunction,\n\tTerraDrawExtend,\n} from \"terra-draw\";\nimport { GeoJsonObject } from \"geojson\";\n\nexport class TerraDrawGoogleMapsAdapter extends TerraDrawExtend.TerraDrawBaseAdapter {\n\tconstructor(\n\t\tconfig: {\n\t\t\tlib: typeof google.maps;\n\t\t\tmap: google.maps.Map;\n\t\t} & TerraDrawExtend.BaseAdapterConfig,\n\t) {\n\t\tsuper(config);\n\t\tthis._lib = config.lib;\n\t\tthis._map = config.map;\n\n\t\tthis._coordinatePrecision =\n\t\t\ttypeof config.coordinatePrecision === \"number\"\n\t\t\t\t? config.coordinatePrecision\n\t\t\t\t: 9;\n\t}\n\n\tprivate _cursor: string | undefined;\n\tprivate _cursorStyleSheet: HTMLStyleElement | undefined;\n\tprivate _lib: typeof google.maps;\n\tprivate _map: google.maps.Map;\n\tprivate _overlay: google.maps.OverlayView | undefined;\n\tprivate _clickEventListener: google.maps.MapsEventListener | undefined;\n\tprivate _mouseMoveEventListener: google.maps.MapsEventListener | undefined;\n\tprivate _readyCalled = false;\n\n\tprivate get _layers(): boolean {\n\t\treturn Boolean(this.renderedFeatureIds?.size > 0);\n\t}\n\n\t/**\n\t * Generates an SVG path string for a circle with the given center coordinates and radius.\n\t * Based off this StackOverflow answer: https://stackoverflow.com/a/27905268/1363484\n\t * @param cx The x-coordinate of the circle's center.\n\t * @param cy The y-coordinate of the circle's center.\n\t * @param r The radius of the circle.\n\t * @returns The SVG path string representing the circle.\n\t */\n\tprivate circlePath(cx: number, cy: number, r: number) {\n\t\tconst d = r * 2;\n\t\treturn `M ${cx} ${cy} m -${r}, 0 a ${r},${r} 0 1,0 ${d},0 a ${r},${r} 0 1,0 -${d},0`;\n\t}\n\n\tpublic register(callbacks: TerraDrawExtend.TerraDrawCallbacks) {\n\t\tsuper.register(callbacks);\n\n\t\t// The overlay is responsible for allow us to\n\t\t// get the projection, which in turn allows us to\n\t\t// go through lng/lat to pixel space and vice versa\n\t\tthis._overlay = new this._lib.OverlayView();\n\t\tthis._overlay.draw = function () {\n\t\t\t// No-op\n\t\t};\n\n\t\t// Unfortunately it is only ready after the onAdd\n\t\t// method is called, which is why we need to use the 'ready'\n\t\t// listener with the Google Maps adapter\n\t\tthis._overlay.onAdd = () => {\n\t\t\tif (this._currentModeCallbacks?.onReady && !this._readyCalled) {\n\t\t\t\tthis._currentModeCallbacks.onReady();\n\t\t\t\tthis._readyCalled = true;\n\t\t\t}\n\t\t};\n\t\tthis._overlay.setMap(this._map);\n\n\t\t// Required to avoid runtime error in Google Maps API\n\t\tthis._overlay.onRemove = () => {\n\t\t\t// No-op\n\t\t};\n\n\t\t// Clicking on data geometries triggers\n\t\t// swallows the map onclick event,\n\t\t// so we need to forward it to the click callback handler\n\t\tthis._clickEventListener = this._map.data.addListener(\n\t\t\t\"click\",\n\t\t\t(\n\t\t\t\tevent: google.maps.MapMouseEvent & {\n\t\t\t\t\tdomEvent: MouseEvent;\n\t\t\t\t},\n\t\t\t) => {\n\t\t\t\tconst clickListener = this._listeners.find(\n\t\t\t\t\t({ name }) => name === \"click\",\n\t\t\t\t);\n\t\t\t\tif (clickListener) {\n\t\t\t\t\tclickListener.callback(event);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\tthis._mouseMoveEventListener = this._map.data.addListener(\n\t\t\t\"mousemove\",\n\t\t\t(\n\t\t\t\tevent: google.maps.MapMouseEvent & {\n\t\t\t\t\tdomEvent: MouseEvent;\n\t\t\t\t},\n\t\t\t) => {\n\t\t\t\tconst mouseMoveListener = this._listeners.find(\n\t\t\t\t\t({ name }) => name === \"mousemove\",\n\t\t\t\t);\n\t\t\t\tif (mouseMoveListener) {\n\t\t\t\t\tmouseMoveListener.callback(event);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t}\n\n\tpublic unregister(): void {\n\t\tsuper.unregister();\n\t\tthis._clickEventListener?.remove();\n\t\tthis._mouseMoveEventListener?.remove();\n\n\t\tif (this._overlay && this._overlay.getMap()) {\n\t\t\tthis._overlay.setMap(null);\n\t\t}\n\t\tthis._overlay = undefined;\n\t\tthis._readyCalled = false;\n\t}\n\n\t/**\n\t * Returns the longitude and latitude coordinates from a given PointerEvent on the map.\n\t * @param event The PointerEvent or MouseEvent containing the screen coordinates of the pointer.\n\t * @returns An object with 'lng' and 'lat' properties representing the longitude and latitude, or null if the conversion is not possible.\n\t */\n\tgetLngLatFromEvent(event: PointerEvent | MouseEvent) {\n\t\tif (!this._overlay) {\n\t\t\tthrow new Error(\"cannot get overlay\");\n\t\t}\n\n\t\tconst bounds = this._map.getBounds();\n\n\t\tif (!bounds) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst ne = bounds.getNorthEast();\n\t\tconst sw = bounds.getSouthWest();\n\t\tconst latLngBounds = new this._lib.LatLngBounds(sw, ne);\n\n\t\tconst mapCanvas = this._map.getDiv();\n\t\tconst offsetX = event.clientX - mapCanvas.getBoundingClientRect().left;\n\t\tconst offsetY = event.clientY - mapCanvas.getBoundingClientRect().top;\n\t\tconst screenCoord = new this._lib.Point(offsetX, offsetY);\n\n\t\tconst projection = this._overlay.getProjection();\n\t\tif (!projection) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst latLng = projection.fromContainerPixelToLatLng(screenCoord);\n\n\t\tif (latLng && latLngBounds.contains(latLng)) {\n\t\t\treturn { lng: latLng.lng(), lat: latLng.lat() };\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves the HTML element of the Google Map element that handles interaction events\n\t * @returns The HTMLElement representing the map container.\n\t */\n\tpublic getMapEventElement() {\n\t\t// TODO: This is a bit hacky, maybe there is a better solution here\n\t\tconst selector = 'div[style*=\"z-index: 3;\"]';\n\t\treturn this._map.getDiv().querySelector(selector) as HTMLDivElement;\n\t}\n\n\t/**\n\t * Converts longitude and latitude coordinates to pixel coordinates in the map container.\n\t * @param lng The longitude coordinate to project.\n\t * @param lat The latitude coordinate to project.\n\t * @returns An object with 'x' and 'y' properties representing the pixel coordinates within the map container.\n\t */\n\tproject(lng: number, lat: number) {\n\t\tif (!this._overlay) {\n\t\t\tthrow new Error(\"cannot get overlay\");\n\t\t}\n\n\t\tconst bounds = this._map.getBounds();\n\n\t\tif (bounds === undefined) {\n\t\t\tthrow new Error(\"cannot get bounds\");\n\t\t}\n\n\t\tconst projection = this._overlay.getProjection();\n\t\tif (projection === undefined) {\n\t\t\tthrow new Error(\"cannot get projection\");\n\t\t}\n\n\t\tconst point = projection.fromLatLngToContainerPixel(\n\t\t\tnew this._lib.LatLng(lat, lng),\n\t\t);\n\n\t\tif (point === null) {\n\t\t\tthrow new Error(\"cannot project coordinates\");\n\t\t}\n\n\t\treturn { x: point.x, y: point.y };\n\t}\n\n\t/**\n\t * Converts pixel coordinates in the map container to longitude and latitude coordinates.\n\t * @param x The x-coordinate in the map container to unproject.\n\t * @param y The y-coordinate in the map container to unproject.\n\t * @returns An object with 'lng' and 'lat' properties representing the longitude and latitude coordinates.\n\t */\n\tunproject(x: number, y: number) {\n\t\tif (!this._overlay) {\n\t\t\tthrow new Error(\"cannot get overlay\");\n\t\t}\n\n\t\tconst projection = this._overlay.getProjection();\n\t\tif (projection === undefined) {\n\t\t\tthrow new Error(\"cannot get projection\");\n\t\t}\n\n\t\tconst latLng = projection.fromContainerPixelToLatLng(\n\t\t\tnew this._lib.Point(x, y),\n\t\t);\n\n\t\tif (latLng === null) {\n\t\t\tthrow new Error(\"cannot unproject coordinates\");\n\t\t}\n\n\t\treturn { lng: latLng.lng(), lat: latLng.lat() };\n\t}\n\n\t/**\n\t * Sets the cursor style for the map container.\n\t * @param cursor The CSS cursor style to apply, or 'unset' to remove any previously applied cursor style.\n\t */\n\tsetCursor(cursor: Parameters<SetCursor>[0]) {\n\t\tif (cursor === this._cursor) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._cursorStyleSheet) {\n\t\t\tthis._cursorStyleSheet.remove();\n\t\t\tthis._cursorStyleSheet = undefined;\n\t\t}\n\n\t\tif (cursor !== \"unset\") {\n\t\t\t// TODO: We could cache these individually per cursor\n\n\t\t\tconst div = this._map.getDiv();\n\t\t\tconst styleDiv = div.querySelector(\".gm-style > div\");\n\n\t\t\tif (styleDiv) {\n\t\t\t\tstyleDiv.classList.add(\"terra-draw-google-maps\");\n\n\t\t\t\tconst style = document.createElement(\"style\");\n\t\t\t\tstyle.innerHTML = `.terra-draw-google-maps { cursor: ${cursor} !important; }`;\n\t\t\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(style);\n\t\t\t\tthis._cursorStyleSheet = style;\n\t\t\t}\n\t\t}\n\n\t\tthis._cursor = cursor;\n\t}\n\n\t/**\n\t * Enables or disables the double-click to zoom functionality on the map.\n\t * @param enabled Set to true to enable double-click to zoom, or false to disable it.\n\t */\n\tsetDoubleClickToZoom(enabled: boolean) {\n\t\tif (enabled) {\n\t\t\tthis._map.setOptions({ disableDoubleClickZoom: false });\n\t\t} else {\n\t\t\tthis._map.setOptions({ disableDoubleClickZoom: true });\n\t\t}\n\t}\n\n\t/**\n\t * Enables or disables the draggable functionality of the map.\n\t * @param enabled Set to true to enable map dragging, or false to disable it.\n\t */\n\tsetDraggability(enabled: boolean) {\n\t\tthis._map.setOptions({ draggable: enabled });\n\t}\n\n\tprivate renderedFeatureIds: Set<TerraDrawExtend.FeatureId> = new Set();\n\n\t/**\n\t * Renders GeoJSON features on the map using the provided styling configuration.\n\t * @param changes An object containing arrays of created, updated, and unchanged features to render.\n\t * @param styling An object mapping draw modes to feature styling functions\n\t */\n\trender(changes: TerraDrawChanges, styling: TerraDrawStylingFunction) {\n\t\tif (this._layers) {\n\t\t\tchanges.deletedIds.forEach((deletedId) => {\n\t\t\t\tconst featureToDelete = this._map.data.getFeatureById(deletedId);\n\t\t\t\tif (featureToDelete) {\n\t\t\t\t\tthis._map.data.remove(featureToDelete);\n\t\t\t\t\tthis.renderedFeatureIds.delete(deletedId);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tchanges.updated.forEach((updatedFeature) => {\n\t\t\t\tif (!updatedFeature || !updatedFeature.id) {\n\t\t\t\t\tthrow new Error(\"Feature is not valid\");\n\t\t\t\t}\n\n\t\t\t\tconst featureToUpdate = this._map.data.getFeatureById(\n\t\t\t\t\tupdatedFeature.id,\n\t\t\t\t);\n\n\t\t\t\tif (!featureToUpdate) {\n\t\t\t\t\tthrow new Error(\"Feature could not be found by Google Maps API\");\n\t\t\t\t}\n\n\t\t\t\t// Remove all keys\n\t\t\t\tfeatureToUpdate.forEachProperty((property, name) => {\n\t\t\t\t\tfeatureToUpdate.setProperty(name, undefined);\n\t\t\t\t});\n\n\t\t\t\t// Update all keys\n\t\t\t\tObject.keys(updatedFeature.properties).forEach((property) => {\n\t\t\t\t\tfeatureToUpdate.setProperty(\n\t\t\t\t\t\tproperty,\n\t\t\t\t\t\tupdatedFeature.properties[property],\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\tswitch (updatedFeature.geometry.type) {\n\t\t\t\t\tcase \"Point\":\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst coordinates = updatedFeature.geometry.coordinates;\n\n\t\t\t\t\t\t\tfeatureToUpdate.setGeometry(\n\t\t\t\t\t\t\t\tnew this._lib.Data.Point(\n\t\t\t\t\t\t\t\t\tnew this._lib.LatLng(coordinates[1], coordinates[0]),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"LineString\":\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst coordinates = updatedFeature.geometry.coordinates;\n\n\t\t\t\t\t\t\tconst path: google.maps.LatLng[] = [];\n\t\t\t\t\t\t\tfor (let i = 0; i < coordinates.length; i++) {\n\t\t\t\t\t\t\t\tconst coordinate = coordinates[i];\n\t\t\t\t\t\t\t\tconst latLng = new this._lib.LatLng(\n\t\t\t\t\t\t\t\t\tcoordinate[1],\n\t\t\t\t\t\t\t\t\tcoordinate[0],\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tpath.push(latLng);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfeatureToUpdate.setGeometry(new this._lib.Data.LineString(path));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"Polygon\":\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst coordinates = updatedFeature.geometry.coordinates;\n\n\t\t\t\t\t\t\tconst paths: google.maps.LatLng[][] = [];\n\t\t\t\t\t\t\tfor (let i = 0; i < coordinates.length; i++) {\n\t\t\t\t\t\t\t\tconst path: google.maps.LatLng[] = [];\n\t\t\t\t\t\t\t\tfor (let j = 0; j < coordinates[i].length; j++) {\n\t\t\t\t\t\t\t\t\tconst latLng = new this._lib.LatLng(\n\t\t\t\t\t\t\t\t\t\tcoordinates[i][j][1],\n\t\t\t\t\t\t\t\t\t\tcoordinates[i][j][0],\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tpath.push(latLng);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpaths.push(path);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfeatureToUpdate.setGeometry(new this._lib.Data.Polygon(paths));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Create new features\n\t\t\tchanges.created.forEach((createdFeature) => {\n\t\t\t\tthis.renderedFeatureIds.add(createdFeature.id as string);\n\t\t\t\tthis._map.data.addGeoJson(createdFeature);\n\t\t\t});\n\t\t}\n\n\t\tchanges.created.forEach((feature) => {\n\t\t\tthis.renderedFeatureIds.add(feature.id as string);\n\t\t});\n\n\t\tconst featureCollection = {\n\t\t\ttype: \"FeatureCollection\",\n\t\t\tfeatures: [...changes.created],\n\t\t} as GeoJsonObject;\n\n\t\tthis._map.data.addGeoJson(featureCollection);\n\n\t\tthis._map.data.setStyle((feature) => {\n\t\t\tconst mode = feature.getProperty(\"mode\");\n\t\t\tconst gmGeometry = feature.getGeometry();\n\t\t\tif (!gmGeometry) {\n\t\t\t\tthrow new Error(\"Google Maps geometry not found\");\n\t\t\t}\n\t\t\tconst type = gmGeometry.getType();\n\t\t\tconst properties: Record<string, any> = {};\n\t\t\tconst id = feature.getId();\n\n\t\t\tfeature.forEachProperty((value, property) => {\n\t\t\t\tproperties[property] = value;\n\t\t\t});\n\n\t\t\tconst calculatedStyles = styling[mode]({\n\t\t\t\ttype: \"Feature\",\n\t\t\t\tid,\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: type as \"Point\" | \"LineString\" | \"Polygon\",\n\t\t\t\t\tcoordinates: [],\n\t\t\t\t},\n\t\t\t\tproperties,\n\t\t\t});\n\n\t\t\tswitch (type) {\n\t\t\t\tcase \"Point\":\n\t\t\t\t\tconst path = this.circlePath(0, 0, calculatedStyles.pointWidth);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tclickable: false,\n\t\t\t\t\t\ticon: {\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\tfillColor: calculatedStyles.pointColor,\n\t\t\t\t\t\t\tfillOpacity: 1,\n\t\t\t\t\t\t\tstrokeColor: calculatedStyles.pointOutlineColor,\n\t\t\t\t\t\t\tstrokeWeight: calculatedStyles.pointOutlineWidth,\n\t\t\t\t\t\t\trotation: 0,\n\t\t\t\t\t\t\tscale: 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tzIndex: calculatedStyles.zIndex,\n\t\t\t\t\t};\n\n\t\t\t\tcase \"LineString\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstrokeColor: calculatedStyles.lineStringColor,\n\t\t\t\t\t\tstrokeWeight: calculatedStyles.lineStringWidth,\n\t\t\t\t\t\tzIndex: calculatedStyles.zIndex,\n\t\t\t\t\t};\n\t\t\t\tcase \"Polygon\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstrokeColor: calculatedStyles.polygonOutlineColor,\n\t\t\t\t\t\tstrokeWeight: calculatedStyles.polygonOutlineWidth,\n\t\t\t\t\t\tfillOpacity: calculatedStyles.polygonFillOpacity,\n\t\t\t\t\t\tfillColor: calculatedStyles.polygonFillColor,\n\t\t\t\t\t\tzIndex: calculatedStyles.zIndex,\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow Error(\"Unknown feature type\");\n\t\t});\n\t}\n\n\tprivate clearLayers() {\n\t\tif (this._layers) {\n\t\t\tthis._map.data.forEach((feature) => {\n\t\t\t\tconst id = feature.getId() as string;\n\t\t\t\tconst hasFeature = this.renderedFeatureIds.has(id);\n\t\t\t\tif (hasFeature) {\n\t\t\t\t\tthis._map.data.remove(feature);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.renderedFeatureIds = new Set();\n\t\t}\n\t}\n\n\t/**\n\t * Clears the map and store of all rendered data layers\n\t * @returns void\n\t * */\n\tpublic clear() {\n\t\tif (this._currentModeCallbacks) {\n\t\t\t// Clean up state first\n\t\t\tthis._currentModeCallbacks.onClear();\n\n\t\t\t// Then clean up rendering\n\t\t\tthis.clearLayers();\n\t\t}\n\t}\n\n\tpublic getCoordinatePrecision(): number {\n\t\t// TODO: It seems this shouldn't be necessary as extends BaseAdapter which as this method\n\t\treturn super.getCoordinatePrecision();\n\t}\n}\n"],"names":["TerraDrawGoogleMapsAdapter","TerraDrawExtend","TerraDrawBaseAdapter","constructor","config","super","this","_cursor","_cursorStyleSheet","_lib","_map","_overlay","_clickEventListener","_mouseMoveEventListener","_readyCalled","renderedFeatureIds","Set","lib","map","_coordinatePrecision","coordinatePrecision","_layers","_this$renderedFeature","Boolean","size","circlePath","cx","cy","r","d","register","callbacks","OverlayView","draw","onAdd","_this$_currentModeCal","_currentModeCallbacks","onReady","setMap","onRemove","data","addListener","event","clickListener","_listeners","find","name","callback","mouseMoveListener","unregister","_this$_clickEventList","_this$_mouseMoveEvent","remove","getMap","undefined","getLngLatFromEvent","Error","bounds","getBounds","ne","getNorthEast","sw","getSouthWest","latLngBounds","LatLngBounds","mapCanvas","getDiv","offsetX","clientX","getBoundingClientRect","left","offsetY","clientY","top","screenCoord","Point","projection","getProjection","latLng","fromContainerPixelToLatLng","contains","lng","lat","getMapEventElement","querySelector","project","point","fromLatLngToContainerPixel","LatLng","x","y","unproject","setCursor","cursor","styleDiv","classList","add","style","document","createElement","innerHTML","getElementsByTagName","appendChild","setDoubleClickToZoom","enabled","setOptions","disableDoubleClickZoom","setDraggability","draggable","render","changes","styling","deletedIds","forEach","deletedId","featureToDelete","getFeatureById","delete","updated","updatedFeature","id","featureToUpdate","forEachProperty","property","setProperty","Object","keys","properties","geometry","type","coordinates","setGeometry","Data","path","i","length","coordinate","push","LineString","paths","j","Polygon","created","createdFeature","addGeoJson","feature","featureCollection","features","setStyle","mode","getProperty","gmGeometry","getGeometry","getType","getId","value","calculatedStyles","clickable","icon","pointWidth","fillColor","pointColor","fillOpacity","strokeColor","pointOutlineColor","strokeWeight","pointOutlineWidth","rotation","scale","zIndex","lineStringColor","lineStringWidth","polygonOutlineColor","polygonOutlineWidth","polygonFillOpacity","polygonFillColor","clearLayers","has","clear","onClear","getCoordinatePrecision"],"mappings":"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"}