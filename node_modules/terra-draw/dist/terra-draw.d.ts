/**
 * @module terra-draw
 */
import { TerraDrawAdapter, TerraDrawAdapterStyling, GetLngLatFromEvent, Project, SetCursor, TerraDrawChanges, TerraDrawStylingFunction, Unproject, HexColor, TerraDrawKeyboardEvent, TerraDrawMouseEvent, OnFinishContext, OnChangeContext, Projection } from "./common";
import { TerraDrawBaseDrawMode } from "./modes/base.mode";
import { TerraDrawCircleMode } from "./modes/circle/circle.mode";
import { TerraDrawFreehandMode } from "./modes/freehand/freehand.mode";
import { TerraDrawLineStringMode } from "./modes/linestring/linestring.mode";
import { TerraDrawPointMode } from "./modes/point/point.mode";
import { TerraDrawPolygonMode } from "./modes/polygon/polygon.mode";
import { TerraDrawRectangleMode } from "./modes/rectangle/rectangle.mode";
import { TerraDrawRenderMode } from "./modes/render/render.mode";
import { TerraDrawSelectMode } from "./modes/select/select.mode";
import { FeatureId, GeoJSONStoreFeatures, GeoJSONStoreGeometries, IdStrategy, JSON, StoreValidation } from "./store/store";
import { BehaviorConfig } from "./modes/base.behavior";
import { Position } from "geojson";
import { ValidateMinAreaSquareMeters } from "./validations/min-size.validation";
import { ValidateMaxAreaSquareMeters } from "./validations/max-size.validation";
import { ValidateNotSelfIntersecting } from "./validations/not-self-intersecting.validation";
import { TerraDrawAngledRectangleMode } from "./modes/angled-rectangle/angled-rectangle.mode";
import { TerraDrawSectorMode } from "./modes/sector/sector.mode";
import { TerraDrawSensorMode } from "./modes/sensor/sensor.mode";
import * as TerraDrawExtend from "./extend";
import { ValidationReasons } from "./validation-reasons";
import { TerraDrawFreehandLineStringMode } from "./modes/freehand-linestring/freehand-linestring.mode";
type InstanceType<T extends new (...args: any[]) => any> = T extends new (...args: any[]) => infer R ? R : never;
type FinishListener = (id: FeatureId, context: OnFinishContext) => void;
type ChangeListener = (ids: FeatureId[], type: string, context?: OnChangeContext) => void;
type SelectListener = (id: FeatureId) => void;
type DeselectListener = () => void;
interface TerraDrawEventListeners {
    ready: () => void;
    finish: FinishListener;
    change: ChangeListener;
    select: SelectListener;
    deselect: DeselectListener;
}
type GetFeatureOptions = {
    pointerDistance?: number;
    includePolygonsWithinPointerDistance?: boolean;
    ignoreSelectFeatures?: boolean;
    ignoreCoordinatePoints?: boolean;
    ignoreCurrentlyDrawing?: boolean;
    ignoreClosingPoints?: boolean;
    addClosestCoordinateInfoToProperties?: boolean;
};
type TerraDrawEvents = keyof TerraDrawEventListeners;
declare class TerraDraw {
    private _modes;
    private _mode;
    private _adapter;
    private _enabled;
    private _store;
    private _eventListeners;
    private _instanceSelectMode;
    constructor(options: {
        adapter: TerraDrawAdapter;
        modes: TerraDrawBaseDrawMode<any>[];
        idStrategy?: IdStrategy<FeatureId>;
        tracked?: boolean;
    });
    private checkEnabled;
    private getModeStyles;
    private featuresAtLocation;
    private getSelectModeOrThrow;
    private getSelectMode;
    private isGuidanceFeature;
    /**
     * @deprecated This method is scheduled for removal in the next major version. Instead use the 'updateModeOptions' method passing the
     * styles property in the options object, and this will dynamically update the styles for the mode.
     *
     * Allows the setting of a style for a given mode
     *
     * @param mode - The mode you wish to set a style for
     * @param styles - The styles you wish to set for the mode - this is
     * the same as the initialisation style schema
     */
    setModeStyles<Styling extends Record<string, number | HexColor>>(mode: string, styles: Styling): void;
    /**
     * Allow updating of the current options passed to the mode dynamically
     * after the mode has been started. You can also use this method to update styles
     * as these are passed from the options object.
     * @param mode - the mode name you wish to update (the mode name is the public 'mode' property of the mode class)
     * @param options - the options object - this allows _partial_ updating of the modes options (i.e. you do not need to pass the whole options object)
     */
    updateModeOptions<Mode extends {
        new (...args: any[]): any;
    }>(mode: InstanceType<Mode>["mode"], options: ConstructorParameters<Mode>[0]): void;
    /**
     * Allows the user to get a snapshot (copy) of all given features
     *
     * @returns An array of all given Feature Geometries in the instances store
     */
    getSnapshot(): GeoJSONStoreFeatures[];
    /**
     * Allows the user to get a snapshot (copy) of a given feature by id
     *
     * @returns A copy of the feature geometry in the instances store
     */
    getSnapshotFeature(id: FeatureId): GeoJSONStoreFeatures | undefined;
    /**
     * Removes all data from the current store and ensures any rendered data is cleared
     * from the map.
     */
    clear(): void;
    /**
     * A property used to determine whether the instance is active or not. You
     * can use the start method to set this to true, and stop method to set this to false.
     * This is a read only property.
     *
     * @return true or false depending on if the instance is stopped or started
     * @readonly
     */
    get enabled(): boolean;
    /**
     * enabled is a read only property and will throw and error if you try and set it.
     */
    set enabled(_: boolean);
    /**
     * A method for getting the current mode name
     * @return the current mode name
     */
    getMode(): string;
    /**
     * Get the state of the mode i.e. if we are currently unregistered, registered, drawing etc. This can
     * be used to make decisions based on what the current mode is doing.
     * @returns the current mode state as a string
     */
    getModeState(): import("./common").TerraDrawModeState;
    /**
     * A method for setting the current mode by name. Under the hood this will stop
     * the previous mode and start the new one.
     * @param mode - The mode name you wish to start
     */
    setMode(mode: string): void;
    /**
     * A method for removing features to the store
     * @param ids
     * @returns
     */
    removeFeatures(ids: FeatureId[]): void;
    /**
     * Provides the ability to programmatically select a feature using the instances provided select mode.
     * If not select mode is provided in the instance, an error will be thrown. If the instance is not currently
     * in the select mode, it will switch to it.
     * @param id - the id of the feature to select
     */
    selectFeature(id: FeatureId): void;
    /**
     * Provides the ability to programmatically deselect a feature using the instances provided select mode.
     * If not select mode is provided in the instance, an error will be thrown. If the instance is not currently
     * in the select mode, it will switch to it.
     * @param id  - the id of the feature to deselect
     */
    deselectFeature(id: FeatureId): void;
    /**
     * Returns the next feature id from the store - defaults to UUID4 unless you have
     * set a custom idStrategy. This method can be useful if you are needing creating features
     * outside of the Terra Draw instance but want to add them in to the store.
     * @returns a id, either number of string based on whatever the configured idStrategy is
     *
     */
    getFeatureId(): FeatureId;
    /**
     * Returns true or false depending on if the Terra Draw instance has a feature with a given id
     * @returns a boolean determining if the instance has a feature with the given id
     */
    hasFeature(id: FeatureId): boolean;
    /**
     * Checks if a property name is reserved and cannot be used.
     * @param propertyName - the property name to check
     * @returns
     */
    private checkIsReservedProperty;
    /**
     * Updates a features properties. This can be used to programmatically change the properties of a feature.
     * The update is a shallow merge so only the properties you provide will be updated. Certain internal properties
     * are reserved and cannot be updated.
     * @param id - the id of the feature to update the property for
     * @param properties - an object of key value pairs that will be shallowly merged in to the features properties
     */
    updateFeatureProperties(id: FeatureId, properties: Record<string, JSON | undefined>): void;
    /**
     * Updates a features geometry. This an be used to programmatically change the coordinates of a feature. This
     * can be useful for if you want to modify a geometry via a button or some similar user interaction.
     * @param id - the id of the feature to update the geometry for
     * @param geometry - the new geometry that will replace the existing geometry
     */
    updateFeatureGeometry(id: FeatureId, geometry: GeoJSONStoreGeometries): void;
    /**
     * A method for transforming a feature's geometry. This can be used to rotate or scale a feature's geometry.
     * This matches the functionality of the scale and rotate behaviors in the select mode.
     * @param id - the id of the feature to transform
     * @param transformation - the transformation to apply to the feature's geometry
     */
    transformFeatureGeometry(id: FeatureId, transformation: {
        projection?: Exclude<Projection, "globe">;
        origin: Position;
        type: "rotate";
        options: {
            angle: number;
        };
    } | {
        projection?: Exclude<Projection, "globe">;
        origin: Position;
        type: "scale";
        options: {
            xScale: number;
            yScale: number;
        };
    }): void;
    /**
     * A method for adding features to the store. This method will validate the features
     * returning an array of validation results. Features must match one of the modes enabled
     * in the instance.
     * @param features - an array of GeoJSON features
     * @returns an array of validation results
     */
    addFeatures(features: GeoJSONStoreFeatures[]): StoreValidation[];
    /**
     * A method starting Terra Draw. It put the instance into a started state, and
     * in registers the passed adapter giving it all the callbacks required to operate.
     */
    start(): void;
    /**
     * Gets the features at a given longitude and latitude.
     * Will return point and linestrings that are a given pixel distance
     * away from the lng/lat and any polygons which contain it.
     */
    getFeaturesAtLngLat(lngLat: {
        lng: number;
        lat: number;
    }, options?: GetFeatureOptions): GeoJSONStoreFeatures[];
    /**
     * Takes a given pointer event and will return point and linestrings that are
     * a given pixel distance away from the longitude/latitude, and any polygons which contain it.
     */
    getFeaturesAtPointerEvent(event: PointerEvent | MouseEvent, options?: GetFeatureOptions): GeoJSONStoreFeatures[];
    /**
     * A method for stopping Terra Draw. Will clear the store, deregister the adapter and
     * remove any rendered layers in the process.
     */
    stop(): void;
    /**
     * Registers a Terra Draw event
     *
     * @param event - The name of the event you wish to listen for
     * @param callback - The callback with you wish to be called when this event occurs
     *
     */
    on<T extends TerraDrawEvents>(event: T, callback: TerraDrawEventListeners[T]): void;
    /**
     * Unregisters a Terra Draw event
     *
     * @param event - The name of the event you wish to unregister
     * @param callback - The callback you originally provided to the 'on' method
     *
     */
    off<T extends TerraDrawEvents>(event: TerraDrawEvents, callback: TerraDrawEventListeners[T]): void;
}
export { TerraDraw, type IdStrategy, type TerraDrawEvents, type TerraDrawEventListeners, TerraDrawSelectMode, TerraDrawPointMode, TerraDrawLineStringMode, TerraDrawPolygonMode, TerraDrawCircleMode, TerraDrawFreehandMode, TerraDrawFreehandLineStringMode, TerraDrawRenderMode, TerraDrawRectangleMode, TerraDrawAngledRectangleMode, TerraDrawSectorMode, TerraDrawSensorMode, TerraDrawExtend, type BehaviorConfig, type GeoJSONStoreFeatures, type GeoJSONStoreGeometries, type HexColor, type TerraDrawMouseEvent, type TerraDrawAdapterStyling, type TerraDrawKeyboardEvent, type TerraDrawChanges, type TerraDrawStylingFunction, type Project, type Unproject, type SetCursor, type GetLngLatFromEvent, ValidateMinAreaSquareMeters, ValidateMaxAreaSquareMeters, ValidateNotSelfIntersecting, ValidationReasons, };
