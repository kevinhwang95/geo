function t(){return t=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var o in i)({}).hasOwnProperty.call(i,o)&&(t[o]=i[o])}return t},t.apply(null,arguments)}var e;!function(t){t.Commit="commit",t.Provisional="provisional",t.Finish="finish"}(e||(e={}));const i={SELECTED:"selected",MID_POINT:"midPoint",SELECTION_POINT_FEATURE_ID:"selectionPointFeatureId",SELECTION_POINT:"selectionPoint"},o={MODE:"mode",CURRENTLY_DRAWING:"currentlyDrawing",EDITED:"edited",CLOSING_POINT:"closingPoint",SNAPPING_POINT:"snappingPoint",COORDINATE_POINT:"coordinatePoint",COORDINATE_POINT_FEATURE_ID:"coordinatePointFeatureId",COORDINATE_POINT_IDS:"coordinatePointIds",PROVISIONAL_COORDINATE_COUNT:"provisionalCoordinateCount",COMMITTED_COORDINATE_COUNT:"committedCoordinateCount"},s=10;function n(t){return Boolean(t&&"object"==typeof t&&null!==t&&!Array.isArray(t))}function r(t){return Boolean(t&&"object"==typeof t&&"properties"in t&&"object"==typeof t.properties&&null!==t.properties&&"mode"in t.properties)}function a(t){return!!function(t){return"number"==typeof t&&!isNaN(new Date(t).valueOf())}(t)}const d="Feature is not a Polygon",h="Feature mode property does not match the mode being added to";var l;!function(t){t.Drawing="drawing",t.Select="select",t.Static="static",t.Render="render"}(l||(l={}));const c={rightClick:!0,contextMenu:!1,leftClick:!0,onDragStart:!0,onDrag:!0,onDragEnd:!0};class u{get state(){return this._state}set state(t){throw new Error("Please use the modes lifecycle methods")}get styles(){return this._styles}set styles(t){if("object"!=typeof t)throw new Error("Styling must be an object");this.onStyleChange&&this.onStyleChange([],"styling"),this._styles=t}registerBehaviors(t){}constructor(t,e=!1){this._state="unregistered",this._styles={},this.pointerEvents=c,this.behaviors=[],this.validate=void 0,this.pointerDistance=40,this.coordinatePrecision=void 0,this.onStyleChange=void 0,this.store=void 0,this.projection="web-mercator",this.setDoubleClickToZoom=void 0,this.unproject=void 0,this.project=void 0,this.setCursor=void 0,this.type=l.Drawing,this.mode="base",e||this.updateOptions(t)}updateOptions(e){null!=e&&e.styles&&(this.styles=t({},this._styles,e.styles)),null!=e&&e.pointerDistance&&(this.pointerDistance=e.pointerDistance),null!=e&&e.validation&&(this.validate=e&&e.validation),null!=e&&e.projection&&(this.projection=e.projection),void 0!==(null==e?void 0:e.pointerEvents)&&(this.pointerEvents=e.pointerEvents)}allowPointerEvent(t,e){return"boolean"==typeof t?t:"function"!=typeof t||t(e)}setDrawing(){if("started"!==this._state)throw new Error("Mode must be unregistered or stopped to start");this._state="drawing"}setStarted(){if("stopped"!==this._state&&"registered"!==this._state&&"drawing"!==this._state&&"selecting"!==this._state)throw new Error("Mode must be unregistered or stopped to start");this._state="started",this.setDoubleClickToZoom(!1)}setStopped(){if("started"!==this._state)throw new Error("Mode must be started to be stopped");this._state="stopped",this.setDoubleClickToZoom(!0)}register(t){if("unregistered"!==this._state)throw new Error("Can not register unless mode is unregistered");this._state="registered",this.store=t.store,this.store.registerOnChange(t.onChange),this.setDoubleClickToZoom=t.setDoubleClickToZoom,this.project=t.project,this.unproject=t.unproject,this.onSelect=t.onSelect,this.onDeselect=t.onDeselect,this.setCursor=t.setCursor,this.onStyleChange=t.onChange,this.onFinish=t.onFinish,this.coordinatePrecision=t.coordinatePrecision,this.registerBehaviors({mode:t.mode,store:this.store,project:this.project,unproject:this.unproject,pointerDistance:this.pointerDistance,coordinatePrecision:t.coordinatePrecision,projection:this.projection})}validateFeature(t){return this.performFeatureValidation(t)}afterFeatureAdded(t){}afterFeatureUpdated(t){}performFeatureValidation(t){if("unregistered"===this._state)throw new Error("Mode must be registered");const i=function(t,e){let i;if(n(t))if(null==t.id)i="Feature has no id";else if("string"!=typeof t.id&&"number"!=typeof t.id)i="Feature must be string or number as per GeoJSON spec";else if(e(t.id))if(n(t.geometry))if(n(t.properties))if("string"==typeof t.geometry.type&&["Polygon","LineString","Point"].includes(t.geometry.type))if(Array.isArray(t.geometry.coordinates)){if(!t.properties.mode||"string"!=typeof t.properties.mode)return{valid:!1,reason:"Feature does not have a valid mode property"}}else i="Feature coordinates is not an array";else i="Feature is not Point, LineString or Polygon";else i="Feature has no properties";else i="Feature has no geometry";else i="Feature must match the id strategy (default is UUID4)";else i="Feature is not object";return i?{valid:!1,reason:i}:{valid:!0}}(t,this.store.idStrategy.isValidId);if(this.validate){const o=this.validate(t,{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Provisional});return{valid:i.valid&&o.valid,reason:o.reason}}return{valid:i.valid,reason:i.reason}}validateModeFeature(t,e){const i=this.performFeatureValidation(t);return i.valid?t.properties.mode!==this.mode?{valid:!1,reason:h}:e(t):{valid:!1,reason:i.reason}}onFinish(t,e){}onDeselect(t){}onSelect(t){}onKeyDown(t){}onKeyUp(t){}onMouseMove(t){}onClick(t){}onDragStart(t,e){}onDrag(t,e){}onDragEnd(t,e){}getHexColorStylingValue(t,e,i){return this.getStylingValue(t,e,i)}getNumericStylingValue(t,e,i){return this.getStylingValue(t,e,i)}getStylingValue(t,e,i){return void 0===t?e:"function"==typeof t?t(i):t}}class p extends u{constructor(...t){super(...t),this.type=l.Select}}function g(t,e){const i=t=>t*Math.PI/180,o=i(t[1]),s=i(t[0]),n=i(e[1]),r=n-o,a=i(e[0])-s,d=Math.sin(r/2)*Math.sin(r/2)+Math.cos(o)*Math.cos(n)*Math.sin(a/2)*Math.sin(a/2);return 2*Math.atan2(Math.sqrt(d),Math.sqrt(1-d))*6371e3/1e3}const y=6371008.8;function f(t){return t%360*Math.PI/180}function m(t){return t/6371.0088}function v(t){return t%(2*Math.PI)*180/Math.PI}function C(t,e=9){const i=Math.pow(10,e);return Math.round(t*i)/i}const P=57.29577951308232,I=.017453292519943295,x=6378137,E=(t,e)=>({x:0===t?0:t*I*x,y:0===e?0:Math.log(Math.tan(Math.PI/4+e*I/2))*x}),S=(t,e)=>({lng:0===t?0:P*(t/x),lat:0===e?0:(2*Math.atan(Math.exp(e/x))-Math.PI/2)*P});function M(t,e,i){const o=f(t[0]),s=f(t[1]),n=f(i),r=m(e),a=Math.asin(Math.sin(s)*Math.cos(r)+Math.cos(s)*Math.sin(r)*Math.cos(n));return[v(o+Math.atan2(Math.sin(n)*Math.sin(r)*Math.cos(s),Math.cos(r)-Math.sin(s)*Math.sin(a))),v(a)]}function F(t){const{center:e,radiusKilometers:i,coordinatePrecision:o}=t,s=t.steps?t.steps:64,n=[];for(let t=0;t<s;t++){const r=M(e,i,-360*t/s);n.push([C(r[0],o),C(r[1],o)])}return n.push(n[0]),{type:"Feature",geometry:{type:"Polygon",coordinates:[n]},properties:{}}}function D(t){let e;if("Polygon"===t.geometry.type)e=t.geometry.coordinates;else{if("LineString"!==t.geometry.type)throw new Error("Self intersects only accepts Polygons and LineStrings");e=[t.geometry.coordinates]}const i=[];for(let t=0;t<e.length;t++)for(let i=0;i<e[t].length-1;i++)for(let o=0;o<e.length;o++)for(let n=0;n<e[o].length-1;n++)s(t,i,o,n);return i.length>0;function o(t){return t<0||t>1}function s(t,s,n,r){const a=e[t][s],d=e[t][s+1],h=e[n][r],l=e[n][r+1],c=function(t,e,i,o){if(w(t,i)||w(t,o)||w(e,i)||w(o,i))return null;const s=t[0],n=t[1],r=e[0],a=e[1],d=i[0],h=i[1],l=o[0],c=o[1],u=(s-r)*(h-c)-(n-a)*(d-l);return 0===u?null:[((s*a-n*r)*(d-l)-(s-r)*(d*c-h*l))/u,((s*a-n*r)*(h-c)-(n-a)*(d*c-h*l))/u]}(a,d,h,l);if(null===c)return;let u,p;u=d[0]!==a[0]?(c[0]-a[0])/(d[0]-a[0]):(c[1]-a[1])/(d[1]-a[1]),p=l[0]!==h[0]?(c[0]-h[0])/(l[0]-h[0]):(c[1]-h[1])/(l[1]-h[1]),o(u)||o(p)||(c.toString(),i.push(c))}}function w(t,e){return t[0]===e[0]&&t[1]===e[1]}function O(t,e){return b(t[0])<=e&&b(t[1])<=e}function _(t){return 2===t.length&&"number"==typeof t[0]&&"number"==typeof t[1]&&Infinity!==t[0]&&Infinity!==t[1]&&(i=t[0])>=-180&&i<=180&&(e=t[1])>=-90&&e<=90;var e,i}function b(t){let e=1,i=0;for(;Math.round(t*e)/e!==t;)e*=10,i++;return i}const k="Feature has holes",N="Feature has less than 4 coordinates",T="Feature has invalid coordinates",j="Feature coordinates are not closed";function W(t,e){if("Polygon"!==t.geometry.type)return{valid:!1,reason:"Feature is not a Polygon"};if(1!==t.geometry.coordinates.length)return{valid:!1,reason:k};if(t.geometry.coordinates[0].length<4)return{valid:!1,reason:N};for(let i=0;i<t.geometry.coordinates[0].length;i++){if(!_(t.geometry.coordinates[0][i]))return{valid:!1,reason:T};if(!O(t.geometry.coordinates[0][i],e))return{valid:!1,reason:"Feature has coordinates with excessive precision"}}return(i=t.geometry.coordinates[0][0])[0]!==(o=t.geometry.coordinates[0][t.geometry.coordinates[0].length-1])[0]||i[1]!==o[1]?{valid:!1,reason:j}:{valid:!0};var i,o}function B(t,e){const i=W(t,e);return i.valid?D(t)?{valid:!1,reason:"Feature intersects itself"}:{valid:!0}:i}const G={cancel:"Escape",finish:"Enter"},R={start:"crosshair"};class L extends u{constructor(t){super(t,!0),this.mode="circle",this.center=void 0,this.clickCount=0,this.currentCircleId=void 0,this.keyEvents=G,this.cursors=R,this.startingRadiusKilometers=1e-5,this.cursorMovedAfterInitialCursorDown=!1,this.updateOptions(t)}updateOptions(e){super.updateOptions(e),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors)),null===(null==e?void 0:e.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents)),null!=e&&e.startingRadiusKilometers&&(this.startingRadiusKilometers=e.startingRadiusKilometers)}close(){if(void 0===this.currentCircleId)return;this.store.updateProperty([{id:this.currentCircleId,property:o.CURRENTLY_DRAWING,value:void 0}]);const t=this.currentCircleId;if(this.validate&&t){const i=this.store.getGeometryCopy(t);if(!this.validate({type:"Feature",id:t,geometry:i,properties:{}},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Finish}).valid)return}this.cursorMovedAfterInitialCursorDown=!1,this.center=void 0,this.currentCircleId=void 0,this.clickCount=0,"drawing"===this.state&&this.setStarted(),this.onFinish(t,{mode:this.mode,action:"draw"})}start(){this.setStarted(),this.setCursor(this.cursors.start)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onClick(t){if("right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t))if(0===this.clickCount){this.center=[t.lng,t.lat];const e=F({center:this.center,radiusKilometers:this.startingRadiusKilometers,coordinatePrecision:this.coordinatePrecision}),[i]=this.store.create([{geometry:e.geometry,properties:{mode:this.mode,radiusKilometers:this.startingRadiusKilometers,[o.CURRENTLY_DRAWING]:!0}}]);this.currentCircleId=i,this.clickCount++,this.cursorMovedAfterInitialCursorDown=!1,this.setDrawing()}else 1===this.clickCount&&this.center&&void 0!==this.currentCircleId&&this.cursorMovedAfterInitialCursorDown&&this.updateCircle(t),this.close()}onMouseMove(t){this.cursorMovedAfterInitialCursorDown=!0,this.updateCircle(t)}onKeyDown(){}onKeyUp(t){t.key===this.keyEvents.cancel?this.cleanUp():t.key===this.keyEvents.finish&&this.close()}onDragStart(){}onDrag(){}onDragEnd(){}cleanUp(){const t=this.currentCircleId;this.center=void 0,this.currentCircleId=void 0,this.clickCount=0,"drawing"===this.state&&this.setStarted();try{void 0!==t&&this.store.delete([t])}catch(t){}}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});return"Feature"===e.type&&"Polygon"===e.geometry.type&&e.properties.mode===this.mode?(i.polygonFillColor=this.getHexColorStylingValue(this.styles.fillColor,i.polygonFillColor,e),i.polygonOutlineColor=this.getHexColorStylingValue(this.styles.outlineColor,i.polygonOutlineColor,e),i.polygonOutlineWidth=this.getNumericStylingValue(this.styles.outlineWidth,i.polygonOutlineWidth,e),i.polygonFillOpacity=this.getNumericStylingValue(this.styles.fillOpacity,i.polygonFillOpacity,e),i.zIndex=s,i):i}validateFeature(t){return this.validateModeFeature(t,t=>B(t,this.coordinatePrecision))}updateCircle(t){if(1===this.clickCount&&this.center&&this.currentCircleId){const i=g(this.center,[t.lng,t.lat]);let o;if("web-mercator"===this.projection){const e=function(t,e){const i=1e3*g(t,e);if(0===i)return 1;const{x:o,y:s}=E(t[0],t[1]),{x:n,y:r}=E(e[0],e[1]);return Math.sqrt(Math.pow(n-o,2)+Math.pow(r-s,2))/i}(this.center,[t.lng,t.lat]);o=function(t){const{center:e,radiusKilometers:i,coordinatePrecision:o}=t,s=t.steps?t.steps:64,n=1e3*i,[r,a]=e,{x:d,y:h}=E(r,a),l=[];for(let t=0;t<s;t++){const e=360*t/s*Math.PI/180,i=n*Math.cos(e),r=n*Math.sin(e),[a,c]=[d+i,h+r],{lng:u,lat:p}=S(a,c);l.push([C(u,o),C(p,o)])}return l.push(l[0]),{type:"Feature",geometry:{type:"Polygon",coordinates:[l]},properties:{}}}({center:this.center,radiusKilometers:i*e,coordinatePrecision:this.coordinatePrecision})}else{if("globe"!==this.projection)throw new Error("Invalid projection");o=F({center:this.center,radiusKilometers:i,coordinatePrecision:this.coordinatePrecision})}if(this.validate&&!this.validate({type:"Feature",id:this.currentCircleId,geometry:o.geometry,properties:{radiusKilometers:i}},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Provisional}).valid)return;this.store.updateGeometry([{id:this.currentCircleId,geometry:o.geometry}]),this.store.updateProperty([{id:this.currentCircleId,property:"radiusKilometers",value:i}])}}afterFeatureUpdated(t){this.currentCircleId===t.id&&(this.cursorMovedAfterInitialCursorDown=!1,this.center=void 0,this.currentCircleId=void 0,this.clickCount=0,"drawing"===this.state&&this.setStarted())}}const U=(t,e)=>{const{x:i,y:o}=t,{x:s,y:n}=e,r=s-i,a=n-o;return Math.sqrt(a*a+r*r)};function A(t){const e=function(t){const e=t.coordinates[0];let i=0;for(let t=0;t<e.length-1;t++){const[o,s]=e[t],[n,r]=e[t+1];i+=(n-o)*(r+s)}return i<0}(t);if(!e)return{type:"Polygon",coordinates:[t.coordinates[0].reverse()]}}const V={cancel:"Escape",finish:"Enter"},Y={start:"crosshair",close:"pointer"};class K extends u{constructor(t){super(t,!0),this.mode="freehand",this.startingClick=!1,this.currentId=void 0,this.closingPointId=void 0,this.minDistance=20,this.keyEvents=V,this.cursors=Y,this.preventPointsNearClose=!0,this.autoClose=!1,this.autoCloseTimeout=500,this.hasLeftStartingPoint=!1,this.preventNewFeature=!1,this.updateOptions(t)}updateOptions(e){super.updateOptions(e),null!=e&&e.minDistance&&(this.minDistance=e.minDistance),void 0!==(null==e?void 0:e.preventPointsNearClose)&&(this.preventPointsNearClose=e.preventPointsNearClose),void 0!==(null==e?void 0:e.autoClose)&&(this.autoClose=e.autoClose),null!=e&&e.autoCloseTimeout&&(this.autoCloseTimeout=e.autoCloseTimeout),null===(null==e?void 0:e.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents)),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors))}close(){if(void 0===this.currentId)return;if(this.currentId){const t=A(this.store.getGeometryCopy(this.currentId));t&&this.store.updateGeometry([{id:this.currentId,geometry:t}]),this.store.updateProperty([{id:this.currentId,property:o.CURRENTLY_DRAWING,value:void 0}])}const t=this.currentId;if(this.validate&&t){const i=this.store.getGeometryCopy(t);if(!this.validate({type:"Feature",id:t,geometry:i,properties:{}},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Finish}).valid)return}this.closingPointId&&this.store.delete([this.closingPointId]),this.startingClick=!1,this.currentId=void 0,this.closingPointId=void 0,this.hasLeftStartingPoint=!1,"drawing"===this.state&&this.setStarted(),this.onFinish(t,{mode:this.mode,action:"draw"})}start(){this.setStarted(),this.setCursor(this.cursors.start)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onMouseMove(t){if(void 0===this.currentId||!1===this.startingClick)return void this.setCursor(this.cursors.start);const i=this.store.getGeometryCopy(this.currentId),o=i.coordinates[0].length-2,[s,n]=i.coordinates[0][o],{x:r,y:a}=this.project(s,n),d=U({x:r,y:a},{x:t.containerX,y:t.containerY}),[h,l]=i.coordinates[0][0],{x:c,y:u}=this.project(h,l);if(U({x:c,y:u},{x:t.containerX,y:t.containerY})<this.pointerDistance){if(this.autoClose&&this.hasLeftStartingPoint&&(this.preventNewFeature=!0,setTimeout(()=>{this.preventNewFeature=!1},this.autoCloseTimeout),this.close()),this.setCursor(this.cursors.close),this.preventPointsNearClose)return}else this.hasLeftStartingPoint=!0,this.setCursor(this.cursors.start);if(d<this.minDistance)return;i.coordinates[0].pop();const p={type:"Polygon",coordinates:[[...i.coordinates[0],[t.lng,t.lat],i.coordinates[0][0]]]};this.validate&&!this.validate({type:"Feature",id:this.currentId,geometry:p,properties:{}},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Provisional}).valid||this.store.updateGeometry([{id:this.currentId,geometry:p}])}onClick(t){if("right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t)){if(this.preventNewFeature)return;if(!1===this.startingClick){const[e,i]=this.store.create([{geometry:{type:"Polygon",coordinates:[[[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat]]]},properties:{mode:this.mode,[o.CURRENTLY_DRAWING]:!0}},{geometry:{type:"Point",coordinates:[t.lng,t.lat]},properties:{mode:this.mode,[o.CLOSING_POINT]:!0}}]);return this.currentId=e,this.closingPointId=i,this.startingClick=!0,void("drawing"!==this.state&&this.setDrawing())}this.close()}}onKeyDown(){}onKeyUp(t){t.key===this.keyEvents.cancel?this.cleanUp():t.key===this.keyEvents.finish&&!0===this.startingClick&&this.close()}onDragStart(){}onDrag(){}onDragEnd(){}cleanUp(){const t=this.currentId,e=this.closingPointId;this.closingPointId=void 0,this.currentId=void 0,this.startingClick=!1,"drawing"===this.state&&this.setStarted();try{void 0!==t&&this.store.delete([t]),void 0!==e&&this.store.delete([e])}catch(t){}}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});return"Feature"===e.type&&"Polygon"===e.geometry.type&&e.properties.mode===this.mode?(i.polygonFillColor=this.getHexColorStylingValue(this.styles.fillColor,i.polygonFillColor,e),i.polygonOutlineColor=this.getHexColorStylingValue(this.styles.outlineColor,i.polygonOutlineColor,e),i.polygonOutlineWidth=this.getNumericStylingValue(this.styles.outlineWidth,i.polygonOutlineWidth,e),i.polygonFillOpacity=this.getNumericStylingValue(this.styles.fillOpacity,i.polygonFillOpacity,e),i.zIndex=s,i):"Feature"===e.type&&"Point"===e.geometry.type&&e.properties.mode===this.mode?(i.pointWidth=this.getNumericStylingValue(this.styles.closingPointWidth,i.pointWidth,e),i.pointColor=this.getHexColorStylingValue(this.styles.closingPointColor,i.pointColor,e),i.pointOutlineColor=this.getHexColorStylingValue(this.styles.closingPointOutlineColor,i.pointOutlineColor,e),i.pointOutlineWidth=this.getNumericStylingValue(this.styles.closingPointOutlineWidth,2,e),i.zIndex=50,i):i}validateFeature(t){return this.validateModeFeature(t,t=>W(t,this.coordinatePrecision))}afterFeatureUpdated(t){this.currentId===t.id&&(this.closingPointId&&this.store.delete([this.closingPointId]),this.startingClick=!1,this.currentId=void 0,this.closingPointId=void 0,this.hasLeftStartingPoint=!1)}}class z{constructor({store:t,mode:e,project:i,unproject:o,pointerDistance:s,coordinatePrecision:n,projection:r}){this.store=void 0,this.mode=void 0,this.project=void 0,this.unproject=void 0,this.pointerDistance=void 0,this.coordinatePrecision=void 0,this.projection=void 0,this.store=t,this.mode=e,this.project=i,this.unproject=o,this.pointerDistance=s,this.coordinatePrecision=n,this.projection=r}}function X({unproject:t,point:e,pointerDistance:i}){const o=i/2,{x:s,y:n}=e;return{type:"Feature",properties:{},geometry:{type:"Polygon",coordinates:[[t(s-o,n-o),t(s+o,n-o),t(s+o,n+o),t(s-o,n+o),t(s-o,n-o)].map(t=>[t.lng,t.lat])]}}}class H extends z{constructor(t){super(t)}create(t){const{containerX:e,containerY:i}=t;return X({unproject:this.unproject,point:{x:e,y:i},pointerDistance:this.pointerDistance})}}class $ extends z{constructor(t){super(t)}measure(t,e){const{x:i,y:o}=this.project(e[0],e[1]);return U({x:i,y:o},{x:t.containerX,y:t.containerY})}}class q extends z{constructor(t,e,i){super(t),this.config=void 0,this.pixelDistance=void 0,this.clickBoundingBox=void 0,this.getSnappableCoordinateFirstClick=t=>this.getSnappable(t,t=>Boolean(t.properties&&t.properties.mode===this.mode)).coordinate,this.getSnappableCoordinate=(t,e)=>this.getSnappable(t,t=>Boolean(t.properties&&t.properties.mode===this.mode&&t.id!==e)).coordinate,this.config=t,this.pixelDistance=e,this.clickBoundingBox=i}getSnappable(t,e){const i=this.clickBoundingBox.create(t),o=this.store.search(i,e),s={featureId:void 0,featureCoordinateIndex:void 0,coordinate:void 0,minDist:Infinity};return o.forEach(e=>{let i;if("Polygon"===e.geometry.type)i=e.geometry.coordinates[0];else{if("LineString"!==e.geometry.type)return;i=e.geometry.coordinates}i.forEach((i,o)=>{const n=this.pixelDistance.measure(t,i);n<s.minDist&&n<this.pointerDistance&&(s.coordinate=i,s.minDist=n,s.featureId=e.id,s.featureCoordinateIndex=o)})}),s}}function Z(t,e,i){const o=f(t[0]),s=f(t[1]),n=f(i),r=m(e),a=Math.asin(Math.sin(s)*Math.cos(r)+Math.cos(s)*Math.sin(r)*Math.cos(n));return[v(o+Math.atan2(Math.sin(n)*Math.sin(r)*Math.cos(s),Math.cos(r)-Math.sin(s)*Math.sin(a))),v(a)]}function J({x:t,y:e},i,o){const s=f(o);return{x:t+i*Math.cos(s),y:e+i*Math.sin(s)}}function Q(t,e){const i=f(t[0]),o=f(e[0]),s=f(t[1]),n=f(e[1]),r=Math.sin(o-i)*Math.cos(n),a=Math.cos(s)*Math.sin(n)-Math.sin(s)*Math.cos(n)*Math.cos(o-i);return v(Math.atan2(r,a))}function tt({x:t,y:e},{x:i,y:o}){const s=i-t,n=o-e;if(0===s&&0===n)return 0;let r=Math.atan2(n,s);return r*=180/Math.PI,r>180?r-=360:r<-180&&(r+=360),r}function et(t){return(t+360)%360}function it(t,e,i){const o=[],s=t.length;let n,r,a,d=0;for(let s=0;s<t.length&&!(e>=d&&s===t.length-1);s++){if(d>e&&0===o.length){if(n=e-d,!n)return o.push(t[s]),o;r=Q(t[s],t[s-1])-180,a=Z(t[s],n,r),o.push(a)}if(d>=i)return n=i-d,n?(r=Q(t[s],t[s-1])-180,a=Z(t[s],n,r),o.push(a),o):(o.push(t[s]),o);if(d>=e&&o.push(t[s]),s===t.length-1)return o;d+=g(t[s],t[s+1])}if(d<e&&t.length===s)throw new Error("Start position is beyond line");const h=t[t.length-1];return[h,h]}function ot(t){return t*(Math.PI/180)}function st(t){return t*(180/Math.PI)}class nt extends z{constructor(t){super(t),this.config=void 0,this.config=t}generateInsertionCoordinates(t,e,i){const o=[t,e];let s=0;for(let t=0;t<o.length-1;t++)s+=g(o[0],o[1]);if(s<=i)return o;let n=s/i-1;Number.isInteger(n)||(n=Math.floor(n)+1);const r=[];for(let t=0;t<n;t++){const e=it(o,i*t,i*(t+1));r.push(e)}const a=[];for(let t=0;t<r.length;t++)a.push(r[t][1]);return this.limitCoordinates(a)}generateInsertionGeodesicCoordinates(t,e,i){const o=g(t,e),s=function(t,e,i){const o=[],s=ot(t[1]),n=ot(t[0]),r=ot(e[1]),a=ot(e[0]);i+=1;const d=2*Math.asin(Math.sqrt(Math.sin((r-s)/2)**2+Math.cos(s)*Math.cos(r)*Math.sin((a-n)/2)**2));if(0===d||isNaN(d))return o;for(let t=0;t<=i;t++){const e=t/i,h=Math.sin((1-e)*d)/Math.sin(d),l=Math.sin(e*d)/Math.sin(d),c=h*Math.cos(s)*Math.cos(n)+l*Math.cos(r)*Math.cos(a),u=h*Math.cos(s)*Math.sin(n)+l*Math.cos(r)*Math.sin(a),p=h*Math.sin(s)+l*Math.sin(r);if(isNaN(c)||isNaN(u)||isNaN(p))continue;const g=Math.atan2(p,Math.sqrt(c**2+u**2)),y=Math.atan2(u,c);isNaN(g)||isNaN(y)||o.push([st(y),st(g)])}return o.slice(1,-1)}(t,e,Math.floor(o/i));return this.limitCoordinates(s)}limitCoordinates(t){return t.map(t=>[C(t[0],this.config.coordinatePrecision),C(t[1],this.config.coordinatePrecision)])}}function rt(t,e){return t[0]===e[0]&&t[1]===e[1]}function at(t,e){if("LineString"!==t.geometry.type)return{valid:!1,reason:"Feature is not a LineString"};if(t.geometry.coordinates.length<2)return{valid:!1,reason:"Feature has less than 2 coordinates"};for(let i=0;i<t.geometry.coordinates.length;i++){if(!_(t.geometry.coordinates[i]))return{valid:!1,reason:"Feature has invalid coordinates"};if(!O(t.geometry.coordinates[i],e))return{valid:!1,reason:"Feature has coordinates with excessive precision"}}return{valid:!0}}function dt(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2))}function ht(t,e){const i=function(t,e){const[i,o,s]=t,[n,r,a]=e;return i*n+o*r+s*a}(t,e)/(dt(t)*dt(e));return Math.acos(Math.min(Math.max(i,-1),1))}function lt(t){const e=f(t[1]),i=f(t[0]);return[Math.cos(e)*Math.cos(i),Math.cos(e)*Math.sin(i),Math.sin(e)]}function ct(t){const[e,i,o]=t,s=v(Math.asin(o));return[v(Math.atan2(i,e)),s]}function ut(t,e,i){const o=lt(t),s=lt(e),n=lt(i),[r,a,d]=n,[h,l,c]=function(t,e){const[i,o,s]=t,[n,r,a]=e;return[o*a-s*r,s*n-i*a,i*r-o*n]}(o,s),u=l*d-c*a,p=c*r-h*d,y=h*a-l*r,f=y*l-p*c,m=u*c-y*h,v=p*h-u*l,C=1/Math.sqrt(Math.pow(f,2)+Math.pow(m,2)+Math.pow(v,2)),P=[f*C,m*C,v*C],I=[-1*f*C,-1*m*C,-1*v*C],x=ht(o,s),E=ht(o,P),S=ht(s,P),M=ht(o,I),F=ht(s,I);let D;return D=E<M&&E<F||S<M&&S<F?P:I,ht(o,D)>x||ht(s,D)>x?g(ct(D),ct(o))<=g(ct(D),ct(s))?[ct(o),!0,!1]:[ct(s),!1,!0]:[ct(D),!1,!1]}function pt(t,e,i){const o=e.x-t.x,s=e.y-t.y,n=Math.max(0,Math.min(1,((i.x-t.x)*o+(i.y-t.y)*s)/(o*o+s*s)));return{x:t.x+n*o,y:t.y+n*s}}class gt extends z{constructor(t,e,i){super(t),this.config=void 0,this.pixelDistance=void 0,this.clickBoundingBox=void 0,this.getSnappableCoordinateFirstClick=t=>{const e=this.getSnappable(t,t=>Boolean(t.properties&&t.properties.mode===this.mode));return e.coordinate?[C(e.coordinate[0],this.config.coordinatePrecision),C(e.coordinate[1],this.config.coordinatePrecision)]:void 0},this.getSnappableCoordinate=(t,e)=>{const i=this.getSnappable(t,t=>Boolean(t.properties&&t.properties.mode===this.mode&&t.id!==e));return i.coordinate?[C(i.coordinate[0],this.config.coordinatePrecision),C(i.coordinate[1],this.config.coordinatePrecision)]:void 0},this.config=t,this.pixelDistance=e,this.clickBoundingBox=i}getSnappable(t,e){const i=this.clickBoundingBox.create(t),o=this.store.search(i,e),s={featureId:void 0,featureCoordinateIndex:void 0,coordinate:void 0,minDistance:Infinity};return o.forEach(e=>{let i;if("Polygon"===e.geometry.type)i=e.geometry.coordinates[0];else{if("LineString"!==e.geometry.type)return;i=e.geometry.coordinates}const o=[];for(let t=0;t<i.length-1;t++)o.push([i[t],i[t+1]]);let n;const r=[t.lng,t.lat];if("web-mercator"===this.config.projection?n=function(t,e){let i=[Infinity,Infinity],o=Infinity,s=0;for(let n of e){const r=n[0],a=n[1];let d,h=Infinity;const l=E(r[0],r[1]),c=E(a[0],a[1]),u=E(t[0],t[1]);if(r[0]===t[0]&&r[1]===t[1])d=r;else if(a[0]===t[0]&&a[1]===t[1])d=a;else{const{x:t,y:e}=pt(l,c,u),{lng:i,lat:o}=S(t,e);d=[i,o]}d&&(h=U(u,E(d[0],d[1])),h<o&&(i=d,o=h,s=e.indexOf(n)))}return Infinity===o?void 0:{coordinate:i,lineIndex:s,distance:o}}(r,o):"globe"===this.config.projection&&(n=function(t,e){let i=[Infinity,Infinity],o=Infinity,s=0;for(let n of e){const r=n[0],a=n[1];let d,h=Infinity;r[0]===t[0]&&r[1]===t[1]?d=r:a[0]===t[0]&&a[1]===t[1]?d=a:[d]=ut(r,a,t),d&&(h=g(t,d),h<o&&(i=d,o=h,s=e.indexOf(n)))}return Infinity===o?void 0:{coordinate:i,distance:o,lineIndex:s}}(r,o)),!n)return;const a=this.pixelDistance.measure(t,n.coordinate);a<s.minDistance&&a<this.pointerDistance&&(s.featureId=e.id,s.coordinate=[C(n.coordinate[0],this.config.coordinatePrecision),C(n.coordinate[1],this.config.coordinatePrecision)],s.featureCoordinateIndex=n.lineIndex,s.minDistance=a)}),s}}const yt={cancel:"Escape",finish:"Enter"},ft={start:"crosshair",close:"pointer",dragStart:"grabbing",dragEnd:"crosshair"};class mt extends u{constructor(t){super(t,!0),this.mode="linestring",this.currentCoordinate=0,this.currentId=void 0,this.closingPointId=void 0,this.keyEvents=yt,this.snapping=void 0,this.cursors=ft,this.mouseMove=!1,this.insertCoordinates=void 0,this.lastCommittedCoordinates=void 0,this.snappedPointId=void 0,this.lastMouseMoveEvent=void 0,this.editable=!1,this.editedFeatureId=void 0,this.editedFeatureCoordinateIndex=void 0,this.editedSnapType=void 0,this.editedInsertIndex=void 0,this.editedPointId=void 0,this.coordinateSnapping=void 0,this.insertPoint=void 0,this.lineSnapping=void 0,this.pixelDistance=void 0,this.clickBoundingBox=void 0,this.updateOptions(t)}updateOptions(e){super.updateOptions(e),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors)),null!=e&&e.snapping&&(this.snapping=e.snapping),null===(null==e?void 0:e.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents)),null!=e&&e.insertCoordinates&&(this.insertCoordinates=e.insertCoordinates),e&&e.editable&&(this.editable=e.editable)}updateSnappedCoordinate(t){const e=this.snapCoordinate(t);if(e){if(this.snappedPointId)this.store.updateGeometry([{id:this.snappedPointId,geometry:{type:"Point",coordinates:e}}]);else{const[t]=this.store.create([{geometry:{type:"Point",coordinates:e},properties:{mode:this.mode,[o.SNAPPING_POINT]:!0}}]);this.snappedPointId=t}t.lng=e[0],t.lat=e[1]}else this.snappedPointId&&(this.store.delete([this.snappedPointId]),this.snappedPointId=void 0);return e}close(){if(void 0===this.currentId)return;const t=this.store.getGeometryCopy(this.currentId);t.coordinates.pop(),this.updateGeometries([...t.coordinates],void 0,e.Commit),this.store.updateProperty([{id:this.currentId,property:o.CURRENTLY_DRAWING,value:void 0}]);const i=this.currentId;this.closingPointId&&this.store.delete([this.closingPointId]),this.snappedPointId&&this.store.delete([this.snappedPointId]),this.currentCoordinate=0,this.currentId=void 0,this.closingPointId=void 0,this.snappedPointId=void 0,this.lastCommittedCoordinates=void 0,"drawing"===this.state&&this.setStarted(),this.onFinish(i,{mode:this.mode,action:"draw"})}updateGeometries(t,e,i){if(!this.currentId)return;const o={type:"LineString",coordinates:t};if(this.validate&&!this.validate({type:"Feature",geometry:o},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:i}).valid)return;const s=[{id:this.currentId,geometry:o}];this.closingPointId&&e&&s.push({id:this.closingPointId,geometry:{type:"Point",coordinates:e}}),"commit"===i&&(this.lastCommittedCoordinates=o.coordinates),this.store.updateGeometry(s)}generateInsertCoordinates(t,e){if(!this.insertCoordinates||!this.lastCommittedCoordinates)throw new Error("Not able to insert coordinates");if("amount"!==this.insertCoordinates.strategy)throw new Error("Strategy does not exist");const i=g(t,e)/(this.insertCoordinates.value+1);let o=[];return"globe"===this.projection?o=this.insertPoint.generateInsertionGeodesicCoordinates(t,e,i):"web-mercator"===this.projection&&(o=this.insertPoint.generateInsertionCoordinates(t,e,i)),o}createLine(t){const[e]=this.store.create([{geometry:{type:"LineString",coordinates:[t,t]},properties:{mode:this.mode,[o.CURRENTLY_DRAWING]:!0}}]);this.lastCommittedCoordinates=[t,t],this.currentId=e,this.currentCoordinate++,this.setDrawing()}firstUpdateToLine(t){if(!this.currentId)return;const i=this.store.getGeometryCopy(this.currentId).coordinates,[s]=this.store.create([{geometry:{type:"Point",coordinates:[...t]},properties:{mode:this.mode,[o.CLOSING_POINT]:!0}}]);this.closingPointId=s,this.setCursor(this.cursors.close);const n=[...i,t];this.updateGeometries(n,void 0,e.Commit),this.currentCoordinate++}updateToLine(t,i){if(!this.currentId)return;const o=this.store.getGeometryCopy(this.currentId).coordinates,[s,n]=this.lastCommittedCoordinates?this.lastCommittedCoordinates[this.lastCommittedCoordinates.length-1]:o[o.length-2],{x:r,y:a}=this.project(s,n);if(U({x:r,y:a},{x:i.x,y:i.y})<this.pointerDistance)return void this.close();this.setCursor(this.cursors.close);const d=[...o,t];this.updateGeometries(d,o[o.length-1],e.Commit),this.currentCoordinate++}registerBehaviors(t){this.coordinateSnapping=new q(t,new $(t),new H(t)),this.insertPoint=new nt(t),this.clickBoundingBox=new H(t),this.pixelDistance=new $(t),this.lineSnapping=new gt(t,this.pixelDistance,this.clickBoundingBox),this.coordinateSnapping=new q(t,this.pixelDistance,this.clickBoundingBox)}start(){this.setStarted(),this.setCursor(this.cursors.start)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onMouseMove(t){this.mouseMove=!0,this.setCursor(this.cursors.start),this.lastMouseMoveEvent=t;const i=this.updateSnappedCoordinate(t)||[t.lng,t.lat];if(void 0===this.currentId||0===this.currentCoordinate)return;const o=this.store.getGeometryCopy(this.currentId).coordinates;if(o.pop(),this.closingPointId){const[e,i]=o[o.length-1],{x:s,y:n}=this.project(e,i);U({x:s,y:n},{x:t.containerX,y:t.containerY})<this.pointerDistance&&this.setCursor(this.cursors.close)}let s=[...o,i];if(this.insertCoordinates&&this.currentId&&this.lastCommittedCoordinates){const t=this.lastCommittedCoordinates[this.lastCommittedCoordinates.length-1],e=i;if(!rt(t,e)){const o=this.generateInsertCoordinates(t,e);s=[...this.lastCommittedCoordinates.slice(0,-1),...o,i]}}this.updateGeometries(s,void 0,e.Provisional)}onRightClick(t){if(!this.editable||"started"!==this.state)return;const{featureId:i,featureCoordinateIndex:o}=this.coordinateSnapping.getSnappable(t,t=>this.lineStringFilter(t));if(!i||void 0===o)return;const s=this.store.getGeometryCopy(i);let n;if("LineString"===s.type&&(n=s.coordinates,!(n.length<=2))){if(n.splice(o,1),this.validate&&!this.validate({id:i,type:"Feature",geometry:s,properties:{}},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Commit}).valid)return;this.snappedPointId&&(this.store.delete([this.snappedPointId]),this.snappedPointId=void 0),this.store.updateGeometry([{id:i,geometry:s}]),this.onFinish(i,{mode:this.mode,action:"edit"})}}onLeftClick(t){this.snappedPointId&&(this.store.delete([this.snappedPointId]),this.snappedPointId=void 0);const e=this.snapCoordinate(t)||[t.lng,t.lat];0===this.currentCoordinate?this.createLine(e):1===this.currentCoordinate&&this.currentId?this.firstUpdateToLine(e):this.currentId&&this.updateToLine(e,{x:t.containerX,y:t.containerY})}onClick(t){("right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t))&&(this.currentCoordinate>0&&!this.mouseMove&&this.onMouseMove(t),this.mouseMove=!1,"right"===t.button?this.onRightClick(t):"left"===t.button&&this.onLeftClick(t))}onKeyDown(){}onKeyUp(t){t.key===this.keyEvents.cancel&&this.cleanUp(),t.key===this.keyEvents.finish&&this.close()}onDragStart(t,e){if(!this.allowPointerEvent(this.pointerEvents.onDragStart,t))return;if(!this.editable)return;let i;if("started"===this.state){const e=this.lineSnapping.getSnappable(t,t=>this.lineStringFilter(t));e.coordinate&&(this.editedSnapType="line",this.editedFeatureCoordinateIndex=e.featureCoordinateIndex,this.editedFeatureId=e.featureId,i=e.coordinate);const o=this.coordinateSnapping.getSnappable(t,t=>this.lineStringFilter(t));o.coordinate&&(this.editedSnapType="coordinate",this.editedFeatureCoordinateIndex=o.featureCoordinateIndex,this.editedFeatureId=o.featureId,i=o.coordinate)}if(this.editedFeatureId&&i){if(!this.editedPointId){const[t]=this.store.create([{geometry:{type:"Point",coordinates:i},properties:{mode:this.mode,[o.EDITED]:!0}}]);this.editedPointId=t}this.setCursor(this.cursors.dragStart),e(!1)}}onDrag(t,i){if(!this.allowPointerEvent(this.pointerEvents.onDrag,t))return;if(void 0===this.editedFeatureId||void 0===this.editedFeatureCoordinateIndex)return;const s=this.store.getGeometryCopy(this.editedFeatureId);"coordinate"===this.editedSnapType||"line"===this.editedSnapType&&void 0!==this.editedInsertIndex?s.coordinates[this.editedFeatureCoordinateIndex]=[t.lng,t.lat]:"line"===this.editedSnapType&&void 0===this.editedInsertIndex&&(this.editedInsertIndex=this.editedFeatureCoordinateIndex+1,s.coordinates.splice(this.editedInsertIndex,0,[t.lng,t.lat]),this.editedFeatureCoordinateIndex++);const n={type:"LineString",coordinates:s.coordinates};this.validate&&!this.validate({type:"Feature",geometry:n,properties:this.store.getPropertiesCopy(this.editedFeatureId)},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Provisional}).valid||(this.snapping&&this.snappedPointId&&(this.store.delete([this.snappedPointId]),this.snappedPointId=void 0),this.store.updateGeometry([{id:this.editedFeatureId,geometry:n}]),this.editedPointId&&this.store.updateGeometry([{id:this.editedPointId,geometry:{type:"Point",coordinates:[t.lng,t.lat]}}]),this.store.updateProperty([{id:this.editedFeatureId,property:o.EDITED,value:!0}]))}onDragEnd(t,e){this.allowPointerEvent(this.pointerEvents.onDragEnd,t)&&void 0!==this.editedFeatureId&&(this.setCursor(this.cursors.dragEnd),this.editedPointId&&(this.store.delete([this.editedPointId]),this.editedPointId=void 0),this.store.updateProperty([{id:this.editedFeatureId,property:o.EDITED,value:!1}]),this.onFinish(this.editedFeatureId,{mode:this.mode,action:"edit"}),this.editedFeatureId=void 0,this.editedFeatureCoordinateIndex=void 0,this.editedInsertIndex=void 0,this.editedSnapType=void 0,e(!0))}cleanUp(){const t=this.currentId,e=this.closingPointId,i=this.snappedPointId;this.closingPointId=void 0,this.snappedPointId=void 0,this.currentId=void 0,this.currentCoordinate=0,"drawing"===this.state&&this.setStarted();try{void 0!==t&&this.store.delete([t]),void 0!==i&&this.store.delete([i]),void 0!==e&&this.store.delete([e])}catch(t){}}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});if("Feature"===e.type&&"LineString"===e.geometry.type&&e.properties.mode===this.mode)return i.lineStringColor=this.getHexColorStylingValue(this.styles.lineStringColor,i.lineStringColor,e),i.lineStringWidth=this.getNumericStylingValue(this.styles.lineStringWidth,i.lineStringWidth,e),i.zIndex=s,i;if("Feature"===e.type&&"Point"===e.geometry.type&&e.properties.mode===this.mode){const t=e.properties[o.CLOSING_POINT];return i.pointColor=this.getHexColorStylingValue(t?this.styles.closingPointColor:this.styles.snappingPointColor,i.pointColor,e),i.pointWidth=this.getNumericStylingValue(t?this.styles.closingPointWidth:this.styles.snappingPointWidth,i.pointWidth,e),i.pointOutlineColor=this.getHexColorStylingValue(t?this.styles.closingPointOutlineColor:this.styles.snappingPointOutlineColor,"#ffffff",e),i.pointOutlineWidth=this.getNumericStylingValue(t?this.styles.closingPointOutlineWidth:this.styles.snappingPointOutlineWidth,2,e),i.zIndex=50,i}return i}validateFeature(t){return this.validateModeFeature(t,t=>at(t,this.coordinatePrecision))}lineStringFilter(t){return Boolean("LineString"===t.geometry.type&&t.properties&&t.properties.mode===this.mode)}snapCoordinate(t){var e,i,o;let s;if(null!=(e=this.snapping)&&e.toLine){let e;e=this.currentId?this.lineSnapping.getSnappableCoordinate(t,this.currentId):this.lineSnapping.getSnappableCoordinateFirstClick(t),e&&(s=e)}return null!=(i=this.snapping)&&i.toCoordinate&&(s=this.currentId?this.coordinateSnapping.getSnappableCoordinate(t,this.currentId):this.coordinateSnapping.getSnappableCoordinateFirstClick(t)),null!=(o=this.snapping)&&o.toCustom&&(s=this.snapping.toCustom(t,{currentCoordinate:this.currentCoordinate,currentId:this.currentId,getCurrentGeometrySnapshot:this.currentId?()=>this.store.getGeometryCopy(this.currentId):()=>null,project:this.project,unproject:this.unproject})),s}afterFeatureUpdated(t){this.editedFeatureId===t.id&&this.editedPointId&&(this.store.delete([this.editedPointId]),this.editedPointId=void 0,this.editedFeatureId=void 0,this.editedFeatureCoordinateIndex=void 0,this.editedSnapType=void 0),this.snappedPointId&&this.lastMouseMoveEvent&&this.updateSnappedCoordinate(this.lastMouseMoveEvent),this.currentId===t.id&&(this.closingPointId&&(this.store.delete([this.closingPointId]),this.closingPointId=void 0),this.currentCoordinate=0,this.currentId=void 0,"drawing"===this.state&&this.setStarted())}}const vt="Feature is not a Point",Ct="Feature has invalid coordinates",Pt="Feature has coordinates with excessive precision";function It(t,e){return"Point"!==t.geometry.type?{valid:!1,reason:vt}:_(t.geometry.coordinates)?O(t.geometry.coordinates,e)?{valid:!0}:{valid:!1,reason:Pt}:{valid:!1,reason:Ct}}const xt={create:"crosshair",dragStart:"grabbing",dragEnd:"crosshair"};class Et extends u{constructor(t){super(t,!0),this.mode="point",this.cursors=xt,this.editable=!1,this.editedFeatureId=void 0,this.pixelDistance=void 0,this.clickBoundingBox=void 0,this.updateOptions(t)}updateOptions(e){super.updateOptions(e),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors)),null!=e&&e.editable&&(this.editable=e.editable)}start(){this.setStarted(),this.setCursor(this.cursors.create)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onClick(t){"right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t)?this.onRightClick(t):"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)&&this.onLeftClick(t)}onMouseMove(){}onKeyDown(){}onKeyUp(){}cleanUp(){this.editedFeatureId=void 0}onDragStart(t,e){if(this.allowPointerEvent(this.pointerEvents.onDragStart,t)){if(this.editable){const e=this.getNearestPointFeature(t);this.editedFeatureId=null==e?void 0:e.id}this.editedFeatureId&&(this.setCursor(this.cursors.dragStart),e(!1))}}onDrag(t,i){this.allowPointerEvent(this.pointerEvents.onDrag,t)&&void 0!==this.editedFeatureId&&(this.validate&&!this.validate({type:"Feature",geometry:{type:"Point",coordinates:[t.lng,t.lat]},properties:this.store.getPropertiesCopy(this.editedFeatureId)},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Finish}).valid||(this.store.updateGeometry([{id:this.editedFeatureId,geometry:{type:"Point",coordinates:[t.lng,t.lat]}}]),this.store.updateProperty([{id:this.editedFeatureId,property:o.EDITED,value:!0}])))}onDragEnd(t,e){this.allowPointerEvent(this.pointerEvents.onDragEnd,t)&&void 0!==this.editedFeatureId&&(this.onFinish(this.editedFeatureId,{mode:this.mode,action:"edit"}),this.setCursor(this.cursors.dragEnd),this.store.updateProperty([{id:this.editedFeatureId,property:o.EDITED,value:!1}]),this.editedFeatureId=void 0,e(!0))}registerBehaviors(t){this.pixelDistance=new $(t),this.clickBoundingBox=new H(t)}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});if("Feature"===e.type&&"Point"===e.geometry.type&&e.properties.mode===this.mode){const t=Boolean(e.id&&this.editedFeatureId===e.id);i.pointWidth=this.getNumericStylingValue(t?this.styles.editedPointWidth:this.styles.pointWidth,i.pointWidth,e),i.pointColor=this.getHexColorStylingValue(t?this.styles.editedPointColor:this.styles.pointColor,i.pointColor,e),i.pointOutlineColor=this.getHexColorStylingValue(t?this.styles.editedPointOutlineColor:this.styles.pointOutlineColor,i.pointOutlineColor,e),i.pointOutlineWidth=this.getNumericStylingValue(t?this.styles.editedPointOutlineWidth:this.styles.pointOutlineWidth,2,e),i.zIndex=30}return i}validateFeature(t){return this.validateModeFeature(t,t=>It(t,this.coordinatePrecision))}onLeftClick(t){const i={type:"Point",coordinates:[t.lng,t.lat]},o={mode:this.mode};if(this.validate&&!this.validate({type:"Feature",geometry:i,properties:o},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Finish}).valid)return;const[s]=this.store.create([{geometry:i,properties:o}]);this.onFinish(s,{mode:this.mode,action:"draw"})}onRightClick(t){if(!this.editable)return;const e=this.getNearestPointFeature(t);e&&this.store.delete([e.id])}getNearestPointFeature(t){const e=this.clickBoundingBox.create(t),i=this.store.search(e);let o,s=Infinity;for(let e=0;e<i.length;e++){const n=i[e];if("Point"!==n.geometry.type||n.properties.mode!==this.mode)continue;const r=this.pixelDistance.measure(t,n.geometry.coordinates);r>s||r>this.pointerDistance||(s=r,o=n)}return o}afterFeatureUpdated(t){this.editedFeatureId===t.id&&(this.editedFeatureId=void 0,this.setCursor(this.cursors.create))}}class St extends z{constructor(t,e){super(t),this.config=void 0,this.pixelDistance=void 0,this._startEndPoints=[],this.config=t,this.pixelDistance=e}get ids(){return this._startEndPoints.concat()}set ids(t){}create(t,e){if(this.ids.length)throw new Error("Opening and closing points already created");if(t.length<=3)throw new Error("Requires at least 4 coordinates");this._startEndPoints=this.store.create([{geometry:{type:"Point",coordinates:t[0]},properties:{mode:e,[o.CLOSING_POINT]:!0}},{geometry:{type:"Point",coordinates:t[t.length-2]},properties:{mode:e,[o.CLOSING_POINT]:!0}}])}delete(){this.ids.length&&(this.store.delete(this.ids),this._startEndPoints=[])}update(t){if(2!==this.ids.length)throw new Error("No closing points to update");this.store.updateGeometry([{id:this.ids[0],geometry:{type:"Point",coordinates:t[0]}},{id:this.ids[1],geometry:{type:"Point",coordinates:t[t.length-3]}}])}isClosingPoint(t){const e=this.store.getGeometryCopy(this.ids[0]),i=this.store.getGeometryCopy(this.ids[1]),o=this.pixelDistance.measure(t,e.coordinates),s=this.pixelDistance.measure(t,i.coordinates);return{isClosing:o<this.pointerDistance,isPreviousClosing:s<this.pointerDistance}}}class Mt extends z{constructor(t){super(t)}createOrUpdate(t){const e=this.store.getGeometryCopy(t),i=this.store.getPropertiesCopy(t);let o;if("Polygon"===e.type)o=e.coordinates[0].slice(0,-1);else{if("LineString"!==e.type)return;o=e.coordinates}const s=this.store.getPropertiesCopy(t),n=s.coordinatePointIds;if(n)if(n&&n.every(t=>this.store.has(t))){const e=s.coordinatePointIds,n=e.map(t=>this.store.getGeometryCopy(t).coordinates);if(e.length!==o.length){this.deleteCoordinatePoints(e);const s=this.createPoints(o,i.mode,t);this.setFeatureCoordinatePoints(t,s)}else o.forEach((t,i)=>{t[0]===n[i][0]&&t[1]===n[i][1]||this.store.updateGeometry([{id:e[i],geometry:{type:"Point",coordinates:t}}])})}else{const e=n.filter(t=>this.store.has(t));e.length&&this.deleteCoordinatePoints(e);const s=this.createPoints(o,i.mode,t);this.setFeatureCoordinatePoints(t,s)}else{const e=this.createPoints(o,i.mode,t);this.setFeatureCoordinatePoints(t,e)}}deletePointsByFeatureIds(t){for(const e of t)this.deleteIfPresent(e)}getUpdated(e,i){const o=this.store.getPropertiesCopy(e);if(o.coordinatePointIds)return o.coordinatePointIds.map((e,o)=>({id:e,geometry:t({},this.store.getGeometryCopy(e),{coordinates:i[o]})}))}createPoints(t,e,i){return this.store.create(t.map((t,s)=>({geometry:{type:"Point",coordinates:t},properties:{mode:e,[o.COORDINATE_POINT]:!0,[o.COORDINATE_POINT_FEATURE_ID]:i,index:s}})))}setFeatureCoordinatePoints(t,e){this.store.updateProperty([{id:t,property:o.COORDINATE_POINT_IDS,value:e}])}deleteCoordinatePoints(t){const e=t.filter(t=>this.store.has(t));this.store.delete(e)}deleteIfPresent(t){const e=this.store.getPropertiesCopy(t).coordinatePointIds;e&&(this.deleteCoordinatePoints(e),this.setFeatureCoordinatePoints(t,null))}}const Ft={cancel:"Escape",finish:"Enter"},Dt={start:"crosshair",close:"pointer",dragStart:"grabbing",dragEnd:"crosshair"};class wt extends u{constructor(t){super(t,!0),this.mode="polygon",this.currentCoordinate=0,this.currentId=void 0,this.keyEvents=Ft,this.cursors=Dt,this.mouseMove=!1,this.showCoordinatePoints=!1,this.lastMouseMoveEvent=void 0,this.snapping=void 0,this.snappedPointId=void 0,this.editable=!1,this.editedFeatureId=void 0,this.editedFeatureCoordinateIndex=void 0,this.editedSnapType=void 0,this.editedInsertIndex=void 0,this.editedPointId=void 0,this.coordinatePoints=void 0,this.lineSnapping=void 0,this.coordinateSnapping=void 0,this.pixelDistance=void 0,this.closingPoints=void 0,this.clickBoundingBox=void 0,this.updateOptions(t)}updateOptions(e){if(super.updateOptions(e),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors)),null===(null==e?void 0:e.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents)),null!=e&&e.snapping&&(this.snapping=e.snapping),void 0!==(null==e?void 0:e.editable)&&(this.editable=e.editable),void 0!==(null==e?void 0:e.pointerEvents)&&(this.pointerEvents=e.pointerEvents),void 0!==(null==e?void 0:e.showCoordinatePoints))if(this.showCoordinatePoints=e.showCoordinatePoints,this.coordinatePoints&&!0===e.showCoordinatePoints)this.store.copyAllWhere(t=>t.mode===this.mode).map(t=>t.id).forEach(t=>{this.coordinatePoints.createOrUpdate(t)});else if(this.coordinatePoints&&!1===this.showCoordinatePoints){const t=this.store.copyAllWhere(t=>t.mode===this.mode&&Boolean(t[o.COORDINATE_POINT_IDS]));this.coordinatePoints.deletePointsByFeatureIds(t.map(t=>t.id))}}close(){if(void 0===this.currentId)return;const t=this.store.getGeometryCopy(this.currentId).coordinates[0];if(t.length<5)return;if(!this.updatePolygonGeometry([...t.slice(0,-2),t[0]],e.Finish))return;const i=this.currentId;if(this.currentId){const t=A(this.store.getGeometryCopy(this.currentId));t&&(this.store.updateGeometry([{id:this.currentId,geometry:t}]),this.showCoordinatePoints&&this.coordinatePoints.createOrUpdate(this.currentId)),this.store.updateProperty([{id:this.currentId,property:o.CURRENTLY_DRAWING,value:void 0},{id:this.currentId,property:o.COMMITTED_COORDINATE_COUNT,value:void 0},{id:this.currentId,property:o.PROVISIONAL_COORDINATE_COUNT,value:void 0}])}this.snappedPointId&&this.store.delete([this.snappedPointId]),this.currentCoordinate=0,this.currentId=void 0,this.snappedPointId=void 0,this.closingPoints.delete(),"drawing"===this.state&&this.setStarted(),this.onFinish(i,{mode:this.mode,action:"draw"})}registerBehaviors(t){this.clickBoundingBox=new H(t),this.pixelDistance=new $(t),this.lineSnapping=new gt(t,this.pixelDistance,this.clickBoundingBox),this.coordinateSnapping=new q(t,this.pixelDistance,this.clickBoundingBox),this.closingPoints=new St(t,this.pixelDistance),this.coordinatePoints=new Mt(t)}start(){this.setStarted(),this.setCursor(this.cursors.start)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}updateSnappedCoordinate(t){const e=this.snapCoordinate(t);if(e){if(this.snappedPointId)this.store.updateGeometry([{id:this.snappedPointId,geometry:{type:"Point",coordinates:e}}]);else{const[t]=this.store.create([{geometry:{type:"Point",coordinates:e},properties:{mode:this.mode,[o.SNAPPING_POINT]:!0}}]);this.snappedPointId=t}t.lng=e[0],t.lat=e[1]}else this.snappedPointId&&(this.store.delete([this.snappedPointId]),this.snappedPointId=void 0)}onMouseMove(t){if(this.mouseMove=!0,this.setCursor(this.cursors.start),this.lastMouseMoveEvent=t,this.updateSnappedCoordinate(t),void 0===this.currentId||0===this.currentCoordinate)return;const i=this.store.getGeometryCopy(this.currentId).coordinates[0];let s;if(1===this.currentCoordinate){const e=1/Math.pow(10,this.coordinatePrecision-1),o=Math.max(1e-6,e);s=[i[0],[t.lng,t.lat],[t.lng,t.lat-o],i[0]]}else if(2===this.currentCoordinate)s=[i[0],i[1],[t.lng,t.lat],i[0]];else{const{isClosing:e,isPreviousClosing:o}=this.closingPoints.isClosingPoint(t);o||e?(this.snappedPointId&&(this.store.delete([this.snappedPointId]),this.snappedPointId=void 0),this.setCursor(this.cursors.close),s=[...i.slice(0,-2),i[0],i[0]]):s=[...i.slice(0,-2),[t.lng,t.lat],i[0]]}this.store.updateProperty([{id:this.currentId,property:o.PROVISIONAL_COORDINATE_COUNT,value:this.currentCoordinate+1}]),this.updatePolygonGeometry(s,e.Provisional)}updatePolygonGeometry(t,e){if(!this.currentId)return!1;const i={type:"Polygon",coordinates:[t]};return!(this.validate&&!this.validate({type:"Feature",geometry:i},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e}).valid||(this.store.updateGeometry([{id:this.currentId,geometry:i}]),this.showCoordinatePoints&&this.coordinatePoints.createOrUpdate(this.currentId),0))}snapCoordinate(t){var e,i,o;let s;if(null!=(e=this.snapping)&&e.toLine){let e;e=this.currentId?this.lineSnapping.getSnappableCoordinate(t,this.currentId):this.lineSnapping.getSnappableCoordinateFirstClick(t),e&&(s=e)}if(null!=(i=this.snapping)&&i.toCoordinate){let e;e=this.currentId?this.coordinateSnapping.getSnappableCoordinate(t,this.currentId):this.coordinateSnapping.getSnappableCoordinateFirstClick(t),e&&(s=e)}return null!=(o=this.snapping)&&o.toCustom&&(s=this.snapping.toCustom(t,{currentCoordinate:this.currentCoordinate,currentId:this.currentId,getCurrentGeometrySnapshot:this.currentId?()=>this.store.getGeometryCopy(this.currentId):()=>null,project:this.project,unproject:this.unproject})),s}polygonFilter(t){return Boolean("Polygon"===t.geometry.type&&t.properties&&t.properties.mode===this.mode)}onRightClick(t){if(!this.editable||"started"!==this.state)return;const{featureId:i,featureCoordinateIndex:o}=this.coordinateSnapping.getSnappable(t,t=>this.polygonFilter(t));if(!i||void 0===o)return;const s=this.store.getGeometryCopy(i);let n;"Polygon"===s.type&&(n=s.coordinates[0],n.length<=4||("Polygon"!==s.type||0!==o&&o!==n.length-1?n.splice(o,1):(n.shift(),n.pop(),n.push([n[0][0],n[0][1]])),(!this.validate||this.validate({id:i,type:"Feature",geometry:s,properties:{}},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Commit}).valid)&&(this.snappedPointId&&(this.store.delete([this.snappedPointId]),this.snappedPointId=void 0),this.store.updateGeometry([{id:i,geometry:s}]),this.showCoordinatePoints&&this.coordinatePoints.createOrUpdate(i),this.onFinish(i,{mode:this.mode,action:"edit"}))))}onLeftClick(t){if(this.snappedPointId&&(this.store.delete([this.snappedPointId]),this.snappedPointId=void 0),0===this.currentCoordinate){const e=this.snapCoordinate(t);e&&(t.lng=e[0],t.lat=e[1]);const[i]=this.store.create([{geometry:{type:"Polygon",coordinates:[[[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat]]]},properties:{mode:this.mode,[o.CURRENTLY_DRAWING]:!0,[o.COMMITTED_COORDINATE_COUNT]:this.currentCoordinate+1,[o.PROVISIONAL_COORDINATE_COUNT]:this.currentCoordinate+1}}]);this.currentId=i,this.currentCoordinate++,this.showCoordinatePoints&&this.coordinatePoints.createOrUpdate(i),this.setDrawing()}else if(1===this.currentCoordinate&&this.currentId){const i=this.snapCoordinate(t);i&&(t.lng=i[0],t.lat=i[1]);const s=this.store.getGeometryCopy(this.currentId);if(rt([t.lng,t.lat],s.coordinates[0][0]))return;if(!this.updatePolygonGeometry([s.coordinates[0][0],[t.lng,t.lat],[t.lng,t.lat],s.coordinates[0][0]],e.Commit))return;this.store.updateProperty([{id:this.currentId,property:o.COMMITTED_COORDINATE_COUNT,value:this.currentCoordinate+1}]),this.currentCoordinate++}else if(2===this.currentCoordinate&&this.currentId){const i=this.snapCoordinate(t);i&&(t.lng=i[0],t.lat=i[1]);const s=this.store.getGeometryCopy(this.currentId).coordinates[0];if(rt([t.lng,t.lat],s[1]))return;if(!this.updatePolygonGeometry([s[0],s[1],[t.lng,t.lat],[t.lng,t.lat],s[0]],e.Commit))return;2===this.currentCoordinate&&this.closingPoints.create(s,"polygon"),this.store.updateProperty([{id:this.currentId,property:o.COMMITTED_COORDINATE_COUNT,value:this.currentCoordinate+1}]),this.currentCoordinate++}else if(this.currentId){const i=this.store.getGeometryCopy(this.currentId).coordinates[0],{isClosing:s,isPreviousClosing:n}=this.closingPoints.isClosingPoint(t);if(n||s)this.close();else{const s=this.snapCoordinate(t);if(s&&(t.lng=s[0],t.lat=s[1]),rt([t.lng,t.lat],i[this.currentCoordinate-1]))return;const n=function(t=[[[0,0],[0,1],[1,1],[1,0],[0,0]]]){return{type:"Feature",geometry:{type:"Polygon",coordinates:t},properties:{}}}([[...i.slice(0,-1),[t.lng,t.lat],i[0]]]);if(!this.updatePolygonGeometry(n.geometry.coordinates[0],e.Commit))return;this.store.updateProperty([{id:this.currentId,property:o.COMMITTED_COORDINATE_COUNT,value:this.currentCoordinate+1}]),this.currentCoordinate++,this.closingPoints.ids.length&&this.closingPoints.update(n.geometry.coordinates[0])}}}onClick(t){this.currentCoordinate>0&&!this.mouseMove&&this.onMouseMove(t),this.mouseMove=!1,"right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t)?this.onRightClick(t):"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)&&this.onLeftClick(t)}onKeyUp(t){t.key===this.keyEvents.cancel?this.cleanUp():t.key===this.keyEvents.finish&&this.close()}onKeyDown(){}onDragStart(t,e){if(!this.allowPointerEvent(this.pointerEvents.onDragStart,t))return;if(!this.editable)return;let i;if("started"===this.state){const e=this.lineSnapping.getSnappable(t,t=>this.polygonFilter(t));e.coordinate&&(this.editedSnapType="line",this.editedFeatureCoordinateIndex=e.featureCoordinateIndex,this.editedFeatureId=e.featureId,i=e.coordinate);const o=this.coordinateSnapping.getSnappable(t,t=>this.polygonFilter(t));o.coordinate&&(this.editedSnapType="coordinate",this.editedFeatureCoordinateIndex=o.featureCoordinateIndex,this.editedFeatureId=o.featureId,i=o.coordinate)}if(this.editedFeatureId&&i){if(!this.editedPointId){const[t]=this.store.create([{geometry:{type:"Point",coordinates:i},properties:{mode:this.mode,[o.EDITED]:!0}}]);this.editedPointId=t}this.setCursor(this.cursors.dragStart),e(!1)}}onDrag(t,i){if(!this.allowPointerEvent(this.pointerEvents.onDrag,t))return;if(void 0===this.editedFeatureId||void 0===this.editedFeatureCoordinateIndex)return;const s=this.store.getGeometryCopy(this.editedFeatureId),n=s.coordinates[0];"coordinate"===this.editedSnapType||"line"===this.editedSnapType&&void 0!==this.editedInsertIndex?0===this.editedFeatureCoordinateIndex||this.editedFeatureCoordinateIndex===s.coordinates[0].length-1?(n[0]=[t.lng,t.lat],n[n.length-1]=[t.lng,t.lat]):n[this.editedFeatureCoordinateIndex]=[t.lng,t.lat]:"line"===this.editedSnapType&&void 0===this.editedInsertIndex&&(this.editedInsertIndex=this.editedFeatureCoordinateIndex+1,s.coordinates[0].splice(this.editedInsertIndex,0,[t.lng,t.lat]),this.editedFeatureCoordinateIndex++);const r={type:"Polygon",coordinates:s.coordinates};this.validate&&!this.validate({type:"Feature",geometry:r,properties:this.store.getPropertiesCopy(this.editedFeatureId)},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Provisional}).valid||(this.snapping&&this.snappedPointId&&(this.store.delete([this.snappedPointId]),this.snappedPointId=void 0),this.store.updateGeometry([{id:this.editedFeatureId,geometry:r}]),this.showCoordinatePoints&&this.coordinatePoints.createOrUpdate(this.editedFeatureId),this.editedPointId&&this.store.updateGeometry([{id:this.editedPointId,geometry:{type:"Point",coordinates:[t.lng,t.lat]}}]),this.store.updateProperty([{id:this.editedFeatureId,property:o.EDITED,value:!0}]))}onDragEnd(t,e){this.allowPointerEvent(this.pointerEvents.onDragEnd,t)&&void 0!==this.editedFeatureId&&(this.setCursor(this.cursors.dragEnd),this.editedPointId&&(this.store.delete([this.editedPointId]),this.editedPointId=void 0),this.store.updateProperty([{id:this.editedFeatureId,property:o.EDITED,value:!1}]),this.onFinish(this.editedFeatureId,{mode:this.mode,action:"edit"}),this.editedFeatureId=void 0,this.editedFeatureCoordinateIndex=void 0,this.editedInsertIndex=void 0,this.editedSnapType=void 0,e(!0))}cleanUp(){const t=this.currentId,e=this.snappedPointId,i=this.editedPointId;this.currentId=void 0,this.snappedPointId=void 0,this.editedPointId=void 0,this.editedFeatureId=void 0,this.editedFeatureCoordinateIndex=void 0,this.editedInsertIndex=void 0,this.editedSnapType=void 0,this.currentCoordinate=0,"drawing"===this.state&&this.setStarted();try{t&&this.coordinatePoints.deletePointsByFeatureIds([t]),void 0!==t&&this.store.delete([t]),void 0!==i&&this.store.delete([i]),void 0!==e&&this.store.delete([e]),this.closingPoints.ids.length&&this.closingPoints.delete()}catch(t){}}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});if(e.properties.mode===this.mode){if("Polygon"===e.geometry.type)return i.polygonFillColor=this.getHexColorStylingValue(this.styles.fillColor,i.polygonFillColor,e),i.polygonOutlineColor=this.getHexColorStylingValue(this.styles.outlineColor,i.polygonOutlineColor,e),i.polygonOutlineWidth=this.getNumericStylingValue(this.styles.outlineWidth,i.polygonOutlineWidth,e),i.polygonFillOpacity=this.getNumericStylingValue(this.styles.fillOpacity,i.polygonFillOpacity,e),i.zIndex=s,i;if("Point"===e.geometry.type){const t=e.properties[o.EDITED],s=e.properties[o.COORDINATE_POINT],n=t?"editedPoint":e.properties[o.CLOSING_POINT]?"closingPoint":e.properties[o.SNAPPING_POINT]?"snappingPoint":s?"coordinatePoint":void 0;if(!n)return i;const r={editedPoint:{width:this.styles.editedPointOutlineWidth,color:this.styles.editedPointColor,outlineColor:this.styles.editedPointOutlineColor,outlineWidth:this.styles.editedPointOutlineWidth},closingPoint:{width:this.styles.closingPointWidth,color:this.styles.closingPointColor,outlineColor:this.styles.closingPointOutlineColor,outlineWidth:this.styles.closingPointOutlineWidth},snappingPoint:{width:this.styles.snappingPointWidth,color:this.styles.snappingPointColor,outlineColor:this.styles.snappingPointOutlineColor,outlineWidth:this.styles.snappingPointOutlineWidth},coordinatePoint:{width:this.styles.coordinatePointWidth,color:this.styles.coordinatePointColor,outlineColor:this.styles.coordinatePointOutlineColor,outlineWidth:this.styles.coordinatePointOutlineWidth}};return i.pointWidth=this.getNumericStylingValue(r[n].width,i.pointWidth,e),i.pointColor=this.getHexColorStylingValue(r[n].color,i.pointColor,e),i.pointOutlineColor=this.getHexColorStylingValue(r[n].outlineColor,i.pointOutlineColor,e),i.pointOutlineWidth=this.getNumericStylingValue(r[n].outlineWidth,2,e),i.zIndex=t?40:s?20:30,i}}return i}afterFeatureAdded(t){this.showCoordinatePoints&&this.coordinatePoints.createOrUpdate(t.id)}afterFeatureUpdated(t){this.showCoordinatePoints&&this.coordinatePoints.createOrUpdate(t.id),this.editedFeatureId===t.id&&this.editedPointId&&(this.store.delete([this.editedPointId]),this.editedPointId=void 0,this.editedFeatureId=void 0,this.editedFeatureCoordinateIndex=void 0,this.editedSnapType=void 0),this.snappedPointId&&this.lastMouseMoveEvent&&this.updateSnappedCoordinate(this.lastMouseMoveEvent),this.currentId===t.id&&(this.currentCoordinate=0,this.currentId=void 0,this.closingPoints.delete(),"drawing"===this.state&&this.setStarted())}validateFeature(t){return this.validateModeFeature(t,t=>W(t,this.coordinatePrecision))}}const Ot={cancel:"Escape",finish:"Enter"},_t={start:"crosshair"};class bt extends u{constructor(t){super(t,!0),this.mode="rectangle",this.center=void 0,this.clickCount=0,this.currentRectangleId=void 0,this.keyEvents=Ot,this.cursors=_t,this.updateOptions(t)}updateOptions(e){super.updateOptions(e),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors)),null===(null==e?void 0:e.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents))}updateRectangle(t,e){if(1===this.clickCount&&this.center&&this.currentRectangleId){const i=this.store.getGeometryCopy(this.currentRectangleId).coordinates[0][0],o={type:"Polygon",coordinates:[[i,[t.lng,i[1]],[t.lng,t.lat],[i[0],t.lat],i]]};if(this.validate&&!this.validate({id:this.currentRectangleId,geometry:o},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e}).valid)return;this.store.updateGeometry([{id:this.currentRectangleId,geometry:o}])}}close(){const t=this.currentRectangleId;if(t){const e=A(this.store.getGeometryCopy(t));e&&this.store.updateGeometry([{id:t,geometry:e}]),this.store.updateProperty([{id:t,property:o.CURRENTLY_DRAWING,value:void 0}])}this.center=void 0,this.currentRectangleId=void 0,this.clickCount=0,"drawing"===this.state&&this.setStarted(),void 0!==t&&this.onFinish(t,{mode:this.mode,action:"draw"})}start(){this.setStarted(),this.setCursor(this.cursors.start)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onClick(t){if("right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t))if(0===this.clickCount){this.center=[t.lng,t.lat];const[e]=this.store.create([{geometry:{type:"Polygon",coordinates:[[[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat]]]},properties:{mode:this.mode,[o.CURRENTLY_DRAWING]:!0}}]);this.currentRectangleId=e,this.clickCount++,this.setDrawing()}else this.updateRectangle(t,e.Finish),this.close()}onMouseMove(t){this.updateRectangle(t,e.Provisional)}onKeyDown(){}onKeyUp(t){t.key===this.keyEvents.cancel?this.cleanUp():t.key===this.keyEvents.finish&&this.close()}onDragStart(){}onDrag(){}onDragEnd(){}cleanUp(){const t=this.currentRectangleId;this.center=void 0,this.currentRectangleId=void 0,this.clickCount=0,"drawing"===this.state&&this.setStarted(),void 0!==t&&this.store.delete([t])}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});return"Feature"===e.type&&"Polygon"===e.geometry.type&&e.properties.mode===this.mode?(i.polygonFillColor=this.getHexColorStylingValue(this.styles.fillColor,i.polygonFillColor,e),i.polygonOutlineColor=this.getHexColorStylingValue(this.styles.outlineColor,i.polygonOutlineColor,e),i.polygonOutlineWidth=this.getNumericStylingValue(this.styles.outlineWidth,i.polygonOutlineWidth,e),i.polygonFillOpacity=this.getNumericStylingValue(this.styles.fillOpacity,i.polygonFillOpacity,e),i.zIndex=s,i):i}validateFeature(t){return this.validateModeFeature(t,t=>B(t,this.coordinatePrecision))}afterFeatureUpdated(t){this.currentRectangleId===t.id&&(this.center=void 0,this.currentRectangleId=void 0,this.clickCount=0,"drawing"===this.state&&this.setStarted())}}class kt extends u{constructor(t){if(!t.modeName)throw new Error("Mode name is required for TerraDrawRenderMode");super(t,!0),this.type=l.Render,this.mode="render",this.updateOptions(t)}updateOptions(t){super.updateOptions(t),null!=t&&t.modeName&&(this.mode=t.modeName)}registerBehaviors(t){this.mode=t.mode}start(){this.setStarted()}stop(){this.setStopped()}onKeyUp(){}onKeyDown(){}onClick(){}onDragStart(){}onDrag(){}onDragEnd(){}onMouseMove(){}cleanUp(){}styleFeature(t){return{pointColor:this.getHexColorStylingValue(this.styles.pointColor,"#3f97e0",t),pointWidth:this.getNumericStylingValue(this.styles.pointWidth,6,t),pointOutlineColor:this.getHexColorStylingValue(this.styles.pointOutlineColor,"#ffffff",t),pointOutlineWidth:this.getNumericStylingValue(this.styles.pointOutlineWidth,0,t),polygonFillColor:this.getHexColorStylingValue(this.styles.polygonFillColor,"#3f97e0",t),polygonFillOpacity:this.getNumericStylingValue(this.styles.polygonFillOpacity,.3,t),polygonOutlineColor:this.getHexColorStylingValue(this.styles.polygonOutlineColor,"#3f97e0",t),polygonOutlineWidth:this.getNumericStylingValue(this.styles.polygonOutlineWidth,4,t),lineStringWidth:this.getNumericStylingValue(this.styles.lineStringWidth,4,t),lineStringColor:this.getHexColorStylingValue(this.styles.lineStringColor,"#3f97e0",t),zIndex:this.getNumericStylingValue(this.styles.zIndex,0,t)}}validateFeature(t){const e=super.validateFeature(t);if(e.valid){const e=t,i=It(e,this.coordinatePrecision).valid||W(e,this.coordinatePrecision).valid||at(e,this.coordinatePrecision).valid;return i?{valid:!0}:{valid:i,reason:"Feature is not a valid Point, Polygon or LineString feature"}}return e}}function Nt(t,e){const i=t,o=e,s=f(i[1]),n=f(o[1]);let r=f(o[0]-i[0]);r>Math.PI&&(r-=2*Math.PI),r<-Math.PI&&(r+=2*Math.PI);const a=Math.log(Math.tan(n/2+Math.PI/4)/Math.tan(s/2+Math.PI/4)),d=(v(Math.atan2(r,a))+360)%360;return d>180?-(360-d):d}function Tt(t,e,i){let o=e;e<0&&(o=-Math.abs(o));const s=o/y,n=t[0]*Math.PI/180,r=f(t[1]),a=f(i),d=s*Math.cos(a);let h=r+d;Math.abs(h)>Math.PI/2&&(h=h>0?Math.PI-h:-Math.PI-h);const l=Math.log(Math.tan(h/2+Math.PI/4)/Math.tan(r/2+Math.PI/4)),c=Math.abs(l)>1e-11?d/l:Math.cos(r),u=[(180*(n+s*Math.sin(a)/c)/Math.PI+540)%360-180,180*h/Math.PI];return u[0]+=u[0]-t[0]>180?-360:t[0]-u[0]>180?360:0,u}function jt(t,e,i,o,s){const n=o(t[0],t[1]),r=o(e[0],e[1]),{lng:a,lat:d}=s((n.x+r.x)/2,(n.y+r.y)/2);return[C(a,i),C(d,i)]}function Wt(t,e,i){const o=Tt(t,1e3*g(t,e)/2,Nt(t,e));return[C(o[0],i),C(o[1],i)]}function Bt({featureCoords:t,precision:e,unproject:i,project:o,projection:s}){const n=[];for(let r=0;r<t.length-1;r++){let a;if("web-mercator"===s)a=jt(t[r],t[r+1],e,o,i);else{if("globe"!==s)throw new Error("Invalid projection");a=Wt(t[r],t[r+1],e)}n.push(a)}return n}class Gt extends z{constructor(t,e,i){super(t),this.config=void 0,this.selectionPointBehavior=void 0,this.coordinatePointBehavior=void 0,this._midPoints=[],this.config=t,this.selectionPointBehavior=e,this.coordinatePointBehavior=i}get ids(){return this._midPoints.concat()}set ids(t){}insert(t,e,i){const s=this.store.getGeometryCopy(e),{midPointFeatureId:n,midPointSegment:r}=this.store.getPropertiesCopy(e),a=this.store.getGeometryCopy(n),d="Polygon"===a.type?a.coordinates[0]:a.coordinates;d.splice(r+1,0,s.coordinates),a.coordinates="Polygon"===a.type?[d]:d,this.store.updateGeometry([{id:n,geometry:a}]),this.store.getPropertiesCopy(t)[o.COORDINATE_POINT_IDS]&&this.coordinatePointBehavior.createOrUpdate(t),this.store.delete([...this._midPoints,...this.selectionPointBehavior.ids]),this.create(d,n,i),this.selectionPointBehavior.create(d,a.type,n)}create(t,e,o){if(!this.store.has(e))throw new Error("Store does not have feature with this id");this._midPoints=this.store.create(function(t,e,i,o,s,n){return Bt({featureCoords:t,precision:i,project:o,unproject:s,projection:n}).map((t,i)=>({geometry:{type:"Point",coordinates:t},properties:e(i)}))}(t,t=>({mode:this.mode,[i.MID_POINT]:!0,midPointSegment:t,midPointFeatureId:e}),o,this.config.project,this.config.unproject,this.projection))}delete(){this._midPoints.length&&(this.store.delete(this._midPoints),this._midPoints=[])}getUpdated(t){if(0!==this._midPoints.length)return Bt({featureCoords:t,precision:this.coordinatePrecision,project:this.config.project,unproject:this.config.unproject,projection:this.config.projection}).map((t,e)=>({id:this._midPoints[e],geometry:{type:"Point",coordinates:t}}))}}class Rt extends z{constructor(t){super(t),this._selectionPoints=[]}get ids(){return this._selectionPoints.concat()}set ids(t){}create(t,e,o){this._selectionPoints=this.store.create(function(t,e,i){const o=[],s="Polygon"===e?t.length-1:t.length;for(let e=0;e<s;e++)o.push({geometry:{type:"Point",coordinates:t[e]},properties:i(e)});return o}(t,e,t=>({mode:this.mode,index:t,[i.SELECTION_POINT]:!0,[i.SELECTION_POINT_FEATURE_ID]:o})))}delete(){this.ids.length&&(this.store.delete(this.ids),this._selectionPoints=[])}getUpdated(t){if(0!==this._selectionPoints.length)return this._selectionPoints.map((e,i)=>({id:e,geometry:{type:"Point",coordinates:t[i]}}))}getOneUpdated(t,e){if(void 0!==this._selectionPoints[t])return{id:this._selectionPoints[t],geometry:{type:"Point",coordinates:e}}}}function Lt(t,e){let i=!1;for(let r=0,a=e.length;r<a;r++){const a=e[r];for(let e=0,r=a.length,d=r-1;e<r;d=e++)(s=a[e])[1]>(o=t)[1]!=(n=a[d])[1]>o[1]&&o[0]<(n[0]-s[0])*(o[1]-s[1])/(n[1]-s[1])+s[0]&&(i=!i)}var o,s,n;return i}const Ut=(t,e,i)=>{const o=t=>t*t,s=(t,e)=>o(t.x-e.x)+o(t.y-e.y);return Math.sqrt(((t,e,i)=>{const o=s(e,i);if(0===o)return s(t,e);let n=((t.x-e.x)*(i.x-e.x)+(t.y-e.y)*(i.y-e.y))/o;return n=Math.max(0,Math.min(1,n)),s(t,{x:e.x+n*(i.x-e.x),y:e.y+n*(i.y-e.y)})})(t,e,i))};class At extends z{constructor(t,e,i){super(t),this.config=void 0,this.createClickBoundingBox=void 0,this.pixelDistance=void 0,this.config=t,this.createClickBoundingBox=e,this.pixelDistance=i}find(t,e){let o,s,n,r,a=Infinity,d=Infinity,h=Infinity;const l=this.createClickBoundingBox.create(t),c=this.store.search(l);for(let l=0;l<c.length;l++){const u=c[l],p=u.geometry;if("Point"===p.type){if(u.properties.selectionPoint||u.properties.coordinatePoint||!e&&u.properties[i.MID_POINT])continue;const s=this.pixelDistance.measure(t,p.coordinates);u.properties[i.MID_POINT]&&s<this.pointerDistance&&s<h?(h=s,n=u):!u.properties[i.MID_POINT]&&s<this.pointerDistance&&s<a&&(a=s,o=u)}else if("LineString"===p.type){if(o)continue;for(let e=0;e<p.coordinates.length-1;e++){const i=p.coordinates[e],o=p.coordinates[e+1],n=Ut({x:t.containerX,y:t.containerY},this.project(i[0],i[1]),this.project(o[0],o[1]));n<this.pointerDistance&&n<d&&(d=n,s=u)}}else if("Polygon"===p.type){if(o||s)continue;Lt([t.lng,t.lat],p.coordinates)&&(r=u)}}return{clickedFeature:o||s||r,clickedMidPoint:n}}}class Vt extends z{constructor(t,e,i,o,s){super(t),this.config=void 0,this.featuresAtCursorEvent=void 0,this.selectionPoints=void 0,this.midPoints=void 0,this.coordinatePoints=void 0,this.draggedFeatureId=null,this.dragPosition=void 0,this.config=t,this.featuresAtCursorEvent=e,this.selectionPoints=i,this.midPoints=o,this.coordinatePoints=s}startDragging(t,e){this.draggedFeatureId=e,this.dragPosition=[t.lng,t.lat]}stopDragging(){this.draggedFeatureId=null,this.dragPosition=void 0}isDragging(){return null!==this.draggedFeatureId}canDrag(t,e){const{clickedFeature:i}=this.featuresAtCursorEvent.find(t,!0);return!(!i||i.id!==e)}drag(t,i){if(!this.draggedFeatureId)return;const o=this.store.getGeometryCopy(this.draggedFeatureId),s=[t.lng,t.lat];if("Polygon"===o.type||"LineString"===o.type){let n,r;if("Polygon"===o.type?(n=o.coordinates[0],r=n.length-1):(n=o.coordinates,r=n.length),!this.dragPosition)return!1;for(let t=0;t<r;t++){const e=n[t];let i,o;if("web-mercator"===this.config.projection){const t=E(this.dragPosition[0],this.dragPosition[1]),n=E(s[0],s[1]),r=E(e[0],e[1]),a={x:t.x-n.x,y:t.y-n.y},d=r.x-a.x,h=r.y-a.y,{lng:l,lat:c}=S(d,h);i=l,o=c}else{const t=[this.dragPosition[0]-s[0],this.dragPosition[1]-s[1]];i=e[0]-t[0],o=e[1]-t[1]}if(i=C(i,this.config.coordinatePrecision),o=C(o,this.config.coordinatePrecision),i>180||i<-180||o>90||o<-90)return!1;n[t]=[i,o]}"Polygon"===o.type&&(n[n.length-1]=[n[0][0],n[0][1]]);const a=this.selectionPoints.getUpdated(n)||[],d=this.midPoints.getUpdated(n)||[],h=this.coordinatePoints.getUpdated(this.draggedFeatureId,n)||[];if(i&&!i({type:"Feature",id:this.draggedFeatureId,geometry:o,properties:{}},{project:this.config.project,unproject:this.config.unproject,coordinatePrecision:this.config.coordinatePrecision,updateType:e.Provisional}).valid)return!1;this.store.updateGeometry([{id:this.draggedFeatureId,geometry:o},...a,...d,...h]),this.dragPosition=[t.lng,t.lat]}else"Point"===o.type&&(this.store.updateGeometry([{id:this.draggedFeatureId,geometry:{type:"Point",coordinates:s}}]),this.dragPosition=[t.lng,t.lat])}}class Yt extends z{constructor(t,e,i,o,s,n,r){super(t),this.config=void 0,this.pixelDistance=void 0,this.selectionPoints=void 0,this.midPoints=void 0,this.coordinatePoints=void 0,this.coordinateSnapping=void 0,this.lineSnapping=void 0,this.draggedCoordinate={id:null,index:-1},this.config=t,this.pixelDistance=e,this.selectionPoints=i,this.midPoints=o,this.coordinatePoints=s,this.coordinateSnapping=n,this.lineSnapping=r}getClosestCoordinate(t,e){const i={dist:Infinity,index:-1,isFirstOrLastPolygonCoord:!1};let o;if("LineString"===e.type)o=e.coordinates;else{if("Polygon"!==e.type)return i;o=e.coordinates[0]}for(let s=0;s<o.length;s++){const n=this.pixelDistance.measure(t,o[s]);if(n<this.pointerDistance&&n<i.dist){const t="Polygon"===e.type&&(s===o.length-1||0===s);i.dist=n,i.index=t?0:s,i.isFirstOrLastPolygonCoord=t}}return i}getDraggableIndex(t,e){const i=this.store.getGeometryCopy(e),o=this.getClosestCoordinate(t,i);return-1===o.index?-1:o.index}snapCoordinate(t,e,i){let o=[t.lng,t.lat];const s=t=>Boolean(t.properties&&t.properties.mode===i.properties.mode&&t.id!==this.draggedCoordinate.id);if(null!=e&&e.toLine){let e;e=this.lineSnapping.getSnappable(t,s).coordinate,e&&(o=e)}if(e.toCoordinate){let e;e=this.coordinateSnapping.getSnappable(t,s).coordinate,e&&(o=e)}if(null!=e&&e.toCustom){let s;s=e.toCustom(t,{currentCoordinate:this.draggedCoordinate.index,currentId:i.id,getCurrentGeometrySnapshot:i.id?()=>this.store.getGeometryCopy(i.id):()=>null,project:this.project,unproject:this.unproject}),s&&(o=s)}return o}drag(t,i,o,s){const n=this.draggedCoordinate.id;if(null===n)return!1;const r=this.draggedCoordinate.index,a=this.store.getGeometryCopy(n),d=this.store.getPropertiesCopy(n),h="LineString"===a.type?a.coordinates:a.coordinates[0],l="Polygon"===a.type&&(r===h.length-1||0===r),c={type:"Feature",id:n,geometry:a,properties:d},u=this.snapCoordinate(t,s,c);if(t.lng>180||t.lng<-180||t.lat>90||t.lat<-90)return!1;if(l){const t=h.length-1;h[0]=u,h[t]=u}else h[r]=u;const p=this.selectionPoints.getOneUpdated(r,u),g=p?[p]:[],y=this.midPoints.getUpdated(h)||[],f=this.coordinatePoints.getUpdated(n,h)||[];return!("Point"!==a.type&&!i&&D({type:"Feature",geometry:a,properties:{}})||o&&!o(c,{project:this.config.project,unproject:this.config.unproject,coordinatePrecision:this.config.coordinatePrecision,updateType:e.Provisional}).valid||(this.store.updateGeometry([{id:n,geometry:a},...g,...y,...f]),0))}isDragging(){return null!==this.draggedCoordinate.id}startDragging(t,e){this.draggedCoordinate={id:t,index:e}}stopDragging(){this.draggedCoordinate={id:null,index:-1}}}function Kt(t){let e=0,i=0,o=0;return("Polygon"===t.geometry.type?t.geometry.coordinates[0].slice(0,-1):t.geometry.coordinates).forEach(t=>{e+=t[0],i+=t[1],o++},!0),[e/o,i/o]}const zt=(t,e)=>{if(0===e||360===e||-360===e)return t;const i=.017453292519943295*e,o=("Polygon"===t.geometry.type?t.geometry.coordinates[0]:t.geometry.coordinates).map(([t,e])=>E(t,e)),s=o.reduce((t,e)=>({x:t.x+e.x,y:t.y+e.y}),{x:0,y:0});s.x/=o.length,s.y/=o.length;const n=o.map(t=>({x:s.x+(t.x-s.x)*Math.cos(i)-(t.y-s.y)*Math.sin(i),y:s.y+(t.x-s.x)*Math.sin(i)+(t.y-s.y)*Math.cos(i)})).map(({x:t,y:e})=>[S(t,e).lng,S(t,e).lat]);return"Polygon"===t.geometry.type?t.geometry.coordinates[0]=n:t.geometry.coordinates=n,t};function Xt(t){const e=("Polygon"===t.geometry.type?t.geometry.coordinates[0]:t.geometry.coordinates).map(t=>{const{x:e,y:i}=E(t[0],t[1]);return[e,i]});return"Polygon"===t.geometry.type?function(t){let e=0,i=0,o=0;const s=t.length;for(let n=0;n<s-1;n++){const[s,r]=t[n],[a,d]=t[n+1],h=s*d-a*r;e+=h,i+=(s+a)*h,o+=(r+d)*h}return e/=2,i/=6*e,o/=6*e,{x:i,y:o}}(e):function(t){const e=t.length;let i=0,o=0;for(let s=0;s<e;s++){const[e,n]=t[s];i+=e,o+=n}return{x:i/e,y:o/e}}(e)}class Ht extends z{constructor(t,e,i,o){super(t),this.config=void 0,this.selectionPoints=void 0,this.midPoints=void 0,this.coordinatePoints=void 0,this.lastBearing=void 0,this.selectedGeometry=void 0,this.selectedGeometryCentroid=void 0,this.selectedGeometryWebMercatorCentroid=void 0,this.config=t,this.selectionPoints=e,this.midPoints=i,this.coordinatePoints=o}reset(){this.lastBearing=void 0,this.selectedGeometry=void 0,this.selectedGeometryWebMercatorCentroid=void 0,this.selectedGeometryCentroid=void 0}rotate(t,i,o){this.selectedGeometry||(this.selectedGeometry=this.store.getGeometryCopy(i));const s=this.selectedGeometry;if("Polygon"!==s.type&&"LineString"!==s.type)return;const n=[t.lng,t.lat];let r;const a={type:"Feature",geometry:s,properties:{}};if("web-mercator"===this.config.projection){this.selectedGeometryWebMercatorCentroid||(this.selectedGeometryWebMercatorCentroid=Xt(a));const e=E(t.lng,t.lat);if(r=tt(this.selectedGeometryWebMercatorCentroid,e),0===r)return;if(!this.lastBearing)return void(this.lastBearing=r);zt(a,-(this.lastBearing-r))}else{if("globe"!==this.config.projection)throw new Error("Unsupported projection");if(this.selectedGeometryCentroid||(this.selectedGeometryCentroid=Kt({type:"Feature",geometry:s,properties:{}})),r=Nt(this.selectedGeometryCentroid,n),!this.lastBearing)return void(this.lastBearing=r+180);!function(t,e){if(0===e||360===e||-360===e)return t;const i=Kt(t);("Polygon"===t.geometry.type?t.geometry.coordinates[0]:t.geometry.coordinates).forEach(t=>{const o=Nt(i,t)+e,s=function(t,e){t[0]+=t[0]-e[0]>180?-360:e[0]-t[0]>180?360:0;const i=y,o=e[1]*Math.PI/180,s=t[1]*Math.PI/180,n=s-o;let r=Math.abs(t[0]-e[0])*Math.PI/180;r>Math.PI&&(r-=2*Math.PI);const a=Math.log(Math.tan(s/2+Math.PI/4)/Math.tan(o/2+Math.PI/4)),d=Math.abs(a)>1e-11?n/a:Math.cos(o);return Math.sqrt(n*n+d*d*r*r)*i}(i,t),n=Tt(i,s,o);t[0]=n[0],t[1]=n[1]})}(a,-(this.lastBearing-(r+180)))}const d="Polygon"===s.type?s.coordinates[0]:s.coordinates;d.forEach(t=>{t[0]=C(t[0],this.coordinatePrecision),t[1]=C(t[1],this.coordinatePrecision)});const h=this.midPoints.getUpdated(d)||[],l=this.selectionPoints.getUpdated(d)||[],c=this.coordinatePoints.getUpdated(i,d)||[];if(o&&!o({id:i,type:"Feature",geometry:s,properties:{}},{project:this.config.project,unproject:this.config.unproject,coordinatePrecision:this.config.coordinatePrecision,updateType:e.Provisional}))return!1;this.store.updateGeometry([{id:i,geometry:s},...l,...h,...c]),"web-mercator"===this.projection?this.lastBearing=r:"globe"===this.projection&&(this.lastBearing=r+180)}}class $t extends z{constructor(t,e){super(t),this.config=void 0,this.dragCoordinateResizeBehavior=void 0,this.config=t,this.dragCoordinateResizeBehavior=e}scale(t,e,i){if(!this.dragCoordinateResizeBehavior.isDragging()){const i=this.dragCoordinateResizeBehavior.getDraggableIndex(t,e);this.dragCoordinateResizeBehavior.startDragging(e,i)}this.dragCoordinateResizeBehavior.drag(t,"center-fixed",i)}reset(){this.dragCoordinateResizeBehavior.stopDragging()}}function qt({coordinates:t,originX:e,originY:i,xScale:o,yScale:s}){1===o&&1===s||t.forEach(t=>{const{x:n,y:r}=E(t[0],t[1]),a=e+(n-e)*o,d=i+(r-i)*s,{lng:h,lat:l}=S(a,d);t[0]=h,t[1]=l})}class Zt extends z{constructor(t,e,i,o,s){super(t),this.config=void 0,this.pixelDistance=void 0,this.selectionPoints=void 0,this.midPoints=void 0,this.coordinatePoints=void 0,this.minimumScale=1e-4,this.draggedCoordinate={id:null,index:-1},this.boundingBoxMaps={opposite:{0:4,1:5,2:6,3:7,4:0,5:1,6:2,7:3}},this.config=t,this.pixelDistance=e,this.selectionPoints=i,this.midPoints=o,this.coordinatePoints=s}getClosestCoordinate(t,e){const i={dist:Infinity,index:-1,isFirstOrLastPolygonCoord:!1};let o;if("LineString"===e.type)o=e.coordinates;else{if("Polygon"!==e.type)return i;o=e.coordinates[0]}for(let s=0;s<o.length;s++){const n=this.pixelDistance.measure(t,o[s]);if(n<this.pointerDistance&&n<i.dist){const t="Polygon"===e.type&&(s===o.length-1||0===s);i.dist=n,i.index=t?0:s,i.isFirstOrLastPolygonCoord=t}}return i}isValidDragWebMercator(t,e,i){switch(t){case 0:if(e<=0||i>=0)return!1;break;case 1:if(i>=0)return!1;break;case 2:if(e>=0||i>=0)return!1;break;case 3:if(e>=0)return!1;break;case 4:if(e>=0||i<=0)return!1;break;case 5:if(i<=0)return!1;break;case 6:if(e<=0||i<=0)return!1;break;case 7:if(e<=0)return!1}return!0}getSelectedFeatureDataWebMercator(){if(!this.draggedCoordinate.id||-1===this.draggedCoordinate.index)return null;const t=this.getFeature(this.draggedCoordinate.id);if(!t)return null;const e=this.getNormalisedCoordinates(t.geometry);return{boundingBox:this.getBBoxWebMercator(e),feature:t,updatedCoords:e,selectedCoordinate:e[this.draggedCoordinate.index]}}centerWebMercatorDrag(t){const e=this.getSelectedFeatureDataWebMercator();if(!e)return null;const{feature:i,boundingBox:o,updatedCoords:s,selectedCoordinate:n}=e,r=Xt(i);if(!r)return null;const a=E(n[0],n[1]),{closestBBoxIndex:d}=this.getIndexesWebMercator(o,a),h=E(t.lng,t.lat);return this.scaleWebMercator({closestBBoxIndex:d,updatedCoords:s,webMercatorCursor:h,webMercatorSelected:a,webMercatorOrigin:r}),s}centerFixedWebMercatorDrag(t){const e=this.getSelectedFeatureDataWebMercator();if(!e)return null;const{feature:i,boundingBox:o,updatedCoords:s,selectedCoordinate:n}=e,r=Xt(i);if(!r)return null;const a=E(n[0],n[1]),{closestBBoxIndex:d}=this.getIndexesWebMercator(o,a),h=E(t.lng,t.lat);return this.scaleFixedWebMercator({closestBBoxIndex:d,updatedCoords:s,webMercatorCursor:h,webMercatorSelected:a,webMercatorOrigin:r}),s}scaleFixedWebMercator({closestBBoxIndex:t,webMercatorOrigin:e,webMercatorSelected:i,webMercatorCursor:o,updatedCoords:s}){if(!this.isValidDragWebMercator(t,e.x-o.x,e.y-o.y))return null;let n=U(e,o)/U(e,i);return n<0&&(n=this.minimumScale),qt({coordinates:s,originX:e.x,originY:e.y,xScale:n,yScale:n}),s}oppositeFixedWebMercatorDrag(t){const e=this.getSelectedFeatureDataWebMercator();if(!e)return null;const{boundingBox:i,updatedCoords:o,selectedCoordinate:s}=e,n=E(s[0],s[1]),{oppositeBboxIndex:r,closestBBoxIndex:a}=this.getIndexesWebMercator(i,n),d={x:i[r][0],y:i[r][1]},h=E(t.lng,t.lat);return this.scaleFixedWebMercator({closestBBoxIndex:a,updatedCoords:o,webMercatorCursor:h,webMercatorSelected:n,webMercatorOrigin:d}),o}oppositeWebMercatorDrag(t){const e=this.getSelectedFeatureDataWebMercator();if(!e)return null;const{boundingBox:i,updatedCoords:o,selectedCoordinate:s}=e,n=E(s[0],s[1]),{oppositeBboxIndex:r,closestBBoxIndex:a}=this.getIndexesWebMercator(i,n),d={x:i[r][0],y:i[r][1]},h=E(t.lng,t.lat);return this.scaleWebMercator({closestBBoxIndex:a,updatedCoords:o,webMercatorCursor:h,webMercatorSelected:n,webMercatorOrigin:d}),o}scaleWebMercator({closestBBoxIndex:t,webMercatorOrigin:e,webMercatorSelected:i,webMercatorCursor:o,updatedCoords:s}){const n=e.x-o.x,r=e.y-o.y;if(!this.isValidDragWebMercator(t,n,r))return null;let a=1;0!==n&&1!==t&&5!==t&&(a=1-(e.x-i.x-n)/n);let d=1;return 0!==r&&3!==t&&7!==t&&(d=1-(e.y-i.y-r)/r),this.validateScale(a,d)?(a<0&&(a=this.minimumScale),d<0&&(d=this.minimumScale),this.performWebMercatorScale(s,e.x,e.y,a,d),s):null}getFeature(t){if(null===this.draggedCoordinate.id)return null;const e=this.store.getGeometryCopy(t);return"Polygon"!==e.type&&"LineString"!==e.type?null:{id:t,type:"Feature",geometry:e,properties:{}}}getNormalisedCoordinates(t){return"Polygon"===t.type?t.coordinates[0]:t.coordinates}validateScale(t,e){const i=!isNaN(t)&&e<Number.MAX_SAFE_INTEGER,o=!isNaN(e)&&e<Number.MAX_SAFE_INTEGER;return i&&o}performWebMercatorScale(t,e,i,o,s){t.forEach(t=>{const{x:n,y:r}=E(t[0],t[1]),a=e+(n-e)*o,d=i+(r-i)*s,{lng:h,lat:l}=S(a,d);t[0]=h,t[1]=l})}getBBoxWebMercator(t){const e=[Infinity,Infinity,-Infinity,-Infinity];(t=t.map(t=>{const{x:e,y:i}=E(t[0],t[1]);return[e,i]})).forEach(([t,i])=>{t<e[0]&&(e[0]=t),i<e[1]&&(e[1]=i),t>e[2]&&(e[2]=t),i>e[3]&&(e[3]=i)});const[i,o,s,n]=e;return[[i,n],[(i+s)/2,n],[s,n],[s,n+(o-n)/2],[s,o],[(i+s)/2,o],[i,o],[i,n+(o-n)/2]]}getIndexesWebMercator(t,e){let i,o=Infinity;for(let s=0;s<t.length;s++){const n=U({x:e.x,y:e.y},{x:t[s][0],y:t[s][1]});n<o&&(i=s,o=n)}if(void 0===i)throw new Error("No closest coordinate found");return{oppositeBboxIndex:this.boundingBoxMaps.opposite[i],closestBBoxIndex:i}}isDragging(){return null!==this.draggedCoordinate.id}startDragging(t,e){this.draggedCoordinate={id:t,index:e}}stopDragging(){this.draggedCoordinate={id:null,index:-1}}getDraggableIndex(t,e){const i=this.store.getGeometryCopy(e),o=this.getClosestCoordinate(t,i);return-1===o.index?-1:o.index}drag(t,i,o){if(!this.draggedCoordinate.id)return!1;const s=this.getFeature(this.draggedCoordinate.id);if(!s)return!1;let n=null;if("center"===i?n=this.centerWebMercatorDrag(t):"opposite"===i?n=this.oppositeWebMercatorDrag(t):"center-fixed"===i?n=this.centerFixedWebMercatorDrag(t):"opposite-fixed"===i&&(n=this.oppositeFixedWebMercatorDrag(t)),!n)return!1;for(let t=0;t<n.length;t++){const e=n[t];if(e[0]=C(e[0],this.coordinatePrecision),e[1]=C(e[1],this.coordinatePrecision),!O(e,this.coordinatePrecision))return!1}const r=this.midPoints.getUpdated(n)||[],a=this.selectionPoints.getUpdated(n)||[],d=this.coordinatePoints.getUpdated(s.id,n)||[],h={type:s.geometry.type,coordinates:"Polygon"===s.geometry.type?[n]:n};return!(o&&!o({id:this.draggedCoordinate.id,type:"Feature",geometry:h,properties:{}},{project:this.config.project,unproject:this.config.unproject,coordinatePrecision:this.config.coordinatePrecision,updateType:e.Provisional}).valid||(this.store.updateGeometry([{id:this.draggedCoordinate.id,geometry:h},...a,...r,...d]),0))}}const Jt={deselect:"Escape",delete:"Delete",rotate:["Control","r"],scale:["Control","s"]},Qt={pointerOver:"move",dragStart:"move",dragEnd:"move",insertMidpoint:"crosshair"};class te extends p{constructor(t){super(t,!0),this.mode="select",this.allowManualDeselection=!0,this.dragEventThrottle=5,this.dragEventCount=0,this.selected=[],this.flags={},this.keyEvents=Jt,this.cursors=Qt,this.validations={},this.selectionPoints=void 0,this.midPoints=void 0,this.coordinateSnap=void 0,this.featuresAtMouseEvent=void 0,this.pixelDistance=void 0,this.clickBoundingBox=void 0,this.dragFeature=void 0,this.dragCoordinate=void 0,this.rotateFeature=void 0,this.scaleFeature=void 0,this.dragCoordinateResizeFeature=void 0,this.coordinatePoints=void 0,this.lineSnap=void 0,this.updateOptions(t)}updateOptions(e){if(super.updateOptions(e),this.cursors=e&&e.cursors?t({},this.cursors,e.cursors):Qt,null===(null==e?void 0:e.keyEvents)?this.keyEvents={deselect:null,delete:null,rotate:null,scale:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents)),void 0!==(null==e?void 0:e.dragEventThrottle)&&(this.dragEventThrottle=e.dragEventThrottle),void 0!==(null==e?void 0:e.allowManualDeselection)&&(this.allowManualDeselection=e.allowManualDeselection),null!=e&&e.flags){this.flags=t({},this.flags,e.flags),this.validations={};for(const t in this.flags){const e=this.flags[t].feature;e&&e.validation&&(this.validations[t]=e.validation)}}}selectFeature(t){this.select(t,!1)}setSelecting(){if("started"!==this._state)throw new Error("Mode must be started to move to selecting state");this._state="selecting"}registerBehaviors(t){this.pixelDistance=new $(t),this.clickBoundingBox=new H(t),this.featuresAtMouseEvent=new At(t,this.clickBoundingBox,this.pixelDistance),this.selectionPoints=new Rt(t),this.coordinatePoints=new Mt(t),this.midPoints=new Gt(t,this.selectionPoints,this.coordinatePoints),this.coordinateSnap=new q(t,this.pixelDistance,this.clickBoundingBox),this.lineSnap=new gt(t,this.pixelDistance,this.clickBoundingBox),this.rotateFeature=new Ht(t,this.selectionPoints,this.midPoints,this.coordinatePoints),this.dragFeature=new Vt(t,this.featuresAtMouseEvent,this.selectionPoints,this.midPoints,this.coordinatePoints),this.dragCoordinate=new Yt(t,this.pixelDistance,this.selectionPoints,this.midPoints,this.coordinatePoints,this.coordinateSnap,this.lineSnap),this.dragCoordinateResizeFeature=new Zt(t,this.pixelDistance,this.selectionPoints,this.midPoints,this.coordinatePoints),this.scaleFeature=new $t(t,this.dragCoordinateResizeFeature)}deselectFeature(){this.deselect()}deselect(){const t=this.selected.filter(t=>this.store.has(t)).map(t=>({id:t,property:i.SELECTED,value:!1}));this.store.updateProperty(t),this.onDeselect(this.selected[0]),this.selected=[],this.selectionPoints.delete(),this.midPoints.delete()}deleteSelected(){this.store.delete(this.selected),this.selected=[]}onRightClick(t){if(!this.selectionPoints.ids.length)return;let i,o=Infinity;if(this.selectionPoints.ids.forEach(e=>{const s=this.store.getGeometryCopy(e),n=this.pixelDistance.measure(t,s.coordinates);n<this.pointerDistance&&n<o&&(o=n,i=this.store.getPropertiesCopy(e))}),!i)return;const s=i.selectionPointFeatureId,n=i.index,r=this.store.getPropertiesCopy(s),a=this.flags[r.mode],d=this.validations[r.mode];if(!(a&&a.feature&&a.feature.coordinates&&a.feature.coordinates.deletable))return;const h=this.store.getGeometryCopy(s);let l;if("Polygon"===h.type){if(l=h.coordinates[0],l.length<=4)return}else if("LineString"===h.type&&(l=h.coordinates,l.length<=2))return;if(!l)return;if("Polygon"!==h.type||0!==n&&n!==l.length-1?l.splice(n,1):(l.shift(),l.pop(),l.push([l[0][0],l[0][1]])),d&&!d({id:s,type:"Feature",geometry:h,properties:r},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Commit}).valid)return;const c=[...this.midPoints.ids,...this.selectionPoints.ids];this.store.delete(c),this.store.updateGeometry([{id:s,geometry:h}]),r.coordinatePointIds&&this.coordinatePoints.createOrUpdate(s),this.selectionPoints.create(l,h.type,s),a&&a.feature&&a.feature.coordinates&&a.feature.coordinates.midpoints&&this.midPoints.create(l,s,this.coordinatePrecision)}select(t,e=!0){if(this.selected[0]===t)return;const{mode:o}=this.store.getPropertiesCopy(t),s=this.flags[o];if(!s||!s.feature)return;const n=this.selected[0];if(n){if(n===t)return;this.deselect()}e&&this.setCursor(this.cursors.pointerOver),this.selected=[t],this.store.updateProperty([{id:t,property:i.SELECTED,value:!0}]),this.onSelect(t);const{type:r,coordinates:a}=this.store.getGeometryCopy(t);if("LineString"!==r&&"Polygon"!==r)return;const d="LineString"===r?a:a[0];d&&s&&s.feature.coordinates&&(this.selectionPoints.create(d,r,t),s.feature.coordinates.midpoints&&this.midPoints.create(d,t,this.coordinatePrecision))}onLeftClick(t){const{clickedFeature:e,clickedMidPoint:i}=this.featuresAtMouseEvent.find(t,this.selected.length>0);if(this.selected.length&&i)this.midPoints.insert(this.selected[0],i.id,this.coordinatePrecision);else if(e&&e.id)this.select(e.id,!0);else if(this.selected.length&&this.allowManualDeselection)return void this.deselect()}start(){this.setStarted(),this.setSelecting()}stop(){this.cleanUp(),this.setStarted(),this.setStopped()}onClick(t){"right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t)?this.onRightClick(t):"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)&&this.onLeftClick(t)}canScale(t){return this.keyEvents.scale&&this.keyEvents.scale.every(e=>t.heldKeys.includes(e))}canRotate(t){return this.keyEvents.rotate&&this.keyEvents.rotate.every(e=>t.heldKeys.includes(e))}preventDefaultKeyEvent(t){const e=this.canRotate(t),i=this.canScale(t);(e||i)&&t.preventDefault()}onKeyDown(t){this.preventDefaultKeyEvent(t)}onKeyUp(t){if(this.preventDefaultKeyEvent(t),this.keyEvents.delete&&t.key===this.keyEvents.delete){if(!this.selected.length)return;const t=this.selected[0];this.onDeselect(this.selected[0]),this.coordinatePoints.deletePointsByFeatureIds([t]),this.deleteSelected(),this.selectionPoints.delete(),this.midPoints.delete()}else this.keyEvents.deselect&&t.key===this.keyEvents.deselect&&this.cleanUp()}cleanUp(){this.selected.length&&this.deselect()}onDragStart(t,e){if(!this.allowPointerEvent(this.pointerEvents.onDragStart,t))return;if(!this.selected.length)return;const i=this.store.getPropertiesCopy(this.selected[0]),o=this.flags[i.mode];if(!(o&&o.feature&&(o.feature.draggable||o.feature.coordinates&&o.feature.coordinates.draggable||o.feature.coordinates&&o.feature.coordinates.resizable||o.feature.coordinates&&"object"==typeof o.feature.coordinates.midpoints&&o.feature.coordinates.midpoints.draggable)))return;this.dragEventCount=0;const s=this.selected[0],n=this.dragCoordinate.getDraggableIndex(t,s);if(o&&o.feature&&o.feature.coordinates&&(o.feature.coordinates.draggable||o.feature.coordinates.resizable)&&-1!==n)return this.setCursor(this.cursors.dragStart),o.feature.coordinates.resizable?this.dragCoordinateResizeFeature.startDragging(s,n):this.dragCoordinate.startDragging(s,n),void e(!1);if(o&&o.feature&&o.feature.coordinates&&"object"==typeof o.feature.coordinates.midpoints&&o.feature.coordinates.midpoints.draggable){const{clickedMidPoint:i}=this.featuresAtMouseEvent.find(t,this.selected.length>0);if(this.selected.length&&i){this.midPoints.insert(s,i.id,this.coordinatePrecision);const o=this.dragCoordinate.getDraggableIndex(t,s);return this.dragCoordinate.startDragging(s,o),void e(!1)}}return o&&o.feature&&o.feature.draggable&&this.dragFeature.canDrag(t,s)?(this.setCursor(this.cursors.dragStart),this.dragFeature.startDragging(t,s),void e(!1)):void 0}onDrag(t,e){if(!this.allowPointerEvent(this.pointerEvents.onDrag,t))return;const i=this.selected[0];if(!i)return;const o=this.store.getPropertiesCopy(i),s=this.flags[o.mode],n=!0===(s&&s.feature&&s.feature.selfIntersectable);if(this.dragEventCount++,this.dragEventCount%this.dragEventThrottle==0)return;const r=this.validations[o.mode];if(s&&s.feature&&s.feature.rotateable&&this.canRotate(t))return e(!1),void this.rotateFeature.rotate(t,i,r);if(s&&s.feature&&s.feature.scaleable&&this.canScale(t))return e(!1),void this.scaleFeature.scale(t,i,r);if(this.dragCoordinateResizeFeature.isDragging()&&s.feature&&s.feature.coordinates&&s.feature.coordinates.resizable){if("globe"===this.projection)throw new Error("Globe is currently unsupported projection for resizable");return e(!1),void this.dragCoordinateResizeFeature.drag(t,s.feature.coordinates.resizable,r)}if(this.dragCoordinate.isDragging()){var a;const e=null==(a=s.feature)||null==(a=a.coordinates)?void 0:a.snappable;let i={toCoordinate:!1};return!0===e?i={toCoordinate:!0}:"object"==typeof e&&(i=e),void this.dragCoordinate.drag(t,n,r,i)}this.dragFeature.isDragging()?this.dragFeature.drag(t,r):e(!0)}onDragEnd(t,e){this.allowPointerEvent(this.pointerEvents.onDragEnd,t)&&(this.setCursor(this.cursors.dragEnd),this.dragCoordinate.isDragging()?this.onFinish(this.selected[0],{mode:this.mode,action:"dragCoordinate"}):this.dragFeature.isDragging()?this.onFinish(this.selected[0],{mode:this.mode,action:"dragFeature"}):this.dragCoordinateResizeFeature.isDragging()&&this.onFinish(this.selected[0],{mode:this.mode,action:"dragCoordinateResize"}),this.dragCoordinate.stopDragging(),this.dragFeature.stopDragging(),this.dragCoordinateResizeFeature.stopDragging(),this.rotateFeature.reset(),this.scaleFeature.reset(),e(!0))}onMouseMove(t){if(!this.selected.length)return void this.setCursor("unset");if(this.dragFeature.isDragging())return;let e=!1;this.midPoints.ids.forEach(i=>{if(e)return;const o=this.store.getGeometryCopy(i);this.pixelDistance.measure(t,o.coordinates)<this.pointerDistance&&(e=!0)});let i=!1;if(this.selectionPoints.ids.forEach(o=>{const s=this.store.getGeometryCopy(o);this.pixelDistance.measure(t,s.coordinates)<this.pointerDistance&&(e=!1,i=!0)}),e)return void this.setCursor(this.cursors.insertMidpoint);const{clickedFeature:o}=this.featuresAtMouseEvent.find(t,!0);this.setCursor(this.selected.length>0&&(o&&o.id===this.selected[0]||i)?this.cursors.pointerOver:"unset")}styleFeature(e){const o=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});if(e.properties.mode===this.mode&&"Point"===e.geometry.type){if(e.properties.selectionPoint)return o.pointColor=this.getHexColorStylingValue(this.styles.selectionPointColor,o.pointColor,e),o.pointOutlineColor=this.getHexColorStylingValue(this.styles.selectionPointOutlineColor,o.pointOutlineColor,e),o.pointWidth=this.getNumericStylingValue(this.styles.selectionPointWidth,o.pointWidth,e),o.pointOutlineWidth=this.getNumericStylingValue(this.styles.selectionPointOutlineWidth,2,e),o.zIndex=30,o;if(e.properties.midPoint)return o.pointColor=this.getHexColorStylingValue(this.styles.midPointColor,o.pointColor,e),o.pointOutlineColor=this.getHexColorStylingValue(this.styles.midPointOutlineColor,o.pointOutlineColor,e),o.pointWidth=this.getNumericStylingValue(this.styles.midPointWidth,4,e),o.pointOutlineWidth=this.getNumericStylingValue(this.styles.midPointOutlineWidth,2,e),o.zIndex=50,o}else if(e.properties[i.SELECTED]){if("Polygon"===e.geometry.type)return o.polygonFillColor=this.getHexColorStylingValue(this.styles.selectedPolygonColor,o.polygonFillColor,e),o.polygonOutlineWidth=this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth,o.polygonOutlineWidth,e),o.polygonOutlineColor=this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor,o.polygonOutlineColor,e),o.polygonFillOpacity=this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity,o.polygonFillOpacity,e),o.zIndex=s,o;if("LineString"===e.geometry.type)return o.lineStringColor=this.getHexColorStylingValue(this.styles.selectedLineStringColor,o.lineStringColor,e),o.lineStringWidth=this.getNumericStylingValue(this.styles.selectedLineStringWidth,o.lineStringWidth,e),o.zIndex=s,o;if("Point"===e.geometry.type)return o.pointWidth=this.getNumericStylingValue(this.styles.selectedPointWidth,o.pointWidth,e),o.pointColor=this.getHexColorStylingValue(this.styles.selectedPointColor,o.pointColor,e),o.pointOutlineColor=this.getHexColorStylingValue(this.styles.selectedPointOutlineColor,o.pointOutlineColor,e),o.pointOutlineWidth=this.getNumericStylingValue(this.styles.selectedPointOutlineWidth,o.pointOutlineWidth,e),o.zIndex=s,o}return o}afterFeatureUpdated(t){if(this.selected.length&&t.id===this.selected[0]){var e,i;const o=this.flags[t.properties.mode];if(null==o||null==(e=o.feature)||!e.coordinates)return;const s=t.geometry.type,n=t.id;let r;if(this.selectionPoints.delete(),this.midPoints.delete(),"Polygon"===s)r=t.geometry.coordinates[0];else{if("LineString"!==s)return;r=t.geometry.coordinates}this.selectionPoints.create(r,s,n),null!=o&&null!=(i=o.feature)&&null!=(i=i.coordinates)&&i.midpoints&&this.midPoints.create("Polygon"===s?t.geometry.coordinates[0]:t.geometry.coordinates,n,this.coordinatePrecision)}}}class ee extends u{constructor(...t){super(...t),this.type=l.Static,this.mode="static"}start(){}stop(){}onKeyUp(){}onKeyDown(){}onClick(){}onDragStart(){}onDrag(){}onDragEnd(){}onMouseMove(){}cleanUp(){}styleFeature(){return t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0})}}function ie(t,e,i,o,s){for(;o>i;){if(o-i>600){const n=o-i+1,r=e-i+1,a=Math.log(n),d=.5*Math.exp(2*a/3),h=.5*Math.sqrt(a*d*(n-d)/n)*(r-n/2<0?-1:1);ie(t,e,Math.max(i,Math.floor(e-r*d/n+h)),Math.min(o,Math.floor(e+(n-r)*d/n+h)),s)}const n=t[e];let r=i,a=o;for(oe(t,i,e),s(t[o],n)>0&&oe(t,i,o);r<a;){for(oe(t,r,a),r++,a--;s(t[r],n)<0;)r++;for(;s(t[a],n)>0;)a--}0===s(t[i],n)?oe(t,i,a):(a++,oe(t,a,o)),a<=e&&(i=a+1),e<=a&&(o=a-1)}}function oe(t,e,i){const o=t[e];t[e]=t[i],t[i]=o}function se(t,e){ne(t,0,t.children.length,e,t)}function ne(t,e,i,o,s){s||(s=ge([])),s.minX=Infinity,s.minY=Infinity,s.maxX=-Infinity,s.maxY=-Infinity;for(let n=e;n<i;n++){const e=t.children[n];re(s,t.leaf?o(e):e)}return s}function re(t,e){return t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),t}function ae(t,e){return t.minX-e.minX}function de(t,e){return t.minY-e.minY}function he(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function le(t){return t.maxX-t.minX+(t.maxY-t.minY)}function ce(t,e){const i=Math.max(t.minX,e.minX),o=Math.max(t.minY,e.minY),s=Math.min(t.maxX,e.maxX),n=Math.min(t.maxY,e.maxY);return Math.max(0,s-i)*Math.max(0,n-o)}function ue(t,e){return t.minX<=e.minX&&t.minY<=e.minY&&e.maxX<=t.maxX&&e.maxY<=t.maxY}function pe(t,e){return e.minX<=t.maxX&&e.minY<=t.maxY&&e.maxX>=t.minX&&e.maxY>=t.minY}function ge(t){return{children:t,height:1,leaf:!0,minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity}}function ye(t,e,i,o,s){const n=[e,i];for(;n.length;){if((i=n.pop())-(e=n.pop())<=o)continue;const r=e+Math.ceil((i-e)/o/2)*o;ie(t,r,e,i,s),n.push(e,r,r,i)}}class fe{constructor(t){this._maxEntries=void 0,this._minEntries=void 0,this.data=void 0,this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}search(t){let e=this.data;const i=[];if(!pe(t,e))return i;const o=this.toBBox,s=[];for(;e;){for(let n=0;n<e.children.length;n++){const r=e.children[n],a=e.leaf?o(r):r;pe(t,a)&&(e.leaf?i.push(r):ue(t,a)?this._all(r,i):s.push(r))}e=s.pop()}return i}collides(t){let e=this.data;if(pe(t,e)){const i=[];for(;e;){for(let o=0;o<e.children.length;o++){const s=e.children[o],n=e.leaf?this.toBBox(s):s;if(pe(t,n)){if(e.leaf||ue(t,n))return!0;i.push(s)}}e=i.pop()}}return!1}load(t){if(t.length<this._minEntries){for(let e=0;e<t.length;e++)this.insert(t[e]);return}let e=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===e.height)this._splitRoot(this.data,e);else{if(this.data.height<e.height){const t=this.data;this.data=e,e=t}this._insert(e,this.data.height-e.height-1,!0)}else this.data=e}insert(t){this._insert(t,this.data.height-1)}clear(){this.data=ge([])}remove(t){let e=this.data;const i=this.toBBox(t),o=[],s=[];let n,r,a=!1;for(;e||o.length;){if(e||(e=o.pop(),r=o[o.length-1],n=s.pop(),a=!0),e.leaf){const i=e.children.indexOf(t);-1!==i&&(e.children.splice(i,1),o.push(e),this._condense(o))}a||e.leaf||!ue(e,i)?r?(n++,e=r.children[n],a=!1):e=null:(o.push(e),s.push(n),n=0,r=e,e=e.children[0])}}toBBox(t){return t}compareMinX(t,e){return t.minX-e.minX}compareMinY(t,e){return t.minY-e.minY}_all(t,e){const i=[];for(;t;)t.leaf?e.push(...t.children):i.push(...t.children),t=i.pop();return e}_build(t,e,i,o){const s=i-e+1;let n,r=this._maxEntries;if(s<=r)return n=ge(t.slice(e,i+1)),se(n,this.toBBox),n;o||(o=Math.ceil(Math.log(s)/Math.log(r)),r=Math.ceil(s/Math.pow(r,o-1))),n=ge([]),n.leaf=!1,n.height=o;const a=Math.ceil(s/r),d=a*Math.ceil(Math.sqrt(r));ye(t,e,i,d,this.compareMinX);for(let s=e;s<=i;s+=d){const e=Math.min(s+d-1,i);ye(t,s,e,a,this.compareMinY);for(let i=s;i<=e;i+=a){const s=Math.min(i+a-1,e);n.children.push(this._build(t,i,s,o-1))}}return se(n,this.toBBox),n}_chooseSubtree(t,e,i,o){for(;o.push(e),!e.leaf&&o.length-1!==i;){let i,o=Infinity,r=Infinity;for(let a=0;a<e.children.length;a++){const d=e.children[a],h=he(d),l=(s=t,n=d,(Math.max(n.maxX,s.maxX)-Math.min(n.minX,s.minX))*(Math.max(n.maxY,s.maxY)-Math.min(n.minY,s.minY))-h);l<r?(r=l,o=h<o?h:o,i=d):l===r&&h<o&&(o=h,i=d)}e=i||e.children[0]}var s,n;return e}_insert(t,e,i){const o=i?t:this.toBBox(t),s=[],n=this._chooseSubtree(o,this.data,e,s);for(n.children.push(t),re(n,o);e>=0&&s[e].children.length>this._maxEntries;)this._split(s,e),e--;this._adjustParentBBoxes(o,s,e)}_split(t,e){const i=t[e],o=i.children.length,s=this._minEntries;this._chooseSplitAxis(i,s,o);const n=this._chooseSplitIndex(i,s,o),r=ge(i.children.splice(n,i.children.length-n));r.height=i.height,r.leaf=i.leaf,se(i,this.toBBox),se(r,this.toBBox),e?t[e-1].children.push(r):this._splitRoot(i,r)}_splitRoot(t,e){this.data=ge([t,e]),this.data.height=t.height+1,this.data.leaf=!1,se(this.data,this.toBBox)}_chooseSplitIndex(t,e,i){let o,s=Infinity,n=Infinity;for(let r=e;r<=i-e;r++){const e=ne(t,0,r,this.toBBox),a=ne(t,r,i,this.toBBox),d=ce(e,a),h=he(e)+he(a);d<s?(s=d,o=r,n=h<n?h:n):d===s&&h<n&&(n=h,o=r)}return o||i-e}_chooseSplitAxis(t,e,i){const o=t.leaf?this.compareMinX:ae,s=t.leaf?this.compareMinY:de;this._allDistMargin(t,e,i,o)<this._allDistMargin(t,e,i,s)&&t.children.sort(o)}_allDistMargin(t,e,i,o){t.children.sort(o);const s=this.toBBox,n=ne(t,0,e,s),r=ne(t,i-e,i,s);let a=le(n)+le(r);for(let o=e;o<i-e;o++){const e=t.children[o];re(n,t.leaf?s(e):e),a+=le(n)}for(let o=i-e-1;o>=e;o--){const e=t.children[o];re(r,t.leaf?s(e):e),a+=le(r)}return a}_adjustParentBBoxes(t,e,i){for(let o=i;o>=0;o--)re(e[o],t)}_condense(t){for(let e,i=t.length-1;i>=0;i--)0===t[i].children.length?i>0?(e=t[i-1].children,e.splice(e.indexOf(t[i]),1)):this.clear():se(t[i],this.toBBox)}}class me{constructor(t){this.tree=void 0,this.idToNode=void 0,this.nodeToId=void 0,this.tree=new fe(t&&t.maxEntries?t.maxEntries:9),this.idToNode=new Map,this.nodeToId=new Map}setMaps(t,e){this.idToNode.set(t.id,e),this.nodeToId.set(e,t.id)}toBBox(t){const e=[],i=[];let o;if("Polygon"===t.geometry.type)o=t.geometry.coordinates[0];else if("LineString"===t.geometry.type)o=t.geometry.coordinates;else{if("Point"!==t.geometry.type)throw new Error("Not a valid feature to turn into a bounding box");o=[t.geometry.coordinates]}for(let t=0;t<o.length;t++)i.push(o[t][1]),e.push(o[t][0]);const s=Math.min(...i),n=Math.max(...i);return{minX:Math.min(...e),minY:s,maxX:Math.max(...e),maxY:n}}insert(t){if(this.idToNode.get(String(t.id)))throw new Error("Feature already exists");const e=this.toBBox(t);this.setMaps(t,e),this.tree.insert(e)}load(t){const e=[],i=new Set;t.forEach(t=>{const o=this.toBBox(t);if(this.setMaps(t,o),i.has(String(t.id)))throw new Error(`Duplicate feature ID found ${t.id}`);i.add(String(t.id)),e.push(o)}),this.tree.load(e)}update(t){this.remove(t.id);const e=this.toBBox(t);this.setMaps(t,e),this.tree.insert(e)}remove(t){const e=this.idToNode.get(t);if(!e)throw new Error(`${t} not inserted into the spatial index`);this.tree.remove(e)}clear(){this.tree.clear()}search(t){return this.tree.search(this.toBBox(t)).map(t=>this.nodeToId.get(t))}collides(t){return this.tree.collides(this.toBBox(t))}}const ve={getId:()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){const e=16*Math.random()|0;return("x"==t?e:3&e|8).toString(16)}),isValidId:t=>"string"==typeof t&&36===t.length};class Ce{constructor(t){this.idStrategy=void 0,this.tracked=void 0,this.spatialIndex=void 0,this.store=void 0,this._onChange=()=>{},this.store={},this.spatialIndex=new me,this.tracked=!t||!1!==t.tracked,this.idStrategy=t&&t.idStrategy?t.idStrategy:ve}clone(t){return JSON.parse(JSON.stringify(t))}getId(){return this.idStrategy.getId()}has(t){return Boolean(this.store[t])}load(t,e,i,o){if(0===t.length)return[];let s=this.clone(t);const n=[],r=[];s=s.filter(t=>{null==t.id&&(t.id=this.idStrategy.getId());const i=t.id;if(e){const o=e(t);if(!o.valid)return n.push({id:i,valid:!1,reason:o.reason}),!1}if(this.tracked){if(t.properties.createdAt){if(!a(t.properties.createdAt))return n.push({id:t.id,valid:!1,reason:"createdAt is not a valid numeric timestamp"}),!1}else t.properties.createdAt=+new Date;if(t.properties.updatedAt){if(!a(t.properties.updatedAt))return n.push({id:t.id,valid:!1,reason:"updatedAt is not a valid numeric timestamp"}),!1}else t.properties.updatedAt=+new Date}return this.has(i)?(n.push({id:i,valid:!1,reason:`Feature already exists with this id: ${i}`}),!1):(this.store[i]=t,r.push(t),n.push({id:i,valid:!0}),!0)}),this.spatialIndex.load(s);const d=r.map(({id:t})=>t);return d.length>0&&(this._onChange(d,"create",o),i&&r.forEach(t=>{i(t)})),n}search(t,e){const i=this.spatialIndex.search(t).map(t=>this.store[t]);return this.clone(e?i.filter(e):i)}registerOnChange(t){this._onChange=(e,i,o)=>{t(e,i,o)}}getGeometryCopy(t){const e=this.store[t];if(!e)throw new Error(`No feature with this id (${t}), can not get geometry copy`);return this.clone(e.geometry)}getPropertiesCopy(t){const e=this.store[t];if(!e)throw new Error(`No feature with this id (${t}), can not get properties copy`);return this.clone(e.properties)}updateProperty(t,e){const i=[];t.forEach(({id:t,property:e,value:o})=>{const s=this.store[t];if(!s)throw new Error(`No feature with this (${t}), can not update geometry`);i.push(t),void 0===o?delete s.properties[e]:s.properties[e]=o,this.tracked&&(s.properties.updatedAt=+new Date)}),this._onChange&&this._onChange(i,"update",e)}updateGeometry(t,e){const i=[];t.forEach(({id:t,geometry:e})=>{i.push(t);const o=this.store[t];if(!o)throw new Error(`No feature with this (${t}), can not update geometry`);o.geometry=this.clone(e),this.spatialIndex.update(o),this.tracked&&(o.properties.updatedAt=+new Date)}),this._onChange&&this._onChange(i,"update",e)}create(e,i){const o=[];return e.forEach(({geometry:e,properties:i})=>{let s,n=t({},i);this.tracked&&(s=+new Date,i?(n.createdAt="number"==typeof i.createdAt?i.createdAt:s,n.updatedAt="number"==typeof i.updatedAt?i.updatedAt:s):n={createdAt:s,updatedAt:s});const r=this.getId(),a={id:r,type:"Feature",geometry:e,properties:n};this.store[r]=a,this.spatialIndex.insert(a),o.push(r)}),this._onChange&&this._onChange([...o],"create",i),o}delete(t,e){t.forEach(t=>{if(!this.store[t])throw new Error(`No feature with id ${t}, can not delete`);delete this.store[t],this.spatialIndex.remove(t)}),this._onChange&&this._onChange([...t],"delete",e)}copy(t){return this.clone(this.store[t])}copyAll(){return this.clone(Object.keys(this.store).map(t=>this.store[t]))}copyAllWhere(t){return this.clone(Object.keys(this.store).map(t=>this.store[t]).filter(e=>e.properties&&t(e.properties)))}clear(){this.store={},this.spatialIndex.clear()}size(){return Object.keys(this.store).length}}function Pe(t){const e=t.coordinates;let i=0;if(e&&e.length>0){i+=Math.abs(Ee(e[0]));for(let t=1;t<e.length;t++)i-=Math.abs(Ee(e[t]))}return i}const Ie=20294876564838.72,xe=Math.PI/180;function Ee(t){const e=t.length;if(e<=2)return 0;let i=0,o=0;for(;o<e;)i+=(t[o+2>=e?(o+2)%e:o+2][0]*xe-t[o][0]*xe)*Math.sin(t[o+1===e?0:o+1][1]*xe),o++;return i*Ie}const Se="Feature is smaller than the minimum area",Me=(t,e)=>"Polygon"!==t.geometry.type?{valid:!1,reason:d}:Pe(t.geometry)<e?{valid:!1,reason:Se}:{valid:!0},Fe=(t,e)=>"Polygon"!==t.geometry.type?{valid:!1,reason:d}:Pe(t.geometry)>e?{valid:!1,reason:"Feature is larger than the maximum area"}:{valid:!0},De="Feature is not a Polygon or LineString",we="Feature intersects itself",Oe=t=>"Polygon"!==t.geometry.type&&"LineString"!==t.geometry.type?{valid:!1,reason:De}:D(t)?{valid:!1,reason:we}:{valid:!0};function _e(t,e,i){const o=tt(t,e);let s=tt(e,i)-o;return s<0&&(s+=360),180-Math.abs(s-90-90)}const be={cancel:"Escape",finish:"Enter"},ke={start:"crosshair",close:"pointer"};class Ne extends u{constructor(t){super(t,!0),this.mode="angled-rectangle",this.currentCoordinate=0,this.currentId=void 0,this.keyEvents=be,this.cursors=ke,this.mouseMove=!1,this.updateOptions(t)}updateOptions(e){super.updateOptions(e),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors)),null===(null==e?void 0:e.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents))}close(){if(void 0===this.currentId)return;this.store.updateProperty([{id:this.currentId,property:o.CURRENTLY_DRAWING,value:void 0}]);const t=this.currentId;this.currentCoordinate=0,this.currentId=void 0,"drawing"===this.state&&this.setStarted(),this.onFinish(t,{mode:this.mode,action:"draw"})}start(){this.setStarted(),this.setCursor(this.cursors.start)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onMouseMove(t){if(this.mouseMove=!0,this.setCursor(this.cursors.start),void 0===this.currentId||0===this.currentCoordinate)return;const i=this.store.getGeometryCopy(this.currentId).coordinates[0];let o;if(1===this.currentCoordinate){const e=1/Math.pow(10,this.coordinatePrecision-1),s=Math.max(1e-6,e);o=[i[0],[t.lng,t.lat],[t.lng,t.lat-s],i[0]]}else if(2===this.currentCoordinate){const e=i[0],s=i[1],n=jt(e,s,this.coordinatePrecision,this.project,this.unproject),r=E(e[0],e[1]),a=E(n[0],n[1]),d=E(s[0],s[1]),h=E(t.lng,t.lat),l=U(h,r)<U(h,d),c=_e(r,a,h),u=l?90-c:_e(r,a,h)-90,p=U(a,h),g=Math.cos(f(u))*p,y=tt(r,d)+("right"===function(t,e,i){const o=(i.x-e.x)*(t.y-e.y)-(i.y-e.y)*(t.x-e.x);return o>1e-10?"left":o<-1e-10?"right":"left"}(r,d,h)?-90:90),m=J(r,g,y),v=J(d,g,y),C=S(m.x,m.y),P=S(v.x,v.y);o=[i[0],i[1],[P.lng,P.lat],[C.lng,C.lat],i[0]]}o&&this.updatePolygonGeometry(this.currentId,o,e.Provisional)}updatePolygonGeometry(t,e,i){const o={type:"Polygon",coordinates:[e]};return!(this.validate&&!this.validate({type:"Feature",geometry:o},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:i}).valid||(this.store.updateGeometry([{id:t,geometry:o}]),0))}onClick(t){if("right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t))if(this.currentCoordinate>0&&!this.mouseMove&&this.onMouseMove(t),this.mouseMove=!1,0===this.currentCoordinate){const[e]=this.store.create([{geometry:{type:"Polygon",coordinates:[[[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat]]]},properties:{mode:this.mode,[o.CURRENTLY_DRAWING]:!0}}]);this.currentId=e,this.currentCoordinate++,this.setDrawing()}else if(1===this.currentCoordinate&&this.currentId){const i=this.store.getGeometryCopy(this.currentId);if(rt([t.lng,t.lat],i.coordinates[0][0]))return;if(!this.updatePolygonGeometry(this.currentId,[i.coordinates[0][0],[t.lng,t.lat],[t.lng,t.lat],i.coordinates[0][0]],e.Commit))return;this.currentCoordinate++}else 2===this.currentCoordinate&&this.currentId&&this.close()}onKeyUp(t){if(t.key===this.keyEvents.cancel)this.cleanUp();else if(t.key===this.keyEvents.finish){if(this.currentCoordinate<2)return void this.cleanUp();this.close()}}onKeyDown(){}onDragStart(){}onDrag(){}onDragEnd(){}cleanUp(){try{this.currentId&&this.store.delete([this.currentId])}catch(t){}this.currentId=void 0,this.currentCoordinate=0,"drawing"===this.state&&this.setStarted()}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});return e.properties.mode===this.mode&&"Polygon"===e.geometry.type&&(i.polygonFillColor=this.getHexColorStylingValue(this.styles.fillColor,i.polygonFillColor,e),i.polygonOutlineColor=this.getHexColorStylingValue(this.styles.outlineColor,i.polygonOutlineColor,e),i.polygonOutlineWidth=this.getNumericStylingValue(this.styles.outlineWidth,i.polygonOutlineWidth,e),i.polygonFillOpacity=this.getNumericStylingValue(this.styles.fillOpacity,i.polygonFillOpacity,e),i.zIndex=s),i}validateFeature(t){return this.validateModeFeature(t,t=>B(t,this.coordinatePrecision))}afterFeatureUpdated(t){this.currentId===t.id&&(this.currentId=void 0,this.currentCoordinate=0,"drawing"===this.state&&this.setStarted())}}function Te(t,e,i){return(e.x-t.x)*(i.y-t.y)-(e.y-t.y)*(i.x-t.x)<=0}const je={cancel:"Escape",finish:"Enter"},We={start:"crosshair",close:"pointer"};class Be extends u{constructor(t){super(t,!0),this.mode="sector",this.currentCoordinate=0,this.currentId=void 0,this.keyEvents=je,this.direction=void 0,this.arcPoints=64,this.cursors=We,this.mouseMove=!1,this.updateOptions(t)}updateOptions(e){super.updateOptions(e),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors)),null===(null==e?void 0:e.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents)),null!=e&&e.arcPoints&&(this.arcPoints=e.arcPoints)}close(){if(void 0===this.currentId)return;const t=A(this.store.getGeometryCopy(this.currentId));t&&this.store.updateGeometry([{id:this.currentId,geometry:t}]),this.store.updateProperty([{id:this.currentId,property:o.CURRENTLY_DRAWING,value:void 0}]);const e=this.currentId;this.currentCoordinate=0,this.currentId=void 0,this.direction=void 0,"drawing"===this.state&&this.setStarted(),this.onFinish(e,{mode:this.mode,action:"draw"})}start(){this.setStarted(),this.setCursor(this.cursors.start)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onMouseMove(t){if(this.mouseMove=!0,this.setCursor(this.cursors.start),void 0===this.currentId||0===this.currentCoordinate)return;const i=this.store.getGeometryCopy(this.currentId).coordinates[0];let o;if(1===this.currentCoordinate){const e=1/Math.pow(10,this.coordinatePrecision-1),s=Math.max(1e-6,e);o=[i[0],[t.lng,t.lat],[t.lng,t.lat-s],i[0]]}else if(2===this.currentCoordinate){const e=i[0],s=i[1],n=[t.lng,t.lat],r=E(e[0],e[1]),a=E(s[0],s[1]),d=E(n[0],n[1]);if(void 0===this.direction){const t=Te(r,a,d);this.direction=t?"clockwise":"anticlockwise"}const h=U(r,a),l=tt(r,a),c=tt(r,d),u=this.arcPoints,p=[e],g=et(l),y=et(c);let f;"anticlockwise"===this.direction?(f=y-g,f<0&&(f+=360)):(f=g-y,f<0&&(f+=360));const m=("anticlockwise"===this.direction?1:-1)*f/u;p.push(s);for(let t=0;t<=u;t++){const e=J(r,h,g+t*m),{lng:i,lat:o}=S(e.x,e.y),s=[C(i,this.coordinatePrecision),C(o,this.coordinatePrecision)];s[0]!==p[p.length-1][0]&&s[1]!==p[p.length-1][1]&&p.push(s)}p.push(e),o=[...p]}o&&this.updatePolygonGeometry(this.currentId,o,e.Provisional)}updatePolygonGeometry(t,e,i){const o={type:"Polygon",coordinates:[e]};return!(this.validate&&!this.validate({type:"Feature",geometry:o},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:i}).valid||(this.store.updateGeometry([{id:t,geometry:o}]),0))}onClick(t){if("right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t))if(this.currentCoordinate>0&&!this.mouseMove&&this.onMouseMove(t),this.mouseMove=!1,0===this.currentCoordinate){const[e]=this.store.create([{geometry:{type:"Polygon",coordinates:[[[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat],[t.lng,t.lat]]]},properties:{mode:this.mode,[o.CURRENTLY_DRAWING]:!0}}]);this.currentId=e,this.currentCoordinate++,this.setDrawing()}else if(1===this.currentCoordinate&&this.currentId){const i=this.store.getGeometryCopy(this.currentId);if(rt([t.lng,t.lat],i.coordinates[0][0]))return;if(!this.updatePolygonGeometry(this.currentId,[i.coordinates[0][0],[t.lng,t.lat],[t.lng,t.lat],i.coordinates[0][0]],e.Commit))return;this.currentCoordinate++}else 2===this.currentCoordinate&&this.currentId&&this.close()}onKeyUp(t){t.key===this.keyEvents.cancel?this.cleanUp():t.key===this.keyEvents.finish&&this.close()}onKeyDown(){}onDragStart(){}onDrag(){}onDragEnd(){}cleanUp(){try{this.currentId&&this.store.delete([this.currentId])}catch(t){}this.currentId=void 0,this.direction=void 0,this.currentCoordinate=0,"drawing"===this.state&&this.setStarted()}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});return e.properties.mode===this.mode&&"Polygon"===e.geometry.type&&(i.polygonFillColor=this.getHexColorStylingValue(this.styles.fillColor,i.polygonFillColor,e),i.polygonOutlineColor=this.getHexColorStylingValue(this.styles.outlineColor,i.polygonOutlineColor,e),i.polygonOutlineWidth=this.getNumericStylingValue(this.styles.outlineWidth,i.polygonOutlineWidth,e),i.polygonFillOpacity=this.getNumericStylingValue(this.styles.fillOpacity,i.polygonFillOpacity,e),i.zIndex=s),i}validateFeature(t){return this.validateModeFeature(t,t=>B(t,this.coordinatePrecision))}afterFeatureUpdated(t){this.currentId===t.id&&(this.currentId=void 0,this.direction=void 0,this.currentCoordinate=0,"drawing"===this.state&&this.setStarted())}}const Ge={cancel:"Escape",finish:"Enter"},Re={start:"crosshair",close:"pointer"};class Le extends u{constructor(t){super(t,!0),this.mode="sensor",this.currentCoordinate=0,this.currentId=void 0,this.currentInitialArcId=void 0,this.currentStartingPointId=void 0,this.keyEvents=Ge,this.direction=void 0,this.arcPoints=64,this.cursors=Re,this.mouseMove=!1,this.updateOptions(t)}updateOptions(e){super.updateOptions(e),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors)),null===(null==e?void 0:e.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents)),null!=e&&e.arcPoints&&(this.arcPoints=e.arcPoints)}close(){if(void 0===this.currentStartingPointId)return;const t=this.currentStartingPointId,e=this.currentInitialArcId,i=this.currentId;if(t&&this.store.delete([t]),e&&this.store.delete([e]),this.currentId){const t=A(this.store.getGeometryCopy(this.currentId));t&&this.store.updateGeometry([{id:this.currentId,geometry:t}]),this.store.updateProperty([{id:this.currentId,property:o.CURRENTLY_DRAWING,value:void 0}])}this.currentCoordinate=0,this.currentStartingPointId=void 0,this.currentInitialArcId=void 0,this.currentId=void 0,this.direction=void 0,"drawing"===this.state&&this.setStarted(),i&&this.onFinish(i,{mode:this.mode,action:"draw"})}start(){this.setStarted(),this.setCursor(this.cursors.start)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onMouseMove(t){if(this.mouseMove=!0,this.setCursor(this.cursors.start),void 0!==this.currentInitialArcId&&void 0!==this.currentStartingPointId&&0!==this.currentCoordinate)if(2===this.currentCoordinate){const i=this.store.getGeometryCopy(this.currentInitialArcId).coordinates,o=this.store.getGeometryCopy(this.currentStartingPointId).coordinates,s=i[0],n=[t.lng,t.lat],r=E(s[0],s[1]),a=E(n[0],n[1]),d=E(o[0],o[1]),h=U(d,r);if(void 0===this.direction){const t=Te(d,r,a);this.direction=t?"clockwise":"anticlockwise"}const l=tt(d,r),c=tt(d,a),u=this.arcPoints,p=[s],g=et(l),y=et(c);let f;"anticlockwise"===this.direction?(f=y-g,f<0&&(f+=360)):(f=g-y,f<0&&(f+=360));const m=("anticlockwise"===this.direction?1:-1)*f/u;for(let t=0;t<=u;t++){const e=J(d,h,g+t*m),{lng:i,lat:o}=S(e.x,e.y),s=[C(i,this.coordinatePrecision),C(o,this.coordinatePrecision)];s[0]!==p[p.length-1][0]&&s[1]!==p[p.length-1][1]&&p.push(s)}this.updateLineStringGeometry(this.currentInitialArcId,p,e.Provisional)}else if(3===this.currentCoordinate){const i=this.store.getGeometryCopy(this.currentInitialArcId).coordinates;if(i.length<2)return;if(!this.direction)return;const s=this.store.getGeometryCopy(this.currentStartingPointId).coordinates,n=i[0],r=i[i.length-1],a=E(t.lng,t.lat),d=E(n[0],n[1]),h=E(r[0],r[1]),l=E(s[0],s[1]),c=U(l,d),u=U(l,a)<c?d:a,p=tt(l,a),g=tt(l,d),y=tt(l,h),f=et(g),m=et(y),v=et(p);if(this.notInSector({normalizedCursor:v,normalizedStart:f,normalizedEnd:m,direction:this.direction}))return;const P=this.getDeltaBearing(this.direction,f,m),I=this.arcPoints,x=("anticlockwise"===this.direction?1:-1)*P/I,M=U(l,u),F=[];for(let t=0;t<=I;t++){const e=J(l,M,f+t*x),{lng:o,lat:s}=S(e.x,e.y),n=[C(o,this.coordinatePrecision),C(s,this.coordinatePrecision)];n[0]!==i[i.length-1][0]&&n[1]!==i[i.length-1][1]&&F.unshift(n)}i.push(...F),i.push(i[0]),this.currentId?this.updatePolygonGeometry(this.currentId,i,e.Provisional):[this.currentId]=this.store.create([{geometry:{type:"Polygon",coordinates:[i]},properties:{mode:this.mode,[o.CURRENTLY_DRAWING]:!0}}])}}updateLineStringGeometry(t,e,i){const o={type:"LineString",coordinates:e};return!(this.validate&&!this.validate({type:"Feature",geometry:o},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:i}).valid||(this.store.updateGeometry([{id:t,geometry:o}]),0))}updatePolygonGeometry(t,e,i){const o={type:"Polygon",coordinates:[e]};return!(this.validate&&!this.validate({type:"Feature",geometry:o},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:i}).valid||(this.store.updateGeometry([{id:t,geometry:o}]),0))}onClick(t){if("right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t))if(this.currentCoordinate>0&&!this.mouseMove&&this.onMouseMove(t),this.mouseMove=!1,0===this.currentCoordinate){const[e]=this.store.create([{geometry:{type:"Point",coordinates:[t.lng,t.lat]},properties:{mode:this.mode}}]);this.currentStartingPointId=e,this.currentCoordinate++,this.setDrawing()}else if(1===this.currentCoordinate&&this.currentStartingPointId){const[e]=this.store.create([{geometry:{type:"LineString",coordinates:[[t.lng,t.lat],[t.lng,t.lat]]},properties:{mode:this.mode}}]);this.currentInitialArcId=e,this.currentCoordinate++}else 2===this.currentCoordinate&&this.currentStartingPointId?this.currentCoordinate++:3===this.currentCoordinate&&this.currentStartingPointId&&this.close()}onKeyUp(t){t.key===this.keyEvents.cancel?this.cleanUp():t.key===this.keyEvents.finish&&this.close()}onKeyDown(){}onDragStart(){}onDrag(){}onDragEnd(){}cleanUp(){try{this.currentStartingPointId&&this.store.delete([this.currentStartingPointId]),this.currentInitialArcId&&this.store.delete([this.currentInitialArcId]),this.currentId&&this.store.delete([this.currentId])}catch(t){}this.currentStartingPointId=void 0,this.direction=void 0,this.currentId=void 0,this.currentCoordinate=0,"drawing"===this.state&&this.setStarted()}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});return e.properties.mode===this.mode&&("Polygon"===e.geometry.type?(i.polygonFillColor=this.getHexColorStylingValue(this.styles.fillColor,i.polygonFillColor,e),i.polygonOutlineColor=this.getHexColorStylingValue(this.styles.outlineColor,i.polygonOutlineColor,e),i.polygonOutlineWidth=this.getNumericStylingValue(this.styles.outlineWidth,i.polygonOutlineWidth,e),i.polygonFillOpacity=this.getNumericStylingValue(this.styles.fillOpacity,i.polygonFillOpacity,e),i.zIndex=s):"LineString"===e.geometry.type?(i.lineStringColor=this.getHexColorStylingValue(this.styles.outlineColor,i.polygonOutlineColor,e),i.lineStringWidth=this.getNumericStylingValue(this.styles.outlineWidth,i.polygonOutlineWidth,e),i.zIndex=s):"Point"===e.geometry.type&&(i.pointColor=this.getHexColorStylingValue(this.styles.centerPointColor,i.pointColor,e),i.pointWidth=this.getNumericStylingValue(this.styles.centerPointWidth,i.pointWidth,e),i.pointOutlineColor=this.getHexColorStylingValue(this.styles.centerPointOutlineColor,i.pointOutlineColor,e),i.pointOutlineWidth=this.getNumericStylingValue(this.styles.centerPointOutlineWidth,i.pointOutlineWidth,e),i.zIndex=20)),i}validateFeature(t){return this.validateModeFeature(t,t=>B(t,this.coordinatePrecision))}afterFeatureUpdated(t){this.currentId===t.id&&(this.currentStartingPointId&&this.store.delete([this.currentStartingPointId]),this.currentInitialArcId&&this.store.delete([this.currentInitialArcId]),this.currentStartingPointId=void 0,this.direction=void 0,this.currentId=void 0,this.currentCoordinate=0,"drawing"===this.state&&this.setStarted())}getDeltaBearing(t,e,i){let o;return"anticlockwise"===t?(o=i-e,o<0&&(o+=360)):(o=e-i,o<0&&(o+=360)),o}notInSector({normalizedCursor:t,normalizedStart:e,normalizedEnd:i,direction:o}){return"clockwise"===o?e<=i?t>=e&&t<=i:t>=e||t<=i:e>=i?t<=e&&t>=i:t<=e||t>=i}}class Ue{constructor({name:t,callback:e,unregister:i,register:o}){this.name=void 0,this.callback=void 0,this.registered=!1,this.register=void 0,this.unregister=void 0,this.name=t,this.register=()=>{this.registered||(this.registered=!0,o(e))},this.unregister=()=>{this.register&&(this.registered=!1,i(e))},this.callback=e}}var Ae={__proto__:null,GeoJSONStore:Ce,TerraDrawBaseDrawMode:u,TerraDrawBaseSelectMode:p,TerraDrawBaseAdapter:class{constructor(t){this._nextKeyUpIsContextMenu=!1,this._minPixelDragDistance=void 0,this._minPixelDragDistanceDrawing=void 0,this._minPixelDragDistanceSelecting=void 0,this._lastDrawEvent=void 0,this._coordinatePrecision=void 0,this._heldKeys=new Set,this._listeners=[],this._dragState="not-dragging",this._currentModeCallbacks=void 0,this._minPixelDragDistance="number"==typeof t.minPixelDragDistance?t.minPixelDragDistance:1,this._minPixelDragDistanceSelecting="number"==typeof t.minPixelDragDistanceSelecting?t.minPixelDragDistanceSelecting:1,this._minPixelDragDistanceDrawing="number"==typeof t.minPixelDragDistanceDrawing?t.minPixelDragDistanceDrawing:8,this._coordinatePrecision="number"==typeof t.coordinatePrecision?t.coordinatePrecision:9}getButton(t){return-1===t.button?"neither":0===t.button?"left":1===t.button?"middle":2===t.button?"right":"neither"}getMapElementXYPosition(t){const e=this.getMapEventElement(),{left:i,top:o}=e.getBoundingClientRect();return{containerX:t.clientX-i,containerY:t.clientY-o}}getDrawEventFromEvent(t,e=!1){const i=this.getLngLatFromEvent(t);if(!i)return null;const{lng:o,lat:s}=i,{containerX:n,containerY:r}=this.getMapElementXYPosition(t),a=this.getButton(t),d=Array.from(this._heldKeys);return{lng:C(o,this._coordinatePrecision),lat:C(s,this._coordinatePrecision),containerX:n,containerY:r,button:a,heldKeys:d,isContextMenu:e}}register(t){this._currentModeCallbacks=t,this._listeners=this.getAdapterListeners(),this._listeners.forEach(t=>{t.register()})}getCoordinatePrecision(){return this._coordinatePrecision}getAdapterListeners(){return[new Ue({name:"pointerdown",callback:t=>{if(!this._currentModeCallbacks)return;if(!t.isPrimary)return;const e=this.getDrawEventFromEvent(t);e&&(this._dragState="pre-dragging",this._lastDrawEvent=e)},register:t=>{this.getMapEventElement().addEventListener("pointerdown",t)},unregister:t=>{this.getMapEventElement().removeEventListener("pointerdown",t)}}),new Ue({name:"pointermove",callback:t=>{if(!this._currentModeCallbacks)return;if(!t.isPrimary)return;t.preventDefault();const e=this.getDrawEventFromEvent(t);if(e)if("not-dragging"===this._dragState)this._currentModeCallbacks.onMouseMove(e),this._lastDrawEvent=e;else if("pre-dragging"===this._dragState){if(!this._lastDrawEvent)return;const t={x:this._lastDrawEvent.containerX,y:this._lastDrawEvent.containerY},i={x:e.containerX,y:e.containerY},o=this._currentModeCallbacks.getState(),s=U(t,i);let n=!1;if(n="drawing"===o?s<this._minPixelDragDistanceDrawing:"selecting"===o?s<this._minPixelDragDistanceSelecting:s<this._minPixelDragDistance,n)return;this._nextKeyUpIsContextMenu=!1,this._dragState="dragging",this._currentModeCallbacks.onDragStart(e,t=>{this.setDraggability.bind(this)(t)})}else"dragging"===this._dragState&&this._currentModeCallbacks.onDrag(e,t=>{this.setDraggability.bind(this)(t)})},register:t=>{this.getMapEventElement().addEventListener("pointermove",t)},unregister:t=>{this.getMapEventElement().removeEventListener("pointermove",t)}}),new Ue({name:"contextmenu",callback:t=>{this._currentModeCallbacks&&(t.preventDefault(),this._nextKeyUpIsContextMenu=!0)},register:t=>{this.getMapEventElement().addEventListener("contextmenu",t)},unregister:t=>{this.getMapEventElement().removeEventListener("contextmenu",t)}}),new Ue({name:"pointerup",callback:t=>{if(!this._currentModeCallbacks)return;if(t.target!==this.getMapEventElement())return;if(!t.isPrimary)return;const e=this.getDrawEventFromEvent(t);e&&("dragging"===this._dragState?this._currentModeCallbacks.onDragEnd(e,t=>{this.setDraggability.bind(this)(t)}):"not-dragging"!==this._dragState&&"pre-dragging"!==this._dragState||(this._nextKeyUpIsContextMenu&&(e.isContextMenu=!0,this._nextKeyUpIsContextMenu=!1),this._currentModeCallbacks.onClick(e)),this._dragState="not-dragging",this.setDraggability(!0))},register:t=>{this.getMapEventElement().addEventListener("pointerup",t)},unregister:t=>{this.getMapEventElement().removeEventListener("pointerup",t)}}),new Ue({name:"keyup",callback:t=>{this._currentModeCallbacks&&(this._heldKeys.delete(t.key),this._currentModeCallbacks.onKeyUp({key:t.key,heldKeys:Array.from(this._heldKeys),preventDefault:()=>t.preventDefault()}))},register:t=>{this.getMapEventElement().addEventListener("keyup",t)},unregister:t=>{this.getMapEventElement().removeEventListener("keyup",t)}}),new Ue({name:"keydown",callback:t=>{this._currentModeCallbacks&&(this._heldKeys.add(t.key),this._currentModeCallbacks.onKeyDown({key:t.key,heldKeys:Array.from(this._heldKeys),preventDefault:()=>t.preventDefault()}))},register:t=>{this.getMapEventElement().addEventListener("keydown",t)},unregister:t=>{this.getMapEventElement().removeEventListener("keydown",t)}})]}unregister(){this._listeners.forEach(t=>{t.unregister()}),this.clear(),this._currentModeCallbacks=void 0}},getDefaultStyling:()=>({polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0}),SELECT_PROPERTIES:i};const Ve={ValidationReasonFeatureNotPoint:vt,ValidationReasonFeatureInvalidCoordinates:Ct,ValidationReasonFeatureInvalidCoordinatePrecision:Pt,ValidationReasonFeatureNotPolygon:d,ValidationReasonFeatureHasHoles:k,ValidationReasonFeatureLessThanFourCoordinates:N,ValidationReasonFeatureHasInvalidCoordinates:T,ValidationReasonFeatureCoordinatesNotClosed:j,ValidationReasonFeatureNotPolygonOrLineString:De,ValidationReasonFeatureSelfIntersects:we,ValidationReasonFeatureLessThanMinSize:Se,ValidationReasonModeMismatch:h},Ye={cancel:"Escape",finish:"Enter"},Ke={start:"crosshair",close:"pointer"};class ze extends u{constructor(t){super(t,!0),this.mode="freehand-linestring",this.startingClick=!1,this.currentId=void 0,this.closingPointId=void 0,this.minDistance=20,this.keyEvents=Ye,this.cursors=Ke,this.preventNewFeature=!1,this.updateOptions(t)}updateOptions(e){super.updateOptions(e),null!=e&&e.minDistance&&(this.minDistance=e.minDistance),null===(null==e?void 0:e.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=e&&e.keyEvents&&(this.keyEvents=t({},this.keyEvents,e.keyEvents)),null!=e&&e.cursors&&(this.cursors=t({},this.cursors,e.cursors))}close(){if(void 0===this.currentId)return;this.currentId&&this.store.updateProperty([{id:this.currentId,property:o.CURRENTLY_DRAWING,value:void 0}]);const t=this.currentId;if(this.validate&&t){const i=this.store.getGeometryCopy(t);if(!this.validate({type:"Feature",id:t,geometry:i,properties:{}},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Finish}).valid)return}this.closingPointId&&this.store.delete([this.closingPointId]),this.startingClick=!1,this.currentId=void 0,this.closingPointId=void 0,"drawing"===this.state&&this.setStarted(),this.onFinish(t,{mode:this.mode,action:"draw"})}start(){this.setStarted(),this.setCursor(this.cursors.start)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onMouseMove(t){if(void 0===this.currentId||!1===this.startingClick)return void this.setCursor(this.cursors.start);const i=this.store.getGeometryCopy(this.currentId),o=i.coordinates.length-2,[s,n]=i.coordinates[o],{x:r,y:a}=this.project(s,n),d=U({x:r,y:a},{x:t.containerX,y:t.containerY}),[h,l]=i.coordinates[i.coordinates.length-1],{x:c,y:u}=this.project(h,l),p=U({x:c,y:u},{x:t.containerX,y:t.containerY});if(this.setCursor(p<this.pointerDistance?this.cursors.close:this.cursors.start),d<this.minDistance)return;const g={type:"LineString",coordinates:[...i.coordinates,[t.lng,t.lat]]};this.validate&&!this.validate({type:"Feature",id:this.currentId,geometry:g,properties:{}},{project:this.project,unproject:this.unproject,coordinatePrecision:this.coordinatePrecision,updateType:e.Provisional}).valid||(this.store.updateGeometry([{id:this.currentId,geometry:g}]),this.closingPointId&&this.store.updateGeometry([{id:this.closingPointId,geometry:{type:"Point",coordinates:[t.lng,t.lat]}}]))}onClick(t){if("right"===t.button&&this.allowPointerEvent(this.pointerEvents.rightClick,t)||"left"===t.button&&this.allowPointerEvent(this.pointerEvents.leftClick,t)||t.isContextMenu&&this.allowPointerEvent(this.pointerEvents.contextMenu,t)){if(this.preventNewFeature)return;if(!1===this.startingClick){const[e,i]=this.store.create([{geometry:{type:"LineString",coordinates:[[t.lng,t.lat],[t.lng,t.lat]]},properties:{mode:this.mode,[o.CURRENTLY_DRAWING]:!0}},{geometry:{type:"Point",coordinates:[t.lng,t.lat]},properties:{mode:this.mode,[o.CLOSING_POINT]:!0}}]);return this.currentId=e,this.closingPointId=i,this.startingClick=!0,void("drawing"!==this.state&&this.setDrawing())}this.close()}}onKeyDown(){}onKeyUp(t){t.key===this.keyEvents.cancel?this.cleanUp():t.key===this.keyEvents.finish&&!0===this.startingClick&&this.close()}onDragStart(){}onDrag(){}onDragEnd(){}cleanUp(){const t=this.currentId,e=this.closingPointId;this.closingPointId=void 0,this.currentId=void 0,this.startingClick=!1,"drawing"===this.state&&this.setStarted();try{void 0!==t&&this.store.delete([t]),void 0!==e&&this.store.delete([e])}catch(t){}}styleFeature(e){const i=t({},{polygonFillColor:"#3f97e0",polygonOutlineColor:"#3f97e0",polygonOutlineWidth:4,polygonFillOpacity:.3,pointColor:"#3f97e0",pointOutlineColor:"#ffffff",pointOutlineWidth:0,pointWidth:6,lineStringColor:"#3f97e0",lineStringWidth:4,zIndex:0});return"Feature"===e.type&&"LineString"===e.geometry.type&&e.properties.mode===this.mode?(i.lineStringColor=this.getHexColorStylingValue(this.styles.lineStringColor,i.lineStringColor,e),i.lineStringWidth=this.getNumericStylingValue(this.styles.lineStringWidth,i.lineStringWidth,e),i.zIndex=s,i):"Feature"===e.type&&"Point"===e.geometry.type&&e.properties.mode===this.mode?(i.pointWidth=this.getNumericStylingValue(this.styles.closingPointWidth,i.pointWidth,e),i.pointColor=this.getHexColorStylingValue(this.styles.closingPointColor,i.pointColor,e),i.pointOutlineColor=this.getHexColorStylingValue(this.styles.closingPointOutlineColor,i.pointOutlineColor,e),i.pointOutlineWidth=this.getNumericStylingValue(this.styles.closingPointOutlineWidth,2,e),i.zIndex=50,i):i}validateFeature(t){return this.validateModeFeature(t,t=>at(t,this.coordinatePrecision))}afterFeatureUpdated(t){this.currentId===t.id&&(this.closingPointId&&this.store.delete([this.closingPointId]),this.startingClick=!1,this.currentId=void 0,this.closingPointId=void 0)}}function Xe(t){if(null===t)return!0;if("boolean"==typeof t)return!0;if("string"==typeof t)return!0;if(void 0===t)return!1;if("number"==typeof t)return Number.isFinite(t);if("bigint"==typeof t)return!1;if("symbol"==typeof t)return!1;if("function"==typeof t)return!1;if(t instanceof RegExp)return!1;if(t instanceof Map)return!1;if(t instanceof Set)return!1;if(t instanceof Date)return!1;if("object"==typeof t&&null!==t&&!Array.isArray(t)){const e=Object.getPrototypeOf(t);if(e!==Object.prototype&&null!==e)return!1}if(ArrayBuffer.isView(t)&&!(t instanceof DataView))return!1;if(Array.isArray(t))for(const e of t)if(!Xe(e))return!1;return"object"==typeof t&&Object.keys(t).every(e=>"string"==typeof e&&Xe(t[e]))}class He{constructor(e){this._modes=void 0,this._mode=void 0,this._adapter=void 0,this._enabled=!1,this._store=void 0,this._eventListeners=void 0,this._instanceSelectMode=void 0,this._adapter=e.adapter,this._mode=new ee;const i=new Set,o=e.modes.reduce((t,e)=>{if(i.has(e.mode))throw new Error(`There is already a ${e.mode} mode provided`);return i.add(e.mode),t[e.mode]=e,t},{}),s=Object.keys(o);if(0===s.length)throw new Error("No modes provided");s.forEach(t=>{if(o[t].type===l.Select){if(this._instanceSelectMode)throw new Error("only one type of select mode can be provided");this._instanceSelectMode=t}}),this._modes=t({},o,{static:this._mode}),this._eventListeners={change:[],select:[],deselect:[],finish:[],ready:[]},this._store=new Ce({tracked:!!e.tracked,idStrategy:e.idStrategy?e.idStrategy:void 0});const n=t=>{const e=[],i=this._store.copyAll().filter(i=>!t.includes(i.id)||(e.push(i),!1));return{changed:e,unchanged:i}},r=(t,e)=>{this._enabled&&this._eventListeners.finish.forEach(i=>{i(t,e)})},a=(t,e,i)=>{if(!this._enabled)return;this._eventListeners.change.forEach(o=>{o(t,e,i)});const{changed:o,unchanged:s}=n(t);"create"===e?this._adapter.render({created:o,deletedIds:[],unchanged:s,updated:[]},this.getModeStyles()):"update"===e?this._adapter.render({created:[],deletedIds:[],unchanged:s,updated:o},this.getModeStyles()):"delete"===e?this._adapter.render({created:[],deletedIds:t,unchanged:s,updated:[]},this.getModeStyles()):"styling"===e&&this._adapter.render({created:[],deletedIds:[],unchanged:s,updated:[]},this.getModeStyles())},d=t=>{if(!this._enabled)return;this._eventListeners.select.forEach(e=>{e(t)});const{changed:e,unchanged:i}=n([t]);this._adapter.render({created:[],deletedIds:[],unchanged:i,updated:e},this.getModeStyles())},h=t=>{if(!this._enabled)return;this._eventListeners.deselect.forEach(t=>{t()});const{changed:e,unchanged:i}=n([t]);e&&this._adapter.render({created:[],deletedIds:[],unchanged:i,updated:e},this.getModeStyles())};Object.keys(this._modes).forEach(t=>{this._modes[t].register({mode:t,store:this._store,setCursor:this._adapter.setCursor.bind(this._adapter),project:this._adapter.project.bind(this._adapter),unproject:this._adapter.unproject.bind(this._adapter),setDoubleClickToZoom:this._adapter.setDoubleClickToZoom.bind(this._adapter),onChange:a,onSelect:d,onDeselect:h,onFinish:r,coordinatePrecision:this._adapter.getCoordinatePrecision()})})}checkEnabled(){if(!this._enabled)throw new Error("Terra Draw is not enabled")}getModeStyles(){const t={};return Object.keys(this._modes).forEach(e=>{t[e]=t=>this._instanceSelectMode&&t.properties[i.SELECTED]?this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(t):this._modes[e].styleFeature.bind(this._modes[e])(t)}),t}featuresAtLocation({lng:t,lat:e},s){const n=s&&void 0!==s.pointerDistance?s.pointerDistance:30,r=!s||void 0===s.ignoreSelectFeatures||s.ignoreSelectFeatures,a=!(!s||void 0===s.ignoreCoordinatePoints)&&s.ignoreCoordinatePoints,d=!(!s||void 0===s.ignoreCurrentlyDrawing)&&s.ignoreCurrentlyDrawing,h=!(!s||void 0===s.ignoreClosingPoints)&&s.ignoreClosingPoints,l=this._adapter.unproject.bind(this._adapter),c=this._adapter.project.bind(this._adapter),u=c(t,e),p=X({unproject:l,point:u,pointerDistance:n});return this._store.search(p).filter(l=>{if(r&&(l.properties[i.MID_POINT]||l.properties[i.SELECTION_POINT]))return!1;if(a&&l.properties[o.COORDINATE_POINT])return!1;if(h&&l.properties[o.CLOSING_POINT])return!1;if(d&&l.properties[o.CURRENTLY_DRAWING])return!1;if("Point"===l.geometry.type){const t=l.geometry.coordinates,e=c(t[0],t[1]);return U(u,e)<n}if("LineString"===l.geometry.type){const t=l.geometry.coordinates;for(let e=0;e<t.length-1;e++){const i=t[e],o=t[e+1];if(Ut(u,c(i[0],i[1]),c(o[0],o[1]))<n)return!0}return!1}if(Lt([t,e],l.geometry.coordinates))return!0;if(null!=s&&s.includePolygonsWithinPointerDistance){const t=l.geometry.coordinates;for(const e of t)for(let t=0;t<e.length-1;t++){const i=e[t],o=e[t+1],s=c(i[0],i[1]),r=c(o[0],o[1]);if(Ut(u,s,r)<n)return!0}}return!1}).map(i=>{if(null==s||!s.addClosestCoordinateInfoToProperties)return i;let o;if("Polygon"===i.geometry.type)o=i.geometry.coordinates[0],o.pop();else{if("LineString"!==i.geometry.type)return i;o=i.geometry.coordinates}let n,r=-1,a=Infinity;for(let t=0;t<o.length;t++){const e=o[t],i=U(c(e[0],e[1]),u);i<a&&(r=t,a=i,n=e)}return i.properties.closestCoordinateIndexToEvent=r,i.properties.closestCoordinatePixelDistanceToEvent=a,i.properties.closestCoordinateDistanceKmToEvent=g(n,[t,e]),i})}getSelectModeOrThrow(){const t=this.getSelectMode({switchToSelectMode:!0});if(!t)throw new Error("No select mode defined in instance");return t}getSelectMode({switchToSelectMode:t}){if(this.checkEnabled(),!this._instanceSelectMode)return null;const e=this.getMode();return t&&e!==this._instanceSelectMode&&this.setMode(this._instanceSelectMode),this._modes[this._instanceSelectMode]}isGuidanceFeature(t){return Boolean(t.properties[i.MID_POINT]||t.properties[i.SELECTION_POINT]||t.properties[o.COORDINATE_POINT]||t.properties[o.SNAPPING_POINT])}setModeStyles(t,e){if(this.checkEnabled(),!this._modes[t])throw new Error("No mode with this name present");this._modes[t].styles=e}updateModeOptions(t,e){if(this.checkEnabled(),!this._modes[t])throw new Error("No mode with this name present");this._modes[t].updateOptions(e)}getSnapshot(){return this._store.copyAll()}getSnapshotFeature(t){if(this._store.has(t))return this._store.copy(t)}clear(){this.checkEnabled(),this._adapter.clear()}get enabled(){return this._enabled}set enabled(t){throw new Error("Enabled is read only")}getMode(){return this._mode.mode}getModeState(){return this._mode.state}setMode(t){if(this.checkEnabled(),!this._modes[t])throw new Error("No mode with this name present");this._mode.stop(),this._mode=this._modes[t],this._mode.start()}removeFeatures(t){this.checkEnabled();const e=[];t.forEach(t=>{if(!this._store.has(t))throw new Error(`No feature with id ${t}, can not delete`);const s=this._store.copy(t);s.properties[i.SELECTED]&&this.deselectFeature(t),s.properties[o.COORDINATE_POINT_IDS]&&e.push(...s.properties[o.COORDINATE_POINT_IDS])}),this._store.delete([...t,...e],{origin:"api"})}selectFeature(t){this.getSelectModeOrThrow().selectFeature(t)}deselectFeature(t){this.getSelectModeOrThrow().deselectFeature(t)}getFeatureId(){return this._store.getId()}hasFeature(t){return this._store.has(t)}checkIsReservedProperty(t){return![...Object.values(i),...Object.values(o)].includes(t)}updateFeatureProperties(t,e){if(!this._store.has(t))throw new Error(`No feature with id ${t} present in store`);const i=this._store.copy(t);if(this.isGuidanceFeature(i))throw new Error("Guidance features are not allowed to be updated directly.");const o=i.properties.mode;if(!this._modes[o])throw new Error(`No mode with name ${o} present in instance`);const s=Object.entries(e);s.forEach(([t,e])=>{if(!this.checkIsReservedProperty(t))throw new Error(`You are trying to update a reserved property name: ${t}. Please choose another name.`);if(void 0!==e&&!Xe(e))throw new Error(`Invalid JSON value provided for property ${t}`)}),this._store.updateProperty(s.map(([t,e])=>({id:i.id,property:t,value:e})),{origin:"api"})}updateFeatureGeometry(e,o){if(!this._store.has(e))throw new Error(`No feature with id ${e} present in store`);const s=this._store.copy(e);if(this.isGuidanceFeature(s))throw new Error("Guidance features are not allowed to be updated directly.");if(!(s&&o&&o.type&&o.coordinates))throw new Error("Invalid geometry provided");if(o.type!==s.geometry.type)throw new Error(`Geometry type mismatch: expected ${s.geometry.type}, got ${o.type}`);const n=s.properties.mode,r=this._modes[n];if(!r)throw new Error(`No mode with name ${n} present in instance`);const a=t({},s,{geometry:o}),d=r.validateFeature(a);if(!d.valid)throw new Error(`Feature validation failed: ${d.reason||"Unknown reason"}`);if(this._store.updateGeometry([{id:s.id,geometry:o}],{origin:"api"}),r.afterFeatureUpdated){r.afterFeatureUpdated(a);const t=a.properties[i.SELECTED],e=this.getSelectMode({switchToSelectMode:!1});e&&t&&e.afterFeatureUpdated(a)}}transformFeatureGeometry(t,e){if(!this._store.has(t))throw new Error(`No feature with id ${t} present in store`);let o=this._store.copy(t);if(this.isGuidanceFeature(o))throw new Error("Guidance features are not allowed to be updated directly.");const s=o.properties.mode,n=this._modes[s];if(!n)throw new Error(`No mode with name ${s} present in instance`);let r;if("Polygon"===o.geometry.type)r=o.geometry.coordinates[0];else{if("LineString"!==o.geometry.type)throw new Error(`Feature geometry type ${o.geometry.type} is not supported for transformation`);r=o.geometry.coordinates}if("web-mercator"!=e.projection)throw new Error(`Projection ${e.projection} is not currently supported for transformation`);if("scale"===e.type){const{x:t,y:i}=E(e.origin[0],e.origin[1]);qt({coordinates:r,originX:t,originY:i,xScale:e.options.xScale||1,yScale:e.options.yScale||1})}else"rotate"===e.type&&(o=zt(o,e.options.angle||0),r="Polygon"===o.geometry.type?o.geometry.coordinates[0]:o.geometry.coordinates);if(r=r.map(t=>[C(t[0],this._adapter.getCoordinatePrecision()),C(t[1],this._adapter.getCoordinatePrecision())]),o.geometry.coordinates="Polygon"===o.geometry.type?[r]:r,this._store.updateGeometry([{id:o.id,geometry:o.geometry}],{origin:"api"}),n.afterFeatureUpdated){n.afterFeatureUpdated(o);const t=o.properties[i.SELECTED],e=this.getSelectMode({switchToSelectMode:!1});e&&t&&e.afterFeatureUpdated(o)}}addFeatures(t){return this.checkEnabled(),0===t.length?[]:this._store.load(t,t=>{if(r(t)){const e=t.properties.mode,i=this._modes[e];if(!i)return{id:t.id,valid:!1,reason:`${e} mode is not in the list of instantiated modes`};const o=i.validateFeature.bind(i)(t);return{id:t.id,valid:o.valid,reason:o.reason?o.reason:o.valid?void 0:"Feature is invalid"}}return{id:t.id,valid:!1,reason:"Mode property does not exist"}},t=>{if(r(t)){const e=this._modes[t.properties.mode];e&&e.afterFeatureAdded&&e.afterFeatureAdded(t)}},{origin:"api"})}start(){this._enabled||(this._enabled=!0,this._adapter.register({onReady:()=>{this._eventListeners.ready.forEach(t=>{t()})},getState:()=>this._mode.state,onClick:t=>{this._mode.onClick(t)},onMouseMove:t=>{this._mode.onMouseMove(t)},onKeyDown:t=>{this._mode.onKeyDown(t)},onKeyUp:t=>{this._mode.onKeyUp(t)},onDragStart:(t,e)=>{this._mode.onDragStart(t,e)},onDrag:(t,e)=>{this._mode.onDrag(t,e)},onDragEnd:(t,e)=>{this._mode.onDragEnd(t,e)},onClear:()=>{this._mode.cleanUp(),this._store.clear()}}))}getFeaturesAtLngLat(t,e){const{lng:i,lat:o}=t;return this.featuresAtLocation({lng:i,lat:o},e)}getFeaturesAtPointerEvent(t,e){const i=this._adapter.getLngLatFromEvent.bind(this._adapter)(t);return null===i?[]:this.featuresAtLocation(i,e)}stop(){this._enabled&&(this._enabled=!1,this._adapter.unregister())}on(t,e){const i=this._eventListeners[t];i.includes(e)||i.push(e)}off(t,e){const i=this._eventListeners[t];i.includes(e)&&i.splice(i.indexOf(e),1)}}export{He as TerraDraw,Ne as TerraDrawAngledRectangleMode,L as TerraDrawCircleMode,Ae as TerraDrawExtend,ze as TerraDrawFreehandLineStringMode,K as TerraDrawFreehandMode,mt as TerraDrawLineStringMode,Et as TerraDrawPointMode,wt as TerraDrawPolygonMode,bt as TerraDrawRectangleMode,kt as TerraDrawRenderMode,Be as TerraDrawSectorMode,te as TerraDrawSelectMode,Le as TerraDrawSensorMode,Fe as ValidateMaxAreaSquareMeters,Me as ValidateMinAreaSquareMeters,Oe as ValidateNotSelfIntersecting,Ve as ValidationReasons};
//# sourceMappingURL=terra-draw.modern.js.map
