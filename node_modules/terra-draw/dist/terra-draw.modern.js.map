{"version":3,"file":"terra-draw.modern.js","sources":["../src/common.ts","../src/store/store-feature-validation.ts","../src/validations/common-validations.ts","../src/modes/base.mode.ts","../src/geometry/measure/haversine-distance.ts","../src/geometry/helpers.ts","../src/geometry/limit-decimal-precision.ts","../src/geometry/project/web-mercator.ts","../src/geometry/shape/create-circle.ts","../src/geometry/boolean/self-intersects.ts","../src/geometry/boolean/is-valid-coordinate.ts","../src/validations/polygon.validation.ts","../src/modes/circle/circle.mode.ts","../src/util/styling.ts","../src/geometry/shape/web-mercator-distortion.ts","../src/geometry/measure/pixel-distance.ts","../src/geometry/ensure-right-hand-rule.ts","../src/geometry/boolean/right-hand-rule.ts","../src/modes/freehand/freehand.mode.ts","../src/modes/base.behavior.ts","../src/geometry/shape/create-bbox.ts","../src/modes/click-bounding-box.behavior.ts","../src/modes/pixel-distance.behavior.ts","../src/modes/coordinate-snapping.behavior.ts","../src/geometry/measure/destination.ts","../src/geometry/measure/bearing.ts","../src/geometry/measure/slice-along.ts","../src/geometry/shape/great-circle-coordinates.ts","../src/modes/insert-coordinates.behavior.ts","../src/geometry/coordinates-identical.ts","../src/validations/linestring.validation.ts","../src/geometry/point-on-line.ts","../src/geometry/web-mercator-point-on-line.ts","../src/modes/line-snapping.behavior.ts","../src/modes/linestring/linestring.mode.ts","../src/validations/point.validation.ts","../src/modes/point/point.mode.ts","../src/modes/polygon/behaviors/closing-points.behavior.ts","../src/modes/select/behaviors/coordinate-point.behavior.ts","../src/modes/polygon/polygon.mode.ts","../src/util/geoms.ts","../src/modes/rectangle/rectangle.mode.ts","../src/modes/render/render.mode.ts","../src/geometry/measure/rhumb-bearing.ts","../src/geometry/measure/rhumb-destination.ts","../src/geometry/midpoint-coordinate.ts","../src/geometry/get-midpoints.ts","../src/modes/select/behaviors/midpoint.behavior.ts","../src/modes/select/behaviors/selection-point.behavior.ts","../src/geometry/get-coordinates-as-points.ts","../src/geometry/boolean/point-in-polygon.ts","../src/geometry/measure/pixel-distance-to-line.ts","../src/modes/select/behaviors/feature-at-pointer-event.behavior.ts","../src/modes/select/behaviors/drag-feature.behavior.ts","../src/modes/select/behaviors/drag-coordinate.behavior.ts","../src/geometry/centroid.ts","../src/geometry/transform/rotate.ts","../src/geometry/web-mercator-centroid.ts","../src/modes/select/behaviors/rotate-feature.behavior.ts","../src/geometry/measure/rhumb-distance.ts","../src/modes/select/behaviors/scale-feature.behavior.ts","../src/geometry/transform/scale.ts","../src/modes/select/behaviors/drag-coordinate-resize.behavior.ts","../src/modes/select/select.mode.ts","../src/modes/static/static.mode.ts","../src/store/spatial-index/quickselect.ts","../src/store/spatial-index/rbush.ts","../src/store/spatial-index/spatial-index.ts","../src/store/store.ts","../src/util/id.ts","../src/geometry/measure/area.ts","../src/validations/min-size.validation.ts","../src/validations/max-size.validation.ts","../src/validations/not-self-intersecting.validation.ts","../src/geometry/calculate-relative-angle.ts","../src/modes/angled-rectangle/angled-rectangle.mode.ts","../src/geometry/determine-halfplane.ts","../src/geometry/clockwise.ts","../src/modes/sector/sector.mode.ts","../src/modes/sensor/sensor.mode.ts","../src/common/adapter-listener.ts","../src/common/base.adapter.ts","../src/validation-reasons.ts","../src/modes/freehand-linestring/freehand-linestring.mode.ts","../src/store/valid-json.ts","../src/terra-draw.ts"],"sourcesContent":["import { LineString, Polygon, Position } from \"geojson\";\nimport {\n\tStoreChangeHandler,\n\tGeoJSONStore,\n\tGeoJSONStoreFeatures,\n\tFeatureId,\n} from \"./store/store\";\n\nexport type HexColor = `#${string}`;\n\nexport type HexColorStyling =\n\t| HexColor\n\t| ((feature: GeoJSONStoreFeatures) => HexColor);\n\nexport type NumericStyling =\n\t| number\n\t| ((feature: GeoJSONStoreFeatures) => number);\n\nexport interface TerraDrawAdapterStyling {\n\tpointColor: HexColor;\n\tpointWidth: number;\n\tpointOutlineColor: HexColor;\n\tpointOutlineWidth: number;\n\tpolygonFillColor: HexColor;\n\tpolygonFillOpacity: number;\n\tpolygonOutlineColor: HexColor;\n\tpolygonOutlineWidth: number;\n\tlineStringWidth: number;\n\tlineStringColor: HexColor;\n\tzIndex: number;\n}\n\nexport type CartesianPoint = { x: number; y: number };\n\n// Neither buttons nor touch/pen contact changed since last event\t-1\n// Mouse move with no buttons pressed, Pen moved while hovering with no buttons pressed\t—\n// Left Mouse, Touch Contact, Pen contact\t0\n// Middle Mouse\t1\n// Right Mouse, Pen barrel button\t2\nexport interface TerraDrawMouseEvent {\n\tlng: number;\n\tlat: number;\n\tcontainerX: number;\n\tcontainerY: number;\n\tbutton: \"neither\" | \"left\" | \"middle\" | \"right\";\n\theldKeys: string[];\n\tisContextMenu: boolean;\n}\n\nexport interface TerraDrawKeyboardEvent {\n\tkey: string;\n\theldKeys: string[];\n\tpreventDefault: () => void;\n}\n\nexport type Cursor = Parameters<SetCursor>[0];\n\nexport type SetCursor = (\n\tcursor:\n\t\t| \"unset\"\n\t\t| \"grab\"\n\t\t| \"grabbing\"\n\t\t| \"crosshair\"\n\t\t| \"pointer\"\n\t\t| \"wait\"\n\t\t| \"move\",\n) => void;\n\nexport type Project = (lng: number, lat: number) => CartesianPoint;\nexport type Unproject = (x: number, y: number) => { lat: number; lng: number };\nexport type GetLngLatFromEvent = (event: PointerEvent | MouseEvent) => {\n\tlng: number;\n\tlat: number;\n} | null;\n\nexport type Projection = \"web-mercator\" | \"globe\";\n\nexport type OnFinishContext = { mode: string; action: string };\n\nexport type OnChangeContext = { origin: \"api\" };\n\nexport type TerraDrawGeoJSONStore = GeoJSONStore<\n\tOnChangeContext | undefined,\n\tFeatureId\n>;\n\nexport interface TerraDrawModeRegisterConfig {\n\tmode: string;\n\tstore: TerraDrawGeoJSONStore;\n\tsetDoubleClickToZoom: (enabled: boolean) => void;\n\tsetCursor: SetCursor;\n\tonChange: StoreChangeHandler<OnChangeContext | undefined>;\n\tonSelect: (selectedId: string) => void;\n\tonDeselect: (deselectedId: string) => void;\n\tonFinish: (finishedId: string, context: OnFinishContext) => void;\n\tproject: Project;\n\tunproject: Unproject;\n\tcoordinatePrecision: number;\n}\n\nexport enum UpdateTypes {\n\tCommit = \"commit\",\n\tProvisional = \"provisional\",\n\tFinish = \"finish\",\n}\n\ntype ValidationContext = Pick<\n\tTerraDrawModeRegisterConfig,\n\t\"project\" | \"unproject\" | \"coordinatePrecision\"\n> & {\n\tupdateType: UpdateTypes;\n};\n\nexport type Validation = (\n\tfeature: GeoJSONStoreFeatures,\n\tcontext: ValidationContext,\n) => {\n\tvalid: boolean;\n\treason?: string;\n};\n\nexport interface Snapping {\n\ttoLine?: boolean;\n\ttoCoordinate?: boolean;\n\ttoCustom?: (\n\t\tevent: TerraDrawMouseEvent,\n\t\tcontext: {\n\t\t\tcurrentId?: FeatureId;\n\t\t\tcurrentCoordinate?: number;\n\t\t\tgetCurrentGeometrySnapshot: () => (Polygon | LineString) | null;\n\t\t\tproject: Project;\n\t\t\tunproject: Unproject;\n\t\t},\n\t) => Position | undefined;\n}\n\nexport type TerraDrawModeState =\n\t| \"unregistered\"\n\t| \"registered\"\n\t| \"started\"\n\t| \"drawing\"\n\t| \"selecting\"\n\t| \"stopped\";\n\nexport interface TerraDrawCallbacks {\n\tgetState: () => TerraDrawModeState;\n\tonKeyUp: (event: TerraDrawKeyboardEvent) => void;\n\tonKeyDown: (event: TerraDrawKeyboardEvent) => void;\n\tonClick: (event: TerraDrawMouseEvent) => void;\n\tonMouseMove: (event: TerraDrawMouseEvent) => void;\n\tonDragStart: (\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) => void;\n\tonDrag: (\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) => void;\n\tonDragEnd: (\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) => void;\n\tonClear: () => void;\n\tonReady?(): void;\n}\n\nexport interface TerraDrawChanges {\n\tcreated: GeoJSONStoreFeatures[];\n\tupdated: GeoJSONStoreFeatures[];\n\tunchanged: GeoJSONStoreFeatures[];\n\tdeletedIds: FeatureId[];\n}\n\nexport type TerraDrawStylingFunction = {\n\t[mode: string]: (feature: GeoJSONStoreFeatures) => TerraDrawAdapterStyling;\n};\n\nexport interface TerraDrawAdapter {\n\tproject: Project;\n\tunproject: Unproject;\n\tsetCursor: SetCursor;\n\tgetLngLatFromEvent: GetLngLatFromEvent;\n\tsetDoubleClickToZoom: (enabled: boolean) => void;\n\tgetMapEventElement: () => HTMLElement;\n\tregister(callbacks: TerraDrawCallbacks): void;\n\tunregister(): void;\n\trender(changes: TerraDrawChanges, styling: TerraDrawStylingFunction): void;\n\tclear(): void;\n\tgetCoordinatePrecision(): number;\n}\n\nexport const SELECT_PROPERTIES = {\n\tSELECTED: \"selected\",\n\tMID_POINT: \"midPoint\",\n\tSELECTION_POINT_FEATURE_ID: \"selectionPointFeatureId\",\n\tSELECTION_POINT: \"selectionPoint\",\n} as const;\n\nexport const COMMON_PROPERTIES = {\n\tMODE: \"mode\",\n\tCURRENTLY_DRAWING: \"currentlyDrawing\",\n\tEDITED: \"edited\",\n\tCLOSING_POINT: \"closingPoint\",\n\tSNAPPING_POINT: \"snappingPoint\",\n\tCOORDINATE_POINT: \"coordinatePoint\",\n\tCOORDINATE_POINT_FEATURE_ID: \"coordinatePointFeatureId\",\n\tCOORDINATE_POINT_IDS: \"coordinatePointIds\",\n\tPROVISIONAL_COORDINATE_COUNT: \"provisionalCoordinateCount\",\n\tCOMMITTED_COORDINATE_COUNT: \"committedCoordinateCount\",\n} as const;\n\n/**\n * Lower z-index represents layers that are lower in the stack\n * and higher z-index represents layers that are higher in the stack\n * i.e. a layer with z-index 10 will be rendered below a layer with z-index 20\n */\nexport const Z_INDEX = {\n\tLAYER_ONE: 10,\n\tLAYER_TWO: 20,\n\tLAYER_THREE: 30,\n\tLAYER_FOUR: 40,\n\tLAYER_FIVE: 50,\n} as const;\n","import { Validation } from \"../common\";\nimport { FeatureId, IdStrategy } from \"./store\";\n\nexport const StoreValidationErrors = {\n\tFeatureHasNoId: \"Feature has no id\",\n\tFeatureIsNotObject: \"Feature is not object\",\n\tInvalidTrackedProperties: \"updatedAt and createdAt are not valid timestamps\",\n\tFeatureHasNoMode: \"Feature does not have a set mode\",\n\tFeatureIdIsNotValidGeoJSON: `Feature must be string or number as per GeoJSON spec`,\n\tFeatureIdIsNotValid: `Feature must match the id strategy (default is UUID4)`,\n\tFeatureHasNoGeometry: \"Feature has no geometry\",\n\tFeatureHasNoProperties: \"Feature has no properties\",\n\tFeatureGeometryNotSupported: \"Feature is not Point, LineString or Polygon\",\n\tFeatureCoordinatesNotAnArray: \"Feature coordinates is not an array\",\n\tInvalidModeProperty: \"Feature does not have a valid mode property\",\n} as const;\n\nfunction isObject(\n\tfeature: unknown,\n): feature is Record<string | number, unknown> {\n\treturn Boolean(\n\t\tfeature &&\n\t\t\ttypeof feature === \"object\" &&\n\t\t\tfeature !== null &&\n\t\t\t!Array.isArray(feature),\n\t);\n}\n\nexport function hasModeProperty(\n\tfeature: unknown,\n): feature is { properties: { mode: string } } {\n\treturn Boolean(\n\t\tfeature &&\n\t\t\ttypeof feature === \"object\" &&\n\t\t\t\"properties\" in feature &&\n\t\t\ttypeof feature.properties === \"object\" &&\n\t\t\tfeature.properties !== null &&\n\t\t\t\"mode\" in feature.properties,\n\t);\n}\n\nfunction dateIsValid(timestamp: unknown): boolean {\n\treturn (\n\t\ttypeof timestamp === \"number\" &&\n\t\t!isNaN(new Date(timestamp as number).valueOf())\n\t);\n}\n\nexport function isValidTimestamp(timestamp: unknown): boolean {\n\tif (!dateIsValid(timestamp)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport function isValidStoreFeature(\n\tfeature: unknown,\n\tisValidId: IdStrategy<FeatureId>[\"isValidId\"],\n): ReturnType<Validation> {\n\tlet error;\n\tif (!isObject(feature)) {\n\t\terror = StoreValidationErrors.FeatureIsNotObject;\n\t} else if (feature.id === null || feature.id === undefined) {\n\t\terror = StoreValidationErrors.FeatureHasNoId;\n\t} else if (typeof feature.id !== \"string\" && typeof feature.id !== \"number\") {\n\t\terror = StoreValidationErrors.FeatureIdIsNotValidGeoJSON;\n\t} else if (!isValidId(feature.id)) {\n\t\terror = StoreValidationErrors.FeatureIdIsNotValid;\n\t} else if (!isObject(feature.geometry)) {\n\t\terror = StoreValidationErrors.FeatureHasNoGeometry;\n\t} else if (!isObject(feature.properties)) {\n\t\terror = StoreValidationErrors.FeatureHasNoProperties;\n\t} else if (\n\t\ttypeof feature.geometry.type !== \"string\" ||\n\t\t![\"Polygon\", \"LineString\", \"Point\"].includes(feature.geometry.type)\n\t) {\n\t\terror = StoreValidationErrors.FeatureGeometryNotSupported;\n\t} else if (!Array.isArray(feature.geometry.coordinates)) {\n\t\terror = StoreValidationErrors.FeatureCoordinatesNotAnArray;\n\t} else if (\n\t\t!feature.properties.mode ||\n\t\ttypeof feature.properties.mode !== \"string\"\n\t) {\n\t\treturn { valid: false, reason: StoreValidationErrors.InvalidModeProperty };\n\t}\n\n\tif (error) {\n\t\treturn { valid: false, reason: error };\n\t}\n\n\treturn { valid: true };\n}\n","export const ValidationReasonFeatureNotPolygon = \"Feature is not a Polygon\";\nexport const ValidationReasonModeMismatch =\n\t\"Feature mode property does not match the mode being added to\";\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport {\n\tOnChangeContext,\n\tHexColor,\n\tOnFinishContext,\n\tProjection,\n\tTerraDrawAdapterStyling,\n\tTerraDrawGeoJSONStore,\n\tTerraDrawKeyboardEvent,\n\tTerraDrawModeRegisterConfig,\n\tTerraDrawModeState,\n\tTerraDrawMouseEvent,\n\tUpdateTypes,\n\tValidation,\n} from \"../common\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreChangeHandler,\n} from \"../store/store\";\nimport { isValidStoreFeature } from \"../store/store-feature-validation\";\nimport { ValidationReasonModeMismatch } from \"../validations/common-validations\";\n\nexport type CustomStyling = Record<\n\tstring,\n\t| string\n\t| number\n\t| ((feature: GeoJSONStoreFeatures) => HexColor)\n\t| ((feature: GeoJSONStoreFeatures) => number)\n>;\n\nexport enum ModeTypes {\n\tDrawing = \"drawing\",\n\tSelect = \"select\",\n\tStatic = \"static\",\n\tRender = \"render\",\n}\n\nexport const DefaultPointerEvents = {\n\trightClick: true,\n\tcontextMenu: false,\n\tleftClick: true,\n\tonDragStart: true,\n\tonDrag: true,\n\tonDragEnd: true,\n} as const;\n\ntype AllowPointerEvent = boolean | ((event: TerraDrawMouseEvent) => boolean);\n\nexport interface PointerEvents {\n\tleftClick: AllowPointerEvent;\n\trightClick: AllowPointerEvent;\n\tcontextMenu: AllowPointerEvent;\n\tonDragStart: AllowPointerEvent;\n\tonDrag: AllowPointerEvent;\n\tonDragEnd: AllowPointerEvent;\n}\n\nexport type BaseModeOptions<Styling extends CustomStyling> = {\n\tstyles?: Partial<Styling>;\n\tpointerDistance?: number;\n\tvalidation?: Validation;\n\tprojection?: Projection;\n\tpointerEvents?: PointerEvents;\n};\n\nexport abstract class TerraDrawBaseDrawMode<Styling extends CustomStyling> {\n\t// State\n\tprotected _state: TerraDrawModeState = \"unregistered\";\n\tget state() {\n\t\treturn this._state;\n\t}\n\tset state(_) {\n\t\tthrow new Error(\"Please use the modes lifecycle methods\");\n\t}\n\n\t// Styles\n\tprotected _styles: Partial<Styling> = {};\n\tget styles(): Partial<Styling> {\n\t\treturn this._styles;\n\t}\n\tset styles(styling: Partial<Styling>) {\n\t\tif (typeof styling !== \"object\") {\n\t\t\tthrow new Error(\"Styling must be an object\");\n\t\t}\n\n\t\t// Note: This may not be initialised yet as styles can be set/changed pre-registration\n\t\tif (this.onStyleChange) {\n\t\t\tthis.onStyleChange([], \"styling\");\n\t\t}\n\t\tthis._styles = styling;\n\t}\n\n\tprotected pointerEvents: PointerEvents = DefaultPointerEvents;\n\tprotected behaviors: TerraDrawModeBehavior[] = [];\n\tprotected validate: Validation | undefined;\n\tprotected pointerDistance: number = 40;\n\tprotected coordinatePrecision!: number;\n\tprotected onStyleChange!: StoreChangeHandler<OnChangeContext | undefined>;\n\tprotected store!: TerraDrawGeoJSONStore;\n\tprotected projection: Projection = \"web-mercator\";\n\n\tprotected setDoubleClickToZoom!: TerraDrawModeRegisterConfig[\"setDoubleClickToZoom\"];\n\tprotected unproject!: TerraDrawModeRegisterConfig[\"unproject\"];\n\tprotected project!: TerraDrawModeRegisterConfig[\"project\"];\n\tprotected setCursor!: TerraDrawModeRegisterConfig[\"setCursor\"];\n\tprotected registerBehaviors(behaviorConfig: BehaviorConfig): void {}\n\n\tconstructor(\n\t\toptions?: BaseModeOptions<Styling>,\n\t\twillCallUpdateOptionsInParentClass = false,\n\t) {\n\t\t// Note: We want to updateOptions on the base class by default, but we don't want it to be\n\t\t// called twice if the extending class is going to call it as well\n\t\tif (!willCallUpdateOptionsInParentClass) {\n\t\t\tthis.updateOptions(options);\n\t\t}\n\t}\n\n\tupdateOptions(options?: BaseModeOptions<Styling>) {\n\t\tif (options?.styles) {\n\t\t\t// Note: we are updating this.styles and not this._styles - this is because\n\t\t\t// once registered we want to trigger the onStyleChange\n\t\t\tthis.styles = { ...this._styles, ...options.styles };\n\t\t}\n\n\t\tif (options?.pointerDistance) {\n\t\t\tthis.pointerDistance = options.pointerDistance;\n\t\t}\n\t\tif (options?.validation) {\n\t\t\tthis.validate = options && options.validation;\n\t\t}\n\t\tif (options?.projection) {\n\t\t\tthis.projection = options.projection;\n\t\t}\n\n\t\tif (options?.pointerEvents !== undefined) {\n\t\t\tthis.pointerEvents = options.pointerEvents;\n\t\t}\n\t}\n\n\tprotected allowPointerEvent(\n\t\tpointerEvent: AllowPointerEvent,\n\t\tevent: TerraDrawMouseEvent,\n\t) {\n\t\tif (typeof pointerEvent === \"boolean\") {\n\t\t\treturn pointerEvent;\n\t\t}\n\t\tif (typeof pointerEvent === \"function\") {\n\t\t\treturn pointerEvent(event);\n\t\t}\n\t\treturn true;\n\t}\n\n\ttype = ModeTypes.Drawing;\n\tmode = \"base\";\n\n\tprotected setDrawing() {\n\t\tif (this._state === \"started\") {\n\t\t\tthis._state = \"drawing\";\n\t\t} else {\n\t\t\tthrow new Error(\"Mode must be unregistered or stopped to start\");\n\t\t}\n\t}\n\n\tprotected setStarted() {\n\t\tif (\n\t\t\tthis._state === \"stopped\" ||\n\t\t\tthis._state === \"registered\" ||\n\t\t\tthis._state === \"drawing\" ||\n\t\t\tthis._state === \"selecting\"\n\t\t) {\n\t\t\tthis._state = \"started\";\n\t\t\tthis.setDoubleClickToZoom(false);\n\t\t} else {\n\t\t\tthrow new Error(\"Mode must be unregistered or stopped to start\");\n\t\t}\n\t}\n\n\tprotected setStopped() {\n\t\tif (this._state === \"started\") {\n\t\t\tthis._state = \"stopped\";\n\t\t\tthis.setDoubleClickToZoom(true);\n\t\t} else {\n\t\t\tthrow new Error(\"Mode must be started to be stopped\");\n\t\t}\n\t}\n\n\tregister(config: TerraDrawModeRegisterConfig) {\n\t\tif (this._state === \"unregistered\") {\n\t\t\tthis._state = \"registered\";\n\t\t\tthis.store = config.store;\n\t\t\tthis.store.registerOnChange(config.onChange);\n\t\t\tthis.setDoubleClickToZoom = config.setDoubleClickToZoom;\n\t\t\tthis.project = config.project;\n\t\t\tthis.unproject = config.unproject;\n\t\t\tthis.onSelect = config.onSelect;\n\t\t\tthis.onDeselect = config.onDeselect;\n\t\t\tthis.setCursor = config.setCursor;\n\t\t\tthis.onStyleChange = config.onChange;\n\t\t\tthis.onFinish = config.onFinish;\n\t\t\tthis.coordinatePrecision = config.coordinatePrecision;\n\n\t\t\tthis.registerBehaviors({\n\t\t\t\tmode: config.mode,\n\t\t\t\tstore: this.store,\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t\tpointerDistance: this.pointerDistance,\n\t\t\t\tcoordinatePrecision: config.coordinatePrecision,\n\t\t\t\tprojection: this.projection,\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error(\"Can not register unless mode is unregistered\");\n\t\t}\n\t}\n\n\tvalidateFeature(feature: unknown): ReturnType<Validation> {\n\t\treturn this.performFeatureValidation(feature);\n\t}\n\n\tafterFeatureAdded(feature: GeoJSONStoreFeatures) {}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {}\n\n\tprivate performFeatureValidation(feature: unknown): ReturnType<Validation> {\n\t\tif (this._state === \"unregistered\") {\n\t\t\tthrow new Error(\"Mode must be registered\");\n\t\t}\n\n\t\tconst validStoreFeature = isValidStoreFeature(\n\t\t\tfeature,\n\t\t\tthis.store.idStrategy.isValidId,\n\t\t);\n\n\t\t// We also want tp validate based on any specific valdiations passed in\n\t\tif (this.validate) {\n\t\t\tconst validation = this.validate(feature as GeoJSONStoreFeatures, {\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\t// validatedFeature: feature as GeoJSONStoreFeatures,\n\t\t\t\tvalid: validStoreFeature.valid && validation.valid,\n\t\t\t\treason: validation.reason,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t// validatedFeature: feature as GeoJSONStoreFeatures,\n\t\t\tvalid: validStoreFeature.valid,\n\t\t\treason: validStoreFeature.reason,\n\t\t};\n\t}\n\n\tprotected validateModeFeature(\n\t\tfeature: unknown,\n\t\tmodeValidationFn: (feature: GeoJSONStoreFeatures) => ReturnType<Validation>,\n\t): ReturnType<Validation> {\n\t\tconst validation = this.performFeatureValidation(feature);\n\t\tif (validation.valid) {\n\t\t\tconst validatedFeature = feature as GeoJSONStoreFeatures;\n\t\t\tconst matches = validatedFeature.properties.mode === this.mode;\n\t\t\tif (!matches) {\n\t\t\t\treturn {\n\t\t\t\t\tvalid: false,\n\t\t\t\t\treason: ValidationReasonModeMismatch,\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst modeValidation = modeValidationFn(validatedFeature);\n\t\t\treturn modeValidation;\n\t\t}\n\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: validation.reason,\n\t\t};\n\t}\n\n\tabstract start(): void;\n\tabstract stop(): void;\n\tabstract cleanUp(): void;\n\tabstract styleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling;\n\n\tonFinish(finishedId: FeatureId, context: OnFinishContext) {}\n\tonDeselect(deselectedId: FeatureId) {}\n\tonSelect(selectedId: FeatureId) {}\n\tonKeyDown(event: TerraDrawKeyboardEvent) {}\n\tonKeyUp(event: TerraDrawKeyboardEvent) {}\n\tonMouseMove(event: TerraDrawMouseEvent) {}\n\tonClick(event: TerraDrawMouseEvent) {}\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {}\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {}\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {}\n\n\tprotected getHexColorStylingValue(\n\t\tvalue: HexColor | ((feature: GeoJSONStoreFeatures) => HexColor) | undefined,\n\t\tdefaultValue: HexColor,\n\t\tfeature: GeoJSONStoreFeatures,\n\t): HexColor {\n\t\treturn this.getStylingValue(value, defaultValue, feature);\n\t}\n\n\tprotected getNumericStylingValue(\n\t\tvalue: number | ((feature: GeoJSONStoreFeatures) => number) | undefined,\n\t\tdefaultValue: number,\n\t\tfeature: GeoJSONStoreFeatures,\n\t): number {\n\t\treturn this.getStylingValue(value, defaultValue, feature);\n\t}\n\n\tprivate getStylingValue<T extends string | number>(\n\t\tvalue: T | ((feature: GeoJSONStoreFeatures) => T) | undefined,\n\t\tdefaultValue: T,\n\t\tfeature: GeoJSONStoreFeatures,\n\t) {\n\t\tif (value === undefined) {\n\t\t\treturn defaultValue;\n\t\t} else if (typeof value === \"function\") {\n\t\t\treturn value(feature);\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nexport abstract class TerraDrawBaseSelectMode<\n\tStyling extends CustomStyling,\n> extends TerraDrawBaseDrawMode<Styling> {\n\tpublic type = ModeTypes.Select;\n\n\tpublic abstract selectFeature(featureId: FeatureId): void;\n\tpublic abstract deselectFeature(featureId: FeatureId): void;\n}\n","import { Position } from \"geojson\";\n\nexport function haversineDistanceKilometers(\n\tpointOne: Position,\n\tpointTwo: Position,\n) {\n\tconst toRadians = (latOrLng: number) => (latOrLng * Math.PI) / 180;\n\n\tconst phiOne = toRadians(pointOne[1]);\n\tconst lambdaOne = toRadians(pointOne[0]);\n\tconst phiTwo = toRadians(pointTwo[1]);\n\tconst lambdaTwo = toRadians(pointTwo[0]);\n\tconst deltaPhi = phiTwo - phiOne;\n\tconst deltalambda = lambdaTwo - lambdaOne;\n\n\tconst a =\n\t\tMath.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\n\t\tMath.cos(phiOne) *\n\t\t\tMath.cos(phiTwo) *\n\t\t\tMath.sin(deltalambda / 2) *\n\t\t\tMath.sin(deltalambda / 2);\n\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n\tconst radius = 6371e3;\n\tconst distance = radius * c;\n\n\treturn distance / 1000;\n}\n","export const earthRadius = 6371008.8;\n\nexport function degreesToRadians(degrees: number): number {\n\tconst radians = degrees % 360;\n\treturn (radians * Math.PI) / 180;\n}\n\nexport function lengthToRadians(distance: number): number {\n\tconst factor = earthRadius / 1000;\n\treturn distance / factor;\n}\n\nexport function radiansToDegrees(radians: number): number {\n\tconst degrees = radians % (2 * Math.PI);\n\treturn (degrees * 180) / Math.PI;\n}\n","export function limitPrecision(num: number, decimalLimit = 9) {\n\tconst decimals = Math.pow(10, decimalLimit);\n\treturn Math.round(num * decimals) / decimals;\n}\n","import { CartesianPoint } from \"../../common\";\n\nconst RADIANS_TO_DEGREES = 57.29577951308232 as const; // 180 / Math.PI\nconst DEGREES_TO_RADIANS = 0.017453292519943295 as const; // Math.PI / 180\nconst R = 6378137 as const;\n\n/**\n * Convert longitude and latitude to web mercator x and y\n * @param lng\n * @param lat\n * @returns - web mercator x and y\n */\nexport const lngLatToWebMercatorXY = (\n\tlng: number,\n\tlat: number,\n): CartesianPoint => ({\n\tx: lng === 0 ? 0 : lng * DEGREES_TO_RADIANS * R,\n\ty:\n\t\tlat === 0\n\t\t\t? 0\n\t\t\t: Math.log(Math.tan(Math.PI / 4 + (lat * DEGREES_TO_RADIANS) / 2)) * R,\n});\n\n/**\n * Convert web mercator x and y to longitude and latitude\n * @param x - web mercator x\n * @param y - web mercator y\n * @returns - longitude and latitude\n */\nexport const webMercatorXYToLngLat = (\n\tx: number,\n\ty: number,\n): { lng: number; lat: number } => ({\n\tlng: x === 0 ? 0 : RADIANS_TO_DEGREES * (x / R),\n\tlat:\n\t\ty === 0\n\t\t\t? 0\n\t\t\t: (2 * Math.atan(Math.exp(y / R)) - Math.PI / 2) * RADIANS_TO_DEGREES,\n});\n","import { Feature, Polygon, Position } from \"geojson\";\nimport {\n\tdegreesToRadians,\n\tlengthToRadians,\n\tradiansToDegrees,\n} from \"../helpers\";\nimport { limitPrecision } from \"../limit-decimal-precision\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../project/web-mercator\";\n\n// Adapted from the @turf/circle module which is MIT Licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-circle/index.ts\n\nfunction destination(\n\torigin: Position,\n\tdistance: number,\n\tbearing: number,\n): Position {\n\tconst longitude1 = degreesToRadians(origin[0]);\n\tconst latitude1 = degreesToRadians(origin[1]);\n\tconst bearingRad = degreesToRadians(bearing);\n\tconst radians = lengthToRadians(distance);\n\n\t// Main\n\tconst latitude2 = Math.asin(\n\t\tMath.sin(latitude1) * Math.cos(radians) +\n\t\t\tMath.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad),\n\t);\n\tconst longitude2 =\n\t\tlongitude1 +\n\t\tMath.atan2(\n\t\t\tMath.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\n\t\t\tMath.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2),\n\t\t);\n\tconst lng = radiansToDegrees(longitude2);\n\tconst lat = radiansToDegrees(latitude2);\n\n\treturn [lng, lat];\n}\n\nexport function circle(options: {\n\tcenter: Position;\n\tradiusKilometers: number;\n\tcoordinatePrecision: number;\n\tsteps?: number;\n}): Feature<Polygon> {\n\tconst { center, radiusKilometers, coordinatePrecision } = options;\n\tconst steps = options.steps ? options.steps : 64;\n\n\tconst coordinates: Position[] = [];\n\tfor (let i = 0; i < steps; i++) {\n\t\tconst circleCoordinate = destination(\n\t\t\tcenter,\n\t\t\tradiusKilometers,\n\t\t\t(i * -360) / steps,\n\t\t);\n\n\t\tcoordinates.push([\n\t\t\tlimitPrecision(circleCoordinate[0], coordinatePrecision),\n\t\t\tlimitPrecision(circleCoordinate[1], coordinatePrecision),\n\t\t]);\n\t}\n\tcoordinates.push(coordinates[0]);\n\n\treturn {\n\t\ttype: \"Feature\",\n\t\tgeometry: { type: \"Polygon\", coordinates: [coordinates] },\n\t\tproperties: {},\n\t};\n}\n\nexport function circleWebMercator(options: {\n\tcenter: Position;\n\tradiusKilometers: number;\n\tcoordinatePrecision: number;\n\tsteps?: number;\n}): GeoJSON.Feature<GeoJSON.Polygon> {\n\tconst { center, radiusKilometers, coordinatePrecision } = options;\n\tconst steps = options.steps ? options.steps : 64;\n\n\tconst radiusMeters = radiusKilometers * 1000;\n\n\tconst [lng, lat] = center;\n\tconst { x, y } = lngLatToWebMercatorXY(lng, lat);\n\n\tconst coordinates: Position[] = [];\n\tfor (let i = 0; i < steps; i++) {\n\t\tconst angle = (((i * 360) / steps) * Math.PI) / 180;\n\t\tconst dx = radiusMeters * Math.cos(angle);\n\t\tconst dy = radiusMeters * Math.sin(angle);\n\t\tconst [wx, wy] = [x + dx, y + dy];\n\t\tconst { lng, lat } = webMercatorXYToLngLat(wx, wy);\n\t\tcoordinates.push([\n\t\t\tlimitPrecision(lng, coordinatePrecision),\n\t\t\tlimitPrecision(lat, coordinatePrecision),\n\t\t]);\n\t}\n\n\t// Close the circle by adding the first point at the end\n\tcoordinates.push(coordinates[0]);\n\n\treturn {\n\t\ttype: \"Feature\",\n\t\tgeometry: { type: \"Polygon\", coordinates: [coordinates] },\n\t\tproperties: {},\n\t};\n}\n","// Based on - https://github.com/mclaeysb/geojson-polygon-self-intersections\n// MIT License - Copyright (c) 2016 Manuel Claeys Bouuaert\n\nimport { Feature, LineString, Polygon, Position } from \"geojson\";\n// import * as rbush from \"rbush\";\n\ntype SelfIntersectsOptions = {\n\tepsilon: number;\n\t// reportVertexOnVertex: boolean;\n\t// reportVertexOnEdge: boolean;\n};\n\nexport function selfIntersects(\n\tfeature: Feature<Polygon> | Feature<LineString>,\n): boolean {\n\tconst options: SelfIntersectsOptions = {\n\t\tepsilon: 0,\n\t\t// reportVertexOnVertex: false,\n\t\t// reportVertexOnEdge: false,\n\t};\n\n\tlet coord: number[][][];\n\n\tif (feature.geometry.type === \"Polygon\") {\n\t\tcoord = feature.geometry.coordinates;\n\t} else if (feature.geometry.type === \"LineString\") {\n\t\tcoord = [feature.geometry.coordinates];\n\t} else {\n\t\tthrow new Error(\"Self intersects only accepts Polygons and LineStrings\");\n\t}\n\n\tconst output: number[][] = [];\n\tconst seen: { [key: string]: boolean } = {};\n\n\tfor (let ring0 = 0; ring0 < coord.length; ring0++) {\n\t\tfor (let edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {\n\t\t\tfor (let ring1 = 0; ring1 < coord.length; ring1++) {\n\t\t\t\tfor (let edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {\n\t\t\t\t\t// speedup possible if only interested in unique: start last two loops at ring0 and edge0+1\n\t\t\t\t\tifInteresctionAddToOutput(ring0, edge0, ring1, edge1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.length > 0;\n\n\t// true if frac is (almost) 1.0 or 0.0\n\t// function isBoundaryCase(frac: number) {\n\t//   const e2 = options.epsilon * options.epsilon;\n\t//   return e2 >= (frac - 1) * (frac - 1) || e2 >= frac * frac;\n\t// }\n\n\tfunction isOutside(frac: number) {\n\t\treturn frac < 0 - options.epsilon || frac > 1 + options.epsilon;\n\t}\n\t// Function to check if two edges intersect and add the intersection to the output\n\tfunction ifInteresctionAddToOutput(\n\t\tring0: number,\n\t\tedge0: number,\n\t\tring1: number,\n\t\tedge1: number,\n\t) {\n\t\tconst start0 = coord[ring0][edge0];\n\t\tconst end0 = coord[ring0][edge0 + 1];\n\t\tconst start1 = coord[ring1][edge1];\n\t\tconst end1 = coord[ring1][edge1 + 1];\n\n\t\tconst intersection = intersect(start0, end0, start1, end1);\n\n\t\tif (intersection === null) {\n\t\t\treturn; // discard parallels and coincidence\n\t\t}\n\n\t\tlet frac0;\n\t\tlet frac1;\n\n\t\tif (end0[0] !== start0[0]) {\n\t\t\tfrac0 = (intersection[0] - start0[0]) / (end0[0] - start0[0]);\n\t\t} else {\n\t\t\tfrac0 = (intersection[1] - start0[1]) / (end0[1] - start0[1]);\n\t\t}\n\t\tif (end1[0] !== start1[0]) {\n\t\t\tfrac1 = (intersection[0] - start1[0]) / (end1[0] - start1[0]);\n\t\t} else {\n\t\t\tfrac1 = (intersection[1] - start1[1]) / (end1[1] - start1[1]);\n\t\t}\n\n\t\t// There are roughly three cases we need to deal with.\n\t\t// 1. If at least one of the fracs lies outside [0,1], there is no intersection.\n\t\tif (isOutside(frac0) || isOutside(frac1)) {\n\t\t\treturn; // require segment intersection\n\t\t}\n\n\t\t// 2. If both are either exactly 0 or exactly 1, this is not an intersection but just\n\t\t// two edge segments sharing a common vertex.\n\t\t// if (isBoundaryCase(frac0) && isBoundaryCase(frac1)) {\n\t\t//   if (!options.reportVertexOnVertex) {\n\t\t//     return;\n\t\t//   }\n\t\t// }\n\n\t\t// // 3. If only one of the fractions is exactly 0 or 1, this is\n\t\t// // a vertex-on-edge situation.\n\t\t// if (isBoundaryCase(frac0) || isBoundaryCase(frac1)) {\n\t\t//   if (!options.reportVertexOnEdge) {\n\t\t//     return;\n\t\t//   }\n\t\t// }\n\n\t\tconst key = intersection.toString();\n\t\tconst unique = !seen[key];\n\t\tif (unique) {\n\t\t\tseen[key] = true;\n\t\t}\n\n\t\toutput.push(intersection);\n\t}\n}\n\nfunction equalArrays(array1: Position, array2: Position) {\n\treturn array1[0] === array2[0] && array1[1] === array2[1];\n}\n\n// Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\nfunction intersect(\n\tstart0: Position,\n\tend0: Position,\n\tstart1: Position,\n\tend1: Position,\n) {\n\tif (\n\t\tequalArrays(start0, start1) ||\n\t\tequalArrays(start0, end1) ||\n\t\tequalArrays(end0, start1) ||\n\t\tequalArrays(end1, start1)\n\t) {\n\t\treturn null;\n\t}\n\n\tconst x0 = start0[0],\n\t\ty0 = start0[1],\n\t\tx1 = end0[0],\n\t\ty1 = end0[1],\n\t\tx2 = start1[0],\n\t\ty2 = start1[1],\n\t\tx3 = end1[0],\n\t\ty3 = end1[1];\n\n\tconst denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);\n\tif (denom === 0) {\n\t\treturn null;\n\t}\n\n\tconst x4 =\n\t\t((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;\n\n\tconst y4 =\n\t\t((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;\n\n\treturn [x4, y4];\n}\n","import { Position } from \"geojson\";\n\nexport function validLatitude(lat: number) {\n\treturn lat >= -90 && lat <= 90;\n}\n\nexport function validLongitude(lng: number) {\n\treturn lng >= -180 && lng <= 180;\n}\n\nexport function coordinatePrecisionIsValid(\n\tcoordinate: Position,\n\tcoordinatePrecision: number,\n) {\n\treturn (\n\t\tgetDecimalPlaces(coordinate[0]) <= coordinatePrecision &&\n\t\tgetDecimalPlaces(coordinate[1]) <= coordinatePrecision\n\t);\n}\n\nexport function coordinateIsValid(coordinate: unknown[]) {\n\treturn (\n\t\tcoordinate.length === 2 &&\n\t\ttypeof coordinate[0] === \"number\" &&\n\t\ttypeof coordinate[1] === \"number\" &&\n\t\tcoordinate[0] !== Infinity &&\n\t\tcoordinate[1] !== Infinity &&\n\t\tvalidLongitude(coordinate[0]) &&\n\t\tvalidLatitude(coordinate[1])\n\t);\n}\n\nexport function getDecimalPlaces(value: number): number {\n\tlet current = 1;\n\tlet precision = 0;\n\twhile (Math.round(value * current) / current !== value) {\n\t\tcurrent *= 10;\n\t\tprecision++;\n\t}\n\n\treturn precision;\n}\n","import { Feature, Polygon, Position } from \"geojson\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport { selfIntersects } from \"../geometry/boolean/self-intersects\";\nimport {\n\tcoordinateIsValid,\n\tcoordinatePrecisionIsValid,\n} from \"../geometry/boolean/is-valid-coordinate\";\nimport { Validation } from \"../common\";\n\nexport const ValidationReasonFeatureNotPolygon = \"Feature is not a Polygon\";\nexport const ValidationReasonFeatureHasHoles = \"Feature has holes\";\nexport const ValidationReasonFeatureLessThanFourCoordinates =\n\t\"Feature has less than 4 coordinates\";\nexport const ValidationReasonFeatureHasInvalidCoordinates =\n\t\"Feature has invalid coordinates\";\nexport const ValidationReasonFeatureCoordinatesNotClosed =\n\t\"Feature coordinates are not closed\";\nexport const ValidationReasonFeatureInvalidCoordinatePrecision =\n\t\"Feature has coordinates with excessive precision\";\n\nexport function ValidatePolygonFeature(\n\tfeature: GeoJSONStoreFeatures,\n\tcoordinatePrecision: number,\n): ReturnType<Validation> {\n\tif (feature.geometry.type !== \"Polygon\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPolygon,\n\t\t};\n\t}\n\n\tif (feature.geometry.coordinates.length !== 1) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureHasHoles,\n\t\t};\n\t}\n\n\tif (feature.geometry.coordinates[0].length < 4) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureLessThanFourCoordinates,\n\t\t};\n\t}\n\n\tfor (let i = 0; i < feature.geometry.coordinates[0].length; i++) {\n\t\tif (!coordinateIsValid(feature.geometry.coordinates[0][i])) {\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\treason: ValidationReasonFeatureHasInvalidCoordinates,\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\t!coordinatePrecisionIsValid(\n\t\t\t\tfeature.geometry.coordinates[0][i],\n\t\t\t\tcoordinatePrecision,\n\t\t\t)\n\t\t) {\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\treason: ValidationReasonFeatureInvalidCoordinatePrecision,\n\t\t\t};\n\t\t}\n\t}\n\n\tif (\n\t\t!coordinatesMatch(\n\t\t\tfeature.geometry.coordinates[0][0],\n\t\t\tfeature.geometry.coordinates[0][\n\t\t\t\tfeature.geometry.coordinates[0].length - 1\n\t\t\t],\n\t\t)\n\t) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureCoordinatesNotClosed,\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n\nexport function ValidateNonIntersectingPolygonFeature(\n\tfeature: GeoJSONStoreFeatures,\n\tcoordinatePrecision: number,\n): ReturnType<Validation> {\n\tconst validatePolygonFeature = ValidatePolygonFeature(\n\t\tfeature,\n\t\tcoordinatePrecision,\n\t);\n\n\tif (!validatePolygonFeature.valid) {\n\t\treturn validatePolygonFeature;\n\t}\n\n\tif (selfIntersects(feature as Feature<Polygon>)) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: \"Feature intersects itself\",\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n\n/**\n * Check if two coordinates are identical\n * @param coordinateOne - coordinate to compare\n * @param coordinateTwo - coordinate to compare with\n * @returns boolean\n */\nfunction coordinatesMatch(coordinateOne: Position, coordinateTwo: Position) {\n\treturn (\n\t\tcoordinateOne[0] === coordinateTwo[0] &&\n\t\tcoordinateOne[1] === coordinateTwo[1]\n\t);\n}\n","import { Feature, Position } from \"geojson\";\nimport {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tProjection,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { haversineDistanceKilometers } from \"../../geometry/measure/haversine-distance\";\nimport { circle, circleWebMercator } from \"../../geometry/shape/create-circle\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { Polygon } from \"geojson\";\nimport { calculateWebMercatorDistortion } from \"../../geometry/shape/web-mercator-distortion\";\n\ntype TerraDrawCircleModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype CirclePolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawCircleModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tkeyEvents?: TerraDrawCircleModeKeyEvents | null;\n\tcursors?: Cursors;\n\tstartingRadiusKilometers?: number;\n\tprojection?: Projection;\n}\n\nexport class TerraDrawCircleMode extends TerraDrawBaseDrawMode<CirclePolygonStyling> {\n\tmode = \"circle\" as const;\n\tprivate center: Position | undefined;\n\tprivate clickCount = 0;\n\tprivate currentCircleId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawCircleModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate startingRadiusKilometers = 0.00001;\n\tprivate cursorMovedAfterInitialCursorDown = false;\n\n\t/**\n\t * Create a new circle mode instance\n\t * @param options - Options to customize the behavior of the circle mode\n\t * @param options.keyEvents - Key events to cancel or finish the mode\n\t * @param options.cursors - Cursors to use for the mode\n\t * @param options.styles - Custom styling for the circle\n\t * @param options.pointerDistance - Distance in pixels to consider a pointer close to a vertex\n\t */\n\tconstructor(options?: TerraDrawCircleModeOptions<CirclePolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawCircleModeOptions<CirclePolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.startingRadiusKilometers) {\n\t\t\tthis.startingRadiusKilometers = options.startingRadiusKilometers;\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentCircleId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentCircleId,\n\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\tvalue: undefined,\n\t\t\t},\n\t\t]);\n\n\t\tconst finishedId = this.currentCircleId;\n\n\t\tif (this.validate && finishedId) {\n\t\t\tconst currentGeometry = this.store.getGeometryCopy<Polygon>(finishedId);\n\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: finishedId,\n\t\t\t\t\tgeometry: currentGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.cursorMovedAfterInitialCursorDown = false;\n\t\tthis.center = undefined;\n\t\tthis.currentCircleId = undefined;\n\t\tthis.clickCount = 0;\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\t// Ensure that any listerers are triggered with the main created geometry\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tif (this.clickCount === 0) {\n\t\t\t\tthis.center = [event.lng, event.lat];\n\t\t\t\tconst startingCircle = circle({\n\t\t\t\t\tcenter: this.center,\n\t\t\t\t\tradiusKilometers: this.startingRadiusKilometers,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t});\n\n\t\t\t\tconst [createdId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: startingCircle.geometry,\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\tradiusKilometers: this.startingRadiusKilometers,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentCircleId = createdId;\n\t\t\t\tthis.clickCount++;\n\t\t\t\tthis.cursorMovedAfterInitialCursorDown = false;\n\t\t\t\tthis.setDrawing();\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tthis.clickCount === 1 &&\n\t\t\t\t\tthis.center &&\n\t\t\t\t\tthis.currentCircleId !== undefined &&\n\t\t\t\t\tthis.cursorMovedAfterInitialCursorDown\n\t\t\t\t) {\n\t\t\t\t\tthis.updateCircle(event);\n\t\t\t\t}\n\n\t\t\t\t// Finish drawing\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.cursorMovedAfterInitialCursorDown = true;\n\t\tthis.updateCircle(event);\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentCircleId;\n\n\t\tthis.center = undefined;\n\t\tthis.currentCircleId = undefined;\n\t\tthis.clickCount = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t} catch {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Polygon\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.fillColor,\n\t\t\t\tstyles.polygonFillColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.outlineColor,\n\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate updateCircle(event: TerraDrawMouseEvent) {\n\t\tif (this.clickCount === 1 && this.center && this.currentCircleId) {\n\t\t\tconst newRadius = haversineDistanceKilometers(this.center, [\n\t\t\t\tevent.lng,\n\t\t\t\tevent.lat,\n\t\t\t]);\n\n\t\t\tlet updatedCircle: Feature<Polygon>;\n\n\t\t\tif (this.projection === \"web-mercator\") {\n\t\t\t\t// We want to track the mouse cursor, but we need to adjust the radius based\n\t\t\t\t// on the distortion of the web mercator projection\n\t\t\t\tconst distortion = calculateWebMercatorDistortion(this.center, [\n\t\t\t\t\tevent.lng,\n\t\t\t\t\tevent.lat,\n\t\t\t\t]);\n\n\t\t\t\tupdatedCircle = circleWebMercator({\n\t\t\t\t\tcenter: this.center,\n\t\t\t\t\tradiusKilometers: newRadius * distortion,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t});\n\t\t\t} else if (this.projection === \"globe\") {\n\t\t\t\tupdatedCircle = circle({\n\t\t\t\t\tcenter: this.center,\n\t\t\t\t\tradiusKilometers: newRadius,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Invalid projection\");\n\t\t\t}\n\n\t\t\tif (this.validate) {\n\t\t\t\tconst valid = this.validate(\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\t\tid: this.currentCircleId,\n\t\t\t\t\t\tgeometry: updatedCircle.geometry,\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tradiusKilometers: newRadius,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tproject: this.project,\n\t\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!valid.valid) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{ id: this.currentCircleId, geometry: updatedCircle.geometry },\n\t\t\t]);\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentCircleId,\n\t\t\t\t\tproperty: \"radiusKilometers\",\n\t\t\t\t\tvalue: newRadius,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a circle and the feature being updated is the current circle,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentCircleId === feature.id) {\n\t\t\tthis.cursorMovedAfterInitialCursorDown = false;\n\t\t\tthis.center = undefined;\n\t\t\tthis.currentCircleId = undefined;\n\t\t\tthis.clickCount = 0;\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { TerraDrawAdapterStyling } from \"../common\";\n\nexport const getDefaultStyling = (): TerraDrawAdapterStyling => {\n\treturn {\n\t\tpolygonFillColor: \"#3f97e0\",\n\t\tpolygonOutlineColor: \"#3f97e0\",\n\t\tpolygonOutlineWidth: 4,\n\t\tpolygonFillOpacity: 0.3,\n\t\tpointColor: \"#3f97e0\",\n\t\tpointOutlineColor: \"#ffffff\",\n\t\tpointOutlineWidth: 0,\n\t\tpointWidth: 6,\n\t\tlineStringColor: \"#3f97e0\",\n\t\tlineStringWidth: 4,\n\t\tzIndex: 0,\n\t};\n};\n","import { Position } from \"geojson\";\nimport { haversineDistanceKilometers } from \"../measure/haversine-distance\";\nimport { lngLatToWebMercatorXY } from \"../project/web-mercator\";\n\n/*\n * Function to calculate the web mercator vs geodesic distortion between two coordinates\n * Value of 1 means no distortion, higher values mean higher distortion\n * */\nexport function calculateWebMercatorDistortion(\n\tsource: Position,\n\ttarget: Position,\n): number {\n\tconst geodesicDistance = haversineDistanceKilometers(source, target) * 1000;\n\tif (geodesicDistance === 0) {\n\t\treturn 1;\n\t}\n\n\tconst { x: x1, y: y1 } = lngLatToWebMercatorXY(source[0], source[1]);\n\tconst { x: x2, y: y2 } = lngLatToWebMercatorXY(target[0], target[1]);\n\tconst euclideanDistance = Math.sqrt(\n\t\tMath.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2),\n\t);\n\treturn euclideanDistance / geodesicDistance;\n}\n","import { CartesianPoint } from \"../../common\";\n\nexport const cartesianDistance = (\n\tpointOne: CartesianPoint,\n\tpointTwo: CartesianPoint,\n) => {\n\tconst { x: x1, y: y1 } = pointOne;\n\tconst { x: x2, y: y2 } = pointTwo;\n\tconst y = x2 - x1;\n\tconst x = y2 - y1;\n\treturn Math.sqrt(x * x + y * y);\n};\n","import { Feature, Polygon } from \"geojson\";\nimport { followsRightHandRule } from \"./boolean/right-hand-rule\";\n\nexport function ensureRightHandRule(polygon: Polygon): undefined | Polygon {\n\tconst isFollowingRightHandRule = followsRightHandRule(polygon);\n\tif (!isFollowingRightHandRule) {\n\t\treturn {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [polygon.coordinates[0].reverse()],\n\t\t} as Polygon;\n\t}\n}\n","import { Polygon } from \"geojson\";\n\n/**\n * Checks if a GeoJSON Polygon follows the right-hand rule.\n * @param polygon - The GeoJSON Polygon to check.\n * @returns {boolean} - True if the polygon follows the right-hand rule (counterclockwise outer ring), otherwise false.\n */\nexport function followsRightHandRule(polygon: Polygon): boolean {\n\tconst outerRing = polygon.coordinates[0];\n\n\tlet sum = 0;\n\tfor (let i = 0; i < outerRing.length - 1; i++) {\n\t\tconst [x1, y1] = outerRing[i];\n\t\tconst [x2, y2] = outerRing[i + 1];\n\t\tsum += (x2 - x1) * (y2 + y1);\n\t}\n\n\treturn sum < 0; // Right-hand rule: counterclockwise = negative area\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tCOMMON_PROPERTIES,\n\tZ_INDEX,\n} from \"../../common\";\nimport { Polygon } from \"geojson\";\n\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { ValidatePolygonFeature } from \"../../validations/polygon.validation\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\n\ntype TerraDrawFreehandModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype FreehandPolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n\tclosingPointColor: HexColorStyling;\n\tclosingPointWidth: NumericStyling;\n\tclosingPointOutlineColor: HexColorStyling;\n\tclosingPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawFreehandModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tminDistance?: number;\n\tpreventPointsNearClose?: boolean;\n\tautoClose?: boolean;\n\tautoCloseTimeout?: number;\n\tkeyEvents?: TerraDrawFreehandModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawFreehandMode extends TerraDrawBaseDrawMode<FreehandPolygonStyling> {\n\tmode = \"freehand\" as const;\n\n\tprivate startingClick = false;\n\tprivate currentId: FeatureId | undefined;\n\tprivate closingPointId: FeatureId | undefined;\n\tprivate minDistance: number = 20;\n\tprivate keyEvents: TerraDrawFreehandModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate preventPointsNearClose: boolean = true;\n\tprivate autoClose: boolean = false;\n\tprivate autoCloseTimeout = 500;\n\tprivate hasLeftStartingPoint = false;\n\tprivate preventNewFeature = false;\n\n\tconstructor(options?: TerraDrawFreehandModeOptions<FreehandPolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tpublic updateOptions(\n\t\toptions?: TerraDrawFreehandModeOptions<FreehandPolygonStyling> | undefined,\n\t): void {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.minDistance) {\n\t\t\tthis.minDistance = options.minDistance;\n\t\t}\n\n\t\tif (options?.preventPointsNearClose !== undefined) {\n\t\t\tthis.preventPointsNearClose = options.preventPointsNearClose;\n\t\t}\n\n\t\tif (options?.autoClose !== undefined) {\n\t\t\tthis.autoClose = options.autoClose;\n\t\t}\n\n\t\tif (options?.autoCloseTimeout) {\n\t\t\tthis.autoCloseTimeout = options.autoCloseTimeout;\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fix right hand rule if necessary\n\t\tif (this.currentId) {\n\t\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId),\n\t\t\t);\n\t\t\tif (correctedGeometry) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{ id: this.currentId, geometry: correctedGeometry },\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tconst finishedId = this.currentId;\n\n\t\tif (this.validate && finishedId) {\n\t\t\tconst currentGeometry = this.store.getGeometryCopy<Polygon>(finishedId);\n\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: finishedId,\n\t\t\t\t\tgeometry: currentGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.closingPointId) {\n\t\t\tthis.store.delete([this.closingPointId]);\n\t\t}\n\t\tthis.startingClick = false;\n\t\tthis.currentId = undefined;\n\t\tthis.closingPointId = undefined;\n\t\tthis.hasLeftStartingPoint = false;\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\t// Ensure that any listerers are triggered with the main created geometry\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tif (this.currentId === undefined || this.startingClick === false) {\n\t\t\tthis.setCursor(this.cursors.start);\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst previousIndex = currentLineGeometry.coordinates[0].length - 2;\n\t\tconst [previousLng, previousLat] =\n\t\t\tcurrentLineGeometry.coordinates[0][previousIndex];\n\t\tconst { x, y } = this.project(previousLng, previousLat);\n\t\tconst distance = cartesianDistance(\n\t\t\t{ x, y },\n\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t);\n\n\t\tconst [closingLng, closingLat] = currentLineGeometry.coordinates[0][0];\n\t\tconst { x: closingX, y: closingY } = this.project(closingLng, closingLat);\n\t\tconst closingDistance = cartesianDistance(\n\t\t\t{ x: closingX, y: closingY },\n\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t);\n\n\t\tif (closingDistance < this.pointerDistance) {\n\t\t\t// We only want to close the polygon if the users cursor has left the\n\t\t\t// region of the starting point\n\t\t\tif (this.autoClose && this.hasLeftStartingPoint) {\n\t\t\t\t// If we have an autoCloseTimeout, we want to prevent new features\n\t\t\t\t// being created by accidental clicks for a short period of time\n\t\t\t\tthis.preventNewFeature = true;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.preventNewFeature = false;\n\t\t\t\t}, this.autoCloseTimeout);\n\n\t\t\t\tthis.close();\n\t\t\t}\n\n\t\t\tthis.setCursor(this.cursors.close);\n\n\t\t\t// We want to prohibit drawing new points at or around the closing\n\t\t\t// point as it can be non user friendly\n\t\t\tif (this.preventPointsNearClose) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.hasLeftStartingPoint = true;\n\t\t\tthis.setCursor(this.cursors.start);\n\t\t}\n\n\t\t// The cusor must have moved a minimum distance\n\t\t// before we add another coordinate\n\t\tif (distance < this.minDistance) {\n\t\t\treturn;\n\t\t}\n\n\t\tcurrentLineGeometry.coordinates[0].pop();\n\n\t\tconst newGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [\n\t\t\t\t[\n\t\t\t\t\t...currentLineGeometry.coordinates[0],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tcurrentLineGeometry.coordinates[0][0],\n\t\t\t\t],\n\t\t\t],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tgeometry: newGeometry,\n\t\t\t},\n\t\t]);\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tif (this.preventNewFeature) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.startingClick === false) {\n\t\t\t\tconst [createdId, closingPointId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\tthis.currentId = createdId;\n\t\t\t\tthis.closingPointId = closingPointId;\n\t\t\t\tthis.startingClick = true;\n\n\t\t\t\t// We could already be in drawing due to updating the existing polygon\n\t\t\t\t// via afterFeatureUpdated\n\t\t\t\tif (this.state !== \"drawing\") {\n\t\t\t\t\tthis.setDrawing();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tif (this.startingClick === true) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentId;\n\t\tconst cleanUpClosingPointId = this.closingPointId;\n\n\t\tthis.closingPointId = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.startingClick = false;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t\tif (cleanUpClosingPointId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpClosingPointId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Polygon\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.fillColor,\n\t\t\t\tstyles.polygonFillColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.outlineColor,\n\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t} else if (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.closingPointWidth,\n\t\t\t\tstyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.closingPointColor,\n\t\t\t\tstyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.closingPointOutlineColor,\n\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.closingPointOutlineWidth,\n\t\t\t\t2,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_FIVE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidatePolygonFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// NOTE: This handles the case we are currently drawing a polygon\n\t\t// We need to reset the drawing state because it is very complicated (impossible?)\n\t\t// to recover the drawing state after a feature update\n\t\tif (this.currentId === feature.id) {\n\t\t\tif (this.closingPointId) {\n\t\t\t\tthis.store.delete([this.closingPointId]);\n\t\t\t}\n\t\t\tthis.startingClick = false;\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.closingPointId = undefined;\n\t\t\tthis.hasLeftStartingPoint = false;\n\t\t}\n\t}\n}\n","import {\n\tProject,\n\tProjection,\n\tTerraDrawGeoJSONStore,\n\tUnproject,\n} from \"../common\";\n\nexport type BehaviorConfig = {\n\tstore: TerraDrawGeoJSONStore;\n\tmode: string;\n\tproject: Project;\n\tunproject: Unproject;\n\tpointerDistance: number;\n\tcoordinatePrecision: number;\n\tprojection: Projection;\n};\n\nexport class TerraDrawModeBehavior {\n\tprotected store: TerraDrawGeoJSONStore;\n\tprotected mode: string;\n\tprotected project: Project;\n\tprotected unproject: Unproject;\n\tprotected pointerDistance: number;\n\tprotected coordinatePrecision: number;\n\tprotected projection: Projection;\n\n\tconstructor({\n\t\tstore,\n\t\tmode,\n\t\tproject,\n\t\tunproject,\n\t\tpointerDistance,\n\t\tcoordinatePrecision,\n\t\tprojection,\n\t}: BehaviorConfig) {\n\t\tthis.store = store;\n\t\tthis.mode = mode;\n\t\tthis.project = project;\n\t\tthis.unproject = unproject;\n\t\tthis.pointerDistance = pointerDistance;\n\t\tthis.coordinatePrecision = coordinatePrecision;\n\t\tthis.projection = projection;\n\t}\n}\n","import { Feature, Polygon } from \"geojson\";\nimport { Unproject } from \"../../common\";\n\nexport function createBBoxFromPoint({\n\tunproject,\n\tpoint,\n\tpointerDistance,\n}: {\n\tpoint: {\n\t\tx: number;\n\t\ty: number;\n\t};\n\tunproject: Unproject;\n\tpointerDistance: number;\n}) {\n\tconst halfDist = pointerDistance / 2;\n\tconst { x, y } = point;\n\n\treturn {\n\t\ttype: \"Feature\",\n\t\tproperties: {},\n\t\tgeometry: {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [\n\t\t\t\t[\n\t\t\t\t\tunproject(x - halfDist, y - halfDist), // TopLeft\n\t\t\t\t\tunproject(x + halfDist, y - halfDist), // TopRight\n\t\t\t\t\tunproject(x + halfDist, y + halfDist), // BottomRight\n\t\t\t\t\tunproject(x - halfDist, y + halfDist), // BottomLeft\n\t\t\t\t\tunproject(x - halfDist, y - halfDist), // TopLeft\n\t\t\t\t].map((c) => [c.lng, c.lat]),\n\t\t\t],\n\t\t},\n\t} as Feature<Polygon>;\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { TerraDrawMouseEvent } from \"../common\";\nimport { createBBoxFromPoint } from \"../geometry/shape/create-bbox\";\n\nexport class ClickBoundingBoxBehavior extends TerraDrawModeBehavior {\n\tconstructor(config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\n\tpublic create(event: TerraDrawMouseEvent) {\n\t\tconst { containerX: x, containerY: y } = event;\n\t\treturn createBBoxFromPoint({\n\t\t\tunproject: this.unproject,\n\t\t\tpoint: { x, y },\n\t\t\tpointerDistance: this.pointerDistance,\n\t\t});\n\t}\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { TerraDrawMouseEvent } from \"../common\";\n\nimport { Position } from \"geojson\";\nimport { cartesianDistance } from \"../geometry/measure/pixel-distance\";\n\nexport class PixelDistanceBehavior extends TerraDrawModeBehavior {\n\tconstructor(config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\tpublic measure(clickEvent: TerraDrawMouseEvent, secondCoordinate: Position) {\n\t\tconst { x, y } = this.project(secondCoordinate[0], secondCoordinate[1]);\n\n\t\tconst distance = cartesianDistance(\n\t\t\t{ x, y },\n\t\t\t{ x: clickEvent.containerX, y: clickEvent.containerY },\n\t\t);\n\n\t\treturn distance;\n\t}\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { TerraDrawMouseEvent } from \"../common\";\nimport { Feature, Position } from \"geojson\";\nimport { ClickBoundingBoxBehavior } from \"./click-bounding-box.behavior\";\nimport { BBoxPolygon, FeatureId } from \"../store/store\";\nimport { PixelDistanceBehavior } from \"./pixel-distance.behavior\";\n\nexport class CoordinateSnappingBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t\tprivate readonly clickBoundingBox: ClickBoundingBoxBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\t/** Returns the nearest snappable coordinate - on first click there is no currentId so no need to provide */\n\tpublic getSnappableCoordinateFirstClick = (event: TerraDrawMouseEvent) => {\n\t\tconst snappble = this.getSnappable(event, (feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties && feature.properties.mode === this.mode,\n\t\t\t);\n\t\t});\n\n\t\treturn snappble.coordinate;\n\t};\n\n\tpublic getSnappableCoordinate = (\n\t\tevent: TerraDrawMouseEvent,\n\t\tcurrentFeatureId: FeatureId,\n\t) => {\n\t\tconst snappable = this.getSnappable(event, (feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties &&\n\t\t\t\t\tfeature.properties.mode === this.mode &&\n\t\t\t\t\tfeature.id !== currentFeatureId,\n\t\t\t);\n\t\t});\n\n\t\treturn snappable.coordinate;\n\t};\n\n\tpublic getSnappable(\n\t\tevent: TerraDrawMouseEvent,\n\t\tfilter?: (feature: Feature) => boolean,\n\t) {\n\t\tconst bbox = this.clickBoundingBox.create(event) as BBoxPolygon;\n\n\t\tconst features = this.store.search(bbox, filter);\n\n\t\tconst closest: {\n\t\t\tcoordinate: undefined | Position;\n\t\t\tminDist: number;\n\t\t\tfeatureId: undefined | FeatureId;\n\t\t\tfeatureCoordinateIndex: undefined | number;\n\t\t} = {\n\t\t\tfeatureId: undefined,\n\t\t\tfeatureCoordinateIndex: undefined,\n\t\t\tcoordinate: undefined,\n\t\t\tminDist: Infinity,\n\t\t};\n\n\t\tfeatures.forEach((feature) => {\n\t\t\tlet coordinates: Position[];\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcoordinates.forEach((coord, coordIndex) => {\n\t\t\t\tconst dist = this.pixelDistance.measure(event, coord);\n\t\t\t\tif (dist < closest.minDist && dist < this.pointerDistance) {\n\t\t\t\t\tclosest.coordinate = coord;\n\t\t\t\t\tclosest.minDist = dist;\n\t\t\t\t\tclosest.featureId = feature.id;\n\t\t\t\t\tclosest.featureCoordinateIndex = coordIndex;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn closest;\n\t}\n}\n","import { Position } from \"geojson\";\nimport {\n\tdegreesToRadians,\n\tlengthToRadians,\n\tradiansToDegrees,\n} from \"../helpers\";\nimport { CartesianPoint } from \"../../common\";\n\n// Adapted from @turf/destination module which is MIT Licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-desination/index.ts\n\nexport function destination(\n\torigin: Position,\n\tdistance: number,\n\tbearing: number,\n): Position {\n\tconst longitude1 = degreesToRadians(origin[0]);\n\tconst latitude1 = degreesToRadians(origin[1]);\n\tconst bearingRad = degreesToRadians(bearing);\n\tconst radians = lengthToRadians(distance);\n\n\tconst latitude2 = Math.asin(\n\t\tMath.sin(latitude1) * Math.cos(radians) +\n\t\t\tMath.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad),\n\t);\n\tconst longitude2 =\n\t\tlongitude1 +\n\t\tMath.atan2(\n\t\t\tMath.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\n\t\t\tMath.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2),\n\t\t);\n\tconst lng = radiansToDegrees(longitude2);\n\tconst lat = radiansToDegrees(latitude2);\n\n\treturn [lng, lat];\n}\n\n// Function to create a destination point in Web Mercator projection\nexport function webMercatorDestination(\n\t{ x, y }: CartesianPoint,\n\tdistance: number,\n\tbearing: number,\n): CartesianPoint {\n\t// Convert origin to Web Mercator\n\tconst bearingRad = degreesToRadians(bearing);\n\n\t// Calculate the destination coordinates\n\tconst deltaX = distance * Math.cos(bearingRad);\n\tconst deltaY = distance * Math.sin(bearingRad);\n\n\tconst newX = x + deltaX;\n\tconst newY = y + deltaY;\n\n\treturn { x: newX, y: newY };\n}\n","import { Position } from \"geojson\";\nimport { degreesToRadians, radiansToDegrees } from \"../helpers\";\nimport { CartesianPoint } from \"../../common\";\n\n// Adapted from the @turf/bearing module which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-bearing\n\nexport function bearing(start: Position, end: Position): number {\n\tconst lon1 = degreesToRadians(start[0]);\n\tconst lon2 = degreesToRadians(end[0]);\n\tconst lat1 = degreesToRadians(start[1]);\n\tconst lat2 = degreesToRadians(end[1]);\n\tconst a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n\tconst b =\n\t\tMath.cos(lat1) * Math.sin(lat2) -\n\t\tMath.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n\treturn radiansToDegrees(Math.atan2(a, b));\n}\n\nexport function webMercatorBearing(\n\t{ x: x1, y: y1 }: CartesianPoint,\n\t{ x: x2, y: y2 }: CartesianPoint,\n): number {\n\tconst deltaX = x2 - x1;\n\tconst deltaY = y2 - y1;\n\n\tif (deltaX === 0 && deltaY === 0) {\n\t\treturn 0; // No movement\n\t}\n\n\t// Calculate the angle in radians\n\tlet angle = Math.atan2(deltaY, deltaX);\n\n\t// Convert the angle to degrees\n\tangle = angle * (180 / Math.PI);\n\n\t// Normalize to -180 to 180\n\tif (angle > 180) {\n\t\tangle -= 360;\n\t} else if (angle < -180) {\n\t\tangle += 360;\n\t}\n\n\treturn angle;\n}\n\nexport function normalizeBearing(bearing: number): number {\n\treturn (bearing + 360) % 360;\n}\n","import { LineString, Position } from \"geojson\";\nimport { destination } from \"./destination\";\nimport { bearing } from \"./bearing\";\nimport { haversineDistanceKilometers } from \"./haversine-distance\";\n\n// Adapted from @turf/line-slice-along module which is MIT licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-line-slice-along/index.ts\n\nexport function lineSliceAlong(\n\tcoords: LineString[\"coordinates\"],\n\tstartDist: number,\n\tstopDist: number,\n): Position[] {\n\tconst slice: Position[] = [];\n\n\tconst origCoordsLength = coords.length;\n\n\tlet travelled = 0;\n\tlet overshot, direction, interpolated;\n\tfor (let i = 0; i < coords.length; i++) {\n\t\tif (startDist >= travelled && i === coords.length - 1) {\n\t\t\tbreak;\n\t\t} else if (travelled > startDist && slice.length === 0) {\n\t\t\tovershot = startDist - travelled;\n\t\t\tif (!overshot) {\n\t\t\t\tslice.push(coords[i]);\n\t\t\t\treturn slice;\n\t\t\t}\n\t\t\tdirection = bearing(coords[i], coords[i - 1]) - 180;\n\t\t\tinterpolated = destination(coords[i], overshot, direction);\n\t\t\tslice.push(interpolated);\n\t\t}\n\n\t\tif (travelled >= stopDist) {\n\t\t\tovershot = stopDist - travelled;\n\t\t\tif (!overshot) {\n\t\t\t\tslice.push(coords[i]);\n\t\t\t\treturn slice;\n\t\t\t}\n\t\t\tdirection = bearing(coords[i], coords[i - 1]) - 180;\n\t\t\tinterpolated = destination(coords[i], overshot, direction);\n\t\t\tslice.push(interpolated);\n\t\t\treturn slice;\n\t\t}\n\n\t\tif (travelled >= startDist) {\n\t\t\tslice.push(coords[i]);\n\t\t}\n\n\t\tif (i === coords.length - 1) {\n\t\t\treturn slice;\n\t\t}\n\n\t\ttravelled += haversineDistanceKilometers(coords[i], coords[i + 1]);\n\t}\n\n\tif (travelled < startDist && coords.length === origCoordsLength) {\n\t\tthrow new Error(\"Start position is beyond line\");\n\t}\n\n\tconst last = coords[coords.length - 1];\n\treturn [last, last];\n}\n","import { Position } from \"geojson\";\n\nfunction toRadians(degrees: number): number {\n\treturn degrees * (Math.PI / 180);\n}\n\nfunction toDegrees(radians: number): number {\n\treturn radians * (180 / Math.PI);\n}\n\nexport function generateGreatCircleCoordinates(\n\tstart: Position,\n\tend: Position,\n\tnumberOfPoints: number,\n): Position[] {\n\tconst points: Position[] = [];\n\n\tconst lat1 = toRadians(start[1]);\n\tconst lon1 = toRadians(start[0]);\n\tconst lat2 = toRadians(end[1]);\n\tconst lon2 = toRadians(end[0]);\n\n\tnumberOfPoints += 1;\n\n\t// Calculate the angular distance between the two points using the Haversine formula\n\tconst d =\n\t\t2 *\n\t\tMath.asin(\n\t\t\tMath.sqrt(\n\t\t\t\tMath.sin((lat2 - lat1) / 2) ** 2 +\n\t\t\t\t\tMath.cos(lat1) * Math.cos(lat2) * Math.sin((lon2 - lon1) / 2) ** 2,\n\t\t\t),\n\t\t);\n\n\tif (d === 0 || isNaN(d)) {\n\t\t// Start and end coordinates are the same, or distance calculation failed, return empty array\n\t\treturn points;\n\t}\n\n\tfor (let i = 0; i <= numberOfPoints; i++) {\n\t\tconst f = i / numberOfPoints; // Fraction of the total distance for the current point\n\t\tconst A = Math.sin((1 - f) * d) / Math.sin(d); // Interpolation factor A\n\t\tconst B = Math.sin(f * d) / Math.sin(d); // Interpolation factor B\n\n\t\t// Calculate the x, y, z coordinates of the intermediate point\n\t\tconst x =\n\t\t\tA * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);\n\t\tconst y =\n\t\t\tA * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);\n\t\tconst z = A * Math.sin(lat1) + B * Math.sin(lat2);\n\n\t\t// Calculate the latitude and longitude of the intermediate point from the x, y, z coordinates\n\t\tif (isNaN(x) || isNaN(y) || isNaN(z)) {\n\t\t\t// Skip this point if any coordinate is NaN\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst lat = Math.atan2(z, Math.sqrt(x ** 2 + y ** 2));\n\t\tconst lon = Math.atan2(y, x);\n\n\t\tif (isNaN(lat) || isNaN(lon)) {\n\t\t\t// Skip this point if any coordinate is NaN\n\t\t\tcontinue;\n\t\t}\n\n\t\tpoints.push([toDegrees(lon), toDegrees(lat)]);\n\t}\n\n\treturn points.slice(1, -1);\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { Position } from \"geojson\";\nimport { haversineDistanceKilometers } from \"../geometry/measure/haversine-distance\";\nimport { lineSliceAlong } from \"../geometry/measure/slice-along\";\nimport { limitPrecision } from \"../geometry/limit-decimal-precision\";\nimport { generateGreatCircleCoordinates } from \"../geometry/shape/great-circle-coordinates\";\n\nexport class InsertCoordinatesBehavior extends TerraDrawModeBehavior {\n\tconstructor(readonly config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\n\tpublic generateInsertionCoordinates(\n\t\tcoordinateOne: Position,\n\t\tcoordinateTwo: Position,\n\t\tsegmentLength: number,\n\t): Position[] {\n\t\tconst line = [coordinateOne, coordinateTwo];\n\n\t\tlet lineLength = 0;\n\t\tfor (let i = 0; i < line.length - 1; i++) {\n\t\t\tlineLength += haversineDistanceKilometers(line[0], line[1]);\n\t\t}\n\n\t\t// If the line is shorter than the segment length then the original line is returned.\n\t\tif (lineLength <= segmentLength) {\n\t\t\treturn line;\n\t\t}\n\n\t\tlet numberOfSegments = lineLength / segmentLength - 1;\n\n\t\t// If numberOfSegments is integer, no need to plus 1\n\t\tif (!Number.isInteger(numberOfSegments)) {\n\t\t\tnumberOfSegments = Math.floor(numberOfSegments) + 1;\n\t\t}\n\n\t\tconst segments: Position[][] = [];\n\t\tfor (let i = 0; i < numberOfSegments; i++) {\n\t\t\tconst outline = lineSliceAlong(\n\t\t\t\tline,\n\t\t\t\tsegmentLength * i,\n\t\t\t\tsegmentLength * (i + 1),\n\t\t\t);\n\t\t\tsegments.push(outline);\n\t\t}\n\n\t\tconst coordinates: Position[] = [];\n\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\tconst line = segments[i];\n\t\t\tcoordinates.push(line[1]);\n\t\t}\n\n\t\tconst limitedCoordinates = this.limitCoordinates(coordinates);\n\n\t\treturn limitedCoordinates;\n\t}\n\n\tpublic generateInsertionGeodesicCoordinates(\n\t\tcoordinateOne: Position,\n\t\tcoordinateTwo: Position,\n\t\tsegmentLength: number,\n\t): Position[] {\n\t\tconst distance = haversineDistanceKilometers(coordinateOne, coordinateTwo);\n\t\tconst numberOfPoints = Math.floor(distance / segmentLength);\n\t\tconst coordinates = generateGreatCircleCoordinates(\n\t\t\tcoordinateOne,\n\t\t\tcoordinateTwo,\n\t\t\tnumberOfPoints,\n\t\t);\n\t\tconst limitedCoordinates = this.limitCoordinates(coordinates);\n\n\t\treturn limitedCoordinates;\n\t}\n\n\tprivate limitCoordinates(coordinates: Position[]) {\n\t\treturn coordinates.map((coordinate) => [\n\t\t\tlimitPrecision(coordinate[0], this.config.coordinatePrecision),\n\t\t\tlimitPrecision(coordinate[1], this.config.coordinatePrecision),\n\t\t]);\n\t}\n}\n","import { Position } from \"geojson\";\n\nexport function coordinatesIdentical(\n\tcoordinate: Position,\n\tcoordinateTwo: Position,\n) {\n\treturn (\n\t\tcoordinate[0] === coordinateTwo[0] && coordinate[1] === coordinateTwo[1]\n\t);\n}\n","import { Validation } from \"../common\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport {\n\tcoordinateIsValid,\n\tcoordinatePrecisionIsValid,\n} from \"../geometry/boolean/is-valid-coordinate\";\n\nexport const ValidationReasonFeatureIsNotALineString =\n\t\"Feature is not a LineString\";\nexport const ValidationReasonFeatureHasLessThanTwoCoordinates =\n\t\"Feature has less than 2 coordinates\";\nexport const ValidationReasonFeatureInvalidCoordinates =\n\t\"Feature has invalid coordinates\";\nexport const ValidationReasonFeatureInvalidCoordinatePrecision =\n\t\"Feature has coordinates with excessive precision\";\n\nexport function ValidateLineStringFeature(\n\tfeature: GeoJSONStoreFeatures,\n\tcoordinatePrecision: number,\n): ReturnType<Validation> {\n\tif (feature.geometry.type !== \"LineString\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureIsNotALineString,\n\t\t};\n\t}\n\n\tif (feature.geometry.coordinates.length < 2) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureHasLessThanTwoCoordinates,\n\t\t};\n\t}\n\n\tfor (let i = 0; i < feature.geometry.coordinates.length; i++) {\n\t\tif (!coordinateIsValid(feature.geometry.coordinates[i])) {\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\treason: ValidationReasonFeatureInvalidCoordinates,\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\t!coordinatePrecisionIsValid(\n\t\t\t\tfeature.geometry.coordinates[i],\n\t\t\t\tcoordinatePrecision,\n\t\t\t)\n\t\t) {\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\treason: ValidationReasonFeatureInvalidCoordinatePrecision,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn { valid: true };\n}\n","import { Feature, Point, Position, LineString } from \"geojson\";\nimport { degreesToRadians, radiansToDegrees } from \"./helpers\";\nimport { haversineDistanceKilometers } from \"./measure/haversine-distance\";\n\n// nearestPointOnLine is adapted from the @turf/midpoint which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-nearest-point-on-line\n\nexport function nearestPointOnLine(\n\tinputCoordinate: Position,\n\tlines: [Position, Position][],\n):\n\t| {\n\t\t\tcoordinate: Position;\n\t\t\tdistance: number;\n\t\t\tlineIndex: number;\n\t  }\n\t| undefined {\n\tlet closestPoint: Position = [Infinity, Infinity];\n\tlet closestDistance = Infinity;\n\tlet lineIndex = 0;\n\n\tfor (let line of lines) {\n\t\tconst startPosition: Position = line[0];\n\t\tconst stopPosition: Position = line[1];\n\n\t\t// sectionLength\n\t\tlet intersectPosition: Position;\n\t\tlet intersectDistance: number = Infinity;\n\n\t\t// Short circuit if snap point is start or end position of the line segment.\n\t\tif (\n\t\t\tstartPosition[0] === inputCoordinate[0] &&\n\t\t\tstartPosition[1] === inputCoordinate[1]\n\t\t) {\n\t\t\tintersectPosition = startPosition;\n\t\t} else if (\n\t\t\tstopPosition[0] === inputCoordinate[0] &&\n\t\t\tstopPosition[1] === inputCoordinate[1]\n\t\t) {\n\t\t\tintersectPosition = stopPosition;\n\t\t} else {\n\t\t\t// Otherwise, find the nearest point the hard way.\n\t\t\t[intersectPosition] = nearestPointOnSegment(\n\t\t\t\tstartPosition,\n\t\t\t\tstopPosition,\n\t\t\t\tinputCoordinate,\n\t\t\t);\n\t\t}\n\n\t\tif (intersectPosition) {\n\t\t\tintersectDistance = haversineDistanceKilometers(\n\t\t\t\tinputCoordinate,\n\t\t\t\tintersectPosition,\n\t\t\t);\n\n\t\t\tif (intersectDistance < closestDistance) {\n\t\t\t\tclosestPoint = intersectPosition;\n\t\t\t\tclosestDistance = intersectDistance;\n\t\t\t\tlineIndex = lines.indexOf(line);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn closestDistance === Infinity\n\t\t? undefined\n\t\t: { coordinate: closestPoint, distance: closestDistance, lineIndex };\n}\n\n/*\n * Plan is to externalise these vector functions to a simple third party\n * library.\n * Possible candidate is @amandaghassaei/vector-math though having some import\n * issues.\n */\ntype Vector = [number, number, number];\n\nfunction dot(v1: Vector, v2: Vector): number {\n\tconst [v1x, v1y, v1z] = v1;\n\tconst [v2x, v2y, v2z] = v2;\n\treturn v1x * v2x + v1y * v2y + v1z * v2z;\n}\n\n// https://en.wikipedia.org/wiki/Cross_product\nfunction cross(v1: Vector, v2: Vector): Vector {\n\tconst [v1x, v1y, v1z] = v1;\n\tconst [v2x, v2y, v2z] = v2;\n\treturn [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];\n}\n\nfunction magnitude(v: Vector) {\n\treturn Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));\n}\n\nfunction angle(v1: Vector, v2: Vector): number {\n\tconst theta = dot(v1, v2) / (magnitude(v1) * magnitude(v2));\n\treturn Math.acos(Math.min(Math.max(theta, -1), 1));\n}\n\nfunction lngLatToVector(a: Position): Vector {\n\tconst lat = degreesToRadians(a[1]);\n\tconst lng = degreesToRadians(a[0]);\n\treturn [\n\t\tMath.cos(lat) * Math.cos(lng),\n\t\tMath.cos(lat) * Math.sin(lng),\n\t\tMath.sin(lat),\n\t];\n}\n\nfunction vectorToLngLat(v: Vector): Position {\n\tconst [x, y, z] = v;\n\tconst lat = radiansToDegrees(Math.asin(z));\n\tconst lng = radiansToDegrees(Math.atan2(y, x));\n\n\treturn [lng, lat];\n}\n\nfunction nearestPointOnSegment(\n\tposA: Position, // start point of segment to measure to\n\tposB: Position, // end point of segment to measure to\n\tposC: Position, // point to measure from\n): [Position, boolean, boolean] {\n\t// Based heavily on this article on finding cross track distance to an arc:\n\t// https://gis.stackexchange.com/questions/209540/projecting-cross-track-distance-on-great-circle\n\n\t// Convert spherical (lng, lat) to cartesian vector coords (x, y, z)\n\t// In the below https://tikz.net/spherical_1/ we convert lng (𝜙) and lat (𝜃)\n\t// into vectors with x, y, and z components with a length (r) of 1.\n\tconst A = lngLatToVector(posA); // the vector from 0,0,0 to posA\n\tconst B = lngLatToVector(posB); // ... to posB\n\tconst C = lngLatToVector(posC); // ... to posC\n\n\t// Components of target point.\n\tconst [Cx, Cy, Cz] = C;\n\n\t// Calculate coefficients.\n\tconst [D, E, F] = cross(A, B);\n\tconst a = E * Cz - F * Cy;\n\tconst b = F * Cx - D * Cz;\n\tconst c = D * Cy - E * Cx;\n\n\tconst f = c * E - b * F;\n\tconst g = a * F - c * D;\n\tconst h = b * D - a * E;\n\n\tconst t = 1 / Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2) + Math.pow(h, 2));\n\n\t// Vectors to the two points these great circles intersect.\n\tconst I1: Vector = [f * t, g * t, h * t];\n\tconst I2: Vector = [-1 * f * t, -1 * g * t, -1 * h * t];\n\n\t// Figure out which is the closest intersection to this segment of the great\n\t// circle.\n\tconst angleAB = angle(A, B);\n\tconst angleAI1 = angle(A, I1);\n\tconst angleBI1 = angle(B, I1);\n\tconst angleAI2 = angle(A, I2);\n\tconst angleBI2 = angle(B, I2);\n\n\tlet I: Vector;\n\n\tif (\n\t\t(angleAI1 < angleAI2 && angleAI1 < angleBI2) ||\n\t\t(angleBI1 < angleAI2 && angleBI1 < angleBI2)\n\t) {\n\t\tI = I1;\n\t} else {\n\t\tI = I2;\n\t}\n\n\t// I is the closest intersection to the segment, though might not actually be\n\t// ON the segment.\n\n\t// If angle AI or BI is greater than angleAB, I lies on the circle *beyond* A\n\t// and B so use the closest of A or B as the intersection\n\tif (angle(A, I) > angleAB || angle(B, I) > angleAB) {\n\t\tif (\n\t\t\thaversineDistanceKilometers(vectorToLngLat(I), vectorToLngLat(A)) <=\n\t\t\thaversineDistanceKilometers(vectorToLngLat(I), vectorToLngLat(B))\n\t\t) {\n\t\t\treturn [vectorToLngLat(A), true, false];\n\t\t} else {\n\t\t\treturn [vectorToLngLat(B), false, true];\n\t\t}\n\t}\n\n\t// As angleAI nor angleBI don't exceed angleAB, I is on the segment\n\treturn [vectorToLngLat(I), false, false];\n}\n","import { Position } from \"geojson\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"./project/web-mercator\";\nimport { cartesianDistance } from \"./measure/pixel-distance\";\nimport { CartesianPoint } from \"../common\";\n\n// nearestPointOnLine is adapted from the @turf/midpoint which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-nearest-point-on-line\n\n/**\n * Takes two points and finds the closest point on the line between them to a third point.\n * @param lines\n * @param inputCoordinate\n * @returns\n */\nexport function webMercatorNearestPointOnLine(\n\tinputCoordinate: Position,\n\tlines: [Position, Position][],\n):\n\t| {\n\t\t\tcoordinate: Position;\n\t\t\tlineIndex: number;\n\t\t\tdistance: number;\n\t  }\n\t| undefined {\n\tlet closestPoint: Position = [Infinity, Infinity];\n\tlet closestDistance = Infinity;\n\tlet lineIndex = 0;\n\n\tfor (let line of lines) {\n\t\tconst startPosition: Position = line[0];\n\t\tconst stopPosition: Position = line[1];\n\n\t\t// sectionLength\n\t\tlet intersectPosition: Position;\n\t\tlet intersectDistance: number = Infinity;\n\n\t\tconst start = lngLatToWebMercatorXY(startPosition[0], startPosition[1]);\n\t\tconst stop = lngLatToWebMercatorXY(stopPosition[0], stopPosition[1]);\n\t\tconst source = lngLatToWebMercatorXY(\n\t\t\tinputCoordinate[0],\n\t\t\tinputCoordinate[1],\n\t\t);\n\n\t\t// Short circuit if snap point is start or end position of the line segment.\n\t\tif (\n\t\t\tstartPosition[0] === inputCoordinate[0] &&\n\t\t\tstartPosition[1] === inputCoordinate[1]\n\t\t) {\n\t\t\tintersectPosition = startPosition;\n\t\t} else if (\n\t\t\tstopPosition[0] === inputCoordinate[0] &&\n\t\t\tstopPosition[1] === inputCoordinate[1]\n\t\t) {\n\t\t\tintersectPosition = stopPosition;\n\t\t} else {\n\t\t\t// Otherwise, find the nearest point the hard way.\n\t\t\tconst { x, y } = findNearestPointOnLine(start, stop, source);\n\n\t\t\tconst { lng, lat } = webMercatorXYToLngLat(x, y);\n\t\t\tintersectPosition = [lng, lat];\n\t\t}\n\n\t\tif (intersectPosition) {\n\t\t\tintersectDistance = cartesianDistance(\n\t\t\t\tsource,\n\t\t\t\tlngLatToWebMercatorXY(intersectPosition[0], intersectPosition[1]),\n\t\t\t);\n\n\t\t\tif (intersectDistance < closestDistance) {\n\t\t\t\tclosestPoint = intersectPosition;\n\t\t\t\tclosestDistance = intersectDistance;\n\t\t\t\tlineIndex = lines.indexOf(line);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn closestDistance === Infinity\n\t\t? undefined\n\t\t: {\n\t\t\t\tcoordinate: closestPoint,\n\t\t\t\tlineIndex: lineIndex,\n\t\t\t\tdistance: closestDistance,\n\t\t\t};\n}\n\n/**\n * Finds the nearest Web Mercator coordinate on a line to a given coordinate.\n * @param pointA - The first point of the line (Web Mercator coordinate).\n * @param pointB - The second point of the line (Web Mercator coordinate).\n * @param target - The target point to which the nearest point on the line is calculated.\n * @returns The nearest Web Mercator coordinate on the line to the target.\n */\nfunction findNearestPointOnLine(\n\tpointA: CartesianPoint,\n\tpointB: CartesianPoint,\n\ttarget: CartesianPoint,\n): CartesianPoint {\n\t// Vector from pointA to pointB\n\tconst lineVector = {\n\t\tx: pointB.x - pointA.x,\n\t\ty: pointB.y - pointA.y,\n\t};\n\n\t// Vector from pointA to the target point\n\tconst targetVector = {\n\t\tx: target.x - pointA.x,\n\t\ty: target.y - pointA.y,\n\t};\n\n\t// Compute the dot product of the target vector with the line vector\n\tconst dotProduct =\n\t\ttargetVector.x * lineVector.x + targetVector.y * lineVector.y;\n\n\t// Compute the length squared of the line vector\n\tconst lineLengthSquared =\n\t\tlineVector.x * lineVector.x + lineVector.y * lineVector.y;\n\n\t// Find the projection of the target vector onto the line vector\n\tconst t = Math.max(0, Math.min(1, dotProduct / lineLengthSquared));\n\n\t// Compute the nearest point on the line\n\tconst nearestPoint = {\n\t\tx: pointA.x + t * lineVector.x,\n\t\ty: pointA.y + t * lineVector.y,\n\t};\n\n\treturn nearestPoint;\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { TerraDrawMouseEvent } from \"../common\";\nimport { Feature, Position } from \"geojson\";\nimport { ClickBoundingBoxBehavior } from \"./click-bounding-box.behavior\";\nimport { BBoxPolygon, FeatureId } from \"../store/store\";\nimport { PixelDistanceBehavior } from \"./pixel-distance.behavior\";\nimport { nearestPointOnLine } from \"../geometry/point-on-line\";\nimport { webMercatorNearestPointOnLine } from \"../geometry/web-mercator-point-on-line\";\nimport { limitPrecision } from \"../geometry/limit-decimal-precision\";\n\nexport class LineSnappingBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t\tprivate readonly clickBoundingBox: ClickBoundingBoxBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\t/** Returns the nearest snappable coordinate - on first click there is no currentId so no need to provide */\n\tpublic getSnappableCoordinateFirstClick = (event: TerraDrawMouseEvent) => {\n\t\tconst snappable = this.getSnappable(event, (feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties && feature.properties.mode === this.mode,\n\t\t\t);\n\t\t});\n\n\t\treturn snappable.coordinate\n\t\t\t? [\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tsnappable.coordinate[0],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tsnappable.coordinate[1],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t]\n\t\t\t: undefined;\n\t};\n\n\tpublic getSnappableCoordinate = (\n\t\tevent: TerraDrawMouseEvent,\n\t\tcurrentFeatureId: FeatureId,\n\t) => {\n\t\tconst snappable = this.getSnappable(event, (feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties &&\n\t\t\t\t\tfeature.properties.mode === this.mode &&\n\t\t\t\t\tfeature.id !== currentFeatureId,\n\t\t\t);\n\t\t});\n\n\t\treturn snappable.coordinate\n\t\t\t? [\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tsnappable.coordinate[0],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tsnappable.coordinate[1],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t]\n\t\t\t: undefined;\n\t};\n\n\tpublic getSnappable(\n\t\tevent: TerraDrawMouseEvent,\n\t\tfilter?: (feature: Feature) => boolean,\n\t) {\n\t\tconst boundingBox = this.clickBoundingBox.create(event) as BBoxPolygon;\n\t\tconst features = this.store.search(boundingBox, filter);\n\t\tconst closest: {\n\t\t\tcoordinate: undefined | Position;\n\t\t\tminDistance: number;\n\t\t\tfeatureId: undefined | FeatureId;\n\t\t\tfeatureCoordinateIndex: undefined | number;\n\t\t} = {\n\t\t\tfeatureId: undefined,\n\t\t\tfeatureCoordinateIndex: undefined,\n\t\t\tcoordinate: undefined,\n\t\t\tminDistance: Infinity,\n\t\t};\n\t\tfeatures.forEach((feature) => {\n\t\t\tlet coordinates: Position[];\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst lines: [Position, Position][] = [];\n\n\t\t\tfor (let i = 0; i < coordinates.length - 1; i++) {\n\t\t\t\tlines.push([coordinates[i], coordinates[i + 1]]);\n\t\t\t}\n\n\t\t\tlet nearest:\n\t\t\t\t| {\n\t\t\t\t\t\tcoordinate: Position;\n\t\t\t\t\t\tlineIndex: number;\n\t\t\t\t\t\tdistance: number;\n\t\t\t\t  }\n\t\t\t\t| undefined;\n\n\t\t\tconst lngLat: Position = [event.lng, event.lat];\n\n\t\t\tif (this.config.projection === \"web-mercator\") {\n\t\t\t\tnearest = webMercatorNearestPointOnLine(lngLat, lines);\n\t\t\t} else if (this.config.projection === \"globe\") {\n\t\t\t\tnearest = nearestPointOnLine(lngLat, lines);\n\t\t\t}\n\n\t\t\tif (!nearest) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst distance = this.pixelDistance.measure(event, nearest.coordinate);\n\t\t\tif (distance < closest.minDistance && distance < this.pointerDistance) {\n\t\t\t\tclosest.featureId = feature.id;\n\t\t\t\tclosest.coordinate = [\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tnearest.coordinate[0],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tnearest.coordinate[1],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t];\n\t\t\t\tclosest.featureCoordinateIndex = nearest.lineIndex;\n\t\t\t\tclosest.minDistance = distance;\n\t\t\t}\n\t\t});\n\n\t\treturn closest;\n\t}\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tCartesianPoint,\n\tZ_INDEX,\n\tSnapping,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { Feature, LineString, Point, Position } from \"geojson\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../click-bounding-box.behavior\";\nimport { PixelDistanceBehavior } from \"../pixel-distance.behavior\";\nimport { CoordinateSnappingBehavior } from \"../coordinate-snapping.behavior\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tGeoJSONStoreGeometries,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { InsertCoordinatesBehavior } from \"../insert-coordinates.behavior\";\nimport { haversineDistanceKilometers } from \"../../geometry/measure/haversine-distance\";\nimport { coordinatesIdentical } from \"../../geometry/coordinates-identical\";\nimport { ValidateLineStringFeature } from \"../../validations/linestring.validation\";\nimport { LineSnappingBehavior } from \"../line-snapping.behavior\";\n\ntype TerraDrawLineStringModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" } as const;\n\ntype LineStringStyling = {\n\tlineStringWidth: NumericStyling;\n\tlineStringColor: HexColorStyling;\n\tclosingPointColor: HexColorStyling;\n\tclosingPointWidth: NumericStyling;\n\tclosingPointOutlineColor: HexColorStyling;\n\tclosingPointOutlineWidth: NumericStyling;\n\tsnappingPointColor: HexColorStyling;\n\tsnappingPointWidth: NumericStyling;\n\tsnappingPointOutlineColor: HexColorStyling;\n\tsnappingPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n\tdragStart?: Cursor;\n\tdragEnd?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n\tdragStart: \"grabbing\",\n\tdragEnd: \"crosshair\",\n} as Required<Cursors>;\n\ninterface InertCoordinates {\n\tstrategy: \"amount\"; // In future this could be extended\n\tvalue: number;\n}\n\ninterface TerraDrawLineStringModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tsnapping?: Snapping;\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawLineStringModeKeyEvents | null;\n\tcursors?: Cursors;\n\tinsertCoordinates?: InertCoordinates;\n\teditable?: boolean;\n}\n\nexport class TerraDrawLineStringMode extends TerraDrawBaseDrawMode<LineStringStyling> {\n\tmode = \"linestring\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate closingPointId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawLineStringModeKeyEvents = defaultKeyEvents;\n\tprivate snapping: Snapping | undefined;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\tprivate insertCoordinates: InertCoordinates | undefined;\n\tprivate lastCommittedCoordinates: Position[] | undefined;\n\tprivate snappedPointId: FeatureId | undefined;\n\tprivate lastMouseMoveEvent: TerraDrawMouseEvent | undefined;\n\n\t// Editable properties\n\tprivate editable: boolean = false;\n\tprivate editedFeatureId: FeatureId | undefined;\n\tprivate editedFeatureCoordinateIndex: number | undefined;\n\tprivate editedSnapType: \"line\" | \"coordinate\" | undefined;\n\tprivate editedInsertIndex: number | undefined;\n\tprivate editedPointId: FeatureId | undefined;\n\n\t// Behaviors\n\tprivate coordinateSnapping!: CoordinateSnappingBehavior;\n\tprivate insertPoint!: InsertCoordinatesBehavior;\n\tprivate lineSnapping!: LineSnappingBehavior;\n\tprivate pixelDistance!: PixelDistanceBehavior;\n\tprivate clickBoundingBox!: ClickBoundingBoxBehavior;\n\n\tconstructor(options?: TerraDrawLineStringModeOptions<LineStringStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tupdateOptions(\n\t\toptions?: TerraDrawLineStringModeOptions<LineStringStyling> | undefined,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.snapping) {\n\t\t\tthis.snapping = options.snapping;\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.insertCoordinates) {\n\t\t\tthis.insertCoordinates = options.insertCoordinates;\n\t\t}\n\n\t\tif (options && options.editable) {\n\t\t\tthis.editable = options.editable;\n\t\t}\n\t}\n\n\tprivate updateSnappedCoordinate(event: TerraDrawMouseEvent) {\n\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\tif (snappedCoordinate) {\n\t\t\tif (this.snappedPointId) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{\n\t\t\t\t\t\tid: this.snappedPointId,\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tconst [snappedPointId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.SNAPPING_POINT]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\tthis.snappedPointId = snappedPointId;\n\t\t\t}\n\n\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\tevent.lat = snappedCoordinate[1];\n\t\t} else if (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\treturn snappedCoordinate;\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\t// Finish off the drawing\n\t\tcurrentLineGeometry.coordinates.pop();\n\n\t\tthis.updateGeometries(\n\t\t\t[...currentLineGeometry.coordinates],\n\t\t\tundefined,\n\t\t\tUpdateTypes.Commit,\n\t\t);\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\tvalue: undefined,\n\t\t\t},\n\t\t]);\n\n\t\tconst finishedId = this.currentId;\n\n\t\t// Reset the state back to starting state\n\t\tif (this.closingPointId) {\n\t\t\tthis.store.delete([this.closingPointId]);\n\t\t}\n\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t}\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentId = undefined;\n\t\tthis.closingPointId = undefined;\n\t\tthis.snappedPointId = undefined;\n\t\tthis.lastCommittedCoordinates = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\t// Ensure that any listeners are triggered with the main created geometry\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\tprivate updateGeometries(\n\t\tcoordinates: LineString[\"coordinates\"],\n\t\tclosingPointCoordinate: Point[\"coordinates\"] | undefined,\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tif (!this.currentId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst updatedGeometry = { type: \"LineString\", coordinates } as LineString;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: updateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst geometries = [\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tgeometry: updatedGeometry,\n\t\t\t},\n\t\t] as {\n\t\t\tid: FeatureId;\n\t\t\tgeometry: GeoJSONStoreGeometries;\n\t\t}[];\n\n\t\tif (this.closingPointId && closingPointCoordinate) {\n\t\t\tgeometries.push({\n\t\t\t\tid: this.closingPointId,\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: closingPointCoordinate,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tif (updateType === \"commit\") {\n\t\t\tthis.lastCommittedCoordinates = updatedGeometry.coordinates;\n\t\t}\n\n\t\tthis.store.updateGeometry(geometries);\n\t}\n\n\tprivate generateInsertCoordinates(startCoord: Position, endCoord: Position) {\n\t\tif (!this.insertCoordinates || !this.lastCommittedCoordinates) {\n\t\t\tthrow new Error(\"Not able to insert coordinates\");\n\t\t}\n\n\t\t// Other strategies my be implemented in the future\n\t\tif (this.insertCoordinates.strategy !== \"amount\") {\n\t\t\tthrow new Error(\"Strategy does not exist\");\n\t\t}\n\n\t\tconst distance = haversineDistanceKilometers(startCoord, endCoord);\n\t\tconst segmentDistance = distance / (this.insertCoordinates.value + 1);\n\t\tlet insertedCoordinates: Position[] = [];\n\n\t\tif (this.projection === \"globe\") {\n\t\t\tinsertedCoordinates =\n\t\t\t\tthis.insertPoint.generateInsertionGeodesicCoordinates(\n\t\t\t\t\tstartCoord,\n\t\t\t\t\tendCoord,\n\t\t\t\t\tsegmentDistance,\n\t\t\t\t);\n\t\t} else if (this.projection === \"web-mercator\") {\n\t\t\tinsertedCoordinates = this.insertPoint.generateInsertionCoordinates(\n\t\t\t\tstartCoord,\n\t\t\t\tendCoord,\n\t\t\t\tsegmentDistance,\n\t\t\t);\n\t\t}\n\n\t\treturn insertedCoordinates;\n\t}\n\n\tprivate createLine(startingCoord: Position) {\n\t\tconst [createdId] = this.store.create([\n\t\t\t{\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"LineString\",\n\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\tstartingCoord,\n\t\t\t\t\t\tstartingCoord, // This is the 'live' point that changes on mouse move\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\tproperties: {\n\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true, // This is the current line being drawn\n\t\t\t\t},\n\t\t\t},\n\t\t]);\n\t\tthis.lastCommittedCoordinates = [startingCoord, startingCoord];\n\t\tthis.currentId = createdId;\n\t\tthis.currentCoordinate++;\n\t\tthis.setDrawing();\n\t}\n\n\tprivate firstUpdateToLine(updatedCoord: Position) {\n\t\tif (!this.currentId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst currentCoordinates = currentLineGeometry.coordinates;\n\n\t\tconst [pointId] = this.store.create([\n\t\t\t{\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: [...updatedCoord],\n\t\t\t\t},\n\t\t\t\tproperties: {\n\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t},\n\t\t\t},\n\t\t]);\n\t\tthis.closingPointId = pointId;\n\n\t\t// We are creating the point so we immediately want\n\t\t// to set the point cursor to show it can be closed\n\t\tthis.setCursor(this.cursors.close);\n\n\t\tconst initialLineCoordinates = [...currentCoordinates, updatedCoord];\n\t\tconst closingPointCoordinate = undefined; // We don't need this until second click\n\n\t\tthis.updateGeometries(\n\t\t\tinitialLineCoordinates,\n\t\t\tclosingPointCoordinate,\n\t\t\tUpdateTypes.Commit,\n\t\t);\n\n\t\tthis.currentCoordinate++;\n\t}\n\n\tprivate updateToLine(updatedCoord: Position, cursorXY: CartesianPoint) {\n\t\tif (!this.currentId) {\n\t\t\treturn;\n\t\t}\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst currentCoordinates = currentLineGeometry.coordinates;\n\n\t\t// If we are not inserting points we can get the penultimate coordinated\n\t\tconst [previousLng, previousLat] = this.lastCommittedCoordinates\n\t\t\t? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1]\n\t\t\t: currentCoordinates[currentCoordinates.length - 2];\n\n\t\t// Determine if the click closes the line and finished drawing\n\t\tconst { x, y } = this.project(previousLng, previousLat);\n\t\tconst distance = cartesianDistance(\n\t\t\t{ x, y },\n\t\t\t{ x: cursorXY.x, y: cursorXY.y },\n\t\t);\n\t\tconst isClosingClick = distance < this.pointerDistance;\n\n\t\tif (isClosingClick) {\n\t\t\tthis.close();\n\t\t\treturn;\n\t\t}\n\n\t\t// The cursor will immediately change to closing because the\n\t\t// closing point will be underneath the cursor\n\t\tthis.setCursor(this.cursors.close);\n\n\t\tconst updatedLineCoordinates = [...currentCoordinates, updatedCoord];\n\t\tconst updatedClosingPointCoordinate =\n\t\t\tcurrentCoordinates[currentCoordinates.length - 1];\n\n\t\tthis.updateGeometries(\n\t\t\tupdatedLineCoordinates,\n\t\t\tupdatedClosingPointCoordinate,\n\t\t\tUpdateTypes.Commit,\n\t\t);\n\n\t\tthis.currentCoordinate++;\n\t}\n\n\t/** @internal */\n\tregisterBehaviors(config: BehaviorConfig) {\n\t\tthis.coordinateSnapping = new CoordinateSnappingBehavior(\n\t\t\tconfig,\n\t\t\tnew PixelDistanceBehavior(config),\n\t\t\tnew ClickBoundingBoxBehavior(config),\n\t\t);\n\n\t\tthis.insertPoint = new InsertCoordinatesBehavior(config);\n\n\t\tthis.clickBoundingBox = new ClickBoundingBoxBehavior(config);\n\t\tthis.pixelDistance = new PixelDistanceBehavior(config);\n\t\tthis.lineSnapping = new LineSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.coordinateSnapping = new CoordinateSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\t\tthis.lastMouseMoveEvent = event;\n\n\t\tconst snappedCoordinate = this.updateSnappedCoordinate(event);\n\n\t\tconst updatedCoord = snappedCoordinate\n\t\t\t? snappedCoordinate\n\t\t\t: [event.lng, event.lat];\n\n\t\tif (this.currentId === undefined || this.currentCoordinate === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst currentCoordinates = currentLineGeometry.coordinates;\n\n\t\t// Remove the 'live' point that changes on mouse move\n\t\tcurrentCoordinates.pop();\n\n\t\t// We want to ensure that when we are hovering over\n\t\t// the closing point that the pointer cursor is shown\n\t\tif (this.closingPointId) {\n\t\t\tconst [previousLng, previousLat] =\n\t\t\t\tcurrentCoordinates[currentCoordinates.length - 1];\n\t\t\tconst { x, y } = this.project(previousLng, previousLat);\n\t\t\tconst distance = cartesianDistance(\n\t\t\t\t{ x, y },\n\t\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t\t);\n\n\t\t\tconst isClosingClick = distance < this.pointerDistance;\n\n\t\t\tif (isClosingClick) {\n\t\t\t\tthis.setCursor(this.cursors.close);\n\t\t\t}\n\t\t}\n\n\t\tlet line = [...currentCoordinates, updatedCoord];\n\n\t\tif (\n\t\t\tthis.insertCoordinates &&\n\t\t\tthis.currentId &&\n\t\t\tthis.lastCommittedCoordinates\n\t\t) {\n\t\t\tconst startCoord =\n\t\t\t\tthis.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1];\n\t\t\tconst endCoord = updatedCoord;\n\t\t\tif (!coordinatesIdentical(startCoord, endCoord)) {\n\t\t\t\tconst insertedCoordinates = this.generateInsertCoordinates(\n\t\t\t\t\tstartCoord,\n\t\t\t\t\tendCoord,\n\t\t\t\t);\n\t\t\t\tline = [\n\t\t\t\t\t...this.lastCommittedCoordinates.slice(0, -1),\n\t\t\t\t\t...insertedCoordinates,\n\t\t\t\t\tupdatedCoord,\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\t// Update the 'live' point\n\t\tthis.updateGeometries(line, undefined, UpdateTypes.Provisional);\n\t}\n\n\tprivate onRightClick(event: TerraDrawMouseEvent) {\n\t\tif (!this.editable || this.state !== \"started\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { featureId, featureCoordinateIndex: coordinateIndex } =\n\t\t\tthis.coordinateSnapping.getSnappable(event, (feature) =>\n\t\t\t\tthis.lineStringFilter(feature),\n\t\t\t);\n\n\t\tif (!featureId || coordinateIndex === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(featureId);\n\n\t\tlet coordinates;\n\t\tif (geometry.type === \"LineString\") {\n\t\t\tcoordinates = geometry.coordinates;\n\n\t\t\t// Prevent creating an invalid linestring\n\t\t\tif (coordinates.length <= 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove coordinate from array\n\t\tcoordinates.splice(coordinateIndex, 1);\n\n\t\t// Validate the new geometry\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\tid: featureId,\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Commit,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// The geometry has changed, so if we were snapped to a point we need to remove it\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: featureId,\n\t\t\t\tgeometry,\n\t\t\t},\n\t\t]);\n\n\t\tthis.onFinish(featureId, { mode: this.mode, action: \"edit\" });\n\t}\n\n\tprivate onLeftClick(event: TerraDrawMouseEvent) {\n\t\t// Reset the snapping point\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\t\tconst updatedCoordinate = snappedCoordinate\n\t\t\t? snappedCoordinate\n\t\t\t: [event.lng, event.lat];\n\n\t\tif (this.currentCoordinate === 0) {\n\t\t\tthis.createLine(updatedCoordinate);\n\t\t} else if (this.currentCoordinate === 1 && this.currentId) {\n\t\t\tthis.firstUpdateToLine(updatedCoordinate);\n\t\t} else if (this.currentId) {\n\t\t\tthis.updateToLine(updatedCoordinate, {\n\t\t\t\tx: event.containerX,\n\t\t\t\ty: event.containerY,\n\t\t\t});\n\t\t}\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\t// We want pointer devices (mobile/tablet) to have\n\t\t\t// similar behaviour to mouse based devices so we\n\t\t\t// trigger a mousemove event before every click\n\t\t\t// if one has not been triggered to emulate this\n\t\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\t\tthis.onMouseMove(event);\n\t\t\t}\n\t\t\tthis.mouseMove = false;\n\n\t\t\tif (event.button === \"right\") {\n\t\t\t\tthis.onRightClick(event);\n\t\t\t} else if (event.button === \"left\") {\n\t\t\t\tthis.onLeftClick(event);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t}\n\n\t\tif (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragStart, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.editable) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet snappedCoordinate: Position | undefined = undefined;\n\n\t\tif (this.state === \"started\") {\n\t\t\tconst lineSnapped = this.lineSnapping.getSnappable(event, (feature) =>\n\t\t\t\tthis.lineStringFilter(feature),\n\t\t\t);\n\n\t\t\tif (lineSnapped.coordinate) {\n\t\t\t\tthis.editedSnapType = \"line\";\n\t\t\t\tthis.editedFeatureCoordinateIndex = lineSnapped.featureCoordinateIndex;\n\t\t\t\tthis.editedFeatureId = lineSnapped.featureId;\n\t\t\t\tsnappedCoordinate = lineSnapped.coordinate;\n\t\t\t}\n\n\t\t\tconst coordinateSnapped = this.coordinateSnapping.getSnappable(\n\t\t\t\tevent,\n\t\t\t\t(feature) => this.lineStringFilter(feature),\n\t\t\t);\n\n\t\t\tif (coordinateSnapped.coordinate) {\n\t\t\t\tthis.editedSnapType = \"coordinate\";\n\t\t\t\tthis.editedFeatureCoordinateIndex =\n\t\t\t\t\tcoordinateSnapped.featureCoordinateIndex;\n\t\t\t\tthis.editedFeatureId = coordinateSnapped.featureId;\n\t\t\t\tsnappedCoordinate = coordinateSnapped.coordinate;\n\t\t\t}\n\t\t}\n\n\t\t// We only need to stop the map dragging if\n\t\t// we actually have something selected\n\t\tif (!this.editedFeatureId || !snappedCoordinate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create a point to drag when editing\n\t\tif (!this.editedPointId) {\n\t\t\tconst [editedPointId] = this.store.create([\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t},\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.EDITED]: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.editedPointId = editedPointId;\n\t\t}\n\n\t\t// Drag Feature\n\t\tthis.setCursor(this.cursors.dragStart);\n\n\t\tsetMapDraggability(false);\n\t}\n\n\t/** @internal */\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDrag, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tthis.editedFeatureId === undefined ||\n\t\t\tthis.editedFeatureCoordinateIndex === undefined\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst featureCopy: LineString = this.store.getGeometryCopy(\n\t\t\tthis.editedFeatureId,\n\t\t);\n\t\tconst featureCoordinates = featureCopy.coordinates;\n\n\t\t// Either it's a coordinate drag or a line drag where the line coordinate has already been inserted\n\t\tif (\n\t\t\tthis.editedSnapType === \"coordinate\" ||\n\t\t\t(this.editedSnapType === \"line\" && this.editedInsertIndex !== undefined)\n\t\t) {\n\t\t\tfeatureCoordinates[this.editedFeatureCoordinateIndex] = [\n\t\t\t\tevent.lng,\n\t\t\t\tevent.lat,\n\t\t\t];\n\t\t} else if (\n\t\t\tthis.editedSnapType === \"line\" &&\n\t\t\tthis.editedInsertIndex === undefined\n\t\t) {\n\t\t\t// Splice inserts _before_ the index, so we need to add 1\n\t\t\tthis.editedInsertIndex = this.editedFeatureCoordinateIndex + 1;\n\n\t\t\t// Insert the new dragged snapped line coordinate\n\t\t\tfeatureCopy.coordinates.splice(this.editedInsertIndex, 0, [\n\t\t\t\tevent.lng,\n\t\t\t\tevent.lat,\n\t\t\t]);\n\n\t\t\t// We have inserted a point, need to change the edit index\n\t\t\t// so it can be moved correctly when it gets dragged again\n\t\t\tthis.editedFeatureCoordinateIndex++;\n\t\t}\n\n\t\tconst newLineStringGeometry = {\n\t\t\ttype: \"LineString\",\n\t\t\tcoordinates: featureCopy.coordinates,\n\t\t} as LineString;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: newLineStringGeometry,\n\t\t\t\t\tproperties: this.store.getPropertiesCopy(this.editedFeatureId),\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping && this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tgeometry: newLineStringGeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (this.editedPointId) {\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.editedPointId,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t]);\n\t}\n\n\t/** @internal */\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragEnd, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editedFeatureId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setCursor(this.cursors.dragEnd);\n\n\t\tif (this.editedPointId) {\n\t\t\tthis.store.delete([this.editedPointId]);\n\t\t\tthis.editedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: false,\n\t\t\t},\n\t\t]);\n\n\t\tthis.onFinish(this.editedFeatureId, { mode: this.mode, action: \"edit\" });\n\n\t\t// Reset edit state\n\t\tthis.editedFeatureId = undefined;\n\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\tthis.editedInsertIndex = undefined;\n\t\tthis.editedSnapType = undefined;\n\n\t\tsetMapDraggability(true);\n\t}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentId;\n\t\tconst cleanupClosingPointId = this.closingPointId;\n\t\tconst snappedPointId = this.snappedPointId;\n\n\t\tthis.closingPointId = undefined;\n\t\tthis.snappedPointId = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.currentCoordinate = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t\tif (snappedPointId !== undefined) {\n\t\t\t\tthis.store.delete([snappedPointId]);\n\t\t\t}\n\t\t\tif (cleanupClosingPointId !== undefined) {\n\t\t\t\tthis.store.delete([cleanupClosingPointId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"LineString\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.lineStringColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.lineStringColor,\n\t\t\t\tstyles.lineStringColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.lineStringWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.lineStringWidth,\n\t\t\t\tstyles.lineStringWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t} else if (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tconst isClosingPoint =\n\t\t\t\tfeature.properties[COMMON_PROPERTIES.CLOSING_POINT];\n\n\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\tisClosingPoint\n\t\t\t\t\t? this.styles.closingPointColor\n\t\t\t\t\t: this.styles.snappingPointColor,\n\t\t\t\tstyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\tisClosingPoint\n\t\t\t\t\t? this.styles.closingPointWidth\n\t\t\t\t\t: this.styles.snappingPointWidth,\n\t\t\t\tstyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tisClosingPoint\n\t\t\t\t\t? this.styles.closingPointOutlineColor\n\t\t\t\t\t: this.styles.snappingPointOutlineColor,\n\t\t\t\t\"#ffffff\",\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tisClosingPoint\n\t\t\t\t\t? this.styles.closingPointOutlineWidth\n\t\t\t\t\t: this.styles.snappingPointOutlineWidth,\n\t\t\t\t2,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_FIVE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateLineStringFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n\n\tprivate lineStringFilter(feature: Feature) {\n\t\treturn Boolean(\n\t\t\tfeature.geometry.type === \"LineString\" &&\n\t\t\t\tfeature.properties &&\n\t\t\t\tfeature.properties.mode === this.mode,\n\t\t);\n\t}\n\n\tprivate snapCoordinate(event: TerraDrawMouseEvent) {\n\t\tlet snappedCoordinate: Position | undefined;\n\n\t\tif (this.snapping?.toLine) {\n\t\t\tlet snapped: Position | undefined;\n\t\t\tif (this.currentId) {\n\t\t\t\tsnapped = this.lineSnapping.getSnappableCoordinate(\n\t\t\t\t\tevent,\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tsnapped = this.lineSnapping.getSnappableCoordinateFirstClick(event);\n\t\t\t}\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping?.toCoordinate) {\n\t\t\tif (this.currentId) {\n\t\t\t\tsnappedCoordinate = this.coordinateSnapping.getSnappableCoordinate(\n\t\t\t\t\tevent,\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tsnappedCoordinate =\n\t\t\t\t\tthis.coordinateSnapping.getSnappableCoordinateFirstClick(event);\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping?.toCustom) {\n\t\t\tsnappedCoordinate = this.snapping.toCustom(event, {\n\t\t\t\tcurrentCoordinate: this.currentCoordinate,\n\t\t\t\tcurrentId: this.currentId,\n\t\t\t\tgetCurrentGeometrySnapshot: this.currentId\n\t\t\t\t\t? () =>\n\t\t\t\t\t\t\tthis.store.getGeometryCopy<LineString>(\n\t\t\t\t\t\t\t\tthis.currentId as FeatureId,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t: () => null,\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t});\n\t\t}\n\n\t\treturn snappedCoordinate;\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// Clean up here is important to get right as we need to make a best effort to avoid erroneous\n\t\t// internal state.\n\n\t\t// If we are editing a feature by dragging one of its points\n\t\t// we want to clear that state up as new polygon might be completely\n\t\t// different in terms of it's coordinates\n\t\tif (this.editedFeatureId === feature.id && this.editedPointId) {\n\t\t\tthis.store.delete([this.editedPointId]);\n\t\t\tthis.editedPointId = undefined;\n\t\t\tthis.editedFeatureId = undefined;\n\t\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\t\tthis.editedSnapType = undefined;\n\t\t}\n\n\t\t// We can recalculate the snapped point from the last mouse event if there was one\n\t\tif (this.snappedPointId && this.lastMouseMoveEvent) {\n\t\t\tthis.updateSnappedCoordinate(\n\t\t\t\tthis.lastMouseMoveEvent as TerraDrawMouseEvent,\n\t\t\t);\n\t\t}\n\n\t\t// NOTE: This handles the case we are currently drawing a polygon\n\t\t// We need to reset the drawing state because it is very complicated (impossible?)\n\t\t// to recover the drawing state after a feature update\n\t\tif (this.currentId === feature.id) {\n\t\t\tif (this.closingPointId) {\n\t\t\t\tthis.store.delete([this.closingPointId]);\n\t\t\t\tthis.closingPointId = undefined;\n\t\t\t}\n\n\t\t\tthis.currentCoordinate = 0;\n\t\t\tthis.currentId = undefined;\n\n\t\t\t// Go back to started state\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { Validation } from \"../common\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport {\n\tcoordinateIsValid,\n\tcoordinatePrecisionIsValid,\n} from \"../geometry/boolean/is-valid-coordinate\";\n\nexport const ValidationReasonFeatureNotPoint = \"Feature is not a Point\";\nexport const ValidationReasonFeatureInvalidCoordinates =\n\t\"Feature has invalid coordinates\";\nexport const ValidationReasonFeatureInvalidCoordinatePrecision =\n\t\"Feature has coordinates with excessive precision\";\n\nexport function ValidatePointFeature(\n\tfeature: GeoJSONStoreFeatures,\n\tcoordinatePrecision: number,\n): ReturnType<Validation> {\n\tif (feature.geometry.type !== \"Point\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPoint,\n\t\t};\n\t}\n\n\tif (!coordinateIsValid(feature.geometry.coordinates)) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureInvalidCoordinates,\n\t\t};\n\t}\n\n\tif (\n\t\t!coordinatePrecisionIsValid(\n\t\t\tfeature.geometry.coordinates,\n\t\t\tcoordinatePrecision,\n\t\t)\n\t) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureInvalidCoordinatePrecision,\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tNumericStyling,\n\tHexColorStyling,\n\tCursor,\n\tUpdateTypes,\n\tCOMMON_PROPERTIES,\n\tZ_INDEX,\n} from \"../../common\";\nimport {\n\tBBoxPolygon,\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { ValidatePointFeature } from \"../../validations/point.validation\";\nimport { Point, Position } from \"geojson\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../click-bounding-box.behavior\";\nimport { PixelDistanceBehavior } from \"../pixel-distance.behavior\";\n\ntype PointModeStyling = {\n\tpointWidth: NumericStyling;\n\tpointColor: HexColorStyling;\n\tpointOutlineColor: HexColorStyling;\n\tpointOutlineWidth: NumericStyling;\n\teditedPointColor: HexColorStyling;\n\teditedPointWidth: NumericStyling;\n\teditedPointOutlineColor: HexColorStyling;\n\teditedPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tcreate?: Cursor;\n\tdragStart?: Cursor;\n\tdragEnd?: Cursor;\n}\n\nconst defaultCursors = {\n\tcreate: \"crosshair\",\n\tdragStart: \"grabbing\",\n\tdragEnd: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawPointModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tcursors?: Cursors;\n\teditable?: boolean;\n}\n\nexport class TerraDrawPointMode extends TerraDrawBaseDrawMode<PointModeStyling> {\n\tmode = \"point\" as const;\n\n\t// Options\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate editable: boolean = false;\n\n\t// Internal state\n\tprivate editedFeatureId: FeatureId | undefined;\n\n\t// Behaviors\n\tprivate pixelDistance!: PixelDistanceBehavior;\n\tprivate clickBoundingBox!: ClickBoundingBoxBehavior;\n\n\tconstructor(options?: TerraDrawPointModeOptions<PointModeStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tupdateOptions(\n\t\toptions?: TerraDrawPointModeOptions<PointModeStyling> | undefined,\n\t): void {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.editable) {\n\t\t\tthis.editable = options.editable;\n\t\t}\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.create);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tthis.onRightClick(event);\n\t\t\treturn;\n\t\t} else if (\n\t\t\tevent.button === \"left\" &&\n\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)\n\t\t) {\n\t\t\tthis.onLeftClick(event);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @internal */\n\tonMouseMove() {}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tthis.editedFeatureId = undefined;\n\t}\n\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragStart, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editable) {\n\t\t\tconst nearestPointFeature = this.getNearestPointFeature(event);\n\t\t\tthis.editedFeatureId = nearestPointFeature?.id;\n\t\t}\n\n\t\t// We only need to stop the map dragging if\n\t\t// we actually have something selected\n\t\tif (!this.editedFeatureId) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Drag Feature\n\t\tthis.setCursor(this.cursors.dragStart);\n\n\t\tsetMapDraggability(false);\n\t}\n\n\t/** @internal */\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDrag, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editedFeatureId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst newGeometry = {\n\t\t\ttype: \"Point\",\n\t\t\tcoordinates: [event.lng, event.lat],\n\t\t};\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t\tproperties: this.store.getPropertiesCopy(this.editedFeatureId),\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// For cursor points we can simply move it\n\t\t// to the dragged position\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t},\n\t\t\t},\n\t\t]);\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t]);\n\t}\n\n\t/** @internal */\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragEnd, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editedFeatureId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.onFinish(this.editedFeatureId, { mode: this.mode, action: \"edit\" });\n\n\t\tthis.setCursor(this.cursors.dragEnd);\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: false,\n\t\t\t},\n\t\t]);\n\t\tthis.editedFeatureId = undefined;\n\t\tsetMapDraggability(true);\n\t}\n\n\tregisterBehaviors(config: BehaviorConfig) {\n\t\tthis.pixelDistance = new PixelDistanceBehavior(config);\n\t\tthis.clickBoundingBox = new ClickBoundingBoxBehavior(config);\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tconst isEdited = Boolean(\n\t\t\t\tfeature.id && this.editedFeatureId === feature.id,\n\t\t\t);\n\n\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\tisEdited ? this.styles.editedPointWidth : this.styles.pointWidth,\n\t\t\t\tstyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\tisEdited ? this.styles.editedPointColor : this.styles.pointColor,\n\t\t\t\tstyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tisEdited\n\t\t\t\t\t? this.styles.editedPointOutlineColor\n\t\t\t\t\t: this.styles.pointOutlineColor,\n\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tisEdited\n\t\t\t\t\t? this.styles.editedPointOutlineWidth\n\t\t\t\t\t: this.styles.pointOutlineWidth,\n\t\t\t\t2,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_THREE;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidatePointFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n\n\tprivate onLeftClick(event: TerraDrawMouseEvent) {\n\t\tconst geometry = {\n\t\t\ttype: \"Point\",\n\t\t\tcoordinates: [event.lng, event.lat],\n\t\t} as Point;\n\n\t\tconst properties = { mode: this.mode };\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst [pointId] = this.store.create([{ geometry, properties }]);\n\n\t\t// Ensure that any listerers are triggered with the main created geometry\n\t\tthis.onFinish(pointId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\tprivate onRightClick(event: TerraDrawMouseEvent) {\n\t\t// We only want to be able to delete points if the mode is editable\n\t\tif (!this.editable) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst clickedFeature = this.getNearestPointFeature(event);\n\n\t\tif (clickedFeature) {\n\t\t\tthis.store.delete([clickedFeature.id as FeatureId]);\n\t\t}\n\t}\n\n\tprivate getNearestPointFeature(event: TerraDrawMouseEvent) {\n\t\tconst bbox = this.clickBoundingBox.create(event) as BBoxPolygon;\n\t\tconst features = this.store.search(bbox);\n\n\t\tlet distance = Infinity;\n\t\tlet clickedFeature: GeoJSONStoreFeatures | undefined = undefined;\n\n\t\tfor (let i = 0; i < features.length; i++) {\n\t\t\tconst feature = features[i];\n\t\t\tconst isPoint =\n\t\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\t\tfeature.properties.mode === this.mode;\n\n\t\t\tif (!isPoint) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst position = feature.geometry.coordinates as Position;\n\t\t\tconst distanceToFeature = this.pixelDistance.measure(event, position);\n\n\t\t\tif (\n\t\t\t\tdistanceToFeature > distance ||\n\t\t\t\tdistanceToFeature > this.pointerDistance\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdistance = distanceToFeature;\n\t\t\tclickedFeature = feature;\n\t\t}\n\n\t\treturn clickedFeature;\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// If we are editing a point by dragging it we want to clear that state\n\t\t// up as new point location might be completely  different in terms of it's location\n\t\tif (this.editedFeatureId === feature.id) {\n\t\t\tthis.editedFeatureId = undefined;\n\t\t\tthis.setCursor(this.cursors.create);\n\t\t}\n\t}\n}\n","import { Point, Position } from \"geojson\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { COMMON_PROPERTIES, TerraDrawMouseEvent } from \"../../../common\";\nimport { PixelDistanceBehavior } from \"../../pixel-distance.behavior\";\n\nexport class ClosingPointsBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate _startEndPoints: string[] = [];\n\n\tget ids() {\n\t\treturn this._startEndPoints.concat();\n\t}\n\n\tset ids(_: string[]) {}\n\n\tpublic create(selectedCoords: Position[], mode: string) {\n\t\tif (this.ids.length) {\n\t\t\tthrow new Error(\"Opening and closing points already created\");\n\t\t}\n\n\t\tif (selectedCoords.length <= 3) {\n\t\t\tthrow new Error(\"Requires at least 4 coordinates\");\n\t\t}\n\n\t\tthis._startEndPoints = this.store.create(\n\t\t\t// Opening coordinate\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: selectedCoords[0],\n\t\t\t\t\t} as Point,\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t// Final coordinate\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: selectedCoords[selectedCoords.length - 2],\n\t\t\t\t\t} as Point,\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t);\n\t}\n\n\tpublic delete() {\n\t\tif (this.ids.length) {\n\t\t\tthis.store.delete(this.ids);\n\t\t\tthis._startEndPoints = [];\n\t\t}\n\t}\n\n\tpublic update(updatedCoordinates: Position[]) {\n\t\tif (this.ids.length !== 2) {\n\t\t\tthrow new Error(\"No closing points to update\");\n\t\t}\n\n\t\tthis.store.updateGeometry(\n\t\t\t// Opening coordinate\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tid: this.ids[0],\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: updatedCoordinates[0],\n\t\t\t\t\t} as Point,\n\t\t\t\t},\n\t\t\t\t// Final coordinate\n\t\t\t\t{\n\t\t\t\t\tid: this.ids[1],\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: updatedCoordinates[updatedCoordinates.length - 3],\n\t\t\t\t\t} as Point,\n\t\t\t\t},\n\t\t\t],\n\t\t);\n\t}\n\n\tpublic isClosingPoint(event: TerraDrawMouseEvent) {\n\t\tconst opening = this.store.getGeometryCopy(this.ids[0]);\n\t\tconst closing = this.store.getGeometryCopy(this.ids[1]);\n\n\t\tconst distance = this.pixelDistance.measure(\n\t\t\tevent,\n\t\t\topening.coordinates as Position,\n\t\t);\n\n\t\tconst distancePrevious = this.pixelDistance.measure(\n\t\t\tevent,\n\t\t\tclosing.coordinates as Position,\n\t\t);\n\n\t\tconst isClosing = distance < this.pointerDistance;\n\t\tconst isPreviousClosing = distancePrevious < this.pointerDistance;\n\n\t\treturn { isClosing, isPreviousClosing };\n\t}\n}\n","import { Point, Position } from \"geojson\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { FeatureId } from \"../../../store/store\";\nimport { COMMON_PROPERTIES } from \"../../../common\";\n\nexport class CoordinatePointBehavior extends TerraDrawModeBehavior {\n\tconstructor(config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\n\tpublic createOrUpdate(featureId: FeatureId) {\n\t\tconst existingFeature = this.store.getGeometryCopy(featureId);\n\t\tconst existingProperties = this.store.getPropertiesCopy(featureId);\n\n\t\tlet coordinates: Position[];\n\n\t\tif (existingFeature.type === \"Polygon\") {\n\t\t\tcoordinates = existingFeature.coordinates[0].slice(0, -1) as Position[];\n\t\t} else if (existingFeature.type === \"LineString\") {\n\t\t\tcoordinates = existingFeature.coordinates as Position[];\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tconst existingFeatureProps = this.store.getPropertiesCopy(featureId);\n\n\t\tconst existingCoordinatePointIds =\n\t\t\texistingFeatureProps.coordinatePointIds as FeatureId[];\n\n\t\t// If no existing coordinate points, create them\n\t\tif (!existingCoordinatePointIds) {\n\t\t\tconst coordinatePointIds = this.createPoints(\n\t\t\t\tcoordinates,\n\t\t\t\texistingProperties.mode as string,\n\t\t\t\tfeatureId,\n\t\t\t);\n\t\t\tthis.setFeatureCoordinatePoints(featureId, coordinatePointIds);\n\t\t}\n\t\t// If the existing coordinate points are present in the store, update them\n\t\telse if (\n\t\t\texistingCoordinatePointIds &&\n\t\t\texistingCoordinatePointIds.every((id) => this.store.has(id))\n\t\t) {\n\t\t\t// Check if the coordinates have changed\n\t\t\tconst existingCoordinates =\n\t\t\t\texistingFeatureProps.coordinatePointIds as FeatureId[];\n\t\t\tconst existingCoordinatePoints = existingCoordinates.map(\n\t\t\t\t(id) => this.store.getGeometryCopy(id).coordinates as Position,\n\t\t\t);\n\n\t\t\t// If the number of coordinates has changed, delete and recreate as it's too\n\t\t\t// complex to update the existing coordinates unless someone is feeling brave\n\t\t\tif (existingCoordinates.length !== coordinates.length) {\n\t\t\t\tthis.deleteCoordinatePoints(existingCoordinates);\n\t\t\t\tconst coordinatePointIds = this.createPoints(\n\t\t\t\t\tcoordinates,\n\t\t\t\t\texistingProperties.mode as string,\n\t\t\t\t\tfeatureId,\n\t\t\t\t);\n\t\t\t\tthis.setFeatureCoordinatePoints(featureId, coordinatePointIds);\n\t\t\t} else {\n\t\t\t\t// Update the coordinates\n\t\t\t\tcoordinates.forEach((coordinate, i) => {\n\t\t\t\t\t// If the coordinates are the same, don't update\n\t\t\t\t\tif (\n\t\t\t\t\t\tcoordinate[0] === existingCoordinatePoints[i][0] &&\n\t\t\t\t\t\tcoordinate[1] === existingCoordinatePoints[i][1]\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Only update the coordinates that have changed\n\t\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: existingCoordinates[i],\n\t\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\t\tcoordinates: coordinate,\n\t\t\t\t\t\t\t} as Point,\n\t\t\t\t\t\t},\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// If the existing coordinate points are not present in the store, delete them and recreate\n\t\telse {\n\t\t\t// If there are any leftover coordinate points we remove them\n\t\t\tconst existingPoints = existingCoordinatePointIds.filter((id) =>\n\t\t\t\tthis.store.has(id),\n\t\t\t);\n\t\t\tif (existingPoints.length) {\n\t\t\t\tthis.deleteCoordinatePoints(existingPoints);\n\t\t\t}\n\n\t\t\t// Create new coordinate points\n\t\t\tconst coordinatePointIds = this.createPoints(\n\t\t\t\tcoordinates,\n\t\t\t\texistingProperties.mode as string,\n\t\t\t\tfeatureId,\n\t\t\t);\n\t\t\tthis.setFeatureCoordinatePoints(featureId, coordinatePointIds);\n\t\t}\n\t}\n\n\tpublic deletePointsByFeatureIds(features: FeatureId[]) {\n\t\tfor (const featureId of features) {\n\t\t\tthis.deleteIfPresent(featureId);\n\t\t}\n\t}\n\n\tpublic getUpdated(featureId: FeatureId, updatedCoordinates: Position[]) {\n\t\tconst featureProperties = this.store.getPropertiesCopy(featureId);\n\n\t\tif (!featureProperties.coordinatePointIds) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn (featureProperties.coordinatePointIds as FeatureId[]).map(\n\t\t\t(id, i) => {\n\t\t\t\treturn {\n\t\t\t\t\tid,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t...this.store.getGeometryCopy(id),\n\t\t\t\t\t\tcoordinates: updatedCoordinates[i],\n\t\t\t\t\t} as Point,\n\t\t\t\t};\n\t\t\t},\n\t\t) as {\n\t\t\tid: FeatureId;\n\t\t\tgeometry: Point;\n\t\t}[];\n\t}\n\n\tprivate createPoints(\n\t\tcoordinates: Position[],\n\t\tmode: string,\n\t\tfeatureId: FeatureId,\n\t) {\n\t\treturn this.store.create(\n\t\t\tcoordinates.map((coordinate, i) => ({\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: coordinate,\n\t\t\t\t},\n\t\t\t\tproperties: {\n\t\t\t\t\tmode,\n\t\t\t\t\t[COMMON_PROPERTIES.COORDINATE_POINT]: true,\n\t\t\t\t\t[COMMON_PROPERTIES.COORDINATE_POINT_FEATURE_ID]: featureId,\n\t\t\t\t\tindex: i,\n\t\t\t\t},\n\t\t\t})),\n\t\t);\n\t}\n\n\tprivate setFeatureCoordinatePoints(\n\t\tfeatureId: FeatureId,\n\t\tvalue: FeatureId[] | null,\n\t) {\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: featureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.COORDINATE_POINT_IDS,\n\t\t\t\tvalue: value,\n\t\t\t},\n\t\t]);\n\t}\n\n\tprivate deleteCoordinatePoints(coordinatePointIds: FeatureId[]) {\n\t\t// We have to account for someone manually deleting the coordinate points or only partially restoring them\n\t\t// from some persistent storage. Essentially we cannot assume they are all present in the store.\n\t\tconst existingCoordinatePointIds = coordinatePointIds.filter((id) =>\n\t\t\tthis.store.has(id),\n\t\t) as FeatureId[];\n\t\tthis.store.delete(existingCoordinatePointIds);\n\t}\n\n\tprivate deleteIfPresent(featureId: FeatureId) {\n\t\tconst existingFeatureProps = this.store.getPropertiesCopy(featureId);\n\t\tconst coordinatePoints =\n\t\t\texistingFeatureProps.coordinatePointIds as FeatureId[];\n\n\t\tif (coordinatePoints) {\n\t\t\tthis.deleteCoordinatePoints(coordinatePoints);\n\t\t\tthis.setFeatureCoordinatePoints(featureId, null);\n\t\t}\n\t}\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tCOMMON_PROPERTIES,\n\tProject,\n\tUnproject,\n\tZ_INDEX,\n\tSnapping,\n} from \"../../common\";\nimport { Feature, Polygon, Position } from \"geojson\";\nimport {\n\tTerraDrawBaseDrawMode,\n\tBaseModeOptions,\n\tCustomStyling,\n\tPointerEvents,\n} from \"../base.mode\";\nimport { PixelDistanceBehavior } from \"../pixel-distance.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../click-bounding-box.behavior\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { createPolygon } from \"../../util/geoms\";\nimport { coordinatesIdentical } from \"../../geometry/coordinates-identical\";\nimport { ClosingPointsBehavior } from \"./behaviors/closing-points.behavior\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { ValidatePolygonFeature } from \"../../validations/polygon.validation\";\nimport { LineSnappingBehavior } from \"../line-snapping.behavior\";\nimport { CoordinateSnappingBehavior } from \"../coordinate-snapping.behavior\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\nimport { CoordinatePointBehavior } from \"../select/behaviors/coordinate-point.behavior\";\n\ntype TerraDrawPolygonModeKeyEvents = {\n\tcancel?: KeyboardEvent[\"key\"] | null;\n\tfinish?: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype PolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n\tclosingPointWidth: NumericStyling;\n\tclosingPointColor: HexColorStyling;\n\tclosingPointOutlineWidth: NumericStyling;\n\tclosingPointOutlineColor: HexColorStyling;\n\tsnappingPointWidth: NumericStyling;\n\tsnappingPointColor: HexColorStyling;\n\tsnappingPointOutlineWidth: NumericStyling;\n\tsnappingPointOutlineColor: HexColorStyling;\n\teditedPointWidth: NumericStyling;\n\teditedPointColor: HexColorStyling;\n\teditedPointOutlineWidth: NumericStyling;\n\teditedPointOutlineColor: HexColorStyling;\n\tcoordinatePointWidth: NumericStyling;\n\tcoordinatePointColor: HexColorStyling;\n\tcoordinatePointOutlineWidth: NumericStyling;\n\tcoordinatePointOutlineColor: HexColorStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n\tdragStart?: Cursor;\n\tdragEnd?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n\tdragStart: \"grabbing\",\n\tdragEnd: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawPolygonModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tsnapping?: Snapping;\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawPolygonModeKeyEvents | null;\n\tpointerEvents?: PointerEvents;\n\tcursors?: Cursors;\n\teditable?: boolean;\n\tshowCoordinatePoints?: boolean;\n}\n\nexport class TerraDrawPolygonMode extends TerraDrawBaseDrawMode<PolygonStyling> {\n\tmode = \"polygon\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawPolygonModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\tprivate showCoordinatePoints = false;\n\tprivate lastMouseMoveEvent: TerraDrawMouseEvent | undefined;\n\n\t// Snapping\n\tprivate snapping: Snapping | undefined;\n\tprivate snappedPointId: FeatureId | undefined;\n\n\t// Editable\n\tprivate editable: boolean = false;\n\tprivate editedFeatureId: FeatureId | undefined;\n\tprivate editedFeatureCoordinateIndex: number | undefined;\n\tprivate editedSnapType: \"line\" | \"coordinate\" | undefined;\n\tprivate editedInsertIndex: number | undefined;\n\tprivate editedPointId: FeatureId | undefined;\n\n\t// Behaviors\n\tprivate coordinatePoints!: CoordinatePointBehavior;\n\tprivate lineSnapping!: LineSnappingBehavior;\n\tprivate coordinateSnapping!: CoordinateSnappingBehavior;\n\tprivate pixelDistance!: PixelDistanceBehavior;\n\tprivate closingPoints!: ClosingPointsBehavior;\n\tprivate clickBoundingBox!: ClickBoundingBoxBehavior;\n\n\tconstructor(options?: TerraDrawPolygonModeOptions<PolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawPolygonModeOptions<PolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\t// null is the case where we want to explicitly turn key bindings off\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.snapping) {\n\t\t\tthis.snapping = options.snapping;\n\t\t}\n\n\t\tif (options?.editable !== undefined) {\n\t\t\tthis.editable = options.editable;\n\t\t}\n\n\t\tif (options?.pointerEvents !== undefined) {\n\t\t\tthis.pointerEvents = options.pointerEvents;\n\t\t}\n\n\t\tif (options?.showCoordinatePoints !== undefined) {\n\t\t\tthis.showCoordinatePoints = options.showCoordinatePoints;\n\n\t\t\t// If we are not showing coordinate points, we need to add them all\n\t\t\tif (this.coordinatePoints && options.showCoordinatePoints === true) {\n\t\t\t\tconst features = this.store.copyAllWhere(\n\t\t\t\t\t(properties) => properties.mode === this.mode,\n\t\t\t\t);\n\t\t\t\tconst polygonIds = features.map((feature) => feature.id as FeatureId);\n\t\t\t\tpolygonIds.forEach((id) => {\n\t\t\t\t\tthis.coordinatePoints.createOrUpdate(id);\n\t\t\t\t});\n\t\t\t} else if (this.coordinatePoints && this.showCoordinatePoints === false) {\n\t\t\t\tconst featuresWithCoordinates = this.store.copyAllWhere(\n\t\t\t\t\t(properties) =>\n\t\t\t\t\t\tproperties.mode === this.mode &&\n\t\t\t\t\t\tBoolean(\n\t\t\t\t\t\t\tproperties[COMMON_PROPERTIES.COORDINATE_POINT_IDS] as FeatureId[],\n\t\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\t\tthis.coordinatePoints.deletePointsByFeatureIds(\n\t\t\t\t\tfeaturesWithCoordinates.map((f) => f.id as FeatureId),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t).coordinates[0];\n\n\t\t// We don't want to allow closing if there is not enough\n\t\t// coordinates. We have extra because we insert them on mouse\n\t\t// move\n\t\tif (currentPolygonCoordinates.length < 5) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t[...currentPolygonCoordinates.slice(0, -2), currentPolygonCoordinates[0]],\n\t\t\tUpdateTypes.Finish,\n\t\t);\n\n\t\tif (!updated) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst finishedId = this.currentId;\n\n\t\t// Fix right hand rule if necessary\n\t\tif (this.currentId) {\n\t\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId),\n\t\t\t);\n\n\t\t\tif (correctedGeometry) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{ id: this.currentId, geometry: correctedGeometry },\n\t\t\t\t]);\n\n\t\t\t\t// Create or update coordinate points to reflect the new geometry\n\t\t\t\tif (this.showCoordinatePoints) {\n\t\t\t\t\tthis.coordinatePoints.createOrUpdate(this.currentId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.PROVISIONAL_COORDINATE_COUNT,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t}\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentId = undefined;\n\t\tthis.snappedPointId = undefined;\n\t\tthis.closingPoints.delete();\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tregisterBehaviors(config: BehaviorConfig) {\n\t\tthis.clickBoundingBox = new ClickBoundingBoxBehavior(config);\n\t\tthis.pixelDistance = new PixelDistanceBehavior(config);\n\t\tthis.lineSnapping = new LineSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.coordinateSnapping = new CoordinateSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.closingPoints = new ClosingPointsBehavior(config, this.pixelDistance);\n\n\t\tthis.coordinatePoints = new CoordinatePointBehavior(config);\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\tprivate updateSnappedCoordinate(event: TerraDrawMouseEvent) {\n\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\tif (snappedCoordinate) {\n\t\t\tif (this.snappedPointId) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{\n\t\t\t\t\t\tid: this.snappedPointId,\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tconst [snappedPointId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.SNAPPING_POINT]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\tthis.snappedPointId = snappedPointId;\n\t\t\t}\n\n\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\tevent.lat = snappedCoordinate[1];\n\t\t} else if (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\n\t\tthis.lastMouseMoveEvent = event;\n\t\tthis.updateSnappedCoordinate(event);\n\n\t\tif (this.currentId === undefined || this.currentCoordinate === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t).coordinates[0];\n\n\t\tlet updatedCoordinates;\n\n\t\tif (this.currentCoordinate === 1) {\n\t\t\t// We must add a very small epsilon value so that Mapbox GL\n\t\t\t// renders the polygon - There might be a cleaner solution?\n\t\t\tconst epsilon = 1 / Math.pow(10, this.coordinatePrecision - 1);\n\t\t\tconst offset = Math.max(0.000001, epsilon);\n\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\t[event.lng, event.lat - offset],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t} else if (this.currentCoordinate === 2) {\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\tcurrentPolygonCoordinates[1],\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t} else {\n\t\t\tconst { isClosing, isPreviousClosing } =\n\t\t\t\tthis.closingPoints.isClosingPoint(event);\n\n\t\t\tif (isPreviousClosing || isClosing) {\n\t\t\t\tif (this.snappedPointId) {\n\t\t\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\t\t\tthis.snappedPointId = undefined;\n\t\t\t\t}\n\n\t\t\t\tthis.setCursor(this.cursors.close);\n\n\t\t\t\tupdatedCoordinates = [\n\t\t\t\t\t...currentPolygonCoordinates.slice(0, -2),\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tupdatedCoordinates = [\n\t\t\t\t\t...currentPolygonCoordinates.slice(0, -2),\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tproperty: COMMON_PROPERTIES.PROVISIONAL_COORDINATE_COUNT,\n\t\t\t\tvalue: this.currentCoordinate + 1,\n\t\t\t},\n\t\t]);\n\n\t\tthis.updatePolygonGeometry(updatedCoordinates, UpdateTypes.Provisional);\n\t}\n\n\tprivate updatePolygonGeometry(\n\t\tcoordinates: Polygon[\"coordinates\"][0],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tif (!this.currentId) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [coordinates],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{ id: this.currentId, geometry: updatedGeometry },\n\t\t]);\n\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(this.currentId);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate snapCoordinate(event: TerraDrawMouseEvent): undefined | Position {\n\t\tlet snappedCoordinate: Position | undefined = undefined;\n\n\t\tif (this.snapping?.toLine) {\n\t\t\tlet snapped: Position | undefined;\n\t\t\tif (this.currentId) {\n\t\t\t\tsnapped = this.lineSnapping.getSnappableCoordinate(\n\t\t\t\t\tevent,\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tsnapped = this.lineSnapping.getSnappableCoordinateFirstClick(event);\n\t\t\t}\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping?.toCoordinate) {\n\t\t\tlet snapped: Position | undefined = undefined;\n\t\t\tif (this.currentId) {\n\t\t\t\tsnapped = this.coordinateSnapping.getSnappableCoordinate(\n\t\t\t\t\tevent,\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tsnapped =\n\t\t\t\t\tthis.coordinateSnapping.getSnappableCoordinateFirstClick(event);\n\t\t\t}\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping?.toCustom) {\n\t\t\tsnappedCoordinate = this.snapping.toCustom(event, {\n\t\t\t\tcurrentCoordinate: this.currentCoordinate,\n\t\t\t\tcurrentId: this.currentId,\n\t\t\t\tgetCurrentGeometrySnapshot: this.currentId\n\t\t\t\t\t? () =>\n\t\t\t\t\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId as FeatureId)\n\t\t\t\t\t: () => null,\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t});\n\t\t}\n\n\t\treturn snappedCoordinate;\n\t}\n\n\tprivate polygonFilter(feature: Feature) {\n\t\treturn Boolean(\n\t\t\tfeature.geometry.type === \"Polygon\" &&\n\t\t\t\tfeature.properties &&\n\t\t\t\tfeature.properties.mode === this.mode,\n\t\t);\n\t}\n\n\tprivate onRightClick(event: TerraDrawMouseEvent) {\n\t\t// Right click is only relevant when editable is true\n\t\tif (!this.editable || this.state !== \"started\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { featureId, featureCoordinateIndex: coordinateIndex } =\n\t\t\tthis.coordinateSnapping.getSnappable(event, (feature) =>\n\t\t\t\tthis.polygonFilter(feature),\n\t\t\t);\n\n\t\tif (!featureId || coordinateIndex === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(featureId);\n\n\t\tlet coordinates;\n\t\tif (geometry.type === \"Polygon\") {\n\t\t\tcoordinates = geometry.coordinates[0];\n\n\t\t\t// Prevent creating an invalid polygon\n\t\t\tif (coordinates.length <= 4) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isFinalPolygonCoordinate =\n\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t(coordinateIndex === 0 || coordinateIndex === coordinates.length - 1);\n\n\t\tif (isFinalPolygonCoordinate) {\n\t\t\t// Deleting the final coordinate in a polygon breaks it\n\t\t\t// because GeoJSON expects a duplicate, so we need to fix\n\t\t\t// it by adding the new first coordinate to the end\n\t\t\tcoordinates.shift();\n\t\t\tcoordinates.pop();\n\t\t\tcoordinates.push([coordinates[0][0], coordinates[0][1]]);\n\t\t} else {\n\t\t\t// Remove coordinate from array\n\t\t\tcoordinates.splice(coordinateIndex, 1);\n\t\t}\n\n\t\t// Validate the new geometry\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\tid: featureId,\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Commit,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// The geometry has changed, so if we were snapped to a point we need to remove it\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: featureId,\n\t\t\t\tgeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(featureId);\n\t\t}\n\n\t\tthis.onFinish(featureId, { mode: this.mode, action: \"edit\" });\n\t}\n\n\tprivate onLeftClick(event: TerraDrawMouseEvent) {\n\t\t// Reset the snapping point\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tif (this.currentCoordinate === 0) {\n\t\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\t\tif (snappedCoordinate) {\n\t\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\t\tevent.lat = snappedCoordinate[1];\n\t\t\t}\n\n\t\t\tconst [newId] = this.store.create([\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t[COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT]:\n\t\t\t\t\t\t\tthis.currentCoordinate + 1,\n\t\t\t\t\t\t[COMMON_PROPERTIES.PROVISIONAL_COORDINATE_COUNT]:\n\t\t\t\t\t\t\tthis.currentCoordinate + 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\t\t\tthis.currentId = newId;\n\t\t\tthis.currentCoordinate++;\n\n\t\t\tif (this.showCoordinatePoints) {\n\t\t\t\tthis.coordinatePoints.createOrUpdate(newId);\n\t\t\t}\n\n\t\t\t// Ensure the state is updated to reflect drawing has started\n\t\t\tthis.setDrawing();\n\t\t} else if (this.currentCoordinate === 1 && this.currentId) {\n\t\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\t\tif (snappedCoordinate) {\n\t\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\t\tevent.lat = snappedCoordinate[1];\n\t\t\t}\n\n\t\t\tconst currentPolygonGeometry = this.store.getGeometryCopy<Polygon>(\n\t\t\t\tthis.currentId,\n\t\t\t);\n\n\t\t\tconst previousCoordinate = currentPolygonGeometry.coordinates[0][0];\n\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\tpreviousCoordinate,\n\t\t\t);\n\n\t\t\tif (isIdentical) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t[\n\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t],\n\t\t\t\tUpdateTypes.Commit,\n\t\t\t);\n\n\t\t\tif (!updated) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT,\n\t\t\t\t\tvalue: this.currentCoordinate + 1,\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.currentCoordinate++;\n\t\t} else if (this.currentCoordinate === 2 && this.currentId) {\n\t\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\t\tif (snappedCoordinate) {\n\t\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\t\tevent.lat = snappedCoordinate[1];\n\t\t\t}\n\n\t\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\t\tthis.currentId,\n\t\t\t).coordinates[0];\n\n\t\t\tconst previousCoordinate = currentPolygonCoordinates[1];\n\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\tpreviousCoordinate,\n\t\t\t);\n\n\t\t\tif (isIdentical) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t[\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t\tcurrentPolygonCoordinates[1],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t],\n\t\t\t\tUpdateTypes.Commit,\n\t\t\t);\n\n\t\t\tif (!updated) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.currentCoordinate === 2) {\n\t\t\t\tthis.closingPoints.create(currentPolygonCoordinates, \"polygon\");\n\t\t\t}\n\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT,\n\t\t\t\t\tvalue: this.currentCoordinate + 1,\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.currentCoordinate++;\n\t\t} else if (this.currentId) {\n\t\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\t\tthis.currentId,\n\t\t\t).coordinates[0];\n\n\t\t\tconst { isClosing, isPreviousClosing } =\n\t\t\t\tthis.closingPoints.isClosingPoint(event);\n\n\t\t\tif (isPreviousClosing || isClosing) {\n\t\t\t\tthis.close();\n\t\t\t} else {\n\t\t\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\t\t\tif (snappedCoordinate) {\n\t\t\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\t\t\tevent.lat = snappedCoordinate[1];\n\t\t\t\t}\n\n\t\t\t\tconst previousCoordinate =\n\t\t\t\t\tcurrentPolygonCoordinates[this.currentCoordinate - 1];\n\t\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tpreviousCoordinate,\n\t\t\t\t);\n\n\t\t\t\tif (isIdentical) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst updatedPolygon = createPolygon([\n\t\t\t\t\t[\n\t\t\t\t\t\t...currentPolygonCoordinates.slice(0, -1),\n\t\t\t\t\t\t[event.lng, event.lat], // New point that onMouseMove can manipulate\n\t\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t\t],\n\t\t\t\t]);\n\n\t\t\t\t// If not close to the final point, keep adding points\n\t\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t\tupdatedPolygon.geometry.coordinates[0],\n\t\t\t\t\tUpdateTypes.Commit,\n\t\t\t\t);\n\t\t\t\tif (!updated) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.store.updateProperty([\n\t\t\t\t\t{\n\t\t\t\t\t\tid: this.currentId,\n\t\t\t\t\t\tproperty: COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT,\n\t\t\t\t\t\tvalue: this.currentCoordinate + 1,\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentCoordinate++;\n\n\t\t\t\t// Update closing points straight away\n\t\t\t\tif (this.closingPoints.ids.length) {\n\t\t\t\t\tthis.closingPoints.update(updatedPolygon.geometry.coordinates[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\t// We want pointer devices (mobile/tablet) to have\n\t\t// similar behaviour to mouse based devices so we\n\t\t// trigger a mousemove event before every click\n\t\t// if one has not been trigged to emulate this\n\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\tthis.onMouseMove(event);\n\t\t}\n\t\tthis.mouseMove = false;\n\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tthis.onRightClick(event);\n\t\t\treturn;\n\t\t} else if (\n\t\t\tevent.button === \"left\" &&\n\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)\n\t\t) {\n\t\t\tthis.onLeftClick(event);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragStart, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.editable) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet snappedCoordinate: Position | undefined = undefined;\n\n\t\tif (this.state === \"started\") {\n\t\t\t// Here we reuse the snapping logic to find the feature and coordinate\n\t\t\t// that we want to edit. We can drag a arbitrary polygon coordinate point\n\t\t\t// or an arbitrary point on one of its 'lines\n\n\t\t\tconst lineSnapped = this.lineSnapping.getSnappable(event, (feature) =>\n\t\t\t\tthis.polygonFilter(feature),\n\t\t\t);\n\n\t\t\tif (lineSnapped.coordinate) {\n\t\t\t\tthis.editedSnapType = \"line\";\n\t\t\t\tthis.editedFeatureCoordinateIndex = lineSnapped.featureCoordinateIndex;\n\t\t\t\tthis.editedFeatureId = lineSnapped.featureId;\n\t\t\t\tsnappedCoordinate = lineSnapped.coordinate;\n\t\t\t}\n\n\t\t\tconst coordinateSnapped = this.coordinateSnapping.getSnappable(\n\t\t\t\tevent,\n\t\t\t\t(feature) => this.polygonFilter(feature),\n\t\t\t);\n\n\t\t\tif (coordinateSnapped.coordinate) {\n\t\t\t\tthis.editedSnapType = \"coordinate\";\n\t\t\t\tthis.editedFeatureCoordinateIndex =\n\t\t\t\t\tcoordinateSnapped.featureCoordinateIndex;\n\t\t\t\tthis.editedFeatureId = coordinateSnapped.featureId;\n\t\t\t\tsnappedCoordinate = coordinateSnapped.coordinate;\n\t\t\t}\n\t\t}\n\n\t\t// We only need to stop the map dragging if\n\t\t// we actually have something selected\n\t\tif (!this.editedFeatureId || !snappedCoordinate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create a point to drag when editing\n\t\tif (!this.editedPointId) {\n\t\t\tconst [editedPointId] = this.store.create([\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t},\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.EDITED]: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.editedPointId = editedPointId;\n\t\t}\n\n\t\t// Drag Feature\n\t\tthis.setCursor(this.cursors.dragStart);\n\n\t\tsetMapDraggability(false);\n\t}\n\n\t/** @internal */\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDrag, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tthis.editedFeatureId === undefined ||\n\t\t\tthis.editedFeatureCoordinateIndex === undefined\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst featureCopy: Polygon = this.store.getGeometryCopy(\n\t\t\tthis.editedFeatureId,\n\t\t);\n\t\tconst featureCoordinates = featureCopy.coordinates[0];\n\n\t\t// Either it's a coordinate drag or a line drag where the line coordinate has already been inserted\n\t\tif (\n\t\t\tthis.editedSnapType === \"coordinate\" ||\n\t\t\t(this.editedSnapType === \"line\" && this.editedInsertIndex !== undefined)\n\t\t) {\n\t\t\t// Account for the first and last point being the same\n\t\t\tconst isStartingOrEndingCoordinate =\n\t\t\t\tthis.editedFeatureCoordinateIndex === 0 ||\n\t\t\t\tthis.editedFeatureCoordinateIndex ===\n\t\t\t\t\tfeatureCopy.coordinates[0].length - 1;\n\n\t\t\tif (isStartingOrEndingCoordinate) {\n\t\t\t\tfeatureCoordinates[0] = [event.lng, event.lat];\n\t\t\t\tfeatureCoordinates[featureCoordinates.length - 1] = [\n\t\t\t\t\tevent.lng,\n\t\t\t\t\tevent.lat,\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tfeatureCoordinates[this.editedFeatureCoordinateIndex] = [\n\t\t\t\t\tevent.lng,\n\t\t\t\t\tevent.lat,\n\t\t\t\t];\n\t\t\t}\n\t\t} else if (\n\t\t\tthis.editedSnapType === \"line\" &&\n\t\t\tthis.editedInsertIndex === undefined\n\t\t) {\n\t\t\t// Splice inserts _before_ the index, so we need to add 1\n\t\t\tthis.editedInsertIndex = this.editedFeatureCoordinateIndex + 1;\n\n\t\t\t// Insert the new dragged snapped line coordinate\n\t\t\tfeatureCopy.coordinates[0].splice(this.editedInsertIndex, 0, [\n\t\t\t\tevent.lng,\n\t\t\t\tevent.lat,\n\t\t\t]);\n\n\t\t\t// We have inserted a point, need to change the edit index\n\t\t\t// so it can be moved correctly when it gets dragged again\n\t\t\tthis.editedFeatureCoordinateIndex++;\n\t\t}\n\n\t\tconst newPolygonGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: featureCopy.coordinates,\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: newPolygonGeometry,\n\t\t\t\t\tproperties: this.store.getPropertiesCopy(this.editedFeatureId),\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping && this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tgeometry: newPolygonGeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(this.editedFeatureId);\n\t\t}\n\n\t\tif (this.editedPointId) {\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.editedPointId,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t]);\n\t}\n\n\t/** @internal */\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragEnd, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editedFeatureId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setCursor(this.cursors.dragEnd);\n\n\t\tif (this.editedPointId) {\n\t\t\tthis.store.delete([this.editedPointId]);\n\t\t\tthis.editedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: false,\n\t\t\t},\n\t\t]);\n\n\t\tthis.onFinish(this.editedFeatureId, { mode: this.mode, action: \"edit\" });\n\n\t\t// Reset edit state\n\t\tthis.editedFeatureId = undefined;\n\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\tthis.editedInsertIndex = undefined;\n\t\tthis.editedSnapType = undefined;\n\n\t\tsetMapDraggability(true);\n\t}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentId;\n\t\tconst snappedPointId = this.snappedPointId;\n\t\tconst editedPointId = this.editedPointId;\n\n\t\tthis.currentId = undefined;\n\t\tthis.snappedPointId = undefined;\n\t\tthis.editedPointId = undefined;\n\t\tthis.editedFeatureId = undefined;\n\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\tthis.editedInsertIndex = undefined;\n\t\tthis.editedSnapType = undefined;\n\t\tthis.currentCoordinate = 0;\n\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId) {\n\t\t\t\tthis.coordinatePoints.deletePointsByFeatureIds([cleanUpId]);\n\t\t\t}\n\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t\tif (editedPointId !== undefined) {\n\t\t\t\tthis.store.delete([editedPointId]);\n\t\t\t}\n\t\t\tif (snappedPointId !== undefined) {\n\t\t\t\tthis.store.delete([snappedPointId]);\n\t\t\t}\n\t\t\tif (this.closingPoints.ids.length) {\n\t\t\t\tthis.closingPoints.delete();\n\t\t\t}\n\t\t} catch (error) {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (feature.properties.mode === this.mode) {\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.fillColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t\treturn styles;\n\t\t\t} else if (feature.geometry.type === \"Point\") {\n\t\t\t\tconst editedPoint = feature.properties[COMMON_PROPERTIES.EDITED];\n\t\t\t\tconst closingPoint =\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.CLOSING_POINT];\n\t\t\t\tconst snappingPoint =\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.SNAPPING_POINT];\n\t\t\t\tconst coordinatePoint =\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.COORDINATE_POINT];\n\n\t\t\t\tconst pointType = editedPoint\n\t\t\t\t\t? \"editedPoint\"\n\t\t\t\t\t: closingPoint\n\t\t\t\t\t\t? \"closingPoint\"\n\t\t\t\t\t\t: snappingPoint\n\t\t\t\t\t\t\t? \"snappingPoint\"\n\t\t\t\t\t\t\t: coordinatePoint\n\t\t\t\t\t\t\t\t? \"coordinatePoint\"\n\t\t\t\t\t\t\t\t: undefined;\n\n\t\t\t\tif (!pointType) {\n\t\t\t\t\treturn styles;\n\t\t\t\t}\n\n\t\t\t\tconst styleMap = {\n\t\t\t\t\teditedPoint: {\n\t\t\t\t\t\twidth: this.styles.editedPointOutlineWidth,\n\t\t\t\t\t\tcolor: this.styles.editedPointColor,\n\t\t\t\t\t\toutlineColor: this.styles.editedPointOutlineColor,\n\t\t\t\t\t\toutlineWidth: this.styles.editedPointOutlineWidth,\n\t\t\t\t\t},\n\t\t\t\t\tclosingPoint: {\n\t\t\t\t\t\twidth: this.styles.closingPointWidth,\n\t\t\t\t\t\tcolor: this.styles.closingPointColor,\n\t\t\t\t\t\toutlineColor: this.styles.closingPointOutlineColor,\n\t\t\t\t\t\toutlineWidth: this.styles.closingPointOutlineWidth,\n\t\t\t\t\t},\n\t\t\t\t\tsnappingPoint: {\n\t\t\t\t\t\twidth: this.styles.snappingPointWidth,\n\t\t\t\t\t\tcolor: this.styles.snappingPointColor,\n\t\t\t\t\t\toutlineColor: this.styles.snappingPointOutlineColor,\n\t\t\t\t\t\toutlineWidth: this.styles.snappingPointOutlineWidth,\n\t\t\t\t\t},\n\t\t\t\t\tcoordinatePoint: {\n\t\t\t\t\t\twidth: this.styles.coordinatePointWidth,\n\t\t\t\t\t\tcolor: this.styles.coordinatePointColor,\n\t\t\t\t\t\toutlineColor: this.styles.coordinatePointOutlineColor,\n\t\t\t\t\t\toutlineWidth: this.styles.coordinatePointOutlineWidth,\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tstyleMap[pointType].width,\n\t\t\t\t\tstyles.pointWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tstyleMap[pointType].color,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tstyleMap[pointType].outlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tstyleMap[pointType].outlineWidth,\n\t\t\t\t\t2,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tif (editedPoint) {\n\t\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_FOUR;\n\t\t\t\t} else if (coordinatePoint) {\n\t\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_TWO;\n\t\t\t\t} else {\n\t\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_THREE;\n\t\t\t\t}\n\n\t\t\t\treturn styles;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tafterFeatureAdded(feature: GeoJSONStoreFeatures) {\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(feature.id as FeatureId);\n\t\t}\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// Clean up here is important to get right as we need to make a best effort to avoid erroneous\n\t\t// internal state.\n\n\t\t// IF we have coordinate points showing these need to be completely recreated\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(feature.id as FeatureId);\n\t\t}\n\n\t\t// If we are editing a feature by dragging one of its points\n\t\t// we want to clear that state up as new polygon might be completely\n\t\t// different in terms of it's coordinates\n\t\tif (this.editedFeatureId === feature.id && this.editedPointId) {\n\t\t\tthis.store.delete([this.editedPointId]);\n\t\t\tthis.editedPointId = undefined;\n\t\t\tthis.editedFeatureId = undefined;\n\t\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\t\tthis.editedSnapType = undefined;\n\t\t}\n\n\t\t// We can recalculate the snapped point from the last mouse event if there was one\n\t\tif (this.snappedPointId && this.lastMouseMoveEvent) {\n\t\t\tthis.updateSnappedCoordinate(\n\t\t\t\tthis.lastMouseMoveEvent as TerraDrawMouseEvent,\n\t\t\t);\n\t\t}\n\n\t\t// NOTE: This handles the case we are currently drawing a polygon\n\t\t// We need to reset the drawing state because it is very complicated (impossible?)\n\t\t// to recover the drawing state after a feature update\n\t\tif (this.currentId === feature.id) {\n\t\t\tthis.currentCoordinate = 0;\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.closingPoints.delete();\n\n\t\t\t// Go back to started state\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidatePolygonFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n}\n","import { Feature, LineString, Polygon, Position } from \"geojson\";\n\nexport function createPolygon(\n\tcoordinates: Position[][] = [\n\t\t[\n\t\t\t[0, 0],\n\t\t\t[0, 1],\n\t\t\t[1, 1],\n\t\t\t[1, 0],\n\t\t\t[0, 0],\n\t\t],\n\t],\n): Feature<Polygon> {\n\treturn {\n\t\ttype: \"Feature\",\n\t\tgeometry: {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates,\n\t\t},\n\t\tproperties: {},\n\t};\n}\n\nexport function createLineString(coordinates: Position[]): Feature<LineString> {\n\treturn {\n\t\ttype: \"Feature\",\n\t\tgeometry: {\n\t\t\ttype: \"LineString\",\n\t\t\tcoordinates,\n\t\t},\n\t\tproperties: {},\n\t};\n}\n","import { Polygon, Position } from \"geojson\";\nimport {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\n\ntype TerraDrawRectangleModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype RectanglePolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawRectangleModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tkeyEvents?: TerraDrawRectangleModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawRectangleMode extends TerraDrawBaseDrawMode<RectanglePolygonStyling> {\n\tmode = \"rectangle\" as const;\n\tprivate center: Position | undefined;\n\tprivate clickCount = 0;\n\tprivate currentRectangleId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawRectangleModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\n\tconstructor(\n\t\toptions?: TerraDrawRectangleModeOptions<RectanglePolygonStyling>,\n\t) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawRectangleModeOptions<RectanglePolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\t}\n\n\tprivate updateRectangle(event: TerraDrawMouseEvent, updateType: UpdateTypes) {\n\t\tif (this.clickCount === 1 && this.center && this.currentRectangleId) {\n\t\t\tconst geometry = this.store.getGeometryCopy(this.currentRectangleId);\n\n\t\t\tconst firstCoord = (geometry.coordinates as Position[][])[0][0];\n\n\t\t\tconst newGeometry = {\n\t\t\t\ttype: \"Polygon\",\n\t\t\t\tcoordinates: [\n\t\t\t\t\t[\n\t\t\t\t\t\tfirstCoord,\n\t\t\t\t\t\t[event.lng, firstCoord[1]],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t[firstCoord[0], event.lat],\n\t\t\t\t\t\tfirstCoord,\n\t\t\t\t\t],\n\t\t\t\t],\n\t\t\t} as Polygon;\n\n\t\t\tif (this.validate) {\n\t\t\t\tconst validationResult = this.validate(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: this.currentRectangleId,\n\t\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t\t{\n\t\t\t\t\t\tproject: this.project,\n\t\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\t\tupdateType,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!validationResult.valid) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentRectangleId,\n\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tconst finishedId = this.currentRectangleId;\n\n\t\t// Fix right hand rule if necessary\n\t\tif (finishedId) {\n\t\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\t\tthis.store.getGeometryCopy<Polygon>(finishedId),\n\t\t\t);\n\t\t\tif (correctedGeometry) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{ id: finishedId, geometry: correctedGeometry },\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: finishedId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tthis.center = undefined;\n\t\tthis.currentRectangleId = undefined;\n\t\tthis.clickCount = 0;\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tif (finishedId !== undefined) {\n\t\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t\t}\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tif (this.clickCount === 0) {\n\t\t\t\tthis.center = [event.lng, event.lat];\n\t\t\t\tconst [createdId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentRectangleId = createdId;\n\t\t\t\tthis.clickCount++;\n\t\t\t\tthis.setDrawing();\n\t\t\t} else {\n\t\t\t\tthis.updateRectangle(event, UpdateTypes.Finish);\n\t\t\t\t// Finish drawing\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.updateRectangle(event, UpdateTypes.Provisional);\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentRectangleId;\n\n\t\tthis.center = undefined;\n\t\tthis.currentRectangleId = undefined;\n\t\tthis.clickCount = 0;\n\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tif (cleanUpId !== undefined) {\n\t\t\tthis.store.delete([cleanUpId]);\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Polygon\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.fillColor,\n\t\t\t\tstyles.polygonFillColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.outlineColor,\n\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a rectangle and the feature being updated is the current rectangle,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentRectangleId === feature.id) {\n\t\t\tthis.center = undefined;\n\t\t\tthis.currentRectangleId = undefined;\n\t\t\tthis.clickCount = 0;\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {\n\tHexColorStyling,\n\tNumericStyling,\n\tTerraDrawAdapterStyling,\n} from \"../../common\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tModeTypes,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport { GeoJSONStoreFeatures } from \"../../terra-draw\";\nimport { ValidatePointFeature } from \"../../validations/point.validation\";\nimport { ValidatePolygonFeature } from \"../../validations/polygon.validation\";\nimport { ValidateLineStringFeature } from \"../../validations/linestring.validation\";\nimport { StoreValidation } from \"../../store/store\";\n\ntype RenderModeStyling = {\n\tpointColor: HexColorStyling;\n\tpointWidth: NumericStyling;\n\tpointOutlineColor: HexColorStyling;\n\tpointOutlineWidth: NumericStyling;\n\tpolygonFillColor: HexColorStyling;\n\tpolygonFillOpacity: NumericStyling;\n\tpolygonOutlineColor: HexColorStyling;\n\tpolygonOutlineWidth: NumericStyling;\n\tlineStringWidth: NumericStyling;\n\tlineStringColor: HexColorStyling;\n\tzIndex: NumericStyling;\n};\n\ninterface TerraDrawRenderModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tmodeName?: string;\n\t// styles need to be there else we could fall back to BaseModeOptions\n\tstyles: Partial<T>;\n}\n\nexport class TerraDrawRenderMode extends TerraDrawBaseDrawMode<RenderModeStyling> {\n\tpublic type = ModeTypes.Render; // The type of the mode\n\tpublic mode = \"render\"; // This gets changed dynamically\n\n\tconstructor(options: TerraDrawRenderModeOptions<RenderModeStyling>) {\n\t\tif (!options.modeName) {\n\t\t\tthrow new Error(\"Mode name is required for TerraDrawRenderMode\");\n\t\t}\n\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tupdateOptions(\n\t\toptions?: TerraDrawRenderModeOptions<RenderModeStyling> | undefined,\n\t): void {\n\t\tsuper.updateOptions(options);\n\t\tif (options?.modeName) {\n\t\t\tthis.mode = options.modeName;\n\t\t}\n\t}\n\n\t/** @internal */\n\tregisterBehaviors(behaviorConfig: BehaviorConfig) {\n\t\t// TODO: this is probably abusing\n\t\t// registerBehaviors but it works quite well conceptually\n\n\t\t// We can set the mode name dynamically\n\t\tthis.mode = behaviorConfig.mode;\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.setStopped();\n\t}\n\n\t/** @internal */\n\tonKeyUp() {}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonClick() {}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tonMouseMove() {}\n\n\t/** @internal */\n\tcleanUp() {}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst defaultStyles = getDefaultStyling();\n\n\t\treturn {\n\t\t\tpointColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.pointColor,\n\t\t\t\tdefaultStyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpointWidth: this.getNumericStylingValue(\n\t\t\t\tthis.styles.pointWidth,\n\t\t\t\tdefaultStyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpointOutlineColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.pointOutlineColor,\n\t\t\t\tdefaultStyles.pointOutlineColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpointOutlineWidth: this.getNumericStylingValue(\n\t\t\t\tthis.styles.pointOutlineWidth,\n\t\t\t\tdefaultStyles.pointOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpolygonFillColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.polygonFillColor,\n\t\t\t\tdefaultStyles.polygonFillColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpolygonFillOpacity: this.getNumericStylingValue(\n\t\t\t\tthis.styles.polygonFillOpacity,\n\t\t\t\tdefaultStyles.polygonFillOpacity,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpolygonOutlineColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.polygonOutlineColor,\n\t\t\t\tdefaultStyles.polygonOutlineColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpolygonOutlineWidth: this.getNumericStylingValue(\n\t\t\t\tthis.styles.polygonOutlineWidth,\n\t\t\t\tdefaultStyles.polygonOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tlineStringWidth: this.getNumericStylingValue(\n\t\t\t\tthis.styles.lineStringWidth,\n\t\t\t\tdefaultStyles.lineStringWidth,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tlineStringColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.lineStringColor,\n\t\t\t\tdefaultStyles.lineStringColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tzIndex: this.getNumericStylingValue(\n\t\t\t\tthis.styles.zIndex,\n\t\t\t\tdefaultStyles.zIndex,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t};\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\tconst validationResult = super.validateFeature(feature);\n\t\tif (validationResult.valid) {\n\t\t\tconst validatedFeature = feature as GeoJSONStoreFeatures;\n\n\t\t\tconst featureIsValid =\n\t\t\t\tValidatePointFeature(validatedFeature, this.coordinatePrecision)\n\t\t\t\t\t.valid ||\n\t\t\t\tValidatePolygonFeature(validatedFeature, this.coordinatePrecision)\n\t\t\t\t\t.valid ||\n\t\t\t\tValidateLineStringFeature(validatedFeature, this.coordinatePrecision)\n\t\t\t\t\t.valid;\n\n\t\t\tif (featureIsValid) {\n\t\t\t\treturn { valid: true };\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tvalid: featureIsValid,\n\t\t\t\treason: \"Feature is not a valid Point, Polygon or LineString feature\",\n\t\t\t};\n\t\t}\n\n\t\treturn validationResult;\n\t}\n}\n","import { Position } from \"geojson\";\nimport { degreesToRadians, radiansToDegrees } from \"../helpers\";\n\n// Based on Turf.js Rhumb Bearing module which is MIT Licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-rhumb-bearing/index.ts\n\nexport function rhumbBearing(start: Position, end: Position): number {\n\tconst from = start;\n\tconst to = end;\n\n\t// φ => phi\n\t// Δλ => deltaLambda\n\t// Δψ => deltaPsi\n\t// θ => theta\n\tconst phi1 = degreesToRadians(from[1]);\n\tconst phi2 = degreesToRadians(to[1]);\n\tlet deltaLambda = degreesToRadians(to[0] - from[0]);\n\n\t// if deltaLambdaon over 180° take shorter rhumb line across the anti-meridian:\n\tif (deltaLambda > Math.PI) {\n\t\tdeltaLambda -= 2 * Math.PI;\n\t}\n\tif (deltaLambda < -Math.PI) {\n\t\tdeltaLambda += 2 * Math.PI;\n\t}\n\n\tconst deltaPsi = Math.log(\n\t\tMath.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4),\n\t);\n\n\tconst theta = Math.atan2(deltaLambda, deltaPsi);\n\n\tconst bear360 = (radiansToDegrees(theta) + 360) % 360;\n\n\tconst bear180 = bear360 > 180 ? -(360 - bear360) : bear360;\n\n\treturn bear180;\n}\n","import { Position } from \"geojson\";\nimport { degreesToRadians, earthRadius } from \"../helpers\";\n\n// Based on @turf/rhumb-destination module which is MIT Licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-rhumb-destination/index.ts\n\nexport function rhumbDestination(\n\torigin: Position,\n\tdistanceMeters: number,\n\tbearing: number,\n): Position {\n\tconst wasNegativeDistance = distanceMeters < 0;\n\tlet distanceInMeters = distanceMeters;\n\n\tif (wasNegativeDistance) {\n\t\tdistanceInMeters = -Math.abs(distanceInMeters);\n\t}\n\n\tconst delta = distanceInMeters / earthRadius; // angular distance in radians\n\tconst lambda1 = (origin[0] * Math.PI) / 180; // to radians, but without normalize to 𝜋\n\tconst phi1 = degreesToRadians(origin[1]);\n\tconst theta = degreesToRadians(bearing);\n\n\tconst DeltaPhi = delta * Math.cos(theta);\n\tlet phi2 = phi1 + DeltaPhi;\n\n\t// check for going past the pole, normalise latitude if so\n\tif (Math.abs(phi2) > Math.PI / 2) {\n\t\tphi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;\n\t}\n\n\tconst DeltaPsi = Math.log(\n\t\tMath.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4),\n\t);\n\t// E-W course becomes ill-conditioned with 0/0\n\tconst q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n\n\tconst DeltaLambda = (delta * Math.sin(theta)) / q;\n\tconst lambda2 = lambda1 + DeltaLambda;\n\n\t// normalise to −180..+180°\n\tconst destination = [\n\t\t(((lambda2 * 180) / Math.PI + 540) % 360) - 180,\n\t\t(phi2 * 180) / Math.PI,\n\t];\n\n\t// compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n\t// solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n\tdestination[0] +=\n\t\tdestination[0] - origin[0] > 180\n\t\t\t? -360\n\t\t\t: origin[0] - destination[0] > 180\n\t\t\t\t? 360\n\t\t\t\t: 0;\n\treturn destination;\n}\n","import { Position } from \"geojson\";\nimport { limitPrecision } from \"./limit-decimal-precision\";\nimport { Project, Unproject } from \"../common\";\nimport { haversineDistanceKilometers } from \"./measure/haversine-distance\";\nimport { rhumbBearing } from \"./measure/rhumb-bearing\";\nimport { rhumbDestination } from \"./measure/rhumb-destination\";\n\n// midpointCoordinate is adapted from the @turf/midpoint which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-midpoint\n\nexport function midpointCoordinate(\n\tcoordinates1: Position,\n\tcoordinates2: Position,\n\tprecision: number,\n\tproject: Project,\n\tunproject: Unproject,\n) {\n\tconst projectedCoordinateOne = project(coordinates1[0], coordinates1[1]);\n\tconst projectedCoordinateTwo = project(coordinates2[0], coordinates2[1]);\n\n\tconst { lng, lat } = unproject(\n\t\t(projectedCoordinateOne.x + projectedCoordinateTwo.x) / 2,\n\t\t(projectedCoordinateOne.y + projectedCoordinateTwo.y) / 2,\n\t);\n\n\treturn [limitPrecision(lng, precision), limitPrecision(lat, precision)];\n}\n\n/* Get the geodesic midpoint coordinate between two coordinates */\nexport function geodesicMidpointCoordinate(\n\tcoordinates1: Position,\n\tcoordinates2: Position,\n\tprecision: number,\n) {\n\tconst dist = haversineDistanceKilometers(coordinates1, coordinates2) * 1000;\n\tconst heading = rhumbBearing(coordinates1, coordinates2);\n\tconst midpoint = rhumbDestination(coordinates1, dist / 2, heading);\n\treturn [\n\t\tlimitPrecision(midpoint[0], precision),\n\t\tlimitPrecision(midpoint[1], precision),\n\t];\n}\n","import { Point, Position } from \"geojson\";\nimport { Project, Projection, Unproject } from \"../common\";\nimport { JSONObject } from \"../store/store\";\nimport {\n\tmidpointCoordinate,\n\tgeodesicMidpointCoordinate,\n} from \"./midpoint-coordinate\";\n\nexport function getMidPointCoordinates({\n\tfeatureCoords,\n\tprecision,\n\tunproject,\n\tproject,\n\tprojection,\n}: {\n\tfeatureCoords: Position[];\n\tprecision: number;\n\tproject: Project;\n\tunproject: Unproject;\n\tprojection: Projection;\n}) {\n\tconst midPointCoords: Position[] = [];\n\tfor (let i = 0; i < featureCoords.length - 1; i++) {\n\t\tlet mid;\n\t\tif (projection === \"web-mercator\") {\n\t\t\tmid = midpointCoordinate(\n\t\t\t\tfeatureCoords[i],\n\t\t\t\tfeatureCoords[i + 1],\n\t\t\t\tprecision,\n\t\t\t\tproject,\n\t\t\t\tunproject,\n\t\t\t);\n\t\t} else if (projection === \"globe\") {\n\t\t\tmid = geodesicMidpointCoordinate(\n\t\t\t\tfeatureCoords[i],\n\t\t\t\tfeatureCoords[i + 1],\n\t\t\t\tprecision,\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid projection\");\n\t\t}\n\n\t\tmidPointCoords.push(mid);\n\t}\n\treturn midPointCoords;\n}\n\nexport function getMidPoints(\n\tselectedCoords: Position[],\n\tproperties: (index: number) => JSONObject,\n\tprecision: number,\n\tproject: Project,\n\tunproject: Unproject,\n\tprojection: Projection,\n) {\n\treturn getMidPointCoordinates({\n\t\tfeatureCoords: selectedCoords,\n\t\tprecision,\n\t\tproject,\n\t\tunproject,\n\t\tprojection,\n\t}).map((coord, i) => ({\n\t\tgeometry: { type: \"Point\", coordinates: coord } as Point,\n\t\tproperties: properties(i),\n\t}));\n}\n","import { LineString, Point, Polygon, Position } from \"geojson\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport {\n\tgetMidPointCoordinates,\n\tgetMidPoints,\n} from \"../../../geometry/get-midpoints\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport {\n\tCOMMON_PROPERTIES,\n\tProjection,\n\tSELECT_PROPERTIES,\n} from \"../../../common\";\nimport { FeatureId } from \"../../../store/store\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\n\nexport class MidPointBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly selectionPointBehavior: SelectionPointBehavior,\n\t\tprivate readonly coordinatePointBehavior: CoordinatePointBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate _midPoints: string[] = [];\n\n\tget ids() {\n\t\treturn this._midPoints.concat();\n\t}\n\n\tset ids(_: string[]) {}\n\n\tpublic insert(\n\t\tfeatureId: FeatureId,\n\t\tmidPointId: FeatureId,\n\t\tcoordinatePrecision: number,\n\t) {\n\t\tconst midPoint = this.store.getGeometryCopy(midPointId);\n\t\tconst { midPointFeatureId, midPointSegment } =\n\t\t\tthis.store.getPropertiesCopy(midPointId);\n\t\tconst geometry = this.store.getGeometryCopy<Polygon | LineString>(\n\t\t\tmidPointFeatureId as FeatureId,\n\t\t);\n\n\t\t// Update the coordinates to include inserted midpoint\n\t\tconst updatedCoordinates =\n\t\t\tgeometry.type === \"Polygon\"\n\t\t\t\t? geometry.coordinates[0]\n\t\t\t\t: geometry.coordinates;\n\n\t\tupdatedCoordinates.splice(\n\t\t\t(midPointSegment as number) + 1,\n\t\t\t0,\n\t\t\tmidPoint.coordinates as Position,\n\t\t);\n\n\t\t// Update geometry coordinates depending\n\t\t// on if a polygon or linestring\n\t\tgeometry.coordinates =\n\t\t\tgeometry.type === \"Polygon\" ? [updatedCoordinates] : updatedCoordinates;\n\n\t\t// Update the selected features geometry to insert\n\t\t// the new midpoint\n\t\tthis.store.updateGeometry([{ id: midPointFeatureId as string, geometry }]);\n\n\t\t// We need to update the coordinate points to reflect the new midpoint\n\t\tconst featureProperties = this.store.getPropertiesCopy(featureId as string);\n\n\t\tif (featureProperties[COMMON_PROPERTIES.COORDINATE_POINT_IDS]) {\n\t\t\tthis.coordinatePointBehavior.createOrUpdate(featureId);\n\t\t}\n\n\t\t// TODO: is there a way of just updating the selection points rather\n\t\t// than fully deleting / recreating?\n\t\t// Recreate the selection points\n\n\t\tthis.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]);\n\n\t\t// We don't need to check if flags are correct\n\t\t// because selection points are prerequisite for midpoints\n\t\tthis.create(\n\t\t\tupdatedCoordinates,\n\t\t\tmidPointFeatureId as string,\n\t\t\tcoordinatePrecision,\n\t\t);\n\t\tthis.selectionPointBehavior.create(\n\t\t\tupdatedCoordinates,\n\t\t\tgeometry.type,\n\t\t\tmidPointFeatureId as string,\n\t\t);\n\t}\n\n\tpublic create(\n\t\tselectedCoords: Position[],\n\t\tfeatureId: FeatureId,\n\t\tcoordinatePrecision: number,\n\t) {\n\t\tif (!this.store.has(featureId)) {\n\t\t\tthrow new Error(\"Store does not have feature with this id\");\n\t\t}\n\n\t\tthis._midPoints = this.store.create(\n\t\t\tgetMidPoints(\n\t\t\t\tselectedCoords,\n\t\t\t\t(i) => ({\n\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t[SELECT_PROPERTIES.MID_POINT]: true,\n\t\t\t\t\tmidPointSegment: i,\n\t\t\t\t\tmidPointFeatureId: featureId,\n\t\t\t\t}),\n\t\t\t\tcoordinatePrecision,\n\t\t\t\tthis.config.project,\n\t\t\t\tthis.config.unproject,\n\t\t\t\tthis.projection,\n\t\t\t),\n\t\t);\n\t}\n\n\tpublic delete() {\n\t\tif (this._midPoints.length) {\n\t\t\tthis.store.delete(this._midPoints);\n\t\t\tthis._midPoints = [];\n\t\t}\n\t}\n\n\tpublic getUpdated(updatedCoordinates: Position[]) {\n\t\tif (this._midPoints.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn getMidPointCoordinates({\n\t\t\tfeatureCoords: updatedCoordinates,\n\t\t\tprecision: this.coordinatePrecision,\n\t\t\tproject: this.config.project,\n\t\t\tunproject: this.config.unproject,\n\t\t\tprojection: this.config.projection as Projection,\n\t\t}).map((updatedMidPointCoord, i) => ({\n\t\t\tid: this._midPoints[i] as string,\n\t\t\tgeometry: {\n\t\t\t\ttype: \"Point\",\n\t\t\t\tcoordinates: updatedMidPointCoord,\n\t\t\t} as Point,\n\t\t}));\n\t}\n}\n","import { LineString, Point, Polygon, Position } from \"geojson\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { getCoordinatesAsPoints } from \"../../../geometry/get-coordinates-as-points\";\nimport { FeatureId } from \"../../../store/store\";\nimport { SELECT_PROPERTIES } from \"../../../common\";\n\nexport type SelectionPointProperties = {\n\tmode: string;\n\tindex: number;\n\t[SELECT_PROPERTIES.SELECTION_POINT_FEATURE_ID]: string;\n\t[SELECT_PROPERTIES.SELECTION_POINT]: true;\n};\n\nexport class SelectionPointBehavior extends TerraDrawModeBehavior {\n\tconstructor(config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\n\tprivate _selectionPoints: FeatureId[] = [];\n\n\tget ids() {\n\t\treturn this._selectionPoints.concat();\n\t}\n\n\tset ids(_: FeatureId[]) {}\n\n\tpublic create(\n\t\tselectedCoords: Position[],\n\t\ttype: Polygon[\"type\"] | LineString[\"type\"],\n\t\tfeatureId: FeatureId,\n\t) {\n\t\tthis._selectionPoints = this.store.create(\n\t\t\tgetCoordinatesAsPoints(selectedCoords, type, (i) => ({\n\t\t\t\tmode: this.mode,\n\t\t\t\tindex: i,\n\t\t\t\t[SELECT_PROPERTIES.SELECTION_POINT]: true,\n\t\t\t\t[SELECT_PROPERTIES.SELECTION_POINT_FEATURE_ID]: featureId,\n\t\t\t})),\n\t\t);\n\t}\n\n\tpublic delete() {\n\t\tif (this.ids.length) {\n\t\t\tthis.store.delete(this.ids);\n\t\t\tthis._selectionPoints = [];\n\t\t}\n\t}\n\n\tpublic getUpdated(updatedCoordinates: Position[]) {\n\t\tif (this._selectionPoints.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._selectionPoints.map((id, i) => {\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: updatedCoordinates[i],\n\t\t\t\t} as Point,\n\t\t\t};\n\t\t});\n\t}\n\n\tpublic getOneUpdated(index: number, updatedCoordinate: Position) {\n\t\tif (this._selectionPoints[index] === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tid: this._selectionPoints[index] as string,\n\t\t\tgeometry: {\n\t\t\t\ttype: \"Point\",\n\t\t\t\tcoordinates: updatedCoordinate,\n\t\t\t} as Point,\n\t\t};\n\t}\n}\n","import { Point, Position } from \"geojson\";\nimport { JSONObject } from \"../store/store\";\n\nexport function getCoordinatesAsPoints<Properties extends JSONObject>(\n\tselectedCoords: Position[],\n\tgeometryType: \"Polygon\" | \"LineString\",\n\tproperties: (index: number) => Properties,\n) {\n\tconst selectionPoints = [];\n\n\t// We can skip the last point for polygons\n\t// as it's a duplicate of the first\n\tconst length =\n\t\tgeometryType === \"Polygon\"\n\t\t\t? selectedCoords.length - 1\n\t\t\t: selectedCoords.length;\n\n\tfor (let i = 0; i < length; i++) {\n\t\tselectionPoints.push({\n\t\t\tgeometry: {\n\t\t\t\ttype: \"Point\",\n\t\t\t\tcoordinates: selectedCoords[i],\n\t\t\t} as Point,\n\t\t\tproperties: properties(i),\n\t\t});\n\t}\n\n\treturn selectionPoints;\n}\n","import { Position } from \"geojson\";\n\n// Based on which-polygon (Mapbox)\n// https://github.com/mapbox/which-polygon/blob/2eb5b8a427d018ebd964c05acd3b9166c4558b2c/index.js#L81\n// ISC License - Copyright (c) 2017, Mapbox\n\nexport function pointInPolygon(point: Position, rings: Position[][]) {\n\tlet inside = false;\n\tfor (let i = 0, len = rings.length; i < len; i++) {\n\t\tconst ring = rings[i];\n\t\tfor (let j = 0, len2 = ring.length, k = len2 - 1; j < len2; k = j++) {\n\t\t\tif (rayIntersect(point, ring[j], ring[k])) {\n\t\t\t\tinside = !inside;\n\t\t\t}\n\t\t}\n\t}\n\treturn inside;\n}\n\nfunction rayIntersect(p: Position, p1: Position, p2: Position) {\n\treturn (\n\t\tp1[1] > p[1] !== p2[1] > p[1] &&\n\t\tp[0] < ((p2[0] - p1[0]) * (p[1] - p1[1])) / (p2[1] - p1[1]) + p1[0]\n\t);\n}\n","import { CartesianPoint } from \"../../common\";\n\nexport const pixelDistanceToLine = (\n\tpoint: CartesianPoint,\n\tlinePointOne: CartesianPoint,\n\tlinePointTwo: CartesianPoint,\n) => {\n\tconst square = (x: number) => {\n\t\treturn x * x;\n\t};\n\tconst dist2 = (v: CartesianPoint, w: CartesianPoint) => {\n\t\treturn square(v.x - w.x) + square(v.y - w.y);\n\t};\n\tconst distToSegmentSquared = (\n\t\tp: CartesianPoint,\n\t\tv: CartesianPoint,\n\t\tw: CartesianPoint,\n\t) => {\n\t\tconst l2 = dist2(v, w);\n\n\t\tif (l2 === 0) {\n\t\t\treturn dist2(p, v);\n\t\t}\n\n\t\tlet t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n\t\tt = Math.max(0, Math.min(1, t));\n\n\t\treturn dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });\n\t};\n\n\treturn Math.sqrt(distToSegmentSquared(point, linePointOne, linePointTwo));\n};\n","import { SELECT_PROPERTIES, TerraDrawMouseEvent } from \"../../../common\";\nimport { BBoxPolygon, GeoJSONStoreFeatures } from \"../../../store/store\";\n\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../../click-bounding-box.behavior\";\n\nimport { pointInPolygon } from \"../../../geometry/boolean/point-in-polygon\";\nimport { PixelDistanceBehavior } from \"../../pixel-distance.behavior\";\nimport { pixelDistanceToLine } from \"../../../geometry/measure/pixel-distance-to-line\";\n\nexport class FeatureAtPointerEventBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly createClickBoundingBox: ClickBoundingBoxBehavior,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tpublic find(event: TerraDrawMouseEvent, hasSelection: boolean) {\n\t\tlet clickedPoint: GeoJSONStoreFeatures | undefined = undefined;\n\t\tlet clickedPointDistance = Infinity;\n\t\tlet clickedLineString: GeoJSONStoreFeatures | undefined = undefined;\n\t\tlet clickedLineStringDistance = Infinity;\n\t\tlet clickedMidPoint: GeoJSONStoreFeatures | undefined = undefined;\n\t\tlet clickedMidPointDistance = Infinity;\n\t\tlet clickedPolygon: GeoJSONStoreFeatures | undefined = undefined;\n\n\t\tconst bbox = this.createClickBoundingBox.create(event);\n\t\tconst features = this.store.search(bbox as BBoxPolygon);\n\n\t\tfor (let i = 0; i < features.length; i++) {\n\t\t\tconst feature = features[i];\n\t\t\tconst geometry = feature.geometry;\n\n\t\t\tif (geometry.type === \"Point\") {\n\t\t\t\t// Ignore selection points always, and ignore mid points\n\t\t\t\t// when nothing is selected\n\t\t\t\tconst isSelectionPoint = feature.properties.selectionPoint;\n\t\t\t\tconst isCoordinatePoint = feature.properties.coordinatePoint;\n\t\t\t\tconst isNonSelectedMidPoint =\n\t\t\t\t\t!hasSelection && feature.properties[SELECT_PROPERTIES.MID_POINT];\n\n\t\t\t\tif (isSelectionPoint || isCoordinatePoint || isNonSelectedMidPoint) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst distance = this.pixelDistance.measure(\n\t\t\t\t\tevent,\n\t\t\t\t\tgeometry.coordinates,\n\t\t\t\t);\n\n\t\t\t\t// We want to catch both clicked\n\t\t\t\t// features but also any midpoints\n\t\t\t\t// in the clicked area\n\t\t\t\tif (\n\t\t\t\t\tfeature.properties[SELECT_PROPERTIES.MID_POINT] &&\n\t\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\t\tdistance < clickedMidPointDistance\n\t\t\t\t) {\n\t\t\t\t\tclickedMidPointDistance = distance;\n\t\t\t\t\tclickedMidPoint = feature;\n\t\t\t\t} else if (\n\t\t\t\t\t!feature.properties[SELECT_PROPERTIES.MID_POINT] &&\n\t\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\t\tdistance < clickedPointDistance\n\t\t\t\t) {\n\t\t\t\t\tclickedPointDistance = distance;\n\t\t\t\t\tclickedPoint = feature;\n\t\t\t\t}\n\t\t\t} else if (geometry.type === \"LineString\") {\n\t\t\t\tif (clickedPoint) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < geometry.coordinates.length - 1; i++) {\n\t\t\t\t\tconst coord = geometry.coordinates[i];\n\t\t\t\t\tconst nextCoord = geometry.coordinates[i + 1];\n\t\t\t\t\tconst distanceToLine = pixelDistanceToLine(\n\t\t\t\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t\t\t\t\tthis.project(coord[0], coord[1]),\n\t\t\t\t\t\tthis.project(nextCoord[0], nextCoord[1]),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tdistanceToLine < this.pointerDistance &&\n\t\t\t\t\t\tdistanceToLine < clickedLineStringDistance\n\t\t\t\t\t) {\n\t\t\t\t\t\tclickedLineStringDistance = distanceToLine;\n\t\t\t\t\t\tclickedLineString = feature;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (geometry.type === \"Polygon\") {\n\t\t\t\tif (clickedPoint || clickedLineString) {\n\t\t\t\t\t// We already have a clicked feature\n\t\t\t\t\t// so we can ignore the polygon\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst clickInsidePolygon = pointInPolygon(\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tgeometry.coordinates,\n\t\t\t\t);\n\n\t\t\t\tif (clickInsidePolygon) {\n\t\t\t\t\tclickedPolygon = feature;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tclickedFeature: clickedPoint || clickedLineString || clickedPolygon,\n\t\t\tclickedMidPoint,\n\t\t};\n\t}\n}\n","import { TerraDrawMouseEvent, UpdateTypes, Validation } from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { FeatureAtPointerEventBehavior } from \"./feature-at-pointer-event.behavior\";\nimport { Position } from \"geojson\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport { MidPointBehavior } from \"./midpoint.behavior\";\nimport { limitPrecision } from \"../../../geometry/limit-decimal-precision\";\nimport { FeatureId } from \"../../../store/store\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../../geometry/project/web-mercator\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\n\nexport class DragFeatureBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly featuresAtCursorEvent: FeatureAtPointerEventBehavior,\n\t\tprivate readonly selectionPoints: SelectionPointBehavior,\n\t\tprivate readonly midPoints: MidPointBehavior,\n\t\tprivate readonly coordinatePoints: CoordinatePointBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate draggedFeatureId: FeatureId | null = null;\n\n\tprivate dragPosition: Position | undefined;\n\n\tstartDragging(event: TerraDrawMouseEvent, id: FeatureId) {\n\t\tthis.draggedFeatureId = id;\n\t\tthis.dragPosition = [event.lng, event.lat];\n\t}\n\n\tstopDragging() {\n\t\tthis.draggedFeatureId = null;\n\t\tthis.dragPosition = undefined;\n\t}\n\n\tisDragging() {\n\t\treturn this.draggedFeatureId !== null;\n\t}\n\n\tcanDrag(event: TerraDrawMouseEvent, selectedId: FeatureId) {\n\t\tconst { clickedFeature } = this.featuresAtCursorEvent.find(event, true);\n\n\t\t// If the cursor is not over the selected\n\t\t// feature then we don't want to drag\n\t\tif (!clickedFeature || clickedFeature.id !== selectedId) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tdrag(event: TerraDrawMouseEvent, validateFeature?: Validation) {\n\t\tif (!this.draggedFeatureId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(this.draggedFeatureId);\n\t\tconst cursorCoord = [event.lng, event.lat];\n\n\t\t// Update the geometry of the dragged feature\n\t\tif (geometry.type === \"Polygon\" || geometry.type === \"LineString\") {\n\t\t\tlet updatedCoords: Position[];\n\t\t\tlet upToCoord: number;\n\n\t\t\tif (geometry.type === \"Polygon\") {\n\t\t\t\tupdatedCoords = geometry.coordinates[0];\n\t\t\t\tupToCoord = updatedCoords.length - 1;\n\t\t\t} else {\n\t\t\t\t// Must be LineString here\n\t\t\t\tupdatedCoords = geometry.coordinates;\n\t\t\t\tupToCoord = updatedCoords.length;\n\t\t\t}\n\n\t\t\tif (!this.dragPosition) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < upToCoord; i++) {\n\t\t\t\tconst coordinate = updatedCoords[i];\n\n\t\t\t\tlet updatedLng: number;\n\t\t\t\tlet updatedLat: number;\n\n\t\t\t\tif (this.config.projection === \"web-mercator\") {\n\t\t\t\t\tconst webMercatorDragPosition = lngLatToWebMercatorXY(\n\t\t\t\t\t\tthis.dragPosition[0],\n\t\t\t\t\t\tthis.dragPosition[1],\n\t\t\t\t\t);\n\t\t\t\t\tconst webMercatorCursorCoord = lngLatToWebMercatorXY(\n\t\t\t\t\t\tcursorCoord[0],\n\t\t\t\t\t\tcursorCoord[1],\n\t\t\t\t\t);\n\t\t\t\t\tconst webMercatorCoordinate = lngLatToWebMercatorXY(\n\t\t\t\t\t\tcoordinate[0],\n\t\t\t\t\t\tcoordinate[1],\n\t\t\t\t\t);\n\n\t\t\t\t\tconst delta = {\n\t\t\t\t\t\tx: webMercatorDragPosition.x - webMercatorCursorCoord.x,\n\t\t\t\t\t\ty: webMercatorDragPosition.y - webMercatorCursorCoord.y,\n\t\t\t\t\t};\n\n\t\t\t\t\tconst updatedX = webMercatorCoordinate.x - delta.x;\n\t\t\t\t\tconst updatedY = webMercatorCoordinate.y - delta.y;\n\n\t\t\t\t\tconst { lng, lat } = webMercatorXYToLngLat(updatedX, updatedY);\n\n\t\t\t\t\tupdatedLng = lng;\n\t\t\t\t\tupdatedLat = lat;\n\t\t\t\t} else {\n\t\t\t\t\tconst delta = [\n\t\t\t\t\t\tthis.dragPosition[0] - cursorCoord[0],\n\t\t\t\t\t\tthis.dragPosition[1] - cursorCoord[1],\n\t\t\t\t\t];\n\t\t\t\t\tupdatedLng = coordinate[0] - delta[0];\n\t\t\t\t\tupdatedLat = coordinate[1] - delta[1];\n\t\t\t\t}\n\n\t\t\t\t// Keep precision limited when calculating new coordinates\n\t\t\t\tupdatedLng = limitPrecision(\n\t\t\t\t\tupdatedLng,\n\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t);\n\n\t\t\t\tupdatedLat = limitPrecision(\n\t\t\t\t\tupdatedLat,\n\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t);\n\n\t\t\t\t// Ensure that coordinates do not exceed\n\t\t\t\t// lng lat limits. Long term we may want to figure out\n\t\t\t\t// proper handling of anti meridian crossings\n\t\t\t\tif (\n\t\t\t\t\tupdatedLng > 180 ||\n\t\t\t\t\tupdatedLng < -180 ||\n\t\t\t\t\tupdatedLat > 90 ||\n\t\t\t\t\tupdatedLat < -90\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tupdatedCoords[i] = [updatedLng, updatedLat];\n\t\t\t}\n\n\t\t\t// Set final coordinate identical to first\n\t\t\t// We only want to do this for polygons!\n\t\t\tif (geometry.type === \"Polygon\") {\n\t\t\t\tupdatedCoords[updatedCoords.length - 1] = [\n\t\t\t\t\tupdatedCoords[0][0],\n\t\t\t\t\tupdatedCoords[0][1],\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tconst updatedSelectionPoints =\n\t\t\t\tthis.selectionPoints.getUpdated(updatedCoords) || [];\n\n\t\t\tconst updatedMidPoints = this.midPoints.getUpdated(updatedCoords) || [];\n\n\t\t\tconst updatedCoordinatePoints =\n\t\t\t\tthis.coordinatePoints.getUpdated(\n\t\t\t\t\tthis.draggedFeatureId,\n\t\t\t\t\tupdatedCoords,\n\t\t\t\t) || [];\n\n\t\t\tif (validateFeature) {\n\t\t\t\tconst validationResult = validateFeature(\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\t\tid: this.draggedFeatureId,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tproperties: {},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tproject: this.config.project,\n\t\t\t\t\t\tunproject: this.config.unproject,\n\t\t\t\t\t\tcoordinatePrecision: this.config.coordinatePrecision,\n\t\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!validationResult.valid) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Issue the update to the selected feature\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{ id: this.draggedFeatureId, geometry },\n\t\t\t\t...updatedSelectionPoints,\n\t\t\t\t...updatedMidPoints,\n\t\t\t\t...updatedCoordinatePoints,\n\t\t\t]);\n\n\t\t\tthis.dragPosition = [event.lng, event.lat];\n\n\t\t\t// Update mid point positions\n\t\t} else if (geometry.type === \"Point\") {\n\t\t\t// For cursor points we can simply move it\n\t\t\t// to the dragged position\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.draggedFeatureId,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: cursorCoord,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.dragPosition = [event.lng, event.lat];\n\t\t}\n\t}\n}\n","import {\n\tSnapping,\n\tTerraDrawMouseEvent,\n\tUpdateTypes,\n\tValidation,\n} from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\n\nimport { LineString, Polygon, Position, Point, Feature } from \"geojson\";\nimport { PixelDistanceBehavior } from \"../../pixel-distance.behavior\";\nimport { MidPointBehavior } from \"./midpoint.behavior\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport { selfIntersects } from \"../../../geometry/boolean/self-intersects\";\nimport { FeatureId, GeoJSONStoreFeatures } from \"../../../store/store\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\nimport { CoordinateSnappingBehavior } from \"../../coordinate-snapping.behavior\";\nimport { LineSnappingBehavior } from \"../../line-snapping.behavior\";\n\nexport class DragCoordinateBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t\tprivate readonly selectionPoints: SelectionPointBehavior,\n\t\tprivate readonly midPoints: MidPointBehavior,\n\t\tprivate readonly coordinatePoints: CoordinatePointBehavior,\n\t\tprivate readonly coordinateSnapping: CoordinateSnappingBehavior,\n\t\tprivate readonly lineSnapping: LineSnappingBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate draggedCoordinate: { id: null | FeatureId; index: number } = {\n\t\tid: null,\n\t\tindex: -1,\n\t};\n\n\tprivate getClosestCoordinate(\n\t\tevent: TerraDrawMouseEvent,\n\t\tgeometry: Polygon | LineString | Point,\n\t) {\n\t\tconst closestCoordinate = {\n\t\t\tdist: Infinity,\n\t\t\tindex: -1,\n\t\t\tisFirstOrLastPolygonCoord: false,\n\t\t};\n\n\t\tlet geomCoordinates: Position[] | undefined;\n\n\t\tif (geometry.type === \"LineString\") {\n\t\t\tgeomCoordinates = geometry.coordinates;\n\t\t} else if (geometry.type === \"Polygon\") {\n\t\t\tgeomCoordinates = geometry.coordinates[0];\n\t\t} else {\n\t\t\t// We don't want to handle dragging\n\t\t\t// points here\n\t\t\treturn closestCoordinate;\n\t\t}\n\n\t\t// Look through the selected features coordinates\n\t\t// and try to find a coordinate that is draggable\n\t\tfor (let i = 0; i < geomCoordinates.length; i++) {\n\t\t\tconst coord = geomCoordinates[i];\n\t\t\tconst distance = this.pixelDistance.measure(event, coord);\n\n\t\t\tif (\n\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\tdistance < closestCoordinate.dist\n\t\t\t) {\n\t\t\t\t// We don't create a point for the final\n\t\t\t\t// polygon coord, so we must set it to the first\n\t\t\t\t// coordinate instead\n\t\t\t\tconst isFirstOrLastPolygonCoord =\n\t\t\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t\t\t(i === geomCoordinates.length - 1 || i === 0);\n\n\t\t\t\tclosestCoordinate.dist = distance;\n\t\t\t\tclosestCoordinate.index = isFirstOrLastPolygonCoord ? 0 : i;\n\t\t\t\tclosestCoordinate.isFirstOrLastPolygonCoord = isFirstOrLastPolygonCoord;\n\t\t\t}\n\t\t}\n\n\t\treturn closestCoordinate;\n\t}\n\n\tpublic getDraggableIndex(\n\t\tevent: TerraDrawMouseEvent,\n\t\tselectedId: FeatureId,\n\t): number {\n\t\tconst geometry = this.store.getGeometryCopy(selectedId);\n\t\tconst closestCoordinate = this.getClosestCoordinate(event, geometry);\n\n\t\t// No coordinate was within the pointer distance\n\t\tif (closestCoordinate.index === -1) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn closestCoordinate.index;\n\t}\n\n\tprivate snapCoordinate(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsnapping: Snapping,\n\t\tdraggedFeature: GeoJSONStoreFeatures,\n\t): Position {\n\t\tlet snappedCoordinate: Position = [event.lng, event.lat];\n\n\t\t// This is a uniform filter we can use across all snapping behaviors\n\t\tconst filter = (feature: Feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties &&\n\t\t\t\t\tfeature.properties.mode === draggedFeature.properties.mode &&\n\t\t\t\t\tfeature.id !== this.draggedCoordinate.id,\n\t\t\t);\n\t\t};\n\n\t\tif (snapping?.toLine) {\n\t\t\tlet snapped: Position | undefined;\n\n\t\t\tsnapped = this.lineSnapping.getSnappable(event, filter).coordinate;\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (snapping.toCoordinate) {\n\t\t\tlet snapped: Position | undefined = undefined;\n\n\t\t\tsnapped = this.coordinateSnapping.getSnappable(event, filter).coordinate;\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (snapping?.toCustom) {\n\t\t\tlet snapped: Position | undefined = undefined;\n\n\t\t\tsnapped = snapping.toCustom(event, {\n\t\t\t\tcurrentCoordinate: this.draggedCoordinate.index,\n\t\t\t\tcurrentId: draggedFeature.id,\n\t\t\t\tgetCurrentGeometrySnapshot: draggedFeature.id\n\t\t\t\t\t? () =>\n\t\t\t\t\t\t\tthis.store.getGeometryCopy<Polygon>(\n\t\t\t\t\t\t\t\tdraggedFeature.id as FeatureId,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t: () => null,\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t});\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\treturn snappedCoordinate;\n\t}\n\n\tdrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tallowSelfIntersection: boolean,\n\t\tvalidateFeature: Validation,\n\t\tsnapping: Snapping,\n\t): boolean {\n\t\tconst draggedFeatureId = this.draggedCoordinate.id;\n\n\t\tif (draggedFeatureId === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst index = this.draggedCoordinate.index;\n\t\tconst geometry = this.store.getGeometryCopy(draggedFeatureId);\n\t\tconst properties = this.store.getPropertiesCopy(draggedFeatureId);\n\n\t\tconst geomCoordinates = (\n\t\t\tgeometry.type === \"LineString\"\n\t\t\t\t? geometry.coordinates\n\t\t\t\t: geometry.coordinates[0]\n\t\t) as Position[];\n\n\t\tconst isFirstOrLastPolygonCoord =\n\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t(index === geomCoordinates.length - 1 || index === 0);\n\n\t\tconst draggedFeature: GeoJSONStoreFeatures = {\n\t\t\ttype: \"Feature\",\n\t\t\tid: draggedFeatureId,\n\t\t\tgeometry,\n\t\t\tproperties,\n\t\t};\n\n\t\tconst updatedCoordinate = this.snapCoordinate(\n\t\t\tevent,\n\t\t\tsnapping,\n\t\t\tdraggedFeature,\n\t\t);\n\n\t\t// Ensure that coordinates do not exceed\n\t\t// lng lat limits. Long term we may want to figure out\n\t\t// proper handling of anti meridian crossings\n\t\tif (\n\t\t\tevent.lng > 180 ||\n\t\t\tevent.lng < -180 ||\n\t\t\tevent.lat > 90 ||\n\t\t\tevent.lat < -90\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We want to update the actual Polygon/LineString itself -\n\t\t// for Polygons we want the first and last coordinates to match\n\t\tif (isFirstOrLastPolygonCoord) {\n\t\t\tconst lastCoordIndex = geomCoordinates.length - 1;\n\t\t\tgeomCoordinates[0] = updatedCoordinate;\n\t\t\tgeomCoordinates[lastCoordIndex] = updatedCoordinate;\n\t\t} else {\n\t\t\tgeomCoordinates[index] = updatedCoordinate;\n\t\t}\n\n\t\tconst updatedSelectionPoint = this.selectionPoints.getOneUpdated(\n\t\t\tindex,\n\t\t\tupdatedCoordinate,\n\t\t);\n\n\t\tconst updatedSelectionPoints = updatedSelectionPoint\n\t\t\t? [updatedSelectionPoint]\n\t\t\t: [];\n\n\t\tconst updatedMidPoints = this.midPoints.getUpdated(geomCoordinates) || [];\n\n\t\tconst updatedCoordinatePoints =\n\t\t\tthis.coordinatePoints.getUpdated(draggedFeatureId, geomCoordinates) || [];\n\n\t\tif (\n\t\t\tgeometry.type !== \"Point\" &&\n\t\t\t!allowSelfIntersection &&\n\t\t\tselfIntersects({\n\t\t\t\ttype: \"Feature\",\n\t\t\t\tgeometry: geometry,\n\t\t\t\tproperties: {},\n\t\t\t} as Feature<Polygon>)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (validateFeature) {\n\t\t\tconst validationResult = validateFeature(draggedFeature, {\n\t\t\t\tproject: this.config.project,\n\t\t\t\tunproject: this.config.unproject,\n\t\t\t\tcoordinatePrecision: this.config.coordinatePrecision,\n\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t});\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Apply all the updates\n\t\tthis.store.updateGeometry([\n\t\t\t// Update feature\n\t\t\t{\n\t\t\t\tid: draggedFeatureId,\n\t\t\t\tgeometry: geometry,\n\t\t\t},\n\t\t\t// Update selection and mid points\n\t\t\t...updatedSelectionPoints,\n\t\t\t...updatedMidPoints,\n\t\t\t...updatedCoordinatePoints,\n\t\t]);\n\n\t\treturn true;\n\t}\n\n\tisDragging() {\n\t\treturn this.draggedCoordinate.id !== null;\n\t}\n\n\tstartDragging(id: FeatureId, index: number) {\n\t\tthis.draggedCoordinate = {\n\t\t\tid,\n\t\t\tindex,\n\t\t};\n\t}\n\n\tstopDragging() {\n\t\tthis.draggedCoordinate = {\n\t\t\tid: null,\n\t\t\tindex: -1,\n\t\t};\n\t}\n}\n","import { Feature, LineString, Polygon, Position } from \"geojson\";\n\n// Adapter from the @turf/bearing which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-centroid\n\nexport function centroid(geojson: Feature<Polygon | LineString>): Position {\n\tlet xSum = 0;\n\tlet ySum = 0;\n\tlet len = 0;\n\n\tconst coordinates =\n\t\tgeojson.geometry.type === \"Polygon\"\n\t\t\t? geojson.geometry.coordinates[0].slice(0, -1)\n\t\t\t: geojson.geometry.coordinates;\n\n\tcoordinates.forEach((coord: Position) => {\n\t\txSum += coord[0];\n\t\tySum += coord[1];\n\t\tlen++;\n\t}, true);\n\n\treturn [xSum / len, ySum / len];\n}\n","import { Feature, LineString, Polygon, Position } from \"geojson\";\nimport { centroid } from \"../centroid\";\nimport { rhumbBearing } from \"../measure/rhumb-bearing\";\nimport { rhumbDestination } from \"../measure/rhumb-destination\";\nimport { rhumbDistance } from \"../measure/rhumb-distance\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../project/web-mercator\";\nimport { CartesianPoint } from \"../../common\";\n\n// Adapted on @turf/transform-rotate module which is MIT licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-transform-rotate\n\nexport function transformRotate(\n\tfeature: Feature<Polygon | LineString>,\n\tangle: number,\n) {\n\t// Shortcut no-rotation\n\tif (angle === 0 || angle === 360 || angle === -360) {\n\t\treturn feature;\n\t}\n\n\t// Use centroid of GeoJSON if pivot is not provided\n\tconst pivot = centroid(feature);\n\n\tconst coordinates =\n\t\tfeature.geometry.type === \"Polygon\"\n\t\t\t? feature.geometry.coordinates[0]\n\t\t\t: feature.geometry.coordinates;\n\n\tcoordinates.forEach((pointCoords: Position) => {\n\t\tconst initialAngle = rhumbBearing(pivot, pointCoords);\n\t\tconst finalAngle = initialAngle + angle;\n\t\tconst distance = rhumbDistance(pivot, pointCoords);\n\t\tconst newCoords = rhumbDestination(pivot, distance, finalAngle);\n\t\tpointCoords[0] = newCoords[0];\n\t\tpointCoords[1] = newCoords[1];\n\t});\n\n\treturn feature;\n}\n\n/**\n * Rotate a GeoJSON Polygon geometry in web mercator\n * @param polygon - GeoJSON Polygon geometry\n * @param angle - rotation angle in degrees\n * @returns - rotated GeoJSON Polygon geometry\n */\nexport const transformRotateWebMercator = (\n\tfeature: Feature<Polygon> | Feature<LineString>,\n\tangle: number,\n) => {\n\tif (angle === 0 || angle === 360 || angle === -360) {\n\t\treturn feature;\n\t}\n\n\tconst DEGREES_TO_RADIANS = 0.017453292519943295 as const; // Math.PI / 180\n\n\tconst coordinates =\n\t\tfeature.geometry.type === \"Polygon\"\n\t\t\t? feature.geometry.coordinates[0]\n\t\t\t: feature.geometry.coordinates;\n\tconst angleRad = angle * DEGREES_TO_RADIANS;\n\n\t// Convert polygon coordinates to Web Mercator\n\tconst webMercatorCoords = coordinates.map(([lng, lat]) =>\n\t\tlngLatToWebMercatorXY(lng, lat),\n\t);\n\n\t// Find centroid of the polygon in Web Mercator\n\tconst centroid = webMercatorCoords.reduce(\n\t\t(acc: CartesianPoint, coord: CartesianPoint) => ({\n\t\t\tx: acc.x + coord.x,\n\t\t\ty: acc.y + coord.y,\n\t\t}),\n\t\t{ x: 0, y: 0 },\n\t);\n\tcentroid.x /= webMercatorCoords.length;\n\tcentroid.y /= webMercatorCoords.length;\n\n\t// Rotate the coordinates around the centroid\n\tconst rotatedWebMercatorCoords = webMercatorCoords.map((coord) => ({\n\t\tx:\n\t\t\tcentroid.x +\n\t\t\t(coord.x - centroid.x) * Math.cos(angleRad) -\n\t\t\t(coord.y - centroid.y) * Math.sin(angleRad),\n\t\ty:\n\t\t\tcentroid.y +\n\t\t\t(coord.x - centroid.x) * Math.sin(angleRad) +\n\t\t\t(coord.y - centroid.y) * Math.cos(angleRad),\n\t}));\n\n\t// Convert rotated Web Mercator coordinates back to geographic\n\tconst rotatedCoordinates = rotatedWebMercatorCoords.map(\n\t\t({ x, y }) =>\n\t\t\t[\n\t\t\t\twebMercatorXYToLngLat(x, y).lng,\n\t\t\t\twebMercatorXYToLngLat(x, y).lat,\n\t\t\t] as Position,\n\t);\n\n\tif (feature.geometry.type === \"Polygon\") {\n\t\tfeature.geometry.coordinates[0] = rotatedCoordinates;\n\t} else {\n\t\tfeature.geometry.coordinates = rotatedCoordinates;\n\t}\n\n\treturn feature;\n};\n","import { Feature, LineString, Polygon, Position } from \"geojson\";\nimport { lngLatToWebMercatorXY } from \"./project/web-mercator\";\nimport { CartesianPoint } from \"../common\";\n\n/**\n * Calculates the centroid of a GeoJSON Polygon or LineString in Web Mercator\n\n * @param {Feature<Polygon | LineString>} feature - The GeoJSON Feature containing either a Polygon or LineString\n * @returns {{ x: number, y: number }} The centroid of the polygon or line string in Web Mercator coordinates.\n */\nexport function webMercatorCentroid(feature: Feature<Polygon | LineString>) {\n\tconst coordinates =\n\t\tfeature.geometry.type === \"Polygon\"\n\t\t\t? feature.geometry.coordinates[0]\n\t\t\t: feature.geometry.coordinates;\n\n\tconst webMercatorCoordinates = coordinates.map((coord) => {\n\t\tconst { x, y } = lngLatToWebMercatorXY(coord[0], coord[1]);\n\t\treturn [x, y];\n\t});\n\n\tif (feature.geometry.type === \"Polygon\") {\n\t\treturn calculatePolygonCentroid(webMercatorCoordinates);\n\t} else {\n\t\treturn calculateLineStringMidpoint(webMercatorCoordinates);\n\t}\n}\n\nfunction calculatePolygonCentroid(\n\twebMercatorCoordinates: Position[],\n): CartesianPoint {\n\tlet area = 0;\n\tlet centroidX = 0;\n\tlet centroidY = 0;\n\n\tconst n = webMercatorCoordinates.length;\n\n\tfor (let i = 0; i < n - 1; i++) {\n\t\tconst [x1, y1] = webMercatorCoordinates[i];\n\t\tconst [x2, y2] = webMercatorCoordinates[i + 1];\n\n\t\tconst crossProduct = x1 * y2 - x2 * y1;\n\t\tarea += crossProduct;\n\t\tcentroidX += (x1 + x2) * crossProduct;\n\t\tcentroidY += (y1 + y2) * crossProduct;\n\t}\n\n\tarea /= 2;\n\tcentroidX /= 6 * area;\n\tcentroidY /= 6 * area;\n\n\treturn { x: centroidX, y: centroidY };\n}\n\nfunction calculateLineStringMidpoint(lineString: Position[]): CartesianPoint {\n\tconst n = lineString.length;\n\tlet totalX = 0;\n\tlet totalY = 0;\n\n\tfor (let i = 0; i < n; i++) {\n\t\tconst [x, y] = lineString[i];\n\t\ttotalX += x;\n\t\ttotalY += y;\n\t}\n\n\treturn { x: totalX / n, y: totalY / n };\n}\n","import {\n\tCartesianPoint,\n\tTerraDrawMouseEvent,\n\tUpdateTypes,\n\tValidation,\n} from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { Feature, LineString, Polygon, Position } from \"geojson\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport { MidPointBehavior } from \"./midpoint.behavior\";\nimport {\n\ttransformRotate,\n\ttransformRotateWebMercator,\n} from \"../../../geometry/transform/rotate\";\nimport { centroid } from \"../../../geometry/centroid\";\nimport { rhumbBearing } from \"../../../geometry/measure/rhumb-bearing\";\nimport { limitPrecision } from \"../../../geometry/limit-decimal-precision\";\nimport { FeatureId } from \"../../../store/store\";\nimport { webMercatorCentroid } from \"../../../geometry/web-mercator-centroid\";\nimport { lngLatToWebMercatorXY } from \"../../../geometry/project/web-mercator\";\nimport { webMercatorBearing } from \"../../../geometry/measure/bearing\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\n\nexport class RotateFeatureBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly selectionPoints: SelectionPointBehavior,\n\t\tprivate readonly midPoints: MidPointBehavior,\n\t\tprivate readonly coordinatePoints: CoordinatePointBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate lastBearing: number | undefined;\n\tprivate selectedGeometry: Polygon | LineString | undefined;\n\tprivate selectedGeometryCentroid: Position | undefined;\n\tprivate selectedGeometryWebMercatorCentroid: CartesianPoint | undefined;\n\n\treset() {\n\t\tthis.lastBearing = undefined;\n\t\tthis.selectedGeometry = undefined;\n\t\tthis.selectedGeometryWebMercatorCentroid = undefined;\n\t\tthis.selectedGeometryCentroid = undefined;\n\t}\n\n\trotate(\n\t\tevent: TerraDrawMouseEvent,\n\t\tselectedId: FeatureId,\n\t\tvalidateFeature?: Validation,\n\t) {\n\t\tif (!this.selectedGeometry) {\n\t\t\tthis.selectedGeometry = this.store.getGeometryCopy<LineString | Polygon>(\n\t\t\t\tselectedId,\n\t\t\t);\n\t\t}\n\n\t\tconst geometry = this.selectedGeometry;\n\n\t\t// Update the geometry of the dragged feature\n\t\tif (geometry.type !== \"Polygon\" && geometry.type !== \"LineString\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mouseCoord = [event.lng, event.lat];\n\n\t\tlet bearing: number;\n\t\tconst feature = { type: \"Feature\", geometry, properties: {} } as\n\t\t\t| Feature<Polygon>\n\t\t\t| Feature<LineString>;\n\n\t\tif (this.config.projection === \"web-mercator\") {\n\t\t\t// Cache the centroid of the selected geometry\n\t\t\t// to avoid recalculating it on every cursor move\n\t\t\tif (!this.selectedGeometryWebMercatorCentroid) {\n\t\t\t\tthis.selectedGeometryWebMercatorCentroid = webMercatorCentroid(feature);\n\t\t\t}\n\n\t\t\tconst cursorWebMercator = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\t\tbearing = webMercatorBearing(\n\t\t\t\tthis.selectedGeometryWebMercatorCentroid,\n\t\t\t\tcursorWebMercator,\n\t\t\t);\n\n\t\t\tif (bearing === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!this.lastBearing) {\n\t\t\t\tthis.lastBearing = bearing;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst angle = this.lastBearing - bearing;\n\n\t\t\ttransformRotateWebMercator(feature, -angle);\n\t\t} else if (this.config.projection === \"globe\") {\n\t\t\t// Cache the centroid of the selected geometry\n\t\t\t// to avoid recalculating it on every cursor move\n\t\t\tif (!this.selectedGeometryCentroid) {\n\t\t\t\tthis.selectedGeometryCentroid = centroid({\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tbearing = rhumbBearing(this.selectedGeometryCentroid, mouseCoord);\n\n\t\t\t// We need an original bearing to compare against\n\t\t\tif (!this.lastBearing) {\n\t\t\t\tthis.lastBearing = bearing + 180;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst angle = this.lastBearing - (bearing + 180);\n\n\t\t\ttransformRotate(feature, -angle);\n\t\t} else {\n\t\t\tthrow new Error(\"Unsupported projection\");\n\t\t}\n\n\t\t// Coordinates are either polygon or linestring at this point\n\t\tconst updatedCoords: Position[] =\n\t\t\tgeometry.type === \"Polygon\"\n\t\t\t\t? geometry.coordinates[0]\n\t\t\t\t: geometry.coordinates;\n\n\t\t// Ensure that coordinate precision is maintained\n\t\tupdatedCoords.forEach((coordinate) => {\n\t\t\tcoordinate[0] = limitPrecision(coordinate[0], this.coordinatePrecision);\n\t\t\tcoordinate[1] = limitPrecision(coordinate[1], this.coordinatePrecision);\n\t\t});\n\n\t\tconst updatedMidPoints = this.midPoints.getUpdated(updatedCoords) || [];\n\n\t\tconst updatedSelectionPoints =\n\t\t\tthis.selectionPoints.getUpdated(updatedCoords) || [];\n\n\t\tconst updatedCoordinatePoints =\n\t\t\tthis.coordinatePoints.getUpdated(selectedId, updatedCoords) || [];\n\n\t\tif (validateFeature) {\n\t\t\tif (\n\t\t\t\t!validateFeature(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: selectedId,\n\t\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tproperties: {},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tproject: this.config.project,\n\t\t\t\t\t\tunproject: this.config.unproject,\n\t\t\t\t\t\tcoordinatePrecision: this.config.coordinatePrecision,\n\t\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Issue the update to the selected feature\n\t\tthis.store.updateGeometry([\n\t\t\t{ id: selectedId, geometry },\n\t\t\t...updatedSelectionPoints,\n\t\t\t...updatedMidPoints,\n\t\t\t...updatedCoordinatePoints,\n\t\t]);\n\n\t\tif (this.projection === \"web-mercator\") {\n\t\t\tthis.lastBearing = bearing;\n\t\t} else if (this.projection === \"globe\") {\n\t\t\tthis.lastBearing = bearing + 180;\n\t\t}\n\t}\n}\n","import { Position } from \"geojson\";\nimport { earthRadius } from \"../helpers\";\n\n// Adapted from @turf/rhumb-distance module\n// https://github.com/Turfjs/turf/blob/master/packages/turf-rhumb-distance/index.ts\n\nexport function rhumbDistance(destination: Position, origin: Position): number {\n\t// compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n\t// solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n\tdestination[0] +=\n\t\tdestination[0] - origin[0] > 180\n\t\t\t? -360\n\t\t\t: origin[0] - destination[0] > 180\n\t\t\t\t? 360\n\t\t\t\t: 0;\n\n\t// see www.edwilliams.org/avform.htm#Rhumb\n\n\tconst R = earthRadius;\n\tconst phi1 = (origin[1] * Math.PI) / 180;\n\tconst phi2 = (destination[1] * Math.PI) / 180;\n\tconst DeltaPhi = phi2 - phi1;\n\tlet DeltaLambda = (Math.abs(destination[0] - origin[0]) * Math.PI) / 180;\n\n\t// if dLon over 180° take shorter rhumb line across the anti-meridian:\n\tif (DeltaLambda > Math.PI) {\n\t\tDeltaLambda -= 2 * Math.PI;\n\t}\n\n\t// on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\n\t// q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\n\tconst DeltaPsi = Math.log(\n\t\tMath.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4),\n\t);\n\tconst q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n\n\t// distance is pythagoras on 'stretched' Mercator projection\n\tconst delta = Math.sqrt(\n\t\tDeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda,\n\t); // angular distance in radians\n\n\tconst distanceMeters = delta * R;\n\n\treturn distanceMeters;\n}\n","import { TerraDrawMouseEvent, Validation } from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { FeatureId } from \"../../../store/store\";\nimport { DragCoordinateResizeBehavior } from \"./drag-coordinate-resize.behavior\";\n\nexport class ScaleFeatureBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly dragCoordinateResizeBehavior: DragCoordinateResizeBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tpublic scale(\n\t\tevent: TerraDrawMouseEvent,\n\t\tfeatureId: FeatureId,\n\t\tvalidation?: Validation,\n\t) {\n\t\tif (!this.dragCoordinateResizeBehavior.isDragging()) {\n\t\t\tconst index = this.dragCoordinateResizeBehavior.getDraggableIndex(\n\t\t\t\tevent,\n\t\t\t\tfeatureId,\n\t\t\t);\n\t\t\tthis.dragCoordinateResizeBehavior.startDragging(featureId, index);\n\t\t}\n\n\t\tthis.dragCoordinateResizeBehavior.drag(event, \"center-fixed\", validation);\n\t}\n\n\tpublic reset() {\n\t\tthis.dragCoordinateResizeBehavior.stopDragging();\n\t}\n}\n","import { Position } from \"geojson\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../project/web-mercator\";\n\nexport function transformScaleWebMercatorCoordinates({\n\tcoordinates,\n\toriginX,\n\toriginY,\n\txScale,\n\tyScale,\n}: {\n\tcoordinates: Position[];\n\toriginX: number;\n\toriginY: number;\n\txScale: number;\n\tyScale: number;\n}): void {\n\tif (xScale === 1 && yScale === 1) {\n\t\t// No scaling needed, return early\n\t\treturn;\n\t}\n\n\tcoordinates.forEach((coordinate) => {\n\t\tconst { x, y } = lngLatToWebMercatorXY(coordinate[0], coordinate[1]);\n\n\t\tconst updatedX = originX + (x - originX) * xScale;\n\t\tconst updatedY = originY + (y - originY) * yScale;\n\n\t\tconst { lng, lat } = webMercatorXYToLngLat(updatedX, updatedY);\n\n\t\tcoordinate[0] = lng;\n\t\tcoordinate[1] = lat;\n\t});\n}\n","import {\n\tCartesianPoint,\n\tTerraDrawMouseEvent,\n\tUpdateTypes,\n\tValidation,\n} from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { LineString, Polygon, Position, Point, Feature } from \"geojson\";\nimport { PixelDistanceBehavior } from \"../../pixel-distance.behavior\";\nimport { MidPointBehavior } from \"./midpoint.behavior\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport { FeatureId, GeoJSONStoreGeometries } from \"../../../store/store\";\nimport { limitPrecision } from \"../../../geometry/limit-decimal-precision\";\nimport { cartesianDistance } from \"../../../geometry/measure/pixel-distance\";\nimport { coordinatePrecisionIsValid } from \"../../../geometry/boolean/is-valid-coordinate\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../../geometry/project/web-mercator\";\nimport { webMercatorCentroid } from \"../../../geometry/web-mercator-centroid\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\nimport { transformScaleWebMercatorCoordinates } from \"../../../geometry/transform/scale\";\n\nexport type ResizeOptions =\n\t| \"center\"\n\t| \"opposite\"\n\t| \"center-fixed\"\n\t| \"opposite-fixed\";\n\ntype BoundingBoxIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\n\ntype BoundingBox = readonly [\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n];\n\nexport class DragCoordinateResizeBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t\tprivate readonly selectionPoints: SelectionPointBehavior,\n\t\tprivate readonly midPoints: MidPointBehavior,\n\t\tprivate readonly coordinatePoints: CoordinatePointBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate minimumScale = 0.0001;\n\n\tprivate draggedCoordinate: { id: null | FeatureId; index: number } = {\n\t\tid: null,\n\t\tindex: -1,\n\t};\n\n\t// This map provides the oppsite corner of the bbox\n\t// to the index of the coordinate provided\n\t//   0    1    2\n\t//   *----*----*\n\t// \t |\t\t   |\n\t// 7 *\t\t   *  3\n\t//   |\t\t   |\n\t//   *----*----*\n\t// \t 6    5    4\n\t//\n\tprivate boundingBoxMaps = {\n\t\topposite: {\n\t\t\t0: 4,\n\t\t\t1: 5,\n\t\t\t2: 6,\n\t\t\t3: 7,\n\t\t\t4: 0,\n\t\t\t5: 1,\n\t\t\t6: 2,\n\t\t\t7: 3,\n\t\t},\n\t};\n\n\tprivate getClosestCoordinate(\n\t\tevent: TerraDrawMouseEvent,\n\t\tgeometry: Polygon | LineString | Point,\n\t) {\n\t\tconst closestCoordinate = {\n\t\t\tdist: Infinity,\n\t\t\tindex: -1,\n\t\t\tisFirstOrLastPolygonCoord: false,\n\t\t};\n\n\t\tlet geomCoordinates: Position[] | undefined;\n\n\t\tif (geometry.type === \"LineString\") {\n\t\t\tgeomCoordinates = geometry.coordinates;\n\t\t} else if (geometry.type === \"Polygon\") {\n\t\t\tgeomCoordinates = geometry.coordinates[0];\n\t\t} else {\n\t\t\t// We don't want to handle dragging\n\t\t\t// points here\n\t\t\treturn closestCoordinate;\n\t\t}\n\n\t\t// Look through the selected features coordinates\n\t\t// and try to find a coordinate that is draggable\n\t\tfor (let i = 0; i < geomCoordinates.length; i++) {\n\t\t\tconst coord = geomCoordinates[i];\n\t\t\tconst distance = this.pixelDistance.measure(event, coord);\n\n\t\t\tif (\n\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\tdistance < closestCoordinate.dist\n\t\t\t) {\n\t\t\t\t// We don't create a point for the final\n\t\t\t\t// polygon coord, so we must set it to the first\n\t\t\t\t// coordinate instead\n\t\t\t\tconst isFirstOrLastPolygonCoord =\n\t\t\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t\t\t(i === geomCoordinates.length - 1 || i === 0);\n\n\t\t\t\tclosestCoordinate.dist = distance;\n\t\t\t\tclosestCoordinate.index = isFirstOrLastPolygonCoord ? 0 : i;\n\t\t\t\tclosestCoordinate.isFirstOrLastPolygonCoord = isFirstOrLastPolygonCoord;\n\t\t\t}\n\t\t}\n\n\t\treturn closestCoordinate;\n\t}\n\n\tprivate isValidDragWebMercator(\n\t\tindex: BoundingBoxIndex,\n\t\tdistanceX: number,\n\t\tdistanceY: number,\n\t) {\n\t\tswitch (index) {\n\t\t\tcase 0:\n\t\t\t\tif (distanceX <= 0 || distanceY >= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (distanceY >= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (distanceX >= 0 || distanceY >= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (distanceX >= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (distanceX >= 0 || distanceY <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (distanceY <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (distanceX <= 0 || distanceY <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tif (distanceX <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate getSelectedFeatureDataWebMercator() {\n\t\tif (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst feature = this.getFeature(this.draggedCoordinate.id);\n\t\tif (!feature) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst updatedCoords = this.getNormalisedCoordinates(feature.geometry);\n\t\tconst boundingBox = this.getBBoxWebMercator(updatedCoords);\n\n\t\treturn {\n\t\t\tboundingBox,\n\t\t\tfeature,\n\t\t\tupdatedCoords,\n\t\t\tselectedCoordinate: updatedCoords[this.draggedCoordinate.index],\n\t\t};\n\t}\n\n\tprivate centerWebMercatorDrag(event: TerraDrawMouseEvent) {\n\t\tconst featureData = this.getSelectedFeatureDataWebMercator();\n\t\tif (!featureData) {\n\t\t\treturn null;\n\t\t}\n\t\tconst { feature, boundingBox, updatedCoords, selectedCoordinate } =\n\t\t\tfeatureData;\n\n\t\tconst webMercatorOrigin = webMercatorCentroid(feature);\n\n\t\tif (!webMercatorOrigin) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst webMercatorSelected = lngLatToWebMercatorXY(\n\t\t\tselectedCoordinate[0],\n\t\t\tselectedCoordinate[1],\n\t\t);\n\n\t\tconst { closestBBoxIndex } = this.getIndexesWebMercator(\n\t\t\tboundingBox,\n\t\t\twebMercatorSelected,\n\t\t);\n\n\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\tthis.scaleWebMercator({\n\t\t\tclosestBBoxIndex,\n\t\t\tupdatedCoords,\n\t\t\twebMercatorCursor,\n\t\t\twebMercatorSelected,\n\t\t\twebMercatorOrigin,\n\t\t});\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate centerFixedWebMercatorDrag(event: TerraDrawMouseEvent) {\n\t\tconst featureData = this.getSelectedFeatureDataWebMercator();\n\t\tif (!featureData) {\n\t\t\treturn null;\n\t\t}\n\t\tconst { feature, boundingBox, updatedCoords, selectedCoordinate } =\n\t\t\tfeatureData;\n\n\t\tconst webMercatorOrigin = webMercatorCentroid(feature);\n\n\t\tif (!webMercatorOrigin) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst webMercatorSelected = lngLatToWebMercatorXY(\n\t\t\tselectedCoordinate[0],\n\t\t\tselectedCoordinate[1],\n\t\t);\n\n\t\tconst { closestBBoxIndex } = this.getIndexesWebMercator(\n\t\t\tboundingBox,\n\t\t\twebMercatorSelected,\n\t\t);\n\n\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\tthis.scaleFixedWebMercator({\n\t\t\tclosestBBoxIndex,\n\t\t\tupdatedCoords,\n\t\t\twebMercatorCursor,\n\t\t\twebMercatorSelected,\n\t\t\twebMercatorOrigin,\n\t\t});\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate scaleFixedWebMercator({\n\t\tclosestBBoxIndex,\n\t\twebMercatorOrigin,\n\t\twebMercatorSelected,\n\t\twebMercatorCursor,\n\t\tupdatedCoords,\n\t}: {\n\t\tclosestBBoxIndex: BoundingBoxIndex;\n\t\tupdatedCoords: Position[];\n\t\twebMercatorCursor: CartesianPoint;\n\t\twebMercatorSelected: CartesianPoint;\n\t\twebMercatorOrigin: CartesianPoint;\n\t}) {\n\t\tconst cursorDistanceX = webMercatorOrigin.x - webMercatorCursor.x;\n\t\tconst cursorDistanceY = webMercatorOrigin.y - webMercatorCursor.y;\n\n\t\tconst valid = this.isValidDragWebMercator(\n\t\t\tclosestBBoxIndex,\n\t\t\tcursorDistanceX,\n\t\t\tcursorDistanceY,\n\t\t);\n\n\t\tif (!valid) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet scale =\n\t\t\tcartesianDistance(webMercatorOrigin, webMercatorCursor) /\n\t\t\tcartesianDistance(webMercatorOrigin, webMercatorSelected);\n\n\t\tif (scale < 0) {\n\t\t\tscale = this.minimumScale;\n\t\t}\n\n\t\ttransformScaleWebMercatorCoordinates({\n\t\t\tcoordinates: updatedCoords,\n\t\t\toriginX: webMercatorOrigin.x,\n\t\t\toriginY: webMercatorOrigin.y,\n\t\t\txScale: scale,\n\t\t\tyScale: scale,\n\t\t});\n\n\t\t// this.performWebMercatorScale(\n\t\t// \tupdatedCoords,\n\t\t// \twebMercatorOrigin.x,\n\t\t// \twebMercatorOrigin.y,\n\t\t// \tscale,\n\t\t// \tscale,\n\t\t// );\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate oppositeFixedWebMercatorDrag(event: TerraDrawMouseEvent) {\n\t\tconst featureData = this.getSelectedFeatureDataWebMercator();\n\t\tif (!featureData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { boundingBox, updatedCoords, selectedCoordinate } = featureData;\n\n\t\tconst webMercatorSelected = lngLatToWebMercatorXY(\n\t\t\tselectedCoordinate[0],\n\t\t\tselectedCoordinate[1],\n\t\t);\n\n\t\tconst { oppositeBboxIndex, closestBBoxIndex } = this.getIndexesWebMercator(\n\t\t\tboundingBox,\n\t\t\twebMercatorSelected,\n\t\t);\n\n\t\tconst webMercatorOrigin = {\n\t\t\tx: boundingBox[oppositeBboxIndex][0],\n\t\t\ty: boundingBox[oppositeBboxIndex][1],\n\t\t};\n\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\tthis.scaleFixedWebMercator({\n\t\t\tclosestBBoxIndex,\n\t\t\tupdatedCoords,\n\t\t\twebMercatorCursor,\n\t\t\twebMercatorSelected,\n\t\t\twebMercatorOrigin,\n\t\t});\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate oppositeWebMercatorDrag(event: TerraDrawMouseEvent) {\n\t\tconst featureData = this.getSelectedFeatureDataWebMercator();\n\t\tif (!featureData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { boundingBox, updatedCoords, selectedCoordinate } = featureData;\n\n\t\tconst webMercatorSelected = lngLatToWebMercatorXY(\n\t\t\tselectedCoordinate[0],\n\t\t\tselectedCoordinate[1],\n\t\t);\n\n\t\tconst { oppositeBboxIndex, closestBBoxIndex } = this.getIndexesWebMercator(\n\t\t\tboundingBox,\n\t\t\twebMercatorSelected,\n\t\t);\n\n\t\tconst webMercatorOrigin = {\n\t\t\tx: boundingBox[oppositeBboxIndex][0],\n\t\t\ty: boundingBox[oppositeBboxIndex][1],\n\t\t};\n\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\tthis.scaleWebMercator({\n\t\t\tclosestBBoxIndex,\n\t\t\tupdatedCoords,\n\t\t\twebMercatorCursor,\n\t\t\twebMercatorSelected,\n\t\t\twebMercatorOrigin,\n\t\t});\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate scaleWebMercator({\n\t\tclosestBBoxIndex,\n\t\twebMercatorOrigin,\n\t\twebMercatorSelected,\n\t\twebMercatorCursor,\n\t\tupdatedCoords,\n\t}: {\n\t\tclosestBBoxIndex: BoundingBoxIndex;\n\t\tupdatedCoords: Position[];\n\t\twebMercatorCursor: CartesianPoint;\n\t\twebMercatorSelected: CartesianPoint;\n\t\twebMercatorOrigin: CartesianPoint;\n\t}) {\n\t\tconst cursorDistanceX = webMercatorOrigin.x - webMercatorCursor.x;\n\t\tconst cursorDistanceY = webMercatorOrigin.y - webMercatorCursor.y;\n\n\t\tconst valid = this.isValidDragWebMercator(\n\t\t\tclosestBBoxIndex,\n\t\t\tcursorDistanceX,\n\t\t\tcursorDistanceY,\n\t\t);\n\n\t\tif (!valid) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet xScale = 1;\n\t\tif (\n\t\t\tcursorDistanceX !== 0 &&\n\t\t\tclosestBBoxIndex !== 1 &&\n\t\t\tclosestBBoxIndex !== 5\n\t\t) {\n\t\t\tconst currentDistanceX = webMercatorOrigin.x - webMercatorSelected.x;\n\t\t\txScale = 1 - (currentDistanceX - cursorDistanceX) / cursorDistanceX;\n\t\t}\n\n\t\tlet yScale = 1;\n\t\tif (\n\t\t\tcursorDistanceY !== 0 &&\n\t\t\tclosestBBoxIndex !== 3 &&\n\t\t\tclosestBBoxIndex !== 7\n\t\t) {\n\t\t\tconst currentDistanceY = webMercatorOrigin.y - webMercatorSelected.y;\n\t\t\tyScale = 1 - (currentDistanceY - cursorDistanceY) / cursorDistanceY;\n\t\t}\n\n\t\tif (!this.validateScale(xScale, yScale)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (xScale < 0) {\n\t\t\txScale = this.minimumScale;\n\t\t}\n\n\t\tif (yScale < 0) {\n\t\t\tyScale = this.minimumScale;\n\t\t}\n\n\t\tthis.performWebMercatorScale(\n\t\t\tupdatedCoords,\n\t\t\twebMercatorOrigin.x,\n\t\t\twebMercatorOrigin.y,\n\t\t\txScale,\n\t\t\tyScale,\n\t\t);\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate getFeature(id: FeatureId) {\n\t\tif (this.draggedCoordinate.id === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(id);\n\n\t\t// Update the geometry of the dragged feature\n\t\tif (geometry.type !== \"Polygon\" && geometry.type !== \"LineString\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst feature = {\n\t\t\tid,\n\t\t\ttype: \"Feature\",\n\t\t\tgeometry,\n\t\t\tproperties: {},\n\t\t} as Feature<Polygon | LineString>;\n\n\t\treturn feature;\n\t}\n\n\tprivate getNormalisedCoordinates(geometry: Polygon | LineString) {\n\t\t// Coordinates are either polygon or linestring at this point\n\t\treturn geometry.type === \"Polygon\"\n\t\t\t? geometry.coordinates[0]\n\t\t\t: geometry.coordinates;\n\t}\n\n\tprivate validateScale(xScale: number, yScale: number) {\n\t\tconst validX = !isNaN(xScale) && yScale < Number.MAX_SAFE_INTEGER;\n\t\tconst validY = !isNaN(yScale) && yScale < Number.MAX_SAFE_INTEGER;\n\n\t\treturn validX && validY;\n\t}\n\n\tprivate performWebMercatorScale(\n\t\tcoordinates: Position[],\n\t\toriginX: number,\n\t\toriginY: number,\n\t\txScale: number,\n\t\tyScale: number,\n\t) {\n\t\tcoordinates.forEach((coordinate) => {\n\t\t\tconst { x, y } = lngLatToWebMercatorXY(coordinate[0], coordinate[1]);\n\n\t\t\tconst updatedX = originX + (x - originX) * xScale;\n\t\t\tconst updatedY = originY + (y - originY) * yScale;\n\n\t\t\tconst { lng, lat } = webMercatorXYToLngLat(updatedX, updatedY);\n\n\t\t\tcoordinate[0] = lng;\n\t\t\tcoordinate[1] = lat;\n\t\t});\n\t}\n\n\tprivate getBBoxWebMercator(coordinates: Position[]) {\n\t\tconst bbox: [number, number, number, number] = [\n\t\t\tInfinity,\n\t\t\tInfinity,\n\t\t\t-Infinity,\n\t\t\t-Infinity,\n\t\t];\n\n\t\t// Convert from [lng, lat] -> [x, y]\n\t\tcoordinates = coordinates.map((coord) => {\n\t\t\tconst { x, y } = lngLatToWebMercatorXY(coord[0], coord[1]);\n\t\t\treturn [x, y];\n\t\t});\n\n\t\tcoordinates.forEach(([x, y]) => {\n\t\t\tif (x < bbox[0]) {\n\t\t\t\tbbox[0] = x;\n\t\t\t}\n\n\t\t\tif (y < bbox[1]) {\n\t\t\t\tbbox[1] = y;\n\t\t\t}\n\n\t\t\tif (x > bbox[2]) {\n\t\t\t\tbbox[2] = x;\n\t\t\t}\n\n\t\t\tif (y > bbox[3]) {\n\t\t\t\tbbox[3] = y;\n\t\t\t}\n\t\t});\n\n\t\tconst [west, south, east, north] = bbox;\n\n\t\t//   Bounding box is represented as follows:\n\t\t//\n\t\t//   0    1    2\n\t\t//   *----*----*\n\t\t// \t |\t\t   |\n\t\t// 7 *\t\t   *  3\n\t\t//   |\t\t   |\n\t\t//   *----*----*\n\t\t// \t 6    5    4\n\t\t//\n\t\tconst topLeft = [west, north];\n\t\tconst topRight = [east, north];\n\t\tconst lowRight = [east, south];\n\t\tconst lowLeft = [west, south];\n\n\t\tconst midTop = [(west + east) / 2, north];\n\t\tconst midRight = [east, north + (south - north) / 2];\n\t\tconst midBottom = [(west + east) / 2, south];\n\t\tconst midLeft = [west, north + (south - north) / 2];\n\n\t\treturn [\n\t\t\ttopLeft, // 0\n\t\t\tmidTop, // 1\n\t\t\ttopRight, // 2\n\t\t\tmidRight, // 3\n\t\t\tlowRight, // 4\n\t\t\tmidBottom, // 5\n\t\t\tlowLeft, // 6\n\t\t\tmidLeft, // 7\n\t\t] as const;\n\t}\n\n\tprivate getIndexesWebMercator(\n\t\tboundingBox: BoundingBox,\n\t\tselectedXY: CartesianPoint,\n\t) {\n\t\tlet closestIndex: BoundingBoxIndex | undefined;\n\t\tlet closestDistance = Infinity;\n\n\t\tfor (let i = 0; i < boundingBox.length; i++) {\n\t\t\tconst distance = cartesianDistance(\n\t\t\t\t{ x: selectedXY.x, y: selectedXY.y },\n\t\t\t\t{ x: boundingBox[i][0], y: boundingBox[i][1] },\n\t\t\t);\n\n\t\t\tif (distance < closestDistance) {\n\t\t\t\tclosestIndex = i as BoundingBoxIndex;\n\t\t\t\tclosestDistance = distance;\n\t\t\t}\n\t\t}\n\n\t\tif (closestIndex === undefined) {\n\t\t\tthrow new Error(\"No closest coordinate found\");\n\t\t}\n\n\t\t// Depending on where what the origin is set to, we need to find the position to\n\t\t// scale from\n\t\tconst oppositeIndex = this.boundingBoxMaps[\"opposite\"][\n\t\t\tclosestIndex\n\t\t] as BoundingBoxIndex;\n\n\t\treturn {\n\t\t\toppositeBboxIndex: oppositeIndex,\n\t\t\tclosestBBoxIndex: closestIndex,\n\t\t} as const;\n\t}\n\n\t/**\n\t * @returns - true if the feature is being dragged (resized), false otherwise\n\t */\n\tpublic isDragging() {\n\t\treturn this.draggedCoordinate.id !== null;\n\t}\n\n\t/**\n\t * Starts the resizing of the feature\n\t * @param id - feature id of the feature that is being dragged\n\t * @param index - index of the coordinate that is being dragged\n\t * @returns - void\n\t */\n\tpublic startDragging(id: FeatureId, index: number) {\n\t\tthis.draggedCoordinate = {\n\t\t\tid,\n\t\t\tindex,\n\t\t};\n\t}\n\n\t/**\n\t * Stops the resizing of the feature\n\t * @returns - void\t *\n\t */\n\tpublic stopDragging() {\n\t\tthis.draggedCoordinate = {\n\t\t\tid: null,\n\t\t\tindex: -1,\n\t\t};\n\t}\n\n\t/**\n\t * Returns the index of the coordinate that is going to be dragged\n\t * @param event - cursor event\n\t * @param selectedId - feature id of the feature that is selected\n\t * @returns - the index to be dragged\n\t */\n\tpublic getDraggableIndex(\n\t\tevent: TerraDrawMouseEvent,\n\t\tselectedId: FeatureId,\n\t): number {\n\t\tconst geometry = this.store.getGeometryCopy(selectedId);\n\t\tconst closestCoordinate = this.getClosestCoordinate(event, geometry);\n\n\t\t// No coordinate was within the pointer distance\n\t\tif (closestCoordinate.index === -1) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn closestCoordinate.index;\n\t}\n\n\t/**\n\t * Resizes the feature based on the cursor event\n\t * @param event - cursor event\n\t * @param resizeOption - the resize option, either \"center\" or \"opposite\"\n\t * @returns - true is resize was successful, false otherwise\n\t */\n\tpublic drag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tresizeOption: ResizeOptions,\n\t\tvalidateFeature?: Validation,\n\t): boolean {\n\t\tif (!this.draggedCoordinate.id) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst feature = this.getFeature(this.draggedCoordinate.id);\n\t\tif (!feature) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet updatedCoords: Position[] | null = null;\n\n\t\tif (resizeOption === \"center\") {\n\t\t\tupdatedCoords = this.centerWebMercatorDrag(event);\n\t\t} else if (resizeOption === \"opposite\") {\n\t\t\tupdatedCoords = this.oppositeWebMercatorDrag(event);\n\t\t} else if (resizeOption === \"center-fixed\") {\n\t\t\tupdatedCoords = this.centerFixedWebMercatorDrag(event);\n\t\t} else if (resizeOption === \"opposite-fixed\") {\n\t\t\tupdatedCoords = this.oppositeFixedWebMercatorDrag(event);\n\t\t}\n\n\t\tif (!updatedCoords) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Ensure that coordinate precision is maintained\n\t\tfor (let i = 0; i < updatedCoords.length; i++) {\n\t\t\tconst coordinate = updatedCoords[i];\n\t\t\tcoordinate[0] = limitPrecision(coordinate[0], this.coordinatePrecision);\n\t\t\tcoordinate[1] = limitPrecision(coordinate[1], this.coordinatePrecision);\n\n\t\t\t// Ensure the coordinate we are about to update with is valid\n\t\t\tif (!coordinatePrecisionIsValid(coordinate, this.coordinatePrecision)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Perform the update to the midpoints and selection points\n\t\tconst updatedMidPoints = this.midPoints.getUpdated(updatedCoords) || [];\n\t\tconst updatedSelectionPoints =\n\t\t\tthis.selectionPoints.getUpdated(updatedCoords) || [];\n\t\tconst updatedCoordinatePoints =\n\t\t\tthis.coordinatePoints.getUpdated(\n\t\t\t\tfeature.id as FeatureId,\n\t\t\t\tupdatedCoords,\n\t\t\t) || [];\n\n\t\tconst updatedGeometry = {\n\t\t\ttype: feature.geometry.type as \"Polygon\" | \"LineString\",\n\t\t\tcoordinates:\n\t\t\t\tfeature.geometry.type === \"Polygon\" ? [updatedCoords] : updatedCoords,\n\t\t} as GeoJSONStoreGeometries;\n\n\t\tif (validateFeature) {\n\t\t\tconst validationResult = validateFeature(\n\t\t\t\t{\n\t\t\t\t\tid: this.draggedCoordinate.id,\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.config.project,\n\t\t\t\t\tunproject: this.config.unproject,\n\t\t\t\t\tcoordinatePrecision: this.config.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Issue the update to the selected feature\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.draggedCoordinate.id,\n\t\t\t\tgeometry: updatedGeometry,\n\t\t\t},\n\t\t\t...updatedSelectionPoints,\n\t\t\t...updatedMidPoints,\n\t\t\t...updatedCoordinatePoints,\n\t\t]);\n\n\t\treturn true;\n\t}\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawKeyboardEvent,\n\tSELECT_PROPERTIES,\n\tTerraDrawAdapterStyling,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tValidation,\n\tUpdateTypes,\n\tZ_INDEX,\n\tSnapping,\n} from \"../../common\";\nimport { Point, Position } from \"geojson\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseSelectMode,\n} from \"../base.mode\";\nimport { MidPointBehavior } from \"./behaviors/midpoint.behavior\";\nimport {\n\tSelectionPointBehavior,\n\tSelectionPointProperties,\n} from \"./behaviors/selection-point.behavior\";\nimport { FeatureAtPointerEventBehavior } from \"./behaviors/feature-at-pointer-event.behavior\";\nimport { PixelDistanceBehavior } from \"../pixel-distance.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../click-bounding-box.behavior\";\nimport { DragFeatureBehavior } from \"./behaviors/drag-feature.behavior\";\nimport { DragCoordinateBehavior } from \"./behaviors/drag-coordinate.behavior\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { RotateFeatureBehavior } from \"./behaviors/rotate-feature.behavior\";\nimport { ScaleFeatureBehavior } from \"./behaviors/scale-feature.behavior\";\nimport { FeatureId, GeoJSONStoreFeatures } from \"../../store/store\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tDragCoordinateResizeBehavior,\n\tResizeOptions,\n} from \"./behaviors/drag-coordinate-resize.behavior\";\nimport { CoordinatePointBehavior } from \"./behaviors/coordinate-point.behavior\";\nimport { CoordinateSnappingBehavior } from \"../coordinate-snapping.behavior\";\nimport { LineSnappingBehavior } from \"../line-snapping.behavior\";\n\ntype TerraDrawSelectModeKeyEvents = {\n\tdeselect: KeyboardEvent[\"key\"] | null;\n\tdelete: KeyboardEvent[\"key\"] | null;\n\trotate: KeyboardEvent[\"key\"][] | null;\n\tscale: KeyboardEvent[\"key\"][] | null;\n};\n\nconst defaultKeyEvents = {\n\tdeselect: \"Escape\",\n\tdelete: \"Delete\",\n\trotate: [\"Control\", \"r\"],\n\tscale: [\"Control\", \"s\"],\n};\n\ntype ModeFlags = {\n\tfeature?: {\n\t\tvalidation?: Validation;\n\t\tdraggable?: boolean;\n\t\trotateable?: boolean;\n\t\tscaleable?: boolean;\n\t\tselfIntersectable?: boolean;\n\t\tcoordinates?: {\n\t\t\tsnappable?: boolean | Snapping;\n\t\t\tmidpoints?:\n\t\t\t\t| boolean\n\t\t\t\t| {\n\t\t\t\t\t\tdraggable?: boolean;\n\t\t\t\t  };\n\t\t\tdraggable?: boolean;\n\t\t\tresizable?: ResizeOptions;\n\t\t\tdeletable?: boolean;\n\t\t};\n\t};\n};\n\ntype SelectionStyling = {\n\t// Point\n\tselectedPointColor: HexColorStyling;\n\tselectedPointWidth: NumericStyling;\n\tselectedPointOutlineColor: HexColorStyling;\n\tselectedPointOutlineWidth: NumericStyling;\n\n\t// LineString\n\tselectedLineStringColor: HexColorStyling;\n\tselectedLineStringWidth: NumericStyling;\n\n\t// Polygon\n\tselectedPolygonColor: HexColorStyling;\n\tselectedPolygonFillOpacity: NumericStyling;\n\tselectedPolygonOutlineColor: HexColorStyling;\n\tselectedPolygonOutlineWidth: NumericStyling;\n\n\t// Selection Points (points at vertices of a polygon/linestring feature)\n\tselectionPointWidth: NumericStyling;\n\tselectionPointColor: HexColorStyling;\n\tselectionPointOutlineColor: HexColorStyling;\n\tselectionPointOutlineWidth: NumericStyling;\n\n\t// Mid points (points at mid point of a polygon/linestring feature)\n\tmidPointColor: HexColorStyling;\n\tmidPointOutlineColor: HexColorStyling;\n\tmidPointWidth: NumericStyling;\n\tmidPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tpointerOver?: Cursor;\n\tdragStart?: Cursor;\n\tdragEnd?: Cursor;\n\tinsertMidpoint?: Cursor;\n}\n\nconst defaultCursors = {\n\tpointerOver: \"move\",\n\tdragStart: \"move\",\n\tdragEnd: \"move\",\n\tinsertMidpoint: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawSelectModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tpointerDistance?: number;\n\tflags?: { [mode: string]: ModeFlags };\n\tkeyEvents?: TerraDrawSelectModeKeyEvents | null;\n\tdragEventThrottle?: number;\n\tcursors?: Cursors;\n\tallowManualDeselection?: boolean;\n}\n\nexport class TerraDrawSelectMode extends TerraDrawBaseSelectMode<SelectionStyling> {\n\tpublic mode = \"select\" as const;\n\n\tprivate allowManualDeselection = true;\n\tprivate dragEventThrottle = 5;\n\tprivate dragEventCount = 0;\n\tprivate selected: FeatureId[] = [];\n\n\tprivate flags: { [mode: string]: ModeFlags } = {};\n\tprivate keyEvents: TerraDrawSelectModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate validations: Record<string, Validation> = {};\n\n\t// Behaviors\n\tprivate selectionPoints!: SelectionPointBehavior;\n\tprivate midPoints!: MidPointBehavior;\n\tprivate coordinateSnap!: CoordinateSnappingBehavior;\n\tprivate featuresAtMouseEvent!: FeatureAtPointerEventBehavior;\n\tprivate pixelDistance!: PixelDistanceBehavior;\n\tprivate clickBoundingBox!: ClickBoundingBoxBehavior;\n\tprivate dragFeature!: DragFeatureBehavior;\n\tprivate dragCoordinate!: DragCoordinateBehavior;\n\tprivate rotateFeature!: RotateFeatureBehavior;\n\tprivate scaleFeature!: ScaleFeatureBehavior;\n\tprivate dragCoordinateResizeFeature!: DragCoordinateResizeBehavior;\n\tprivate coordinatePoints!: CoordinatePointBehavior;\n\tprivate lineSnap!: LineSnappingBehavior;\n\n\tconstructor(options?: TerraDrawSelectModeOptions<SelectionStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawSelectModeOptions<SelectionStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options && options.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t} else {\n\t\t\tthis.cursors = defaultCursors;\n\t\t}\n\n\t\t// We want to have some defaults, but also allow key bindings\n\t\t// to be explicitly turned off\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = {\n\t\t\t\tdeselect: null,\n\t\t\t\tdelete: null,\n\t\t\t\trotate: null,\n\t\t\t\tscale: null,\n\t\t\t};\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.dragEventThrottle !== undefined) {\n\t\t\tthis.dragEventThrottle = options.dragEventThrottle;\n\t\t}\n\n\t\tif (options?.allowManualDeselection !== undefined) {\n\t\t\tthis.allowManualDeselection = options.allowManualDeselection;\n\t\t}\n\n\t\t// Flags and Validations\n\t\tif (options?.flags) {\n\t\t\tthis.flags = { ...this.flags, ...options.flags };\n\t\t\tthis.validations = {};\n\n\t\t\tfor (const mode in this.flags) {\n\t\t\t\tconst feature = this.flags[mode].feature;\n\t\t\t\tif (feature && feature.validation) {\n\t\t\t\t\tthis.validations[mode] = feature.validation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tselectFeature(featureId: FeatureId) {\n\t\tthis.select(featureId, false);\n\t}\n\n\tsetSelecting() {\n\t\tif (this._state === \"started\") {\n\t\t\tthis._state = \"selecting\";\n\t\t} else {\n\t\t\tthrow new Error(\"Mode must be started to move to selecting state\");\n\t\t}\n\t}\n\n\tregisterBehaviors(config: BehaviorConfig) {\n\t\tthis.pixelDistance = new PixelDistanceBehavior(config);\n\t\tthis.clickBoundingBox = new ClickBoundingBoxBehavior(config);\n\t\tthis.featuresAtMouseEvent = new FeatureAtPointerEventBehavior(\n\t\t\tconfig,\n\t\t\tthis.clickBoundingBox,\n\t\t\tthis.pixelDistance,\n\t\t);\n\n\t\tthis.selectionPoints = new SelectionPointBehavior(config);\n\t\tthis.coordinatePoints = new CoordinatePointBehavior(config);\n\t\tthis.midPoints = new MidPointBehavior(\n\t\t\tconfig,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.coordinatePoints,\n\t\t);\n\t\tthis.coordinateSnap = new CoordinateSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.lineSnap = new LineSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.rotateFeature = new RotateFeatureBehavior(\n\t\t\tconfig,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.midPoints,\n\t\t\tthis.coordinatePoints,\n\t\t);\n\n\t\tthis.dragFeature = new DragFeatureBehavior(\n\t\t\tconfig,\n\t\t\tthis.featuresAtMouseEvent,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.midPoints,\n\t\t\tthis.coordinatePoints,\n\t\t);\n\t\tthis.dragCoordinate = new DragCoordinateBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.midPoints,\n\t\t\tthis.coordinatePoints,\n\t\t\tthis.coordinateSnap,\n\t\t\tthis.lineSnap,\n\t\t);\n\t\tthis.dragCoordinateResizeFeature = new DragCoordinateResizeBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.midPoints,\n\t\t\tthis.coordinatePoints,\n\t\t);\n\t\tthis.scaleFeature = new ScaleFeatureBehavior(\n\t\t\tconfig,\n\t\t\tthis.dragCoordinateResizeFeature,\n\t\t);\n\t}\n\n\tpublic deselectFeature() {\n\t\tthis.deselect();\n\t}\n\n\tprivate deselect() {\n\t\tconst updateSelectedFeatures = this.selected\n\t\t\t.filter((id) => this.store.has(id))\n\t\t\t.map((id) => ({\n\t\t\t\tid,\n\t\t\t\tproperty: SELECT_PROPERTIES.SELECTED,\n\t\t\t\tvalue: false,\n\t\t\t}));\n\n\t\tthis.store.updateProperty(updateSelectedFeatures);\n\n\t\tthis.onDeselect(this.selected[0]);\n\t\tthis.selected = [];\n\t\tthis.selectionPoints.delete();\n\t\tthis.midPoints.delete();\n\t}\n\n\tprivate deleteSelected() {\n\t\t// Delete all selected features\n\t\t// from the store and clear selected\n\t\t// We don't need to set selected false\n\t\t// as we're going to delete the feature\n\n\t\tthis.store.delete(this.selected);\n\t\tthis.selected = [];\n\t}\n\n\tprivate onRightClick(event: TerraDrawMouseEvent) {\n\t\tif (!this.selectionPoints.ids.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet clickedSelectionPointProps: SelectionPointProperties | undefined;\n\n\t\tlet clickedFeatureDistance = Infinity;\n\n\t\tthis.selectionPoints.ids.forEach((id) => {\n\t\t\tconst geometry = this.store.getGeometryCopy<Point>(id);\n\t\t\tconst distance = this.pixelDistance.measure(event, geometry.coordinates);\n\n\t\t\tif (\n\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\tdistance < clickedFeatureDistance\n\t\t\t) {\n\t\t\t\tclickedFeatureDistance = distance;\n\t\t\t\tclickedSelectionPointProps = this.store.getPropertiesCopy(\n\t\t\t\t\tid,\n\t\t\t\t) as SelectionPointProperties;\n\t\t\t}\n\t\t});\n\n\t\tif (!clickedSelectionPointProps) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst featureId = clickedSelectionPointProps.selectionPointFeatureId;\n\t\tconst coordinateIndex = clickedSelectionPointProps.index;\n\n\t\t// We allow for preventing deleting coordinates via flags\n\t\tconst properties = this.store.getPropertiesCopy(featureId);\n\t\tconst modeFlags = this.flags[properties.mode as string];\n\t\tconst validation = this.validations[properties.mode as string];\n\n\t\t// Check if we can actually delete the coordinate\n\t\tconst cannotDelete =\n\t\t\t!modeFlags ||\n\t\t\t!modeFlags.feature ||\n\t\t\t!modeFlags.feature.coordinates ||\n\t\t\t!modeFlags.feature.coordinates.deletable;\n\n\t\tif (cannotDelete) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(featureId);\n\n\t\tlet coordinates;\n\t\tif (geometry.type === \"Polygon\") {\n\t\t\tcoordinates = geometry.coordinates[0];\n\n\t\t\t// Prevent creating an invalid polygon\n\t\t\tif (coordinates.length <= 4) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (geometry.type === \"LineString\") {\n\t\t\tcoordinates = geometry.coordinates;\n\n\t\t\t// Prevent creating an invalid linestring\n\t\t\tif (coordinates.length <= 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Geometry is not Polygon or LineString\n\t\tif (!coordinates) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isFinalPolygonCoordinate =\n\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t(coordinateIndex === 0 || coordinateIndex === coordinates.length - 1);\n\n\t\tif (isFinalPolygonCoordinate) {\n\t\t\t// Deleting the final coordinate in a polygon breaks it\n\t\t\t// because GeoJSON expects a duplicate, so we need to fix\n\t\t\t// it by adding the new first coordinate to the end\n\t\t\tcoordinates.shift();\n\t\t\tcoordinates.pop();\n\t\t\tcoordinates.push([coordinates[0][0], coordinates[0][1]]);\n\t\t} else {\n\t\t\t// Remove coordinate from array\n\t\t\tcoordinates.splice(coordinateIndex, 1);\n\t\t}\n\n\t\t// Validate the new geometry\n\t\tif (validation) {\n\t\t\tconst validationResult = validation(\n\t\t\t\t{\n\t\t\t\t\tid: featureId,\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Commit,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst deletePoints = [...this.midPoints.ids, ...this.selectionPoints.ids];\n\n\t\tthis.store.delete(deletePoints);\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: featureId,\n\t\t\t\tgeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (properties.coordinatePointIds) {\n\t\t\tthis.coordinatePoints.createOrUpdate(featureId);\n\t\t}\n\n\t\tthis.selectionPoints.create(\n\t\t\tcoordinates,\n\t\t\tgeometry.type as \"Polygon\" | \"LineString\",\n\t\t\tfeatureId,\n\t\t);\n\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.coordinates &&\n\t\t\tmodeFlags.feature.coordinates.midpoints\n\t\t) {\n\t\t\tthis.midPoints.create(coordinates, featureId, this.coordinatePrecision);\n\t\t}\n\t}\n\n\tprivate select(featureId: FeatureId, fromCursor = true) {\n\t\tif (this.selected[0] === featureId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { mode } = this.store.getPropertiesCopy(featureId);\n\n\t\t// This will be undefined for points\n\t\tconst modeFlags = this.flags[mode as string];\n\n\t\t// If feature is not selectable then return\n\t\tif (!modeFlags || !modeFlags.feature) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst previouslySelectedId = this.selected[0];\n\n\t\t// If we have something currently selected\n\t\tif (previouslySelectedId) {\n\t\t\t// If it matches the current selected feature id, do nothing\n\t\t\tif (previouslySelectedId === featureId) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// If it's a different feature set selected\n\t\t\t\t// to false on previously selected feature\n\t\t\t\tthis.deselect();\n\t\t\t}\n\t\t}\n\n\t\tif (fromCursor) {\n\t\t\tthis.setCursor(this.cursors.pointerOver);\n\t\t}\n\n\t\t// Select feature\n\t\tthis.selected = [featureId];\n\n\t\tthis.store.updateProperty([\n\t\t\t{ id: featureId, property: SELECT_PROPERTIES.SELECTED, value: true },\n\t\t]);\n\t\tthis.onSelect(featureId);\n\n\t\t// Get the clicked feature\n\t\tconst { type, coordinates } = this.store.getGeometryCopy(featureId);\n\n\t\tif (type !== \"LineString\" && type !== \"Polygon\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// LineString does not have nesting so we can just take 'coordinates'\n\t\t// directly. Polygon is nested so we need to take [0] item in the array\n\t\tconst selectedCoords: Position[] =\n\t\t\ttype === \"LineString\" ? coordinates : coordinates[0];\n\n\t\tif (selectedCoords && modeFlags && modeFlags.feature.coordinates) {\n\t\t\tthis.selectionPoints.create(selectedCoords, type, featureId);\n\n\t\t\tif (modeFlags.feature.coordinates.midpoints) {\n\t\t\t\tthis.midPoints.create(\n\t\t\t\t\tselectedCoords,\n\t\t\t\t\tfeatureId,\n\t\t\t\t\tthis.coordinatePrecision,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onLeftClick(event: TerraDrawMouseEvent) {\n\t\tconst { clickedFeature, clickedMidPoint } = this.featuresAtMouseEvent.find(\n\t\t\tevent,\n\t\t\tthis.selected.length > 0,\n\t\t);\n\n\t\tif (this.selected.length && clickedMidPoint) {\n\t\t\t// TODO: We probably want to make sure the midpoint\n\t\t\t// is visible?\n\n\t\t\tthis.midPoints.insert(\n\t\t\t\tthis.selected[0],\n\t\t\t\tclickedMidPoint.id as string,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (clickedFeature && clickedFeature.id) {\n\t\t\tthis.select(clickedFeature.id, true);\n\t\t} else if (this.selected.length && this.allowManualDeselection) {\n\t\t\tthis.deselect();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setSelecting();\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStarted();\n\t\tthis.setStopped();\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tthis.onRightClick(event);\n\t\t} else if (\n\t\t\tevent.button === \"left\" &&\n\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)\n\t\t) {\n\t\t\tthis.onLeftClick(event);\n\t\t}\n\t}\n\n\tprivate canScale(event: TerraDrawKeyboardEvent | TerraDrawMouseEvent) {\n\t\treturn (\n\t\t\tthis.keyEvents.scale &&\n\t\t\tthis.keyEvents.scale.every((key) => event.heldKeys.includes(key))\n\t\t);\n\t}\n\n\tprivate canRotate(event: TerraDrawKeyboardEvent | TerraDrawMouseEvent) {\n\t\treturn (\n\t\t\tthis.keyEvents.rotate &&\n\t\t\tthis.keyEvents.rotate.every((key) => event.heldKeys.includes(key))\n\t\t);\n\t}\n\n\tprivate preventDefaultKeyEvent(event: TerraDrawKeyboardEvent) {\n\t\tconst isRotationKeys = this.canRotate(event);\n\t\tconst isScaleKeys = this.canScale(event);\n\n\t\t// If we are deliberately rotating or scaling then prevent default\n\t\tif (isRotationKeys || isScaleKeys) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown(event: TerraDrawKeyboardEvent) {\n\t\tthis.preventDefaultKeyEvent(event);\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tthis.preventDefaultKeyEvent(event);\n\n\t\tif (this.keyEvents.delete && event.key === this.keyEvents.delete) {\n\t\t\tif (!this.selected.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedId = this.selected[0];\n\n\t\t\t// We are technically deselecting\n\t\t\t// because the selected feature is deleted\n\t\t\t// and will no longer exist or be selected\n\t\t\tconst previouslySelected = this.selected[0];\n\t\t\tthis.onDeselect(previouslySelected);\n\n\t\t\t// Delete coordinate point first if they are present, this needs\n\t\t\t// to be done before deleting the feature\n\t\t\tthis.coordinatePoints.deletePointsByFeatureIds([selectedId]);\n\n\t\t\t// Delete all selected features\n\t\t\tthis.deleteSelected();\n\n\t\t\t// Remove all selection points\n\t\t\tthis.selectionPoints.delete();\n\t\t\tthis.midPoints.delete();\n\t\t} else if (\n\t\t\tthis.keyEvents.deselect &&\n\t\t\tevent.key === this.keyEvents.deselect\n\t\t) {\n\t\t\tthis.cleanUp();\n\t\t}\n\t}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tif (this.selected.length) {\n\t\t\tthis.deselect();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragStart, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We only need to stop the map dragging if\n\t\t// we actually have something selected\n\t\tif (!this.selected.length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the selected feature is not draggable\n\t\t// don't do anything\n\t\tconst properties = this.store.getPropertiesCopy(this.selected[0]);\n\t\tconst modeFlags = this.flags[properties.mode as string];\n\t\tconst draggable =\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\t(modeFlags.feature.draggable ||\n\t\t\t\t(modeFlags.feature.coordinates &&\n\t\t\t\t\tmodeFlags.feature.coordinates.draggable) ||\n\t\t\t\t(modeFlags.feature.coordinates &&\n\t\t\t\t\tmodeFlags.feature.coordinates.resizable) ||\n\t\t\t\t(modeFlags.feature.coordinates &&\n\t\t\t\t\ttypeof modeFlags.feature.coordinates.midpoints === \"object\" &&\n\t\t\t\t\tmodeFlags.feature.coordinates.midpoints.draggable));\n\n\t\tif (!draggable) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.dragEventCount = 0;\n\n\t\tconst selectedId = this.selected[0];\n\t\tconst draggableCoordinateIndex = this.dragCoordinate.getDraggableIndex(\n\t\t\tevent,\n\t\t\tselectedId,\n\t\t);\n\n\t\t// Drag Coordinate\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.coordinates &&\n\t\t\t(modeFlags.feature.coordinates.draggable ||\n\t\t\t\tmodeFlags.feature.coordinates.resizable) &&\n\t\t\tdraggableCoordinateIndex !== -1\n\t\t) {\n\t\t\tthis.setCursor(this.cursors.dragStart);\n\n\t\t\t// With resizable\n\t\t\tif (modeFlags.feature.coordinates.resizable) {\n\t\t\t\tthis.dragCoordinateResizeFeature.startDragging(\n\t\t\t\t\tselectedId,\n\t\t\t\t\tdraggableCoordinateIndex,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Without with resizable being set\n\t\t\t\tthis.dragCoordinate.startDragging(selectedId, draggableCoordinateIndex);\n\t\t\t}\n\n\t\t\tsetMapDraggability(false);\n\t\t\treturn;\n\t\t}\n\n\t\t// Dragging Midpoint\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.coordinates &&\n\t\t\ttypeof modeFlags.feature.coordinates.midpoints === \"object\" &&\n\t\t\tmodeFlags.feature.coordinates.midpoints.draggable\n\t\t) {\n\t\t\tconst { clickedMidPoint: draggedMidPoint } =\n\t\t\t\tthis.featuresAtMouseEvent.find(event, this.selected.length > 0);\n\n\t\t\tif (this.selected.length && draggedMidPoint) {\n\t\t\t\t// We insert the midpoint first\n\t\t\t\tthis.midPoints.insert(\n\t\t\t\t\tselectedId,\n\t\t\t\t\tdraggedMidPoint.id as string,\n\t\t\t\t\tthis.coordinatePrecision,\n\t\t\t\t);\n\n\t\t\t\tconst draggableCoordinateIndexAfterInsert =\n\t\t\t\t\tthis.dragCoordinate.getDraggableIndex(event, selectedId);\n\n\t\t\t\tthis.dragCoordinate.startDragging(\n\t\t\t\t\tselectedId,\n\t\t\t\t\tdraggableCoordinateIndexAfterInsert,\n\t\t\t\t);\n\n\t\t\t\tsetMapDraggability(false);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Drag Feature\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.draggable &&\n\t\t\tthis.dragFeature.canDrag(event, selectedId)\n\t\t) {\n\t\t\tthis.setCursor(this.cursors.dragStart);\n\t\t\tthis.dragFeature.startDragging(event, selectedId);\n\t\t\tsetMapDraggability(false);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDrag, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst selectedId = this.selected[0];\n\n\t\t// If nothing selected we can return early\n\t\tif (!selectedId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst properties = this.store.getPropertiesCopy(selectedId);\n\t\tconst modeFlags = this.flags[properties.mode as string];\n\t\tconst canSelfIntersect: boolean =\n\t\t\t(modeFlags &&\n\t\t\t\tmodeFlags.feature &&\n\t\t\t\tmodeFlags.feature.selfIntersectable) === true;\n\n\t\t// Ensure drag count is incremented\n\t\tthis.dragEventCount++;\n\n\t\t// Return if we haven't hit the drag throttle limit\n\t\t// (i.e. we only want to drag every nth event)\n\t\tif (this.dragEventCount % this.dragEventThrottle === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst validation = this.validations[properties.mode as string];\n\n\t\t// Check if should rotate\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.rotateable &&\n\t\t\tthis.canRotate(event)\n\t\t) {\n\t\t\tsetMapDraggability(false);\n\t\t\tthis.rotateFeature.rotate(event, selectedId, validation);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if should scale\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.scaleable &&\n\t\t\tthis.canScale(event)\n\t\t) {\n\t\t\tsetMapDraggability(false);\n\n\t\t\tthis.scaleFeature.scale(event, selectedId, validation);\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tthis.dragCoordinateResizeFeature.isDragging() &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.coordinates &&\n\t\t\tmodeFlags.feature.coordinates.resizable\n\t\t) {\n\t\t\tif (this.projection === \"globe\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Globe is currently unsupported projection for resizable\",\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tsetMapDraggability(false);\n\t\t\tthis.dragCoordinateResizeFeature.drag(\n\t\t\t\tevent,\n\t\t\t\tmodeFlags.feature.coordinates.resizable,\n\t\t\t\tvalidation,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if coordinate is draggable and is dragged\n\t\tif (this.dragCoordinate.isDragging()) {\n\t\t\tconst snappable = modeFlags.feature?.coordinates?.snappable;\n\n\t\t\tlet snapOptions: Snapping = { toCoordinate: false };\n\t\t\tif (snappable === true) {\n\t\t\t\tsnapOptions = { toCoordinate: true };\n\t\t\t} else if (typeof snappable === \"object\") {\n\t\t\t\tsnapOptions = snappable;\n\t\t\t}\n\n\t\t\tthis.dragCoordinate.drag(\n\t\t\t\tevent,\n\t\t\t\tcanSelfIntersect,\n\t\t\t\tvalidation,\n\t\t\t\tsnapOptions,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if feature is draggable and is dragged\n\t\tif (this.dragFeature.isDragging()) {\n\t\t\tthis.dragFeature.drag(event, validation);\n\t\t\treturn;\n\t\t}\n\n\t\tsetMapDraggability(true);\n\t}\n\n\t/** @internal */\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragEnd, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setCursor(this.cursors.dragEnd);\n\n\t\t// If we have finished dragging a coordinate or a feature\n\t\t// lets fire an onFinish event which can be listened to\n\t\tif (this.dragCoordinate.isDragging()) {\n\t\t\tthis.onFinish(this.selected[0], {\n\t\t\t\tmode: this.mode,\n\t\t\t\taction: \"dragCoordinate\",\n\t\t\t});\n\t\t} else if (this.dragFeature.isDragging()) {\n\t\t\tthis.onFinish(this.selected[0], {\n\t\t\t\tmode: this.mode,\n\t\t\t\taction: \"dragFeature\",\n\t\t\t});\n\t\t} else if (this.dragCoordinateResizeFeature.isDragging()) {\n\t\t\tthis.onFinish(this.selected[0], {\n\t\t\t\tmode: this.mode,\n\t\t\t\taction: \"dragCoordinateResize\",\n\t\t\t});\n\t\t}\n\n\t\tthis.dragCoordinate.stopDragging();\n\t\tthis.dragFeature.stopDragging();\n\t\tthis.dragCoordinateResizeFeature.stopDragging();\n\t\tthis.rotateFeature.reset();\n\t\tthis.scaleFeature.reset();\n\t\tsetMapDraggability(true);\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tif (!this.selected.length) {\n\t\t\tthis.setCursor(\"unset\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.dragFeature.isDragging()) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet nearbyMidPoint = false;\n\t\tthis.midPoints.ids.forEach((id: string) => {\n\t\t\tif (nearbyMidPoint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst geometry = this.store.getGeometryCopy<Point>(id);\n\t\t\tconst distance = this.pixelDistance.measure(event, geometry.coordinates);\n\n\t\t\tif (distance < this.pointerDistance) {\n\t\t\t\tnearbyMidPoint = true;\n\t\t\t}\n\t\t});\n\n\t\tlet nearbySelectionPoint = false;\n\t\t// TODO: Is there a cleaner way to handle prioritising\n\t\t// dragging selection points?\n\t\tthis.selectionPoints.ids.forEach((id: FeatureId) => {\n\t\t\tconst geometry = this.store.getGeometryCopy<Point>(id);\n\t\t\tconst distance = this.pixelDistance.measure(event, geometry.coordinates);\n\t\t\tif (distance < this.pointerDistance) {\n\t\t\t\tnearbyMidPoint = false;\n\t\t\t\tnearbySelectionPoint = true;\n\t\t\t}\n\t\t});\n\n\t\tif (nearbyMidPoint) {\n\t\t\tthis.setCursor(this.cursors.insertMidpoint);\n\t\t\treturn;\n\t\t}\n\n\t\t// If we have a feature under the pointer then show the pointer over cursor\n\t\tconst { clickedFeature: featureUnderPointer } =\n\t\t\tthis.featuresAtMouseEvent.find(event, true);\n\n\t\tif (\n\t\t\tthis.selected.length > 0 &&\n\t\t\t((featureUnderPointer && featureUnderPointer.id === this.selected[0]) ||\n\t\t\t\tnearbySelectionPoint)\n\t\t) {\n\t\t\tthis.setCursor(this.cursors.pointerOver);\n\t\t} else {\n\t\t\t// Set it back to whatever the default cursor is\n\t\t\tthis.setCursor(\"unset\");\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.properties.mode === this.mode &&\n\t\t\tfeature.geometry.type === \"Point\"\n\t\t) {\n\t\t\tif (feature.properties.selectionPoint) {\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectionPointColor,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectionPointOutlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectionPointWidth,\n\t\t\t\t\tstyles.pointWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectionPointOutlineWidth,\n\t\t\t\t\t2,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_THREE;\n\n\t\t\t\treturn styles;\n\t\t\t}\n\n\t\t\tif (feature.properties.midPoint) {\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.midPointColor,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.midPointOutlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.midPointWidth,\n\t\t\t\t\t4,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.midPointOutlineWidth,\n\t\t\t\t\t2,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_FIVE;\n\n\t\t\t\treturn styles;\n\t\t\t}\n\t\t} else if (feature.properties[SELECT_PROPERTIES.SELECTED]) {\n\t\t\t// Select mode shortcuts the styling of a feature if it is selected\n\t\t\t// A selected feature from another mode will end up in this block\n\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedPolygonColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedPolygonOutlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedPolygonOutlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedPolygonFillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t\treturn styles;\n\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\tstyles.lineStringColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedLineStringColor,\n\t\t\t\t\tstyles.lineStringColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.lineStringWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedLineStringWidth,\n\t\t\t\t\tstyles.lineStringWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t\treturn styles;\n\t\t\t} else if (feature.geometry.type === \"Point\") {\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedPointWidth,\n\t\t\t\t\tstyles.pointWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedPointColor,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedPointOutlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedPointOutlineWidth,\n\t\t\t\t\tstyles.pointOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t\treturn styles;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// If we have a selected feature and it has been updated\n\t\t// we need to update the selection points and midpoints\n\t\tif (this.selected.length && feature.id === this.selected[0]) {\n\t\t\tconst flags = this.flags[feature.properties.mode as string];\n\n\t\t\tif (!flags?.feature?.coordinates) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst type = feature.geometry.type as \"Polygon\" | \"LineString\";\n\t\t\tconst id = feature.id as FeatureId;\n\n\t\t\tthis.selectionPoints.delete();\n\t\t\tthis.midPoints.delete();\n\n\t\t\tlet coordinates: Position[] | undefined;\n\t\t\tif (type === \"Polygon\") {\n\t\t\t\t// For Polygon we need to take the first item in the coordinates array\n\t\t\t\tcoordinates = feature.geometry.coordinates[0] as Position[];\n\t\t\t} else if (type === \"LineString\") {\n\t\t\t\t// For LineString we can take the coordinates directly\n\t\t\t\tcoordinates = feature.geometry.coordinates as Position[];\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.selectionPoints.create(coordinates, type, id);\n\n\t\t\tif (flags?.feature?.coordinates?.midpoints) {\n\t\t\t\tthis.midPoints.create(\n\t\t\t\t\t(type === \"Polygon\"\n\t\t\t\t\t\t? feature.geometry.coordinates[0]\n\t\t\t\t\t\t: feature.geometry.coordinates) as Position[],\n\t\t\t\t\tid,\n\t\t\t\t\tthis.coordinatePrecision,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n","import { TerraDrawAdapterStyling } from \"../../common\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport { ModeTypes, TerraDrawBaseDrawMode } from \"../base.mode\";\n\ntype StaticModeStylingExt<T extends TerraDrawAdapterStyling> = {};\ntype StaticModeStyling = StaticModeStylingExt<TerraDrawAdapterStyling>;\n\nexport class TerraDrawStaticMode extends TerraDrawBaseDrawMode<StaticModeStyling> {\n\ttype = ModeTypes.Static;\n\tmode = \"static\" as const;\n\tstart() {}\n\tstop() {}\n\tonKeyUp() {}\n\tonKeyDown() {}\n\tonClick() {}\n\tonDragStart() {}\n\tonDrag() {}\n\tonDragEnd() {}\n\tonMouseMove() {}\n\tcleanUp() {}\n\tstyleFeature() {\n\t\treturn { ...getDefaultStyling() };\n\t}\n}\n","// ISC License\n// Copyright (c) 2018, Vladimir Agafonkin\n\nexport type CompareFunction<T> = (a: T, b: T) => number;\n\nexport function quickselect<T>(\n\tarr: T[],\n\tk: number,\n\tleft: number,\n\tright: number,\n\tcompare: CompareFunction<T>,\n) {\n\twhile (right > left) {\n\t\tif (right - left > 600) {\n\t\t\tconst n = right - left + 1;\n\t\t\tconst m = k - left + 1;\n\t\t\tconst z = Math.log(n);\n\t\t\tconst s = 0.5 * Math.exp((2 * z) / 3);\n\t\t\tconst sd =\n\t\t\t\t0.5 * Math.sqrt((z * s * (n - s)) / n) * (m - n / 2 < 0 ? -1 : 1);\n\t\t\tconst newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));\n\t\t\tconst newRight = Math.min(right, Math.floor(k + ((n - m) * s) / n + sd));\n\t\t\tquickselect(arr, k, newLeft, newRight, compare);\n\t\t}\n\n\t\tconst t = arr[k];\n\t\tlet i = left;\n\t\tlet j = right;\n\n\t\tswap(arr, left, k);\n\t\tif (compare(arr[right], t) > 0) swap(arr, left, right);\n\n\t\twhile (i < j) {\n\t\t\tswap(arr, i, j);\n\t\t\ti++;\n\t\t\tj--;\n\t\t\twhile (compare(arr[i], t) < 0) i++;\n\t\t\twhile (compare(arr[j], t) > 0) j--;\n\t\t}\n\n\t\tif (compare(arr[left], t) === 0) {\n\t\t\tswap(arr, left, j);\n\t\t} else {\n\t\t\tj++;\n\t\t\tswap(arr, j, right);\n\t\t}\n\n\t\tif (j <= k) left = j + 1;\n\t\tif (k <= j) right = j - 1;\n\t}\n}\n\nfunction swap<T>(arr: T[], i: number, j: number) {\n\tconst tmp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = tmp;\n}\n","// Base on Rbush - https://github.com/mourner/rbush\n// MIT License\n// Copyright (c) 2016 Vladimir Agafonkin\n\nimport { CompareFunction, quickselect } from \"./quickselect\";\n\nexport type Node = {\n\tchildren: Node[];\n\theight: number;\n\tleaf: boolean;\n\tminX: number;\n\tminY: number;\n\tmaxX: number;\n\tmaxY: number;\n};\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node: Node, toBBox: (node: Node) => any) {\n\tdistBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(\n\tnode: Node,\n\tk: number,\n\tp: number,\n\ttoBBox: (node: Node) => Node,\n\tdestNode?: Node,\n) {\n\tif (!destNode) destNode = createNode([]);\n\tdestNode.minX = Infinity;\n\tdestNode.minY = Infinity;\n\tdestNode.maxX = -Infinity;\n\tdestNode.maxY = -Infinity;\n\n\tfor (let i = k; i < p; i++) {\n\t\tconst child = node.children[i];\n\t\textend(destNode, node.leaf ? toBBox(child) : child);\n\t}\n\n\treturn destNode;\n}\n\nfunction extend(a: Node, b: Node) {\n\ta.minX = Math.min(a.minX, b.minX);\n\ta.minY = Math.min(a.minY, b.minY);\n\ta.maxX = Math.max(a.maxX, b.maxX);\n\ta.maxY = Math.max(a.maxY, b.maxY);\n\treturn a;\n}\n\nfunction compareNodeMinX(a: Node, b: Node) {\n\treturn a.minX - b.minX;\n}\nfunction compareNodeMinY(a: Node, b: Node) {\n\treturn a.minY - b.minY;\n}\n\nfunction bboxArea(a: Node) {\n\treturn (a.maxX - a.minX) * (a.maxY - a.minY);\n}\nfunction bboxMargin(a: {\n\tminX: number;\n\tminY: number;\n\tmaxX: number;\n\tmaxY: number;\n}) {\n\treturn a.maxX - a.minX + (a.maxY - a.minY);\n}\n\nfunction enlargedArea(a: Node, b: Node) {\n\treturn (\n\t\t(Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n\t\t(Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY))\n\t);\n}\n\nfunction intersectionArea(a: Node, b: Node) {\n\tconst minX = Math.max(a.minX, b.minX);\n\tconst minY = Math.max(a.minY, b.minY);\n\tconst maxX = Math.min(a.maxX, b.maxX);\n\tconst maxY = Math.min(a.maxY, b.maxY);\n\n\treturn Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\n\nfunction contains(a: Node, b: Node) {\n\treturn (\n\t\ta.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY\n\t);\n}\n\nfunction intersects(a: Node, b: Node) {\n\treturn (\n\t\tb.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY\n\t);\n}\n\nfunction createNode(children: Node[]) {\n\treturn {\n\t\tchildren,\n\t\theight: 1,\n\t\tleaf: true,\n\t\tminX: Infinity,\n\t\tminY: Infinity,\n\t\tmaxX: -Infinity,\n\t\tmaxY: -Infinity,\n\t};\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect<T>(\n\tarr: T[],\n\tleft: number,\n\tright: number,\n\tn: number,\n\tcompare: CompareFunction<T>,\n) {\n\tconst stack = [left, right];\n\n\twhile (stack.length) {\n\t\tright = stack.pop() as number;\n\t\tleft = stack.pop() as number;\n\n\t\tif (right - left <= n) continue;\n\n\t\tconst mid = left + Math.ceil((right - left) / n / 2) * n;\n\t\tquickselect(arr, mid, left, right, compare);\n\n\t\tstack.push(left, mid, mid, right);\n\t}\n}\n\nexport class RBush {\n\tprivate _maxEntries: number;\n\tprivate _minEntries: number;\n\tprivate data!: Node;\n\n\tconstructor(maxEntries: number) {\n\t\t// max entries in a node is 9 by default; min node fill is 40% for best performance\n\t\tthis._maxEntries = Math.max(4, maxEntries);\n\t\tthis._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\t\tthis.clear();\n\t}\n\n\tsearch(bbox: Node): Node[] {\n\t\tlet node = this.data;\n\t\tconst result: Node[] = [];\n\n\t\tif (!intersects(bbox, node)) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst toBBox = this.toBBox;\n\t\tconst nodesToSearch = [];\n\n\t\twhile (node) {\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\t\t\t\tconst childBBox = node.leaf ? toBBox(child) : child;\n\n\t\t\t\tif (intersects(bbox, childBBox)) {\n\t\t\t\t\tif (node.leaf) result.push(child);\n\t\t\t\t\telse if (contains(bbox, childBBox)) this._all(child, result);\n\t\t\t\t\telse nodesToSearch.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = nodesToSearch.pop() as Node;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tcollides(bbox: Node) {\n\t\tlet node = this.data;\n\n\t\tconst intersect = intersects(bbox, node);\n\t\tif (intersect) {\n\t\t\tconst nodesToSearch = [];\n\t\t\twhile (node) {\n\t\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\t\tconst child = node.children[i];\n\t\t\t\t\tconst childBBox = node.leaf ? this.toBBox(child) : child;\n\n\t\t\t\t\tif (intersects(bbox, childBBox)) {\n\t\t\t\t\t\tif (node.leaf || contains(bbox, childBBox)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnodesToSearch.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode = nodesToSearch.pop() as Node;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tload(data: Node[]): void {\n\t\tif (data.length < this._minEntries) {\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tthis.insert(data[i]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// recursively build the tree with the given data from scratch using OMT algorithm\n\t\tlet node = this._build(data.slice(), 0, data.length - 1, 0);\n\n\t\tif (!this.data.children.length) {\n\t\t\t// save as is if tree is empty\n\t\t\tthis.data = node;\n\t\t} else if (this.data.height === node.height) {\n\t\t\t// split root if trees have the same height\n\t\t\tthis._splitRoot(this.data, node);\n\t\t} else {\n\t\t\tif (this.data.height < node.height) {\n\t\t\t\t// swap trees if inserted one is bigger\n\t\t\t\tconst tmpNode = this.data;\n\t\t\t\tthis.data = node;\n\t\t\t\tnode = tmpNode;\n\t\t\t}\n\n\t\t\t// insert the small tree into the large tree at appropriate level\n\t\t\tthis._insert(node, this.data.height - node.height - 1, true);\n\t\t}\n\t}\n\n\tinsert(item: Node): void {\n\t\tthis._insert(item, this.data.height - 1);\n\t}\n\n\tclear(): void {\n\t\tthis.data = createNode([]);\n\t}\n\n\tremove(item: Node): void {\n\t\tlet node: Node | null = this.data;\n\t\tconst bbox = this.toBBox(item);\n\t\tconst path = [];\n\t\tconst indexes: number[] = [];\n\t\tlet i: number | undefined;\n\t\tlet parent: Node | undefined;\n\t\tlet goingUp = false;\n\n\t\t// depth-first iterative tree traversal\n\t\twhile (node || path.length) {\n\t\t\tif (!node) {\n\t\t\t\t// go up\n\t\t\t\tnode = path.pop() as Node;\n\t\t\t\tparent = path[path.length - 1];\n\t\t\t\ti = indexes.pop() as number;\n\t\t\t\tgoingUp = true;\n\t\t\t}\n\n\t\t\tif (node.leaf) {\n\t\t\t\t// check current node\n\n\t\t\t\tconst index = node.children.indexOf(item);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\t// item found, remove the item and condense tree upwards\n\t\t\t\t\tnode.children.splice(index, 1);\n\t\t\t\t\tpath.push(node);\n\t\t\t\t\tthis._condense(path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!goingUp && !node.leaf && contains(node, bbox)) {\n\t\t\t\t// go down\n\t\t\t\tpath.push(node);\n\t\t\t\tindexes.push(i as number);\n\t\t\t\ti = 0;\n\t\t\t\tparent = node;\n\t\t\t\tnode = node.children[0];\n\t\t\t} else if (parent) {\n\t\t\t\t// go right\n\t\t\t\t(i as number)++;\n\t\t\t\tnode = parent.children[i as number];\n\t\t\t\tgoingUp = false;\n\t\t\t} else {\n\t\t\t\tnode = null; // nothing found\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate toBBox<T>(item: T): T {\n\t\treturn item;\n\t}\n\n\tprivate compareMinX(a: Node, b: Node) {\n\t\treturn a.minX - b.minX;\n\t}\n\tprivate compareMinY(a: Node, b: Node) {\n\t\treturn a.minY - b.minY;\n\t}\n\n\tprivate _all(node: Node, result: Node[]) {\n\t\tconst nodesToSearch = [];\n\t\twhile (node) {\n\t\t\tif (node.leaf) result.push(...node.children);\n\t\t\telse nodesToSearch.push(...node.children);\n\n\t\t\tnode = nodesToSearch.pop() as Node;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _build(items: Node[], left: number, right: number, height: number) {\n\t\tconst N = right - left + 1;\n\t\tlet M = this._maxEntries;\n\t\tlet node;\n\n\t\tif (N <= M) {\n\t\t\t// reached leaf level; return leaf\n\t\t\tnode = createNode(items.slice(left, right + 1));\n\t\t\tcalcBBox(node, this.toBBox);\n\t\t\treturn node;\n\t\t}\n\n\t\tif (!height) {\n\t\t\t// target height of the bulk-loaded tree\n\t\t\theight = Math.ceil(Math.log(N) / Math.log(M));\n\n\t\t\t// target number of root entries to maximize storage utilization\n\t\t\tM = Math.ceil(N / Math.pow(M, height - 1));\n\t\t}\n\n\t\tnode = createNode([]);\n\t\tnode.leaf = false;\n\t\tnode.height = height;\n\n\t\t// split the items into M mostly square tiles\n\n\t\tconst N2 = Math.ceil(N / M);\n\t\tconst N1 = N2 * Math.ceil(Math.sqrt(M));\n\n\t\tmultiSelect(items, left, right, N1, this.compareMinX);\n\n\t\tfor (let i = left; i <= right; i += N1) {\n\t\t\tconst right2 = Math.min(i + N1 - 1, right);\n\n\t\t\tmultiSelect(items, i, right2, N2, this.compareMinY);\n\n\t\t\tfor (let j = i; j <= right2; j += N2) {\n\t\t\t\tconst right3 = Math.min(j + N2 - 1, right2);\n\n\t\t\t\t// pack each entry recursively\n\t\t\t\tnode.children.push(this._build(items, j, right3, height - 1));\n\t\t\t}\n\t\t}\n\n\t\tcalcBBox(node, this.toBBox);\n\n\t\treturn node;\n\t}\n\n\tprivate _chooseSubtree(bbox: Node, node: Node, level: number, path: Node[]) {\n\t\twhile (true) {\n\t\t\tpath.push(node);\n\n\t\t\tif (node.leaf || path.length - 1 === level) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet minArea = Infinity;\n\t\t\tlet minEnlargement = Infinity;\n\t\t\tlet targetNode;\n\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\n\t\t\t\tconst area = bboxArea(child);\n\t\t\t\tconst enlargement = enlargedArea(bbox, child) - area;\n\n\t\t\t\t// choose entry with the least area enlargement\n\n\t\t\t\tif (enlargement < minEnlargement) {\n\t\t\t\t\tminEnlargement = enlargement;\n\t\t\t\t\tminArea = area < minArea ? area : minArea;\n\t\t\t\t\ttargetNode = child;\n\t\t\t\t} else if (enlargement === minEnlargement) {\n\t\t\t\t\t// otherwise choose one with the smallest area\n\t\t\t\t\tif (area < minArea) {\n\t\t\t\t\t\tminArea = area;\n\t\t\t\t\t\ttargetNode = child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode = targetNode || node.children[0];\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate _insert(item: Node, level: number, isNode?: boolean) {\n\t\tconst bbox = isNode ? item : this.toBBox(item);\n\t\tconst insertPath: Node[] = [];\n\n\t\t// find the best node for accommodating the item, saving all nodes along the path too\n\t\tconst node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n\t\t// put the item into the node\n\t\tnode.children.push(item);\n\t\textend(node, bbox);\n\n\t\t// split on node overflow; propagate upwards if necessary\n\t\twhile (level >= 0) {\n\t\t\tif (insertPath[level].children.length > this._maxEntries) {\n\t\t\t\tthis._split(insertPath, level);\n\t\t\t\tlevel--;\n\t\t\t} else break;\n\t\t}\n\n\t\t// adjust bboxes along the insertion path\n\t\tthis._adjustParentBBoxes(bbox, insertPath, level);\n\t}\n\n\t// split overflowed node into two\n\tprivate _split(insertPath: Node[], level: number) {\n\t\tconst node = insertPath[level];\n\t\tconst M = node.children.length;\n\t\tconst m = this._minEntries;\n\n\t\tthis._chooseSplitAxis(node, m, M);\n\n\t\tconst splitIndex = this._chooseSplitIndex(node, m, M);\n\n\t\tconst newNode = createNode(\n\t\t\tnode.children.splice(splitIndex, node.children.length - splitIndex),\n\t\t);\n\t\tnewNode.height = node.height;\n\t\tnewNode.leaf = node.leaf;\n\n\t\tcalcBBox(node, this.toBBox);\n\t\tcalcBBox(newNode, this.toBBox);\n\n\t\tif (level) insertPath[level - 1].children.push(newNode);\n\t\telse this._splitRoot(node, newNode);\n\t}\n\n\tprivate _splitRoot(node: Node, newNode: Node) {\n\t\t// split root node\n\t\tthis.data = createNode([node, newNode]);\n\t\tthis.data.height = node.height + 1;\n\t\tthis.data.leaf = false;\n\t\tcalcBBox(this.data, this.toBBox);\n\t}\n\n\tprivate _chooseSplitIndex(node: Node, m: number, M: number) {\n\t\tlet index;\n\t\tlet minOverlap = Infinity;\n\t\tlet minArea = Infinity;\n\n\t\tfor (let i = m; i <= M - m; i++) {\n\t\t\tconst bbox1 = distBBox(node, 0, i, this.toBBox);\n\t\t\tconst bbox2 = distBBox(node, i, M, this.toBBox);\n\n\t\t\tconst overlap = intersectionArea(bbox1, bbox2);\n\t\t\tconst area = bboxArea(bbox1) + bboxArea(bbox2);\n\n\t\t\t// choose distribution with minimum overlap\n\t\t\tif (overlap < minOverlap) {\n\t\t\t\tminOverlap = overlap;\n\t\t\t\tindex = i;\n\n\t\t\t\tminArea = area < minArea ? area : minArea;\n\t\t\t} else if (overlap === minOverlap) {\n\t\t\t\t// otherwise choose distribution with minimum area\n\t\t\t\tif (area < minArea) {\n\t\t\t\t\tminArea = area;\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn index || M - m;\n\t}\n\n\t// sorts node children by the best axis for split\n\tprivate _chooseSplitAxis(node: Node, m: number, M: number) {\n\t\tconst compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n\t\tconst compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n\t\tconst xMargin = this._allDistMargin(node, m, M, compareMinX);\n\t\tconst yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n\t\t// if total distributions margin value is minimal for x, sort by minX,\n\t\t// otherwise it's already sorted by minY\n\t\tif (xMargin < yMargin) {\n\t\t\tnode.children.sort(compareMinX);\n\t\t}\n\t}\n\n\t// total margin of all possible split distributions where each node is at least m full\n\tprivate _allDistMargin(\n\t\tnode: Node,\n\t\tm: number,\n\t\tM: number,\n\t\tcompare: CompareFunction<Node>,\n\t) {\n\t\tnode.children.sort(compare);\n\n\t\tconst toBBox = this.toBBox;\n\t\tconst leftBBox = distBBox(node, 0, m, toBBox);\n\t\tconst rightBBox = distBBox(node, M - m, M, toBBox);\n\t\tlet margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n\t\tfor (let i = m; i < M - m; i++) {\n\t\t\tconst child = node.children[i];\n\t\t\textend(leftBBox, node.leaf ? toBBox(child) : child);\n\t\t\tmargin += bboxMargin(leftBBox);\n\t\t}\n\n\t\tfor (let i = M - m - 1; i >= m; i--) {\n\t\t\tconst child = node.children[i];\n\t\t\textend(rightBBox, node.leaf ? toBBox(child) : child);\n\t\t\tmargin += bboxMargin(rightBBox);\n\t\t}\n\n\t\treturn margin;\n\t}\n\n\tprivate _adjustParentBBoxes(bbox: Node, path: Node[], level: number) {\n\t\t// adjust bboxes along the given tree path\n\t\tfor (let i = level; i >= 0; i--) {\n\t\t\textend(path[i], bbox);\n\t\t}\n\t}\n\n\tprivate _condense(path: Node[]) {\n\t\t// go through the path, removing empty nodes and updating bboxes\n\t\tfor (let i = path.length - 1, siblings; i >= 0; i--) {\n\t\t\tif (path[i].children.length === 0) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsiblings = path[i - 1].children;\n\t\t\t\t\tsiblings.splice(siblings.indexOf(path[i]), 1);\n\t\t\t\t} else this.clear();\n\t\t\t} else {\n\t\t\t\tcalcBBox(path[i], this.toBBox);\n\t\t\t}\n\t\t}\n\t}\n}\n","import { Position } from \"geojson\";\nimport { FeatureId, GeoJSONStoreFeatures } from \"../store\";\nimport { RBush, Node } from \"./rbush\";\n\nexport class SpatialIndex {\n\tprivate tree: RBush;\n\tprivate idToNode: Map<FeatureId, Node>;\n\tprivate nodeToId: Map<Node, FeatureId>;\n\n\tconstructor(options?: { maxEntries: number }) {\n\t\tthis.tree = new RBush(\n\t\t\toptions && options.maxEntries ? options.maxEntries : 9,\n\t\t);\n\t\tthis.idToNode = new Map();\n\t\tthis.nodeToId = new Map();\n\t}\n\n\tprivate setMaps(feature: GeoJSONStoreFeatures, bbox: Node) {\n\t\tthis.idToNode.set(feature.id as FeatureId, bbox);\n\t\tthis.nodeToId.set(bbox, feature.id as FeatureId);\n\t}\n\n\tprivate toBBox(feature: GeoJSONStoreFeatures) {\n\t\tconst longitudes: number[] = [];\n\t\tconst latitudes: number[] = [];\n\n\t\tlet coordinates: Position[];\n\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t} else if (feature.geometry.type === \"Point\") {\n\t\t\tcoordinates = [feature.geometry.coordinates];\n\t\t} else {\n\t\t\tthrow new Error(\"Not a valid feature to turn into a bounding box\");\n\t\t}\n\n\t\tfor (let i = 0; i < coordinates.length; i++) {\n\t\t\tlatitudes.push(coordinates[i][1]);\n\t\t\tlongitudes.push(coordinates[i][0]);\n\t\t}\n\n\t\tconst minLat = Math.min(...latitudes);\n\t\tconst maxLat = Math.max(...latitudes);\n\t\tconst minLng = Math.min(...longitudes);\n\t\tconst maxLng = Math.max(...longitudes);\n\n\t\treturn {\n\t\t\tminX: minLng,\n\t\t\tminY: minLat,\n\t\t\tmaxX: maxLng,\n\t\t\tmaxY: maxLat,\n\t\t} as Node;\n\t}\n\n\tinsert(feature: GeoJSONStoreFeatures): void {\n\t\tif (this.idToNode.get(String(feature.id))) {\n\t\t\tthrow new Error(\"Feature already exists\");\n\t\t}\n\t\tconst bbox = this.toBBox(feature);\n\t\tthis.setMaps(feature, bbox);\n\t\tthis.tree.insert(bbox);\n\t}\n\n\tload(features: GeoJSONStoreFeatures[]): void {\n\t\tconst load: Node[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\t\tfeatures.forEach((feature) => {\n\t\t\tconst bbox = this.toBBox(feature);\n\t\t\tthis.setMaps(feature, bbox);\n\t\t\tif (seenIds.has(String(feature.id))) {\n\t\t\t\tthrow new Error(`Duplicate feature ID found ${feature.id}`);\n\t\t\t}\n\t\t\tseenIds.add(String(feature.id));\n\t\t\tload.push(bbox);\n\t\t});\n\t\tthis.tree.load(load);\n\t}\n\n\tupdate(feature: GeoJSONStoreFeatures): void {\n\t\tthis.remove(feature.id as FeatureId);\n\t\tconst bbox = this.toBBox(feature);\n\t\tthis.setMaps(feature, bbox);\n\t\tthis.tree.insert(bbox);\n\t}\n\n\tremove(featureId: FeatureId): void {\n\t\tconst node = this.idToNode.get(featureId);\n\t\tif (!node) {\n\t\t\tthrow new Error(`${featureId} not inserted into the spatial index`);\n\t\t}\n\n\t\tthis.tree.remove(node);\n\t}\n\n\tclear(): void {\n\t\tthis.tree.clear();\n\t}\n\n\tsearch(feature: GeoJSONStoreFeatures): FeatureId[] {\n\t\tconst found = this.tree.search(this.toBBox(feature));\n\t\treturn found.map((node) => {\n\t\t\treturn this.nodeToId.get(node) as FeatureId;\n\t\t});\n\t}\n\n\tcollides(feature: GeoJSONStoreFeatures): boolean {\n\t\treturn this.tree.collides(this.toBBox(feature));\n\t}\n}\n","import { Feature, Point, Polygon, LineString } from \"geojson\";\nimport { uuid4 } from \"../util/id\";\nimport { SpatialIndex } from \"./spatial-index/spatial-index\";\nimport { isValidTimestamp } from \"./store-feature-validation\";\nimport { Validation } from \"../common\";\n\nexport type JSON = string | number | boolean | null | JSONArray | JSONObject;\n\nexport interface JSONObject {\n\t[member: string]: JSON;\n}\ntype JSONArray = Array<JSON>;\n\ntype DefinedProperties = Record<string, JSON>;\n\nexport type GeoJSONStoreGeometries = Polygon | LineString | Point;\n\nexport type BBoxPolygon = Feature<Polygon, DefinedProperties>;\n\nexport type GeoJSONStoreFeatures = Feature<\n\tGeoJSONStoreGeometries,\n\tDefinedProperties\n>;\n\nexport type StoreValidation = {\n\tid?: FeatureId;\n} & ReturnType<Validation>;\n\ntype StoreChangeEvents = \"delete\" | \"create\" | \"update\" | \"styling\";\n\nexport type StoreChangeHandler<OnChangeContext> = (\n\tids: FeatureId[],\n\tchange: StoreChangeEvents,\n\tcontext?: OnChangeContext,\n) => void;\n\nexport type FeatureId = string | number;\n\nexport type IdStrategy<Id extends FeatureId> = {\n\tisValidId: (id: Id) => boolean;\n\tgetId: () => Id;\n};\n\ntype GeoJSONStoreConfig<Id extends FeatureId> = {\n\tidStrategy?: IdStrategy<Id>;\n\ttracked?: boolean;\n};\n\nexport const defaultIdStrategy = {\n\tgetId: <FeatureId>() => uuid4() as FeatureId,\n\tisValidId: (id: FeatureId) => typeof id === \"string\" && id.length === 36,\n};\n\nexport class GeoJSONStore<\n\tOnChangeContext extends Record<string, JSON> | undefined,\n\tId extends FeatureId = FeatureId,\n> {\n\tconstructor(config?: GeoJSONStoreConfig<Id>) {\n\t\tthis.store = {};\n\t\tthis.spatialIndex = new SpatialIndex();\n\n\t\t// Setting tracked has to happen first\n\t\t// because we use it in featureValidation\n\t\tthis.tracked = config && config.tracked === false ? false : true;\n\t\tthis.idStrategy =\n\t\t\tconfig && config.idStrategy ? config.idStrategy : defaultIdStrategy;\n\t}\n\n\tpublic idStrategy: IdStrategy<Id>;\n\n\tprivate tracked: boolean;\n\n\tprivate spatialIndex: SpatialIndex;\n\n\tprivate store: {\n\t\t[key: FeatureId]: GeoJSONStoreFeatures;\n\t};\n\n\t// Default to no-op\n\tprivate _onChange: StoreChangeHandler<OnChangeContext | undefined> = () => {};\n\n\tprivate clone<T>(obj: T): T {\n\t\treturn JSON.parse(JSON.stringify(obj));\n\t}\n\n\tgetId(): FeatureId {\n\t\treturn this.idStrategy.getId();\n\t}\n\n\thas(id: FeatureId): boolean {\n\t\treturn Boolean(this.store[id]);\n\t}\n\n\tload(\n\t\tdata: GeoJSONStoreFeatures[],\n\t\tfeatureValidation?: (\n\t\t\tfeature: unknown,\n\t\t\ttracked?: boolean,\n\t\t) => StoreValidation,\n\t\tafterFeatureAdded?: (feature: GeoJSONStoreFeatures) => void,\n\t\tcontext?: OnChangeContext,\n\t): StoreValidation[] {\n\t\tif (data.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// We don't want to update the original data\n\t\tlet clonedInputFeatures = this.clone(data);\n\n\t\tconst validations: StoreValidation[] = []; // The list of validations that we will return\n\t\tconst createdFeatures: GeoJSONStoreFeatures[] = []; // Keep track of the features we created\n\n\t\t// We filter out the features that are not valid and do not add them to the store\n\t\tclonedInputFeatures = clonedInputFeatures.filter((feature) => {\n\t\t\tif (feature.id === undefined || feature.id === null) {\n\t\t\t\tfeature.id = this.idStrategy.getId();\n\t\t\t}\n\n\t\t\tconst id = feature.id as FeatureId;\n\t\t\tif (featureValidation) {\n\t\t\t\tconst validation = featureValidation(feature);\n\n\t\t\t\t// Generic error handling if the featureValidation function\n\t\t\t\t// does not throw something more specific itself\n\t\t\t\tif (!validation.valid) {\n\t\t\t\t\tvalidations.push({ id, valid: false, reason: validation.reason });\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.tracked) {\n\t\t\t\tif (!feature.properties.createdAt) {\n\t\t\t\t\tfeature.properties.createdAt = +new Date();\n\t\t\t\t} else {\n\t\t\t\t\tconst valid = isValidTimestamp(feature.properties.createdAt);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\tvalidations.push({\n\t\t\t\t\t\t\tid: feature.id as FeatureId,\n\t\t\t\t\t\t\tvalid: false,\n\t\t\t\t\t\t\treason: \"createdAt is not a valid numeric timestamp\",\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!feature.properties.updatedAt) {\n\t\t\t\t\tfeature.properties.updatedAt = +new Date();\n\t\t\t\t} else {\n\t\t\t\t\tconst valid = isValidTimestamp(feature.properties.updatedAt);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\tvalidations.push({\n\t\t\t\t\t\t\tid: feature.id as FeatureId,\n\t\t\t\t\t\t\tvalid: false,\n\t\t\t\t\t\t\treason: \"updatedAt is not a valid numeric timestamp\",\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We have to be sure that the feature does not already exist with this ID\n\t\t\tif (this.has(id)) {\n\t\t\t\tvalidations.push({\n\t\t\t\t\tid,\n\t\t\t\t\tvalid: false,\n\t\t\t\t\treason: `Feature already exists with this id: ${id}`,\n\t\t\t\t});\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.store[id] = feature;\n\n\t\t\tcreatedFeatures.push(feature);\n\n\t\t\tvalidations.push({ id, valid: true });\n\n\t\t\t// Feature is valid so keep it in the list\n\t\t\treturn true;\n\t\t});\n\n\t\tthis.spatialIndex.load(clonedInputFeatures);\n\n\t\t// The list of changes that we will trigger to onChange\n\t\tconst changes = createdFeatures.map(({ id }) => id as FeatureId);\n\n\t\t// Only trigger onChange with a 'create' change type if we have actually created features\n\t\tif (changes.length > 0) {\n\t\t\tthis._onChange(changes, \"create\", context);\n\n\t\t\tif (afterFeatureAdded) {\n\t\t\t\tcreatedFeatures.forEach((feature) => {\n\t\t\t\t\tafterFeatureAdded(feature);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn validations;\n\t}\n\n\tsearch(\n\t\tbbox: BBoxPolygon,\n\t\tfilter?: (feature: GeoJSONStoreFeatures) => boolean,\n\t) {\n\t\tconst features = this.spatialIndex.search(bbox).map((id) => this.store[id]);\n\t\tif (filter) {\n\t\t\treturn this.clone(features.filter(filter));\n\t\t} else {\n\t\t\treturn this.clone(features);\n\t\t}\n\t}\n\n\tregisterOnChange(onChange: StoreChangeHandler<OnChangeContext | undefined>) {\n\t\tthis._onChange = (ids, change, context) => {\n\t\t\tonChange(ids, change, context);\n\t\t};\n\t}\n\n\tgetGeometryCopy<T extends GeoJSONStoreGeometries>(id: FeatureId): T {\n\t\tconst feature = this.store[id];\n\t\tif (!feature) {\n\t\t\tthrow new Error(\n\t\t\t\t`No feature with this id (${id}), can not get geometry copy`,\n\t\t\t);\n\t\t}\n\t\treturn this.clone(feature.geometry as T);\n\t}\n\n\tgetPropertiesCopy(id: FeatureId) {\n\t\tconst feature = this.store[id];\n\t\tif (!feature) {\n\t\t\tthrow new Error(\n\t\t\t\t`No feature with this id (${id}), can not get properties copy`,\n\t\t\t);\n\t\t}\n\t\treturn this.clone(feature.properties);\n\t}\n\n\tupdateProperty(\n\t\tpropertiesToUpdate: {\n\t\t\tid: FeatureId;\n\t\t\tproperty: string;\n\t\t\tvalue: JSON | undefined;\n\t\t}[],\n\t\tcontext?: OnChangeContext,\n\t): void {\n\t\tconst ids: FeatureId[] = [];\n\t\tpropertiesToUpdate.forEach(({ id, property, value }) => {\n\t\t\tconst feature = this.store[id];\n\n\t\t\tif (!feature) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No feature with this (${id}), can not update geometry`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tids.push(id);\n\n\t\t\tif (value === undefined) {\n\t\t\t\tdelete feature.properties[property];\n\t\t\t} else {\n\t\t\t\tfeature.properties[property] = value;\n\t\t\t}\n\n\t\t\t// Update the time the feature was updated\n\t\t\tif (this.tracked) {\n\t\t\t\tfeature.properties.updatedAt = +new Date();\n\t\t\t}\n\t\t});\n\n\t\tif (this._onChange) {\n\t\t\tthis._onChange(ids, \"update\", context);\n\t\t}\n\t}\n\n\tupdateGeometry(\n\t\tgeometriesToUpdate: { id: FeatureId; geometry: GeoJSONStoreGeometries }[],\n\t\tcontext?: OnChangeContext,\n\t): void {\n\t\tconst ids: FeatureId[] = [];\n\t\tgeometriesToUpdate.forEach(({ id, geometry }) => {\n\t\t\tids.push(id);\n\n\t\t\tconst feature = this.store[id];\n\n\t\t\tif (!feature) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No feature with this (${id}), can not update geometry`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfeature.geometry = this.clone(geometry);\n\n\t\t\tthis.spatialIndex.update(feature);\n\n\t\t\t// Update the time the feature was updated\n\t\t\tif (this.tracked) {\n\t\t\t\tfeature.properties.updatedAt = +new Date();\n\t\t\t}\n\t\t});\n\n\t\tif (this._onChange) {\n\t\t\tthis._onChange(ids, \"update\", context);\n\t\t}\n\t}\n\n\tcreate<Id extends FeatureId>(\n\t\tfeatures: {\n\t\t\tgeometry: GeoJSONStoreGeometries;\n\t\t\tproperties?: JSONObject;\n\t\t}[],\n\t\tcontext?: OnChangeContext,\n\t): Id[] {\n\t\tconst ids: FeatureId[] = [];\n\t\tfeatures.forEach(({ geometry, properties }) => {\n\t\t\tlet createdAt;\n\t\t\tlet createdProperties = { ...properties };\n\n\t\t\tif (this.tracked) {\n\t\t\t\tcreatedAt = +new Date();\n\n\t\t\t\tif (properties) {\n\t\t\t\t\tcreatedProperties.createdAt =\n\t\t\t\t\t\ttypeof properties.createdAt === \"number\"\n\t\t\t\t\t\t\t? properties.createdAt\n\t\t\t\t\t\t\t: createdAt;\n\t\t\t\t\tcreatedProperties.updatedAt =\n\t\t\t\t\t\ttypeof properties.updatedAt === \"number\"\n\t\t\t\t\t\t\t? properties.updatedAt\n\t\t\t\t\t\t\t: createdAt;\n\t\t\t\t} else {\n\t\t\t\t\tcreatedProperties = { createdAt, updatedAt: createdAt };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst id = this.getId();\n\t\t\tconst feature = {\n\t\t\t\tid,\n\t\t\t\ttype: \"Feature\",\n\t\t\t\tgeometry,\n\t\t\t\tproperties: createdProperties,\n\t\t\t} as GeoJSONStoreFeatures;\n\n\t\t\tthis.store[id] = feature;\n\t\t\tthis.spatialIndex.insert(feature);\n\n\t\t\tids.push(id);\n\t\t});\n\n\t\tif (this._onChange) {\n\t\t\tthis._onChange([...ids], \"create\", context);\n\t\t}\n\n\t\treturn ids as Id[];\n\t}\n\n\tdelete(ids: FeatureId[], context?: OnChangeContext): void {\n\t\tids.forEach((id) => {\n\t\t\tif (this.store[id]) {\n\t\t\t\tdelete this.store[id];\n\t\t\t\tthis.spatialIndex.remove(id as FeatureId);\n\t\t\t} else {\n\t\t\t\tthrow new Error(`No feature with id ${id}, can not delete`);\n\t\t\t}\n\t\t});\n\n\t\tif (this._onChange) {\n\t\t\tthis._onChange([...ids], \"delete\", context);\n\t\t}\n\t}\n\n\tcopy(id: FeatureId): GeoJSONStoreFeatures {\n\t\treturn this.clone(this.store[id]);\n\t}\n\n\tcopyAll(): GeoJSONStoreFeatures[] {\n\t\treturn this.clone(Object.keys(this.store).map((id) => this.store[id]));\n\t}\n\n\tcopyAllWhere(\n\t\tequals: (properties: JSONObject) => boolean,\n\t): GeoJSONStoreFeatures[] {\n\t\treturn this.clone(\n\t\t\tObject.keys(this.store)\n\t\t\t\t.map((id) => this.store[id])\n\t\t\t\t.filter((feature) => {\n\t\t\t\t\treturn feature.properties && equals(feature.properties);\n\t\t\t\t}),\n\t\t);\n\t}\n\n\tclear(): void {\n\t\tthis.store = {};\n\t\tthis.spatialIndex.clear();\n\t}\n\n\tsize(): number {\n\t\treturn Object.keys(this.store).length;\n\t}\n}\n","export const uuid4 = function (): string {\n\treturn \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n\t\tconst r = (Math.random() * 16) | 0,\n\t\t\tv = c == \"x\" ? r : (r & 0x3) | 0x8;\n\t\treturn v.toString(16);\n\t});\n};\n","import { Polygon } from \"geojson\";\nimport { earthRadius } from \"../helpers\";\n\n// Adapted from @turf/area is MIT Licensed licensed https://github.com/Turfjs/turf/blob/master/packages/turf-area/index.ts\n// In turn adapted from NASA: https://dataverse.jpl.nasa.gov/file.xhtml?fileId=47998&version=2.0\n\nexport function polygonAreaSquareMeters(polygon: Polygon) {\n\tconst coords = polygon.coordinates;\n\tlet total = 0;\n\tif (coords && coords.length > 0) {\n\t\ttotal += Math.abs(ringArea(coords[0]));\n\t\tfor (let i = 1; i < coords.length; i++) {\n\t\t\ttotal -= Math.abs(ringArea(coords[i]));\n\t\t}\n\t}\n\treturn total;\n}\n\nconst FACTOR = (earthRadius * earthRadius) / 2;\nconst PI_OVER_180 = Math.PI / 180;\n\nfunction ringArea(coords: number[][]): number {\n\tconst coordsLength = coords.length;\n\n\tif (coordsLength <= 2) {\n\t\treturn 0;\n\t}\n\n\tlet total = 0;\n\n\tlet i = 0;\n\twhile (i < coordsLength) {\n\t\tconst lower = coords[i];\n\t\tconst middle = coords[i + 1 === coordsLength ? 0 : i + 1];\n\t\tconst upper =\n\t\t\tcoords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];\n\n\t\tconst lowerX = lower[0] * PI_OVER_180;\n\t\tconst middleY = middle[1] * PI_OVER_180;\n\t\tconst upperX = upper[0] * PI_OVER_180;\n\n\t\ttotal += (upperX - lowerX) * Math.sin(middleY);\n\n\t\ti++;\n\t}\n\n\treturn total * FACTOR;\n}\n","import { Validation } from \"../common\";\nimport { polygonAreaSquareMeters } from \"../geometry/measure/area\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport { ValidationReasonFeatureNotPolygon } from \"./common-validations\";\n\nexport const ValidationReasonFeatureLessThanMinSize =\n\t\"Feature is smaller than the minimum area\";\n\nexport const ValidateMinAreaSquareMeters = (\n\tfeature: GeoJSONStoreFeatures,\n\tminSize: number,\n): ReturnType<Validation> => {\n\tif (feature.geometry.type !== \"Polygon\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPolygon,\n\t\t};\n\t}\n\n\tif (polygonAreaSquareMeters(feature.geometry) < minSize) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureLessThanMinSize,\n\t\t};\n\t}\n\n\treturn { valid: true };\n};\n","import { Validation } from \"../common\";\nimport { polygonAreaSquareMeters } from \"../geometry/measure/area\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport { ValidationReasonFeatureNotPolygon } from \"./common-validations\";\n\nexport const ValidationMaxAreaSquareMetersReason =\n\t\"Feature is larger than the maximum area\";\n\nexport const ValidateMaxAreaSquareMeters = (\n\tfeature: GeoJSONStoreFeatures,\n\tmaxSize: number,\n): ReturnType<Validation> => {\n\tif (feature.geometry.type !== \"Polygon\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPolygon,\n\t\t};\n\t}\n\n\tconst size = polygonAreaSquareMeters(feature.geometry);\n\n\tif (size > maxSize) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationMaxAreaSquareMetersReason,\n\t\t};\n\t}\n\n\treturn { valid: true };\n};\n","import { Feature, LineString, Polygon } from \"geojson\";\nimport { selfIntersects } from \"../geometry/boolean/self-intersects\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport { Validation } from \"../common\";\n\nexport const ValidationReasonFeatureNotPolygonOrLineString =\n\t\"Feature is not a Polygon or LineString\";\nexport const ValidationReasonFeatureSelfIntersects =\n\t\"Feature intersects itself\";\n\nexport const ValidateNotSelfIntersecting = (\n\tfeature: GeoJSONStoreFeatures,\n): ReturnType<Validation> => {\n\tif (\n\t\tfeature.geometry.type !== \"Polygon\" &&\n\t\tfeature.geometry.type !== \"LineString\"\n\t) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPolygonOrLineString,\n\t\t};\n\t}\n\n\tconst hasSelfIntersections = selfIntersects(\n\t\tfeature as Feature<LineString> | Feature<Polygon>,\n\t);\n\n\tif (hasSelfIntersections) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureSelfIntersects,\n\t\t};\n\t}\n\n\treturn { valid: true };\n};\n","import { CartesianPoint } from \"../common\";\nimport { webMercatorBearing } from \"./measure/bearing\";\n\n/**\n * Calculate the relative angle between two lines\n * @param A The first point of the first line\n * @param B The second point of the first line and the first point of the second line\n * @param C The second point of the second line\n * @returns The relative angle between the two lines\n */\nexport function calculateRelativeAngle(\n\tA: CartesianPoint,\n\tB: CartesianPoint,\n\tC: CartesianPoint,\n): number {\n\tconst bearingAB = webMercatorBearing(A, B); // Bearing from A to B\n\tconst bearingBC = webMercatorBearing(B, C); // Bearing from B to C\n\n\t// Calculate the relative angle (bearingBC relative to bearingAB)\n\tlet relativeAngle = bearingBC - bearingAB;\n\n\t// Normalize the relative angle to 0-360 range\n\tif (relativeAngle < 0) {\n\t\trelativeAngle += 360;\n\t}\n\n\t// Normalise to 0 - 90\n\tconst angle = relativeAngle - 90;\n\n\treturn 180 - Math.abs(-90 + angle);\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { Polygon } from \"geojson\";\nimport {\n\tTerraDrawBaseDrawMode,\n\tBaseModeOptions,\n\tCustomStyling,\n} from \"../base.mode\";\nimport { coordinatesIdentical } from \"../../geometry/coordinates-identical\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { webMercatorDestination } from \"../../geometry/measure/destination\";\nimport { webMercatorBearing } from \"../../geometry/measure/bearing\";\nimport { midpointCoordinate } from \"../../geometry/midpoint-coordinate\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../geometry/project/web-mercator\";\nimport { degreesToRadians } from \"../../geometry/helpers\";\nimport { determineHalfPlane } from \"../../geometry/determine-halfplane\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { calculateRelativeAngle } from \"../../geometry/calculate-relative-angle\";\n\ntype TerraDrawPolygonModeKeyEvents = {\n\tcancel?: KeyboardEvent[\"key\"] | null;\n\tfinish?: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype PolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawPolygonModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawPolygonModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawAngledRectangleMode extends TerraDrawBaseDrawMode<PolygonStyling> {\n\tmode = \"angled-rectangle\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawPolygonModeKeyEvents = defaultKeyEvents;\n\n\t// Behaviors\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\n\tconstructor(options?: TerraDrawPolygonModeOptions<PolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawPolygonModeOptions<PolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\tvalue: undefined,\n\t\t\t},\n\t\t]);\n\n\t\tconst finishedId = this.currentId;\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentId = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\n\t\tif (this.currentId === undefined || this.currentCoordinate === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t).coordinates[0];\n\n\t\tlet updatedCoordinates;\n\n\t\tif (this.currentCoordinate === 1) {\n\t\t\t// We must add a very small epsilon value so that Mapbox GL\n\t\t\t// renders the polygon - There might be a cleaner solution?\n\t\t\tconst epsilon = 1 / Math.pow(10, this.coordinatePrecision - 1);\n\t\t\tconst offset = Math.max(0.000001, epsilon);\n\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\t[event.lng, event.lat - offset],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t} else if (this.currentCoordinate === 2) {\n\t\t\tconst firstCoordinate = currentPolygonCoordinates[0];\n\t\t\tconst secondCoordinate = currentPolygonCoordinates[1];\n\t\t\tconst midpoint = midpointCoordinate(\n\t\t\t\tfirstCoordinate,\n\t\t\t\tsecondCoordinate,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t\tthis.project,\n\t\t\t\tthis.unproject,\n\t\t\t);\n\n\t\t\tconst A = lngLatToWebMercatorXY(firstCoordinate[0], firstCoordinate[1]);\n\t\t\tconst B = lngLatToWebMercatorXY(midpoint[0], midpoint[1]);\n\t\t\tconst C = lngLatToWebMercatorXY(secondCoordinate[0], secondCoordinate[1]);\n\t\t\tconst D = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\t\t// Determine if the cursor is closer to A or C\n\t\t\tconst distanceToA = cartesianDistance(D, A);\n\t\t\tconst distanceToB = cartesianDistance(D, C);\n\t\t\tconst ACloserThanC = distanceToA < distanceToB ? true : false;\n\n\t\t\t// We need to work out if the cursor is closer to A or C and then calculate the angle\n\t\t\t// between the cursor and the opposing midpoint\n\t\t\tconst relativeAngle = calculateRelativeAngle(A, B, D);\n\t\t\tconst theta = ACloserThanC\n\t\t\t\t? 90 - relativeAngle\n\t\t\t\t: calculateRelativeAngle(A, B, D) - 90;\n\n\t\t\t// We want to calculate the adjacent i.e. the calculated distance\n\t\t\t// between the cursor and the opposing midpoint\n\t\t\tconst hypotenuse = cartesianDistance(B, D);\n\t\t\tconst adjacent = Math.cos(degreesToRadians(theta)) * hypotenuse;\n\n\t\t\t// Calculate the bearing between the first and second point\n\t\t\tconst firstAndSecondPointBearing = webMercatorBearing(A, C);\n\n\t\t\t// Determine which side of the line the cursor is on\n\t\t\tconst side = determineHalfPlane(A, C, D);\n\n\t\t\t// Determine which direction to draw the rectangle\n\t\t\tconst angle = side === \"right\" ? -90 : 90;\n\n\t\t\t// Calculate the third and fourth coordinates based on the cursor position\n\t\t\tconst rectangleAngle = firstAndSecondPointBearing + angle;\n\t\t\tconst thirdCoordinateXY = webMercatorDestination(\n\t\t\t\tA,\n\t\t\t\tadjacent,\n\t\t\t\trectangleAngle,\n\t\t\t);\n\t\t\tconst fourthCoordinateXY = webMercatorDestination(\n\t\t\t\tC,\n\t\t\t\tadjacent,\n\t\t\t\trectangleAngle,\n\t\t\t);\n\n\t\t\t// Convert the third and fourth coordinates back to lng/lat\n\t\t\tconst thirdCoordinate = webMercatorXYToLngLat(\n\t\t\t\tthirdCoordinateXY.x,\n\t\t\t\tthirdCoordinateXY.y,\n\t\t\t);\n\t\t\tconst fourthCoordinate = webMercatorXYToLngLat(\n\t\t\t\tfourthCoordinateXY.x,\n\t\t\t\tfourthCoordinateXY.y,\n\t\t\t);\n\n\t\t\t// The final coordinates\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\tcurrentPolygonCoordinates[1],\n\t\t\t\t[fourthCoordinate.lng, fourthCoordinate.lat],\n\t\t\t\t[thirdCoordinate.lng, thirdCoordinate.lat],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t}\n\n\t\tif (updatedCoordinates) {\n\t\t\tthis.updatePolygonGeometry(\n\t\t\t\tthis.currentId,\n\t\t\t\tupdatedCoordinates,\n\t\t\t\tUpdateTypes.Provisional,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate updatePolygonGeometry(\n\t\tid: FeatureId,\n\t\tcoordinates: Polygon[\"coordinates\"][0],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [coordinates],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([{ id, geometry: updatedGeometry }]);\n\n\t\treturn true;\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\t// We want pointer devices (mobile/tablet) to have\n\t\t\t// similar behaviour to mouse based devices so we\n\t\t\t// trigger a mousemove event before every click\n\t\t\t// if one has not been triggered to emulate this\n\t\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\t\tthis.onMouseMove(event);\n\t\t\t}\n\t\t\tthis.mouseMove = false;\n\n\t\t\tif (this.currentCoordinate === 0) {\n\t\t\t\tconst [newId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentId = newId;\n\t\t\t\tthis.currentCoordinate++;\n\n\t\t\t\t// Ensure the state is updated to reflect drawing has started\n\t\t\t\tthis.setDrawing();\n\t\t\t} else if (this.currentCoordinate === 1 && this.currentId) {\n\t\t\t\tconst currentPolygonGeometry = this.store.getGeometryCopy<Polygon>(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\n\t\t\t\tconst previousCoordinate = currentPolygonGeometry.coordinates[0][0];\n\t\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tpreviousCoordinate,\n\t\t\t\t);\n\n\t\t\t\tif (isIdentical) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t\t[\n\t\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t],\n\t\t\t\t\tUpdateTypes.Commit,\n\t\t\t\t);\n\n\t\t\t\tif (!updated) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.currentCoordinate++;\n\t\t\t} else if (this.currentCoordinate === 2 && this.currentId) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\t// We don't want to close a unfinished polygon\n\t\t\tif (this.currentCoordinate < 2) {\n\t\t\t\tthis.cleanUp();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\ttry {\n\t\t\tif (this.currentId) {\n\t\t\t\tthis.store.delete([this.currentId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t\tthis.currentId = undefined;\n\t\tthis.currentCoordinate = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (feature.properties.mode === this.mode) {\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.fillColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a rectangle and the feature being updated is the current rectangle,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentId === feature.id) {\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.currentCoordinate = 0;\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { CartesianPoint } from \"../common\";\n\n// Function to determine the relative position of a point to a line segment\nexport function determineHalfPlane(\n\tpoint: CartesianPoint,\n\tlineStart: CartesianPoint,\n\tlineEnd: CartesianPoint,\n): string {\n\t// Calculate the vectors\n\tconst vectorLine = { x: lineEnd.x - lineStart.x, y: lineEnd.y - lineStart.y };\n\tconst vectorPoint = { x: point.x - lineStart.x, y: point.y - lineStart.y };\n\n\t// Calculate the cross product\n\tconst crossProduct =\n\t\tvectorLine.x * vectorPoint.y - vectorLine.y * vectorPoint.x;\n\n\t// Use a small epsilon value to handle floating-point precision errors\n\tconst epsilon = 1e-10;\n\n\tif (crossProduct > epsilon) {\n\t\treturn \"left\";\n\t} else if (crossProduct < -epsilon) {\n\t\treturn \"right\";\n\t} else {\n\t\t// Technically on the line but we treat it as left\n\t\treturn \"left\";\n\t}\n}\n","import { CartesianPoint } from \"../common\";\n\nexport function isClockwiseWebMercator(\n\tcenter: CartesianPoint,\n\tsecondCoord: CartesianPoint,\n\tthirdCoord: CartesianPoint,\n): boolean {\n\t// Calculate the vectors\n\tconst vector1 = { x: secondCoord.x - center.x, y: secondCoord.y - center.y };\n\tconst vector2 = { x: thirdCoord.x - center.x, y: thirdCoord.y - center.y };\n\n\t// Calculate the cross product\n\tconst cross = vector1.x * vector2.y - vector1.y * vector2.x;\n\n\t// If the cross product is negative, the third point is on the right (clockwise)\n\t// If the cross product is positive, the third point is on the left (anticlockwise)\n\treturn cross <= 0;\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { Polygon, Position } from \"geojson\";\nimport {\n\tTerraDrawBaseDrawMode,\n\tBaseModeOptions,\n\tCustomStyling,\n} from \"../base.mode\";\nimport { coordinatesIdentical } from \"../../geometry/coordinates-identical\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { webMercatorDestination } from \"../../geometry/measure/destination\";\nimport {\n\tnormalizeBearing,\n\twebMercatorBearing,\n} from \"../../geometry/measure/bearing\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../geometry/project/web-mercator\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { isClockwiseWebMercator } from \"../../geometry/clockwise\";\nimport { limitPrecision } from \"../../geometry/limit-decimal-precision\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\n\ntype TerraDrawSectorModeKeyEvents = {\n\tcancel?: KeyboardEvent[\"key\"] | null;\n\tfinish?: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype SectorPolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawSectorModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tarcPoints?: number;\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawSectorModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawSectorMode extends TerraDrawBaseDrawMode<SectorPolygonStyling> {\n\tmode = \"sector\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawSectorModeKeyEvents = defaultKeyEvents;\n\tprivate direction: \"clockwise\" | \"anticlockwise\" | undefined;\n\tprivate arcPoints: number = 64;\n\n\t// Behaviors\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\n\tconstructor(options?: TerraDrawSectorModeOptions<SectorPolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawSectorModeOptions<SectorPolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.arcPoints) {\n\t\t\tthis.arcPoints = options.arcPoints;\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fix right hand rule if necessary\n\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId),\n\t\t);\n\t\tif (correctedGeometry) {\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{ id: this.currentId, geometry: correctedGeometry },\n\t\t\t]);\n\t\t}\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\tvalue: undefined,\n\t\t\t},\n\t\t]);\n\n\t\tconst finishedId = this.currentId;\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentId = undefined;\n\t\tthis.direction = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\n\t\tif (this.currentId === undefined || this.currentCoordinate === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t).coordinates[0];\n\n\t\tlet updatedCoordinates: Polygon[\"coordinates\"][0] | undefined;\n\n\t\tif (this.currentCoordinate === 1) {\n\t\t\t// We must add a very small epsilon value so that Mapbox GL\n\t\t\t// renders the polygon - There might be a cleaner solution?\n\t\t\tconst epsilon = 1 / Math.pow(10, this.coordinatePrecision - 1);\n\t\t\tconst offset = Math.max(0.000001, epsilon);\n\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\t[event.lng, event.lat - offset],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t} else if (this.currentCoordinate === 2) {\n\t\t\tconst center = currentPolygonCoordinates[0];\n\t\t\tconst arcCoordOne = currentPolygonCoordinates[1];\n\t\t\tconst arcCoordTwo = [event.lng, event.lat];\n\n\t\t\t// Convert coordinates to Web Mercator\n\t\t\tconst webMercatorCenter = lngLatToWebMercatorXY(center[0], center[1]);\n\t\t\tconst webMercatorArcCoordOne = lngLatToWebMercatorXY(\n\t\t\t\tarcCoordOne[0],\n\t\t\t\tarcCoordOne[1],\n\t\t\t);\n\t\t\tconst webMercatorArcCoordTwo = lngLatToWebMercatorXY(\n\t\t\t\tarcCoordTwo[0],\n\t\t\t\tarcCoordTwo[1],\n\t\t\t);\n\n\t\t\t// We want to determine the direction of the sector, whether\n\t\t\t// it is clockwise or anticlockwise\n\t\t\tif (this.direction === undefined) {\n\t\t\t\tconst clockwise = isClockwiseWebMercator(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\twebMercatorArcCoordOne,\n\t\t\t\t\twebMercatorArcCoordTwo,\n\t\t\t\t);\n\t\t\t\tthis.direction = clockwise ? \"clockwise\" : \"anticlockwise\";\n\t\t\t}\n\n\t\t\t// Calculate the radius (distance from center to second point in Web Mercator)\n\t\t\tconst radius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordOne,\n\t\t\t);\n\n\t\t\t// Calculate bearings for the second and third points in Web Mercator\n\t\t\tconst startBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordOne,\n\t\t\t);\n\t\t\tconst endBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordTwo,\n\t\t\t);\n\n\t\t\t// Generate points along the arc in Web Mercator\n\t\t\tconst numberOfPoints = this.arcPoints; // Number of points to approximate the arc\n\t\t\tconst coordinates: Position[] = [center]; // Start with the center (in WGS84)\n\n\t\t\t// Corrected version to calculate deltaBearing\n\t\t\tconst normalizedStart = normalizeBearing(startBearing);\n\t\t\tconst normalizedEnd = normalizeBearing(endBearing);\n\n\t\t\t// Calculate the delta bearing based on the direction\n\t\t\tlet deltaBearing;\n\t\t\tif (this.direction === \"anticlockwise\") {\n\t\t\t\tdeltaBearing = normalizedEnd - normalizedStart;\n\t\t\t\tif (deltaBearing < 0) {\n\t\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdeltaBearing = normalizedStart - normalizedEnd;\n\t\t\t\tif (deltaBearing < 0) {\n\t\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst bearingStep =\n\t\t\t\t((this.direction === \"anticlockwise\" ? 1 : -1) * deltaBearing) /\n\t\t\t\tnumberOfPoints;\n\n\t\t\t// Add the first coordinate to the polygon\n\t\t\tcoordinates.push(arcCoordOne);\n\n\t\t\t// Add all the arc points\n\t\t\tfor (let i = 0; i <= numberOfPoints; i++) {\n\t\t\t\tconst currentBearing = normalizedStart + i * bearingStep;\n\t\t\t\tconst pointOnArc = webMercatorDestination(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\tradius,\n\t\t\t\t\tcurrentBearing,\n\t\t\t\t);\n\t\t\t\tconst { lng, lat } = webMercatorXYToLngLat(pointOnArc.x, pointOnArc.y);\n\n\t\t\t\tconst nextCoord = [\n\t\t\t\t\tlimitPrecision(lng, this.coordinatePrecision),\n\t\t\t\t\tlimitPrecision(lat, this.coordinatePrecision),\n\t\t\t\t];\n\n\t\t\t\tconst notIdentical =\n\t\t\t\t\tnextCoord[0] !== coordinates[coordinates.length - 1][0] &&\n\t\t\t\t\tnextCoord[1] !== coordinates[coordinates.length - 1][1];\n\t\t\t\tif (notIdentical) {\n\t\t\t\t\tcoordinates.push(nextCoord);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Close the polygon\n\t\t\tcoordinates.push(center);\n\n\t\t\tupdatedCoordinates = [...coordinates];\n\t\t}\n\n\t\tif (updatedCoordinates) {\n\t\t\tthis.updatePolygonGeometry(\n\t\t\t\tthis.currentId,\n\t\t\t\tupdatedCoordinates,\n\t\t\t\tUpdateTypes.Provisional,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate updatePolygonGeometry(\n\t\tid: FeatureId,\n\t\tcoordinates: Polygon[\"coordinates\"][0],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [coordinates],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([{ id, geometry: updatedGeometry }]);\n\n\t\treturn true;\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\t// We want pointer devices (mobile/tablet) to have\n\t\t\t// similar behaviour to mouse based devices so we\n\t\t\t// trigger a mousemove event before every click\n\t\t\t// if one has not been triggered to emulate this\n\t\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\t\tthis.onMouseMove(event);\n\t\t\t}\n\t\t\tthis.mouseMove = false;\n\n\t\t\tif (this.currentCoordinate === 0) {\n\t\t\t\tconst [newId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentId = newId;\n\t\t\t\tthis.currentCoordinate++;\n\n\t\t\t\t// Ensure the state is updated to reflect drawing has started\n\t\t\t\tthis.setDrawing();\n\t\t\t} else if (this.currentCoordinate === 1 && this.currentId) {\n\t\t\t\tconst currentPolygonGeometry = this.store.getGeometryCopy<Polygon>(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\n\t\t\t\tconst previousCoordinate = currentPolygonGeometry.coordinates[0][0];\n\t\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tpreviousCoordinate,\n\t\t\t\t);\n\n\t\t\t\tif (isIdentical) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t\t[\n\t\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t],\n\t\t\t\t\tUpdateTypes.Commit,\n\t\t\t\t);\n\n\t\t\t\tif (!updated) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.currentCoordinate++;\n\t\t\t} else if (this.currentCoordinate === 2 && this.currentId) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\ttry {\n\t\t\tif (this.currentId) {\n\t\t\t\tthis.store.delete([this.currentId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t\tthis.currentId = undefined;\n\t\tthis.direction = undefined;\n\t\tthis.currentCoordinate = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (feature.properties.mode === this.mode) {\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.fillColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a sector and the feature being updated is the current sector,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentId === feature.id) {\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.direction = undefined;\n\t\t\tthis.currentCoordinate = 0;\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { LineString, Point, Polygon, Position } from \"geojson\";\nimport {\n\tTerraDrawBaseDrawMode,\n\tBaseModeOptions,\n\tCustomStyling,\n} from \"../base.mode\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { webMercatorDestination } from \"../../geometry/measure/destination\";\nimport {\n\tnormalizeBearing,\n\twebMercatorBearing,\n} from \"../../geometry/measure/bearing\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../geometry/project/web-mercator\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { isClockwiseWebMercator } from \"../../geometry/clockwise\";\nimport { limitPrecision } from \"../../geometry/limit-decimal-precision\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\n\ntype TerraDrawSensorModeKeyEvents = {\n\tcancel?: KeyboardEvent[\"key\"] | null;\n\tfinish?: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype SensorPolygonStyling = {\n\tcenterPointColor: HexColorStyling;\n\tcenterPointWidth: NumericStyling;\n\tcenterPointOutlineColor: HexColorStyling;\n\tcenterPointOutlineWidth: NumericStyling;\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawSensorModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tarcPoints?: number;\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawSensorModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawSensorMode extends TerraDrawBaseDrawMode<SensorPolygonStyling> {\n\tmode = \"sensor\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate currentInitialArcId: FeatureId | undefined;\n\tprivate currentStartingPointId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawSensorModeKeyEvents = defaultKeyEvents;\n\tprivate direction: \"clockwise\" | \"anticlockwise\" | undefined;\n\tprivate arcPoints: number = 64;\n\n\t// Behaviors\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\n\tconstructor(options?: TerraDrawSensorModeOptions<SensorPolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawSensorModeOptions<SensorPolygonStyling>,\n\t): void {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.arcPoints) {\n\t\t\tthis.arcPoints = options.arcPoints;\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentStartingPointId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst finishedCurrentStartingPointId = this.currentStartingPointId;\n\t\tconst finishedInitialArcId = this.currentInitialArcId;\n\t\tconst finishedCurrentId = this.currentId;\n\n\t\tif (finishedCurrentStartingPointId) {\n\t\t\tthis.store.delete([finishedCurrentStartingPointId]);\n\t\t}\n\n\t\tif (finishedInitialArcId) {\n\t\t\tthis.store.delete([finishedInitialArcId]);\n\t\t}\n\n\t\t// Fix right hand rule if necessary\n\t\tif (this.currentId) {\n\t\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId),\n\t\t\t);\n\t\t\tif (correctedGeometry) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{ id: this.currentId, geometry: correctedGeometry },\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentStartingPointId = undefined;\n\t\tthis.currentInitialArcId = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.direction = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tif (finishedCurrentId) {\n\t\t\tthis.onFinish(finishedCurrentId, { mode: this.mode, action: \"draw\" });\n\t\t}\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\n\t\tif (\n\t\t\tthis.currentInitialArcId === undefined ||\n\t\t\tthis.currentStartingPointId === undefined ||\n\t\t\tthis.currentCoordinate === 0\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.currentCoordinate === 2) {\n\t\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<LineString>(\n\t\t\t\tthis.currentInitialArcId,\n\t\t\t).coordinates;\n\t\t\tconst center = this.store.getGeometryCopy<Point>(\n\t\t\t\tthis.currentStartingPointId,\n\t\t\t).coordinates;\n\n\t\t\tconst arcCoordOne = currentPolygonCoordinates[0];\n\t\t\tconst arcCoordTwo = [event.lng, event.lat];\n\n\t\t\tconst webMercatorArcCoordOne = lngLatToWebMercatorXY(\n\t\t\t\tarcCoordOne[0],\n\t\t\t\tarcCoordOne[1],\n\t\t\t);\n\t\t\tconst webMercatorArcCoordTwo = lngLatToWebMercatorXY(\n\t\t\t\tarcCoordTwo[0],\n\t\t\t\tarcCoordTwo[1],\n\t\t\t);\n\t\t\tconst webMercatorCenter = lngLatToWebMercatorXY(center[0], center[1]);\n\n\t\t\tconst radius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordOne,\n\t\t\t);\n\n\t\t\t// We want to determine the direction of the sector, whether\n\t\t\t// it is clockwise or anticlockwise\n\t\t\tif (this.direction === undefined) {\n\t\t\t\tconst clockwise = isClockwiseWebMercator(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\twebMercatorArcCoordOne,\n\t\t\t\t\twebMercatorArcCoordTwo,\n\t\t\t\t);\n\t\t\t\tthis.direction = clockwise ? \"clockwise\" : \"anticlockwise\";\n\t\t\t}\n\n\t\t\t// Calculate bearings for the second and third points in Web Mercator\n\t\t\tconst startBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordOne,\n\t\t\t);\n\t\t\tconst endBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordTwo,\n\t\t\t);\n\n\t\t\t// Generate points along the arc in Web Mercator\n\t\t\tconst numberOfPoints = this.arcPoints; // Number of points to approximate the arc\n\t\t\tconst coordinates: Position[] = [arcCoordOne];\n\n\t\t\t// Corrected version to calculate deltaBearing\n\t\t\tconst normalizedStart = normalizeBearing(startBearing);\n\t\t\tconst normalizedEnd = normalizeBearing(endBearing);\n\n\t\t\t// Calculate the delta bearing based on the direction\n\t\t\tlet deltaBearing;\n\t\t\tif (this.direction === \"anticlockwise\") {\n\t\t\t\tdeltaBearing = normalizedEnd - normalizedStart;\n\t\t\t\tif (deltaBearing < 0) {\n\t\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdeltaBearing = normalizedStart - normalizedEnd;\n\t\t\t\tif (deltaBearing < 0) {\n\t\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst bearingStep =\n\t\t\t\t((this.direction === \"anticlockwise\" ? 1 : -1) * deltaBearing) /\n\t\t\t\tnumberOfPoints;\n\n\t\t\t// Add all the arc points\n\t\t\tfor (let i = 0; i <= numberOfPoints; i++) {\n\t\t\t\tconst currentBearing = normalizedStart + i * bearingStep;\n\t\t\t\tconst pointOnArc = webMercatorDestination(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\tradius,\n\t\t\t\t\tcurrentBearing,\n\t\t\t\t);\n\t\t\t\tconst { lng, lat } = webMercatorXYToLngLat(pointOnArc.x, pointOnArc.y);\n\n\t\t\t\tconst nextCoord = [\n\t\t\t\t\tlimitPrecision(lng, this.coordinatePrecision),\n\t\t\t\t\tlimitPrecision(lat, this.coordinatePrecision),\n\t\t\t\t];\n\n\t\t\t\tconst notIdentical =\n\t\t\t\t\tnextCoord[0] !== coordinates[coordinates.length - 1][0] &&\n\t\t\t\t\tnextCoord[1] !== coordinates[coordinates.length - 1][1];\n\t\t\t\tif (notIdentical) {\n\t\t\t\t\tcoordinates.push(nextCoord);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateLineStringGeometry(\n\t\t\t\tthis.currentInitialArcId,\n\t\t\t\tcoordinates,\n\t\t\t\tUpdateTypes.Provisional,\n\t\t\t);\n\t\t} else if (this.currentCoordinate === 3) {\n\t\t\tconst coordinates = this.store.getGeometryCopy<LineString>(\n\t\t\t\tthis.currentInitialArcId,\n\t\t\t).coordinates;\n\n\t\t\tif (coordinates.length < 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// This shouldn't happen but we protect against it in case as we can't calculate if the cursor\n\t\t\t// is in the sector otherwise\n\t\t\tif (!this.direction) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst center = this.store.getGeometryCopy<Point>(\n\t\t\t\tthis.currentStartingPointId,\n\t\t\t).coordinates;\n\n\t\t\tconst firstCoord = coordinates[0];\n\t\t\tconst lastCoord = coordinates[coordinates.length - 1];\n\n\t\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\t\t\tconst webMercatorCoordOne = lngLatToWebMercatorXY(\n\t\t\t\tfirstCoord[0],\n\t\t\t\tfirstCoord[1],\n\t\t\t);\n\t\t\tconst webMercatorCoordTwo = lngLatToWebMercatorXY(\n\t\t\t\tlastCoord[0],\n\t\t\t\tlastCoord[1],\n\t\t\t);\n\n\t\t\tconst webMercatorCenter = lngLatToWebMercatorXY(center[0], center[1]);\n\n\t\t\tconst innerRadius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCoordOne,\n\t\t\t);\n\n\t\t\tconst outerRadius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCursor,\n\t\t\t);\n\n\t\t\tconst hasLessThanZeroSize = outerRadius < innerRadius;\n\n\t\t\t// If the cursor is inside the inner radius, the depth of the sensor is always 0\n\t\t\tconst radiusCalculationPosition = hasLessThanZeroSize\n\t\t\t\t? webMercatorCoordOne\n\t\t\t\t: webMercatorCursor;\n\n\t\t\tconst cursorBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCursor,\n\t\t\t);\n\n\t\t\tconst startBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCoordOne,\n\t\t\t);\n\t\t\tconst endBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCoordTwo,\n\t\t\t);\n\n\t\t\tconst normalizedStart = normalizeBearing(startBearing);\n\t\t\tconst normalizedEnd = normalizeBearing(endBearing);\n\t\t\tconst normalizedCursor = normalizeBearing(cursorBearing);\n\n\t\t\tconst notInSector = this.notInSector({\n\t\t\t\tnormalizedCursor,\n\t\t\t\tnormalizedStart,\n\t\t\t\tnormalizedEnd,\n\t\t\t\tdirection: this.direction,\n\t\t\t});\n\n\t\t\t// If it's not a valid cursor movement then we don't update\n\t\t\tif (notInSector) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate the delta bearing based on the direction\n\t\t\tconst deltaBearing = this.getDeltaBearing(\n\t\t\t\tthis.direction,\n\t\t\t\tnormalizedStart,\n\t\t\t\tnormalizedEnd,\n\t\t\t);\n\n\t\t\t// Number of points to approximate the arc\n\t\t\tconst numberOfPoints = this.arcPoints;\n\n\t\t\t// Calculate bearing step\n\t\t\tconst multiplier = this.direction === \"anticlockwise\" ? 1 : -1;\n\t\t\tconst bearingStep = (multiplier * deltaBearing) / numberOfPoints;\n\n\t\t\tconst radius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\tradiusCalculationPosition,\n\t\t\t);\n\n\t\t\t// Add all the arc points\n\t\t\tconst finalArc = [];\n\t\t\tfor (let i = 0; i <= numberOfPoints; i++) {\n\t\t\t\tconst currentBearing = normalizedStart + i * bearingStep;\n\t\t\t\tconst pointOnArc = webMercatorDestination(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\tradius,\n\t\t\t\t\tcurrentBearing,\n\t\t\t\t);\n\t\t\t\tconst { lng, lat } = webMercatorXYToLngLat(pointOnArc.x, pointOnArc.y);\n\n\t\t\t\tconst nextCoord = [\n\t\t\t\t\tlimitPrecision(lng, this.coordinatePrecision),\n\t\t\t\t\tlimitPrecision(lat, this.coordinatePrecision),\n\t\t\t\t];\n\n\t\t\t\tconst notIdentical =\n\t\t\t\t\tnextCoord[0] !== coordinates[coordinates.length - 1][0] &&\n\t\t\t\t\tnextCoord[1] !== coordinates[coordinates.length - 1][1];\n\t\t\t\tif (notIdentical) {\n\t\t\t\t\tfinalArc.unshift(nextCoord);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoordinates.push(...finalArc);\n\n\t\t\t// Close the polygon\n\t\t\tcoordinates.push(coordinates[0]);\n\n\t\t\t// If the polygon doesn't exist, create it\n\t\t\t// else update the existing geometry\n\t\t\tif (!this.currentId) {\n\t\t\t\t[this.currentId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [coordinates],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tthis.updatePolygonGeometry(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t\tcoordinates,\n\t\t\t\t\tUpdateTypes.Provisional,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate updateLineStringGeometry(\n\t\tid: FeatureId,\n\t\tcoordinates: LineString[\"coordinates\"],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"LineString\",\n\t\t\tcoordinates,\n\t\t} as LineString;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([{ id, geometry: updatedGeometry }]);\n\n\t\treturn true;\n\t}\n\n\tprivate updatePolygonGeometry(\n\t\tid: FeatureId,\n\t\tcoordinates: Polygon[\"coordinates\"][0],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [coordinates],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([{ id, geometry: updatedGeometry }]);\n\n\t\treturn true;\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\t// We want pointer devices (mobile/tablet) to have\n\t\t\t// similar behaviour to mouse based devices so we\n\t\t\t// trigger a mousemove event before every click\n\t\t\t// if one has not been triggered to emulate this\n\t\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\t\tthis.onMouseMove(event);\n\t\t\t}\n\t\t\tthis.mouseMove = false;\n\n\t\t\tif (this.currentCoordinate === 0) {\n\t\t\t\tconst [newId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: { type: \"Point\", coordinates: [event.lng, event.lat] },\n\t\t\t\t\t\tproperties: { mode: this.mode },\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentStartingPointId = newId;\n\t\t\t\tthis.currentCoordinate++;\n\n\t\t\t\t// Ensure the state is updated to reflect drawing has started\n\t\t\t\tthis.setDrawing();\n\t\t\t} else if (this.currentCoordinate === 1 && this.currentStartingPointId) {\n\t\t\t\tconst [newId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"LineString\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: { mode: this.mode },\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentInitialArcId = newId;\n\t\t\t\tthis.currentCoordinate++;\n\t\t\t} else if (this.currentCoordinate === 2 && this.currentStartingPointId) {\n\t\t\t\tthis.currentCoordinate++;\n\t\t\t\t// pass\n\t\t\t} else if (this.currentCoordinate === 3 && this.currentStartingPointId) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\ttry {\n\t\t\tif (this.currentStartingPointId) {\n\t\t\t\tthis.store.delete([this.currentStartingPointId]);\n\t\t\t}\n\t\t\tif (this.currentInitialArcId) {\n\t\t\t\tthis.store.delete([this.currentInitialArcId]);\n\t\t\t}\n\t\t\tif (this.currentId) {\n\t\t\t\tthis.store.delete([this.currentId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t\tthis.currentStartingPointId = undefined;\n\t\tthis.direction = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.currentCoordinate = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (feature.properties.mode === this.mode) {\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.fillColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\tstyles.lineStringColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.lineStringWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t} else if (feature.geometry.type === \"Point\") {\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.centerPointColor,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.centerPointWidth,\n\t\t\t\t\tstyles.pointWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.centerPointOutlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.centerPointOutlineWidth,\n\t\t\t\t\tstyles.pointOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_TWO;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a sensor and the feature being updated is the current sensor,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentId === feature.id) {\n\t\t\tif (this.currentStartingPointId) {\n\t\t\t\tthis.store.delete([this.currentStartingPointId]);\n\t\t\t}\n\t\t\tif (this.currentInitialArcId) {\n\t\t\t\tthis.store.delete([this.currentInitialArcId]);\n\t\t\t}\n\n\t\t\tthis.currentStartingPointId = undefined;\n\t\t\tthis.direction = undefined;\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.currentCoordinate = 0;\n\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getDeltaBearing(\n\t\tdirection: \"anticlockwise\" | \"clockwise\",\n\t\tnormalizedStart: number,\n\t\tnormalizedEnd: number,\n\t) {\n\t\tlet deltaBearing;\n\t\tif (direction === \"anticlockwise\") {\n\t\t\tdeltaBearing = normalizedEnd - normalizedStart;\n\t\t\tif (deltaBearing < 0) {\n\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t}\n\t\t} else {\n\t\t\tdeltaBearing = normalizedStart - normalizedEnd;\n\t\t\tif (deltaBearing < 0) {\n\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t}\n\t\t}\n\t\treturn deltaBearing;\n\t}\n\n\tprivate notInSector({\n\t\tnormalizedCursor,\n\t\tnormalizedStart,\n\t\tnormalizedEnd,\n\t\tdirection,\n\t}: {\n\t\tnormalizedCursor: number;\n\t\tnormalizedStart: number;\n\t\tnormalizedEnd: number;\n\t\tdirection: \"clockwise\" | \"anticlockwise\";\n\t}) {\n\t\tif (direction === \"clockwise\") {\n\t\t\t// Handle clockwise direction\n\t\t\tif (normalizedStart <= normalizedEnd) {\n\t\t\t\t// Standard case (no wrap-around)\n\t\t\t\treturn (\n\t\t\t\t\tnormalizedCursor >= normalizedStart &&\n\t\t\t\t\tnormalizedCursor <= normalizedEnd\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Handle wrap-around across 360 degrees\n\t\t\t\treturn (\n\t\t\t\t\tnormalizedCursor >= normalizedStart ||\n\t\t\t\t\tnormalizedCursor <= normalizedEnd\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\t// Handle anticlockwise direction\n\t\t\tif (normalizedStart >= normalizedEnd) {\n\t\t\t\t// Standard case (no wrap-around)\n\t\t\t\treturn (\n\t\t\t\t\tnormalizedCursor <= normalizedStart &&\n\t\t\t\t\tnormalizedCursor >= normalizedEnd\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Handle wrap-around across 360 degrees\n\t\t\t\treturn (\n\t\t\t\t\tnormalizedCursor <= normalizedStart ||\n\t\t\t\t\tnormalizedCursor >= normalizedEnd\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n","export class AdapterListener<Callback extends (...args: any[]) => any> {\n\tpublic name: string;\n\tpublic callback: (...args: any[]) => any;\n\tpublic registered = false;\n\tpublic register: any;\n\tpublic unregister: any;\n\n\t/**\n\t * Creates a new AdapterListener instance with the provided configuration.\n\t *\n\t * @param {Object} config - The configuration object for the listener.\n\t * @param {string} config.name - The name of the event listener.\n\t * @param {Function} config.callback - The callback function to be called when the event is triggered.\n\t * @param {Function} config.unregister - The function to unregister the event listeners.\n\t * @param {Function} config.register - The function to register the event listeners.\n\t */\n\tconstructor({\n\t\tname,\n\t\tcallback,\n\t\tunregister,\n\t\tregister,\n\t}: {\n\t\tname: string;\n\t\tcallback: Callback;\n\t\tunregister: (callbacks: Callback) => void;\n\t\tregister: (callback: Callback) => void;\n\t}) {\n\t\tthis.name = name;\n\n\t\t// Function to register the event listeners\n\t\tthis.register = () => {\n\t\t\tif (!this.registered) {\n\t\t\t\tthis.registered = true;\n\t\t\t\tregister(callback);\n\t\t\t}\n\t\t};\n\n\t\t// Function to unregister the event listeners\n\t\tthis.unregister = () => {\n\t\t\tif (this.register) {\n\t\t\t\tthis.registered = false;\n\t\t\t\tunregister(callback);\n\t\t\t}\n\t\t};\n\n\t\tthis.callback = callback;\n\t}\n}\n","import {\n\tProject,\n\tUnproject,\n\tTerraDrawCallbacks,\n\tTerraDrawChanges,\n\tTerraDrawMouseEvent,\n\tSetCursor,\n\tTerraDrawStylingFunction,\n\tGetLngLatFromEvent,\n\tTerraDrawAdapter,\n} from \"../common\";\nimport { limitPrecision } from \"../geometry/limit-decimal-precision\";\nimport { cartesianDistance } from \"../geometry/measure/pixel-distance\";\nimport { AdapterListener } from \"./adapter-listener\";\n\ntype BasePointerListener = (event: PointerEvent) => void;\ntype BaseKeyboardListener = (event: KeyboardEvent) => void;\ntype BaseMouseListener = (event: MouseEvent) => void;\n\nexport type BaseAdapterConfig = {\n\tcoordinatePrecision?: number;\n\tminPixelDragDistanceDrawing?: number;\n\tminPixelDragDistance?: number;\n\tminPixelDragDistanceSelecting?: number;\n};\n\nexport abstract class TerraDrawBaseAdapter implements TerraDrawAdapter {\n\tconstructor(config: BaseAdapterConfig) {\n\t\tthis._minPixelDragDistance =\n\t\t\ttypeof config.minPixelDragDistance === \"number\"\n\t\t\t\t? config.minPixelDragDistance\n\t\t\t\t: 1;\n\n\t\tthis._minPixelDragDistanceSelecting =\n\t\t\ttypeof config.minPixelDragDistanceSelecting === \"number\"\n\t\t\t\t? config.minPixelDragDistanceSelecting\n\t\t\t\t: 1;\n\n\t\tthis._minPixelDragDistanceDrawing =\n\t\t\ttypeof config.minPixelDragDistanceDrawing === \"number\"\n\t\t\t\t? config.minPixelDragDistanceDrawing\n\t\t\t\t: 8;\n\n\t\tthis._coordinatePrecision =\n\t\t\ttypeof config.coordinatePrecision === \"number\"\n\t\t\t\t? config.coordinatePrecision\n\t\t\t\t: 9;\n\t}\n\n\tprivate _nextKeyUpIsContextMenu = false;\n\n\tprotected _minPixelDragDistance: number;\n\tprotected _minPixelDragDistanceDrawing: number;\n\tprotected _minPixelDragDistanceSelecting: number;\n\tprotected _lastDrawEvent: TerraDrawMouseEvent | undefined;\n\tprotected _coordinatePrecision: number;\n\tprotected _heldKeys: Set<string> = new Set();\n\tprotected _listeners: AdapterListener<\n\t\tBasePointerListener | BaseKeyboardListener | BaseMouseListener\n\t>[] = [];\n\tprotected _dragState: \"not-dragging\" | \"pre-dragging\" | \"dragging\" =\n\t\t\"not-dragging\";\n\tprotected _currentModeCallbacks: TerraDrawCallbacks | undefined;\n\n\tpublic abstract getMapEventElement(): HTMLElement;\n\n\tprotected getButton(event: PointerEvent | MouseEvent) {\n\t\tif (event.button === -1) {\n\t\t\treturn \"neither\";\n\t\t} else if (event.button === 0) {\n\t\t\treturn \"left\";\n\t\t} else if (event.button === 1) {\n\t\t\treturn \"middle\";\n\t\t} else if (event.button === 2) {\n\t\t\treturn \"right\";\n\t\t}\n\n\t\t// This shouldn't happen (?)\n\t\treturn \"neither\";\n\t}\n\n\tprotected getMapElementXYPosition(event: PointerEvent | MouseEvent) {\n\t\tconst mapElement = this.getMapEventElement();\n\t\tconst { left, top } = mapElement.getBoundingClientRect();\n\n\t\treturn {\n\t\t\tcontainerX: event.clientX - left,\n\t\t\tcontainerY: event.clientY - top,\n\t\t};\n\t}\n\n\tprotected getDrawEventFromEvent(\n\t\tevent: PointerEvent | MouseEvent,\n\t\tisContextMenu = false,\n\t): TerraDrawMouseEvent | null {\n\t\tconst latLng = this.getLngLatFromEvent(event);\n\n\t\tif (!latLng) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { lng, lat } = latLng;\n\t\tconst { containerX, containerY } = this.getMapElementXYPosition(event);\n\t\tconst button = this.getButton(event);\n\t\tconst heldKeys = Array.from(this._heldKeys);\n\n\t\treturn {\n\t\t\tlng: limitPrecision(lng, this._coordinatePrecision),\n\t\t\tlat: limitPrecision(lat, this._coordinatePrecision),\n\t\t\tcontainerX,\n\t\t\tcontainerY,\n\t\t\tbutton,\n\t\t\theldKeys,\n\t\t\tisContextMenu,\n\t\t};\n\t}\n\n\t/**\n\t * Registers the provided callbacks for the current drawing mode and attaches\n\t * the necessary event listeners.\n\t * @param {TerraDrawCallbacks} callbacks - An object containing callback functions\n\t * for handling various drawing events in the current mode.\n\t */\n\tpublic register(callbacks: TerraDrawCallbacks) {\n\t\tthis._currentModeCallbacks = callbacks;\n\n\t\tthis._listeners = this.getAdapterListeners();\n\n\t\tthis._listeners.forEach((listener) => {\n\t\t\tlistener.register();\n\t\t});\n\t}\n\n\t/**\n\t * Gets the coordinate precision. The coordinate precision is the number of decimal places in geometry\n\t * coordinates stored in the store.\n\t * @returns {number} The coordinate precision.\n\t */\n\tpublic getCoordinatePrecision() {\n\t\treturn this._coordinatePrecision;\n\t}\n\n\tprotected getAdapterListeners() {\n\t\treturn [\n\t\t\tnew AdapterListener<BasePointerListener>({\n\t\t\t\tname: \"pointerdown\",\n\t\t\t\tcallback: (event) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We don't support multitouch as this point in time\n\t\t\t\t\tif (!event.isPrimary) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst drawEvent = this.getDrawEventFromEvent(event);\n\t\t\t\t\tif (!drawEvent) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._dragState = \"pre-dragging\";\n\n\t\t\t\t\t// On pointer devices pointer mouse move events won't be\n\t\t\t\t\t// triggered so this._lastDrawEvent will not get set in\n\t\t\t\t\t// pointermove listener, so we must set it here.\n\t\t\t\t\tthis._lastDrawEvent = drawEvent;\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tthis.getMapEventElement().addEventListener(\"pointerdown\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tthis.getMapEventElement().removeEventListener(\n\t\t\t\t\t\t\"pointerdown\",\n\t\t\t\t\t\tcallback,\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener<BasePointerListener>({\n\t\t\t\tname: \"pointermove\",\n\t\t\t\tcallback: (event) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) return;\n\n\t\t\t\t\t// We don't support multitouch as this point in time\n\t\t\t\t\tif (!event.isPrimary) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\tconst drawEvent = this.getDrawEventFromEvent(event);\n\t\t\t\t\tif (!drawEvent) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._dragState === \"not-dragging\") {\n\t\t\t\t\t\t// If we're not dragging we can trigger the onMouseMove event\n\t\t\t\t\t\tthis._currentModeCallbacks.onMouseMove(drawEvent);\n\t\t\t\t\t\tthis._lastDrawEvent = drawEvent;\n\t\t\t\t\t} else if (this._dragState === \"pre-dragging\") {\n\t\t\t\t\t\t// This should always be set because of pointerdown event\n\t\t\t\t\t\tif (!this._lastDrawEvent) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst lastEventXY = {\n\t\t\t\t\t\t\tx: this._lastDrawEvent.containerX,\n\t\t\t\t\t\t\ty: this._lastDrawEvent.containerY,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst currentEventXY = {\n\t\t\t\t\t\t\tx: drawEvent.containerX,\n\t\t\t\t\t\t\ty: drawEvent.containerY,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// We only want to prevent micro drags when we are\n\t\t\t\t\t\t// drawing as doing in on selection can cause janky\n\t\t\t\t\t\t// behaviours\n\t\t\t\t\t\tconst modeState = this._currentModeCallbacks.getState();\n\n\t\t\t\t\t\tconst pixelDistanceToCheck = cartesianDistance(\n\t\t\t\t\t\t\tlastEventXY,\n\t\t\t\t\t\t\tcurrentEventXY,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// We start off assuming it is not a microdrag\n\t\t\t\t\t\tlet isMicroDrag = false;\n\n\t\t\t\t\t\tif (modeState === \"drawing\") {\n\t\t\t\t\t\t\t// We want to ignore very small pointer movements when holding\n\t\t\t\t\t\t\t// the map down as these are normally done by accident when\n\t\t\t\t\t\t\t// drawing and is not an intended drag\n\t\t\t\t\t\t\tisMicroDrag =\n\t\t\t\t\t\t\t\tpixelDistanceToCheck < this._minPixelDragDistanceDrawing;\n\t\t\t\t\t\t} else if (modeState === \"selecting\") {\n\t\t\t\t\t\t\t// Similarly when selecting, we want to ignore very small pointer\n\t\t\t\t\t\t\t// movements when holding the map down as these are normally done\n\t\t\t\t\t\t\t// by accident when drawing and is not an intended drag\n\t\t\t\t\t\t\tisMicroDrag =\n\t\t\t\t\t\t\t\tpixelDistanceToCheck < this._minPixelDragDistanceSelecting;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Same as above, but when not drawing we generally want a much lower tolerance\n\t\t\t\t\t\t\tisMicroDrag = pixelDistanceToCheck < this._minPixelDragDistance;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If it is a microdrag we do not register it by returning early\n\t\t\t\t\t\tif (isMicroDrag) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If we are dragging it is not a context menu key up event any more\n\t\t\t\t\t\tthis._nextKeyUpIsContextMenu = false;\n\n\t\t\t\t\t\tthis._dragState = \"dragging\";\n\t\t\t\t\t\tthis._currentModeCallbacks.onDragStart(\n\t\t\t\t\t\t\tdrawEvent,\n\t\t\t\t\t\t\t(enabled: boolean) => {\n\t\t\t\t\t\t\t\tthis.setDraggability.bind(this)(enabled);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (this._dragState === \"dragging\") {\n\t\t\t\t\t\tthis._currentModeCallbacks.onDrag(drawEvent, (enabled: boolean) => {\n\t\t\t\t\t\t\tthis.setDraggability.bind(this)(enabled);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"pointermove\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"pointermove\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener<BaseMouseListener>({\n\t\t\t\tname: \"contextmenu\",\n\t\t\t\tcallback: (event) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) return;\n\n\t\t\t\t\t// We do not want the context menu to open\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t// We signify that the next keyup event is related to the context menu\n\t\t\t\t\t// and we want to set isContextMenu to true\n\t\t\t\t\tthis._nextKeyUpIsContextMenu = true;\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"contextmenu\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"contextmenu\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener<BasePointerListener>({\n\t\t\t\tname: \"pointerup\",\n\t\t\t\tcallback: (event) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (event.target !== this.getMapEventElement()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We don't support multitouch as this point in time\n\t\t\t\t\tif (!event.isPrimary) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst drawEvent = this.getDrawEventFromEvent(event);\n\n\t\t\t\t\tif (!drawEvent) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._dragState === \"dragging\") {\n\t\t\t\t\t\tthis._currentModeCallbacks.onDragEnd(drawEvent, (enabled) => {\n\t\t\t\t\t\t\tthis.setDraggability.bind(this)(enabled);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tthis._dragState === \"not-dragging\" ||\n\t\t\t\t\t\tthis._dragState === \"pre-dragging\"\n\t\t\t\t\t) {\n\t\t\t\t\t\t// If we're not dragging or about to drag we\n\t\t\t\t\t\t// can trigger the onClick event\n\t\t\t\t\t\t// We want to reset it to false after we have used it\n\t\t\t\t\t\tif (this._nextKeyUpIsContextMenu) {\n\t\t\t\t\t\t\tdrawEvent.isContextMenu = true;\n\t\t\t\t\t\t\tthis._nextKeyUpIsContextMenu = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._currentModeCallbacks.onClick(drawEvent);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensure we go back to the regular behaviour\n\t\t\t\t\t// not dragging and re-enable dragging on the actual map\n\t\t\t\t\tthis._dragState = \"not-dragging\";\n\t\t\t\t\tthis.setDraggability(true);\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"pointerup\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"pointerup\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener({\n\t\t\t\tname: \"keyup\",\n\t\t\t\tcallback: (event: KeyboardEvent) => {\n\t\t\t\t\t// map has no keypress event, so we add one to the canvas itself\n\n\t\t\t\t\tif (!this._currentModeCallbacks) return;\n\n\t\t\t\t\tthis._heldKeys.delete(event.key);\n\n\t\t\t\t\tthis._currentModeCallbacks.onKeyUp({\n\t\t\t\t\t\tkey: event.key,\n\t\t\t\t\t\theldKeys: Array.from(this._heldKeys),\n\t\t\t\t\t\tpreventDefault: () => event.preventDefault(),\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"keyup\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"keyup\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener({\n\t\t\t\tname: \"keydown\",\n\t\t\t\tcallback: (event: KeyboardEvent) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._heldKeys.add(event.key);\n\n\t\t\t\t\tthis._currentModeCallbacks.onKeyDown({\n\t\t\t\t\t\tkey: event.key,\n\t\t\t\t\t\theldKeys: Array.from(this._heldKeys),\n\t\t\t\t\t\tpreventDefault: () => event.preventDefault(),\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"keydown\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"keydown\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t];\n\t}\n\n\t/**\n\t * Unregisters the event listeners for the current drawing mode.\n\t * This is typically called when switching between drawing modes or\n\t * stopping the drawing process.\n\t */\n\tpublic unregister() {\n\t\tthis._listeners.forEach((listener) => {\n\t\t\tlistener.unregister();\n\t\t});\n\n\t\tthis.clear();\n\n\t\t// This has to come last because we call this._currentModeCallbacks.onClear()\n\t\tthis._currentModeCallbacks = undefined;\n\t}\n\n\tpublic abstract clear(): void;\n\n\tpublic abstract project(...args: Parameters<Project>): ReturnType<Project>;\n\n\tpublic abstract unproject(\n\t\t...args: Parameters<Unproject>\n\t): ReturnType<Unproject>;\n\n\tpublic abstract setCursor(\n\t\t...args: Parameters<SetCursor>\n\t): ReturnType<SetCursor>;\n\n\tpublic abstract getLngLatFromEvent(\n\t\t...event: Parameters<GetLngLatFromEvent>\n\t): ReturnType<GetLngLatFromEvent>;\n\n\tpublic abstract setDraggability(enabled: boolean): void;\n\n\tpublic abstract setDoubleClickToZoom(enabled: boolean): void;\n\n\tpublic abstract render(\n\t\tchanges: TerraDrawChanges,\n\t\tstyling: TerraDrawStylingFunction,\n\t): void;\n}\n","import {\n\tValidationReasonModeMismatch,\n\tValidationReasonFeatureNotPolygon,\n} from \"./validations/common-validations\";\nimport { ValidationReasonFeatureLessThanMinSize } from \"./validations/min-size.validation\";\nimport {\n\tValidationReasonFeatureNotPolygonOrLineString,\n\tValidationReasonFeatureSelfIntersects,\n} from \"./validations/not-self-intersecting.validation\";\nimport {\n\tValidationReasonFeatureInvalidCoordinates,\n\tValidationReasonFeatureNotPoint,\n\tValidationReasonFeatureInvalidCoordinatePrecision,\n} from \"./validations/point.validation\";\nimport {\n\tValidationReasonFeatureHasHoles,\n\tValidationReasonFeatureLessThanFourCoordinates,\n\tValidationReasonFeatureHasInvalidCoordinates,\n\tValidationReasonFeatureCoordinatesNotClosed,\n} from \"./validations/polygon.validation\";\n\nexport const ValidationReasons = {\n\tValidationReasonFeatureNotPoint,\n\tValidationReasonFeatureInvalidCoordinates,\n\tValidationReasonFeatureInvalidCoordinatePrecision,\n\tValidationReasonFeatureNotPolygon,\n\tValidationReasonFeatureHasHoles,\n\tValidationReasonFeatureLessThanFourCoordinates,\n\tValidationReasonFeatureHasInvalidCoordinates,\n\tValidationReasonFeatureCoordinatesNotClosed,\n\tValidationReasonFeatureNotPolygonOrLineString,\n\tValidationReasonFeatureSelfIntersects,\n\tValidationReasonFeatureLessThanMinSize,\n\tValidationReasonModeMismatch,\n};\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tCOMMON_PROPERTIES,\n\tZ_INDEX,\n} from \"../../common\";\nimport { LineString } from \"geojson\";\n\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { ValidateLineStringFeature } from \"../../validations/linestring.validation\";\n\ntype TerraDrawFreehandLineStringModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype FreehandLineStringStyling = {\n\tlineStringWidth: NumericStyling;\n\tlineStringColor: HexColorStyling;\n\tclosingPointColor: HexColorStyling;\n\tclosingPointWidth: NumericStyling;\n\tclosingPointOutlineColor: HexColorStyling;\n\tclosingPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawFreehandLineStringModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tminDistance?: number;\n\tkeyEvents?: TerraDrawFreehandLineStringModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawFreehandLineStringMode extends TerraDrawBaseDrawMode<FreehandLineStringStyling> {\n\tmode = \"freehand-linestring\" as const;\n\n\tprivate startingClick = false;\n\tprivate currentId: FeatureId | undefined;\n\tprivate closingPointId: FeatureId | undefined;\n\tprivate minDistance: number = 20;\n\tprivate keyEvents: TerraDrawFreehandLineStringModeKeyEvents =\n\t\tdefaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate preventNewFeature = false;\n\n\tconstructor(\n\t\toptions?: TerraDrawFreehandLineStringModeOptions<FreehandLineStringStyling>,\n\t) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tpublic updateOptions(\n\t\toptions?:\n\t\t\t| TerraDrawFreehandLineStringModeOptions<FreehandLineStringStyling>\n\t\t\t| undefined,\n\t): void {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.minDistance) {\n\t\t\tthis.minDistance = options.minDistance;\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fix right hand rule if necessary\n\t\tif (this.currentId) {\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tconst finishedId = this.currentId;\n\n\t\tif (this.validate && finishedId) {\n\t\t\tconst currentGeometry =\n\t\t\t\tthis.store.getGeometryCopy<LineString>(finishedId);\n\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: finishedId,\n\t\t\t\t\tgeometry: currentGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.closingPointId) {\n\t\t\tthis.store.delete([this.closingPointId]);\n\t\t}\n\t\tthis.startingClick = false;\n\t\tthis.currentId = undefined;\n\t\tthis.closingPointId = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\t// Ensure that any listerers are triggered with the main created geometry\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tif (this.currentId === undefined || this.startingClick === false) {\n\t\t\tthis.setCursor(this.cursors.start);\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst previousIndex = currentLineGeometry.coordinates.length - 2;\n\t\tconst [previousLng, previousLat] =\n\t\t\tcurrentLineGeometry.coordinates[previousIndex];\n\t\tconst { x, y } = this.project(previousLng, previousLat);\n\t\tconst distance = cartesianDistance(\n\t\t\t{ x, y },\n\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t);\n\n\t\tconst [closingLng, closingLat] =\n\t\t\tcurrentLineGeometry.coordinates[\n\t\t\t\tcurrentLineGeometry.coordinates.length - 1\n\t\t\t];\n\t\tconst { x: closingX, y: closingY } = this.project(closingLng, closingLat);\n\t\tconst closingDistance = cartesianDistance(\n\t\t\t{ x: closingX, y: closingY },\n\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t);\n\n\t\tif (closingDistance < this.pointerDistance) {\n\t\t\tthis.setCursor(this.cursors.close);\n\t\t} else {\n\t\t\tthis.setCursor(this.cursors.start);\n\t\t}\n\n\t\t// The cusor must have moved a minimum distance\n\t\t// before we add another coordinate\n\t\tif (distance < this.minDistance) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst newGeometry = {\n\t\t\ttype: \"LineString\",\n\t\t\tcoordinates: [...currentLineGeometry.coordinates, [event.lng, event.lat]],\n\t\t} as LineString;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tgeometry: newGeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (this.closingPointId) {\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.closingPointId,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tif (this.preventNewFeature) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.startingClick === false) {\n\t\t\t\tconst [createdId, closingPointId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"LineString\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\tthis.currentId = createdId;\n\t\t\t\tthis.closingPointId = closingPointId;\n\t\t\t\tthis.startingClick = true;\n\n\t\t\t\t// We could already be in drawing due to updating the existing linestring\n\t\t\t\t// via afterFeatureUpdated\n\t\t\t\tif (this.state !== \"drawing\") {\n\t\t\t\t\tthis.setDrawing();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tif (this.startingClick === true) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentId;\n\t\tconst cleanUpClosingPointId = this.closingPointId;\n\n\t\tthis.closingPointId = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.startingClick = false;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t\tif (cleanUpClosingPointId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpClosingPointId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"LineString\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.lineStringColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.lineStringColor,\n\t\t\t\tstyles.lineStringColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.lineStringWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.lineStringWidth,\n\t\t\t\tstyles.lineStringWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t} else if (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.closingPointWidth,\n\t\t\t\tstyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.closingPointColor,\n\t\t\t\tstyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.closingPointOutlineColor,\n\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.closingPointOutlineWidth,\n\t\t\t\t2,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_FIVE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateLineStringFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// NOTE: This handles the case we are currently drawing a linestring\n\t\t// We need to reset the drawing state because it is very complicated (impossible?)\n\t\t// to recover the drawing state after a feature update\n\t\tif (this.currentId === feature.id) {\n\t\t\tif (this.closingPointId) {\n\t\t\t\tthis.store.delete([this.closingPointId]);\n\t\t\t}\n\t\t\tthis.startingClick = false;\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.closingPointId = undefined;\n\t\t}\n\t}\n}\n","/**\n * Checks if a value is a valid JSON value.\n * @param value - The value to check\n * @returns true if the value is valid JSON, false otherwise\n */\nexport function isValidJSONValue(value: unknown): value is JSON {\n\t// null is valid JSON\n\tif (value === null) {\n\t\treturn true;\n\t}\n\n\t// boolean is valid JSON\n\tif (typeof value === \"boolean\") {\n\t\treturn true;\n\t}\n\n\t// string is valid JSON\n\tif (typeof value === \"string\") {\n\t\treturn true;\n\t}\n\n\t// undefined is not valid JSON\n\tif (value === undefined) {\n\t\treturn false;\n\t}\n\n\t// number must be finite to be valid JSON\n\tif (typeof value === \"number\") {\n\t\treturn Number.isFinite(value);\n\t}\n\n\t// BigInt is not a valid JSON type\n\tif (typeof value === \"bigint\") {\n\t\treturn false;\n\t}\n\n\t// Symbols are not valid JSON types\n\tif (typeof value === \"symbol\") {\n\t\treturn false;\n\t}\n\n\t// Functions are not valid JSON types\n\tif (typeof value === \"function\") {\n\t\treturn false;\n\t}\n\n\t// Regular expressions are not valid JSON types\n\tif (value instanceof RegExp) {\n\t\treturn false;\n\t}\n\n\t// Maps are not valid JSON types\n\tif (value instanceof Map) {\n\t\treturn false;\n\t}\n\n\t// Sets are not valid JSON types\n\tif (value instanceof Set) {\n\t\treturn false;\n\t}\n\n\t// Dates are not valid JSON types\n\tif (value instanceof Date) {\n\t\treturn false;\n\t}\n\n\t// Class instances are not valid JSON types (only plain objects)\n\tif (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n\t\tconst proto = Object.getPrototypeOf(value);\n\t\tif (proto !== Object.prototype && proto !== null) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Typed Arrays are not valid JSON types\n\tif (ArrayBuffer.isView(value) && !(value instanceof DataView)) {\n\t\treturn false;\n\t}\n\n\t// Array: all elements must be valid JSON\n\tif (Array.isArray(value)) {\n\t\tfor (const item of value) {\n\t\t\tif (!isValidJSONValue(item)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Object: must be plain object with string keys\n\tif (typeof value === \"object\") {\n\t\treturn Object.keys(value).every(\n\t\t\t(key) =>\n\t\t\t\ttypeof key === \"string\" &&\n\t\t\t\tisValidJSONValue(value[key as keyof typeof value] as unknown),\n\t\t);\n\t}\n\n\t// Other types (shouldn't reach here) are not valid JSON\n\treturn false;\n}\n","/**\n * @module terra-draw\n */\nimport {\n\tTerraDrawAdapter,\n\tTerraDrawAdapterStyling,\n\tGetLngLatFromEvent,\n\tProject,\n\tSetCursor,\n\tTerraDrawChanges,\n\tTerraDrawStylingFunction,\n\tUnproject,\n\tHexColor,\n\tTerraDrawKeyboardEvent,\n\tTerraDrawMouseEvent,\n\tSELECT_PROPERTIES,\n\tOnFinishContext,\n\tCOMMON_PROPERTIES,\n\tTerraDrawGeoJSONStore,\n\tOnChangeContext,\n\tProjection,\n} from \"./common\";\nimport {\n\tModeTypes,\n\tTerraDrawBaseDrawMode,\n\tTerraDrawBaseSelectMode,\n} from \"./modes/base.mode\";\nimport { TerraDrawCircleMode } from \"./modes/circle/circle.mode\";\nimport { TerraDrawFreehandMode } from \"./modes/freehand/freehand.mode\";\nimport { TerraDrawLineStringMode } from \"./modes/linestring/linestring.mode\";\nimport { TerraDrawPointMode } from \"./modes/point/point.mode\";\nimport { TerraDrawPolygonMode } from \"./modes/polygon/polygon.mode\";\nimport { TerraDrawRectangleMode } from \"./modes/rectangle/rectangle.mode\";\nimport { TerraDrawRenderMode } from \"./modes/render/render.mode\";\nimport { TerraDrawSelectMode } from \"./modes/select/select.mode\";\nimport { TerraDrawStaticMode } from \"./modes/static/static.mode\";\nimport {\n\tBBoxPolygon,\n\tFeatureId,\n\tGeoJSONStore,\n\tGeoJSONStoreFeatures,\n\tGeoJSONStoreGeometries,\n\tIdStrategy,\n\tJSON,\n\tJSONObject,\n\tStoreChangeHandler,\n\tStoreValidation,\n} from \"./store/store\";\nimport { BehaviorConfig } from \"./modes/base.behavior\";\nimport { cartesianDistance } from \"./geometry/measure/pixel-distance\";\nimport { pixelDistanceToLine } from \"./geometry/measure/pixel-distance-to-line\";\nimport { Feature, LineString, Polygon, Position } from \"geojson\";\nimport { pointInPolygon } from \"./geometry/boolean/point-in-polygon\";\nimport { createBBoxFromPoint } from \"./geometry/shape/create-bbox\";\nimport { ValidateMinAreaSquareMeters } from \"./validations/min-size.validation\";\nimport { ValidateMaxAreaSquareMeters } from \"./validations/max-size.validation\";\nimport { ValidateNotSelfIntersecting } from \"./validations/not-self-intersecting.validation\";\nimport { TerraDrawAngledRectangleMode } from \"./modes/angled-rectangle/angled-rectangle.mode\";\nimport { TerraDrawSectorMode } from \"./modes/sector/sector.mode\";\nimport { TerraDrawSensorMode } from \"./modes/sensor/sensor.mode\";\nimport * as TerraDrawExtend from \"./extend\";\nimport { hasModeProperty } from \"./store/store-feature-validation\";\nimport { ValidationReasons } from \"./validation-reasons\";\nimport { TerraDrawFreehandLineStringMode } from \"./modes/freehand-linestring/freehand-linestring.mode\";\nimport { lngLatToWebMercatorXY } from \"./geometry/project/web-mercator\";\nimport { transformRotateWebMercator } from \"./geometry/transform/rotate\";\nimport { transformScaleWebMercatorCoordinates } from \"./geometry/transform/scale\";\nimport { limitPrecision } from \"./geometry/limit-decimal-precision\";\nimport { isValidJSONValue } from \"./store/valid-json\";\nimport { haversineDistanceKilometers } from \"./geometry/measure/haversine-distance\";\n\n// Helper type to determine the instance type of a class\ntype InstanceType<T extends new (...args: any[]) => any> = T extends new (\n\t...args: any[]\n) => infer R\n\t? R\n\t: never;\n\ntype FinishListener = (id: FeatureId, context: OnFinishContext) => void;\ntype ChangeListener = (\n\tids: FeatureId[],\n\ttype: string,\n\tcontext?: OnChangeContext,\n) => void;\ntype SelectListener = (id: FeatureId) => void;\ntype DeselectListener = () => void;\n\ninterface TerraDrawEventListeners {\n\tready: () => void;\n\tfinish: FinishListener;\n\tchange: ChangeListener;\n\tselect: SelectListener;\n\tdeselect: DeselectListener;\n}\n\ntype GetFeatureOptions = {\n\tpointerDistance?: number;\n\tincludePolygonsWithinPointerDistance?: boolean;\n\tignoreSelectFeatures?: boolean;\n\tignoreCoordinatePoints?: boolean;\n\tignoreCurrentlyDrawing?: boolean;\n\tignoreClosingPoints?: boolean;\n\taddClosestCoordinateInfoToProperties?: boolean;\n};\n\ntype TerraDrawEvents = keyof TerraDrawEventListeners;\n\nclass TerraDraw {\n\tprivate _modes: {\n\t\t[mode: string]: TerraDrawBaseDrawMode<any> | TerraDrawBaseSelectMode<any>;\n\t};\n\tprivate _mode: TerraDrawBaseDrawMode<any> | TerraDrawBaseSelectMode<any>;\n\tprivate _adapter: TerraDrawAdapter;\n\tprivate _enabled = false;\n\tprivate _store: TerraDrawGeoJSONStore;\n\tprivate _eventListeners: {\n\t\tready: (() => void)[];\n\t\tchange: ChangeListener[];\n\t\tfinish: FinishListener[];\n\t\tselect: SelectListener[];\n\t\tdeselect: DeselectListener[];\n\t};\n\t// This is the select mode that is assigned in the instance.\n\t// There can only be 1 select mode active per instance\n\tprivate _instanceSelectMode: undefined | string;\n\n\tconstructor(options: {\n\t\tadapter: TerraDrawAdapter;\n\t\tmodes: TerraDrawBaseDrawMode<any>[];\n\t\tidStrategy?: IdStrategy<FeatureId>;\n\t\ttracked?: boolean;\n\t}) {\n\t\tthis._adapter = options.adapter;\n\n\t\tthis._mode = new TerraDrawStaticMode();\n\n\t\t// Keep track of if there are duplicate modes\n\t\tconst duplicateModeTracker = new Set();\n\n\t\t// Construct a map of the mode name to the mode\n\t\tconst modesMap = options.modes.reduce<{\n\t\t\t[mode: string]: TerraDrawBaseDrawMode<any>;\n\t\t}>((modeMap, currentMode) => {\n\t\t\tif (duplicateModeTracker.has(currentMode.mode)) {\n\t\t\t\tthrow new Error(`There is already a ${currentMode.mode} mode provided`);\n\t\t\t}\n\t\t\tduplicateModeTracker.add(currentMode.mode);\n\t\t\tmodeMap[currentMode.mode] = currentMode;\n\t\t\treturn modeMap;\n\t\t}, {});\n\n\t\t// Construct an array of the mode keys (names)\n\t\tconst modeKeys = Object.keys(modesMap);\n\n\t\t// Ensure at least one draw mode is provided\n\t\tif (modeKeys.length === 0) {\n\t\t\tthrow new Error(\"No modes provided\");\n\t\t}\n\n\t\t// Ensure only one select mode can be present\n\t\tmodeKeys.forEach((mode) => {\n\t\t\tif (modesMap[mode].type !== ModeTypes.Select) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._instanceSelectMode) {\n\t\t\t\tthrow new Error(\"only one type of select mode can be provided\");\n\t\t\t} else {\n\t\t\t\tthis._instanceSelectMode = mode;\n\t\t\t}\n\t\t});\n\n\t\tthis._modes = { ...modesMap, static: this._mode };\n\t\tthis._eventListeners = {\n\t\t\tchange: [],\n\t\t\tselect: [],\n\t\t\tdeselect: [],\n\t\t\tfinish: [],\n\t\t\tready: [],\n\t\t};\n\t\tthis._store = new GeoJSONStore<OnChangeContext | undefined, FeatureId>({\n\t\t\ttracked: options.tracked ? true : false,\n\t\t\tidStrategy: options.idStrategy ? options.idStrategy : undefined,\n\t\t});\n\n\t\tconst getChanged = (\n\t\t\tids: FeatureId[],\n\t\t): {\n\t\t\tchanged: GeoJSONStoreFeatures[];\n\t\t\tunchanged: GeoJSONStoreFeatures[];\n\t\t} => {\n\t\t\tconst changed: GeoJSONStoreFeatures[] = [];\n\n\t\t\tconst unchanged = this._store.copyAll().filter((f) => {\n\t\t\t\tif (ids.includes(f.id as string)) {\n\t\t\t\t\tchanged.push(f);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t\treturn { changed, unchanged };\n\t\t};\n\n\t\tconst onFinish = (finishedId: FeatureId, context: OnFinishContext) => {\n\t\t\tif (!this._enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._eventListeners.finish.forEach((listener) => {\n\t\t\t\tlistener(finishedId, context);\n\t\t\t});\n\t\t};\n\n\t\tconst onChange: StoreChangeHandler<OnChangeContext | undefined> = (\n\t\t\tids,\n\t\t\tevent,\n\t\t\tcontext,\n\t\t) => {\n\t\t\tif (!this._enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._eventListeners.change.forEach((listener) => {\n\t\t\t\tlistener(ids, event, context);\n\t\t\t});\n\n\t\t\tconst { changed, unchanged } = getChanged(ids);\n\n\t\t\tif (event === \"create\") {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{\n\t\t\t\t\t\tcreated: changed,\n\t\t\t\t\t\tdeletedIds: [],\n\t\t\t\t\t\tunchanged,\n\t\t\t\t\t\tupdated: [],\n\t\t\t\t\t},\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t} else if (event === \"update\") {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{\n\t\t\t\t\t\tcreated: [],\n\t\t\t\t\t\tdeletedIds: [],\n\t\t\t\t\t\tunchanged,\n\t\t\t\t\t\tupdated: changed,\n\t\t\t\t\t},\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t} else if (event === \"delete\") {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{ created: [], deletedIds: ids, unchanged, updated: [] },\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t} else if (event === \"styling\") {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{ created: [], deletedIds: [], unchanged, updated: [] },\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\tconst onSelect = (selectedId: string) => {\n\t\t\tif (!this._enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._eventListeners.select.forEach((listener) => {\n\t\t\t\tlistener(selectedId);\n\t\t\t});\n\n\t\t\tconst { changed, unchanged } = getChanged([selectedId]);\n\n\t\t\tthis._adapter.render(\n\t\t\t\t{ created: [], deletedIds: [], unchanged, updated: changed },\n\t\t\t\tthis.getModeStyles(),\n\t\t\t);\n\t\t};\n\n\t\tconst onDeselect = (deselectedId: string) => {\n\t\t\tif (!this._enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._eventListeners.deselect.forEach((listener) => {\n\t\t\t\tlistener();\n\t\t\t});\n\n\t\t\tconst { changed, unchanged } = getChanged([deselectedId]);\n\n\t\t\t// onDeselect can be called after a delete call which means that\n\t\t\t// you are deselecting a feature that has been deleted. We\n\t\t\t// double check here to ensure that the feature still exists.\n\t\t\tif (changed) {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{\n\t\t\t\t\t\tcreated: [],\n\t\t\t\t\t\tdeletedIds: [],\n\t\t\t\t\t\tunchanged,\n\t\t\t\t\t\tupdated: changed,\n\t\t\t\t\t},\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\t// Register stores and callbacks\n\t\tObject.keys(this._modes).forEach((modeId) => {\n\t\t\tthis._modes[modeId].register({\n\t\t\t\tmode: modeId,\n\t\t\t\tstore: this._store,\n\t\t\t\tsetCursor: this._adapter.setCursor.bind(this._adapter),\n\t\t\t\tproject: this._adapter.project.bind(this._adapter),\n\t\t\t\tunproject: this._adapter.unproject.bind(this._adapter),\n\t\t\t\tsetDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(\n\t\t\t\t\tthis._adapter,\n\t\t\t\t),\n\t\t\t\tonChange: onChange,\n\t\t\t\tonSelect: onSelect,\n\t\t\t\tonDeselect: onDeselect,\n\t\t\t\tonFinish: onFinish,\n\t\t\t\tcoordinatePrecision: this._adapter.getCoordinatePrecision(),\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate checkEnabled() {\n\t\tif (!this._enabled) {\n\t\t\tthrow new Error(\"Terra Draw is not enabled\");\n\t\t}\n\t}\n\n\tprivate getModeStyles() {\n\t\tconst modeStyles: {\n\t\t\t[key: string]: (feature: GeoJSONStoreFeatures) => TerraDrawAdapterStyling;\n\t\t} = {};\n\n\t\tObject.keys(this._modes).forEach((mode) => {\n\t\t\tmodeStyles[mode] = (feature: GeoJSONStoreFeatures) => {\n\t\t\t\t// If the feature is selected, we want to use the select mode styling\n\t\t\t\tif (\n\t\t\t\t\tthis._instanceSelectMode &&\n\t\t\t\t\tfeature.properties[SELECT_PROPERTIES.SELECTED]\n\t\t\t\t) {\n\t\t\t\t\treturn this._modes[this._instanceSelectMode].styleFeature.bind(\n\t\t\t\t\t\tthis._modes[this._instanceSelectMode],\n\t\t\t\t\t)(feature);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise use regular styling\n\t\t\t\treturn this._modes[mode].styleFeature.bind(this._modes[mode])(feature);\n\t\t\t};\n\t\t});\n\t\treturn modeStyles;\n\t}\n\n\tprivate featuresAtLocation(\n\t\t{\n\t\t\tlng,\n\t\t\tlat,\n\t\t}: {\n\t\t\tlng: number;\n\t\t\tlat: number;\n\t\t},\n\t\toptions?: GetFeatureOptions,\n\t) {\n\t\tconst pointerDistance =\n\t\t\toptions && options.pointerDistance !== undefined\n\t\t\t\t? options.pointerDistance\n\t\t\t\t: 30; // default is 30px\n\n\t\tconst ignoreSelectFeatures =\n\t\t\toptions && options.ignoreSelectFeatures !== undefined\n\t\t\t\t? options.ignoreSelectFeatures\n\t\t\t\t: true;\n\n\t\tconst ignoreCoordinatePoints =\n\t\t\toptions && options.ignoreCoordinatePoints !== undefined\n\t\t\t\t? options.ignoreCoordinatePoints\n\t\t\t\t: false;\n\n\t\tconst ignoreCurrentlyDrawing =\n\t\t\toptions && options.ignoreCurrentlyDrawing !== undefined\n\t\t\t\t? options.ignoreCurrentlyDrawing\n\t\t\t\t: false;\n\n\t\tconst ignoreClosingPoints =\n\t\t\toptions && options.ignoreClosingPoints !== undefined\n\t\t\t\t? options.ignoreClosingPoints\n\t\t\t\t: false;\n\n\t\tconst unproject = this._adapter.unproject.bind(this._adapter);\n\t\tconst project = this._adapter.project.bind(this._adapter);\n\n\t\tconst inputPoint = project(lng, lat);\n\n\t\tconst bbox = createBBoxFromPoint({\n\t\t\tunproject,\n\t\t\tpoint: inputPoint,\n\t\t\tpointerDistance,\n\t\t});\n\n\t\tconst features = this._store.search(bbox as BBoxPolygon);\n\n\t\treturn features\n\t\t\t.filter((feature) => {\n\t\t\t\tif (\n\t\t\t\t\tignoreSelectFeatures &&\n\t\t\t\t\t(feature.properties[SELECT_PROPERTIES.MID_POINT] ||\n\t\t\t\t\t\tfeature.properties[SELECT_PROPERTIES.SELECTION_POINT])\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tignoreCoordinatePoints &&\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.COORDINATE_POINT]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tignoreClosingPoints &&\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.CLOSING_POINT]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tignoreCurrentlyDrawing &&\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.CURRENTLY_DRAWING]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (feature.geometry.type === \"Point\") {\n\t\t\t\t\tconst pointCoordinates = feature.geometry.coordinates;\n\t\t\t\t\tconst pointXY = project(pointCoordinates[0], pointCoordinates[1]);\n\t\t\t\t\tconst distance = cartesianDistance(inputPoint, pointXY);\n\t\t\t\t\treturn distance < pointerDistance;\n\t\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\t\tconst coordinates: Position[] = feature.geometry.coordinates;\n\n\t\t\t\t\tfor (let i = 0; i < coordinates.length - 1; i++) {\n\t\t\t\t\t\tconst coord = coordinates[i];\n\t\t\t\t\t\tconst nextCoord = coordinates[i + 1];\n\t\t\t\t\t\tconst distanceToLine = pixelDistanceToLine(\n\t\t\t\t\t\t\tinputPoint,\n\t\t\t\t\t\t\tproject(coord[0], coord[1]),\n\t\t\t\t\t\t\tproject(nextCoord[0], nextCoord[1]),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (distanceToLine < pointerDistance) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tconst lngLatInsidePolygon = pointInPolygon(\n\t\t\t\t\t\t[lng, lat],\n\t\t\t\t\t\tfeature.geometry.coordinates,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (lngLatInsidePolygon) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (options?.includePolygonsWithinPointerDistance) {\n\t\t\t\t\t\tconst rings: Position[][] = feature.geometry.coordinates;\n\n\t\t\t\t\t\tfor (const ring of rings) {\n\t\t\t\t\t\t\tfor (let i = 0; i < ring.length - 1; i++) {\n\t\t\t\t\t\t\t\tconst coord = ring[i];\n\t\t\t\t\t\t\t\tconst nextCoord = ring[i + 1];\n\n\t\t\t\t\t\t\t\tconst projectedStart = project(coord[0], coord[1]);\n\t\t\t\t\t\t\t\tconst projectedEnd = project(nextCoord[0], nextCoord[1]);\n\n\t\t\t\t\t\t\t\tconst distanceToEdge = pixelDistanceToLine(\n\t\t\t\t\t\t\t\t\tinputPoint,\n\t\t\t\t\t\t\t\t\tprojectedStart,\n\t\t\t\t\t\t\t\t\tprojectedEnd,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (distanceToEdge < pointerDistance) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.map((feature) => {\n\t\t\t\tif (!options?.addClosestCoordinateInfoToProperties) {\n\t\t\t\t\treturn feature;\n\t\t\t\t}\n\n\t\t\t\tlet coordinates;\n\t\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t\t\t\tcoordinates.pop(); // Remove duplicate end coordinate\n\t\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t\t\t} else {\n\t\t\t\t\t// Ignore points\n\t\t\t\t\treturn feature;\n\t\t\t\t}\n\n\t\t\t\tlet closestIndex = -1;\n\t\t\t\tlet closestDistance = Infinity;\n\t\t\t\tlet closestCoordinate;\n\n\t\t\t\t// Find the closest coordinate in the polygon/linestring to the pointer event\n\t\t\t\tfor (let i = 0; i < coordinates.length; i++) {\n\t\t\t\t\tconst coordinate = coordinates[i];\n\t\t\t\t\tconst distance = cartesianDistance(\n\t\t\t\t\t\tproject(coordinate[0], coordinate[1]),\n\t\t\t\t\t\tinputPoint,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (distance < closestDistance) {\n\t\t\t\t\t\tclosestIndex = i;\n\t\t\t\t\t\tclosestDistance = distance;\n\t\t\t\t\t\tclosestCoordinate = coordinate;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfeature.properties.closestCoordinateIndexToEvent = closestIndex;\n\t\t\t\tfeature.properties.closestCoordinatePixelDistanceToEvent =\n\t\t\t\t\tclosestDistance;\n\t\t\t\tfeature.properties.closestCoordinateDistanceKmToEvent =\n\t\t\t\t\thaversineDistanceKilometers(closestCoordinate!, [lng, lat]);\n\n\t\t\t\treturn feature;\n\t\t\t});\n\t}\n\n\tprivate getSelectModeOrThrow() {\n\t\tconst selectMode = this.getSelectMode({ switchToSelectMode: true });\n\n\t\tif (!selectMode) {\n\t\t\tthrow new Error(\"No select mode defined in instance\");\n\t\t}\n\n\t\treturn selectMode;\n\t}\n\n\tprivate getSelectMode({\n\t\tswitchToSelectMode,\n\t}: {\n\t\tswitchToSelectMode: boolean;\n\t}) {\n\t\tthis.checkEnabled();\n\n\t\tif (!this._instanceSelectMode) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currentMode = this.getMode();\n\n\t\t// If we're not already in the select mode, we switch to it\n\t\tif (switchToSelectMode && currentMode !== this._instanceSelectMode) {\n\t\t\tthis.setMode(this._instanceSelectMode);\n\t\t}\n\n\t\tconst selectMode = this._modes[\n\t\t\tthis._instanceSelectMode\n\t\t] as TerraDrawBaseSelectMode<any>;\n\n\t\treturn selectMode;\n\t}\n\n\tprivate isGuidanceFeature(feature: GeoJSONStoreFeatures): boolean {\n\t\treturn Boolean(\n\t\t\tfeature.properties[SELECT_PROPERTIES.MID_POINT] ||\n\t\t\t\tfeature.properties[SELECT_PROPERTIES.SELECTION_POINT] ||\n\t\t\t\tfeature.properties[COMMON_PROPERTIES.COORDINATE_POINT] ||\n\t\t\t\tfeature.properties[COMMON_PROPERTIES.SNAPPING_POINT],\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated This method is scheduled for removal in the next major version. Instead use the 'updateModeOptions' method passing the\n\t * styles property in the options object, and this will dynamically update the styles for the mode.\n\t *\n\t * Allows the setting of a style for a given mode\n\t *\n\t * @param mode - The mode you wish to set a style for\n\t * @param styles - The styles you wish to set for the mode - this is\n\t * the same as the initialisation style schema\n\t */\n\tsetModeStyles<Styling extends Record<string, number | HexColor>>(\n\t\tmode: string,\n\t\tstyles: Styling,\n\t) {\n\t\tthis.checkEnabled();\n\t\tif (!this._modes[mode]) {\n\t\t\tthrow new Error(\"No mode with this name present\");\n\t\t}\n\n\t\t// TODO: Not sure why this fails TypeScript with TerraDrawBaseSelectMode?\n\t\t(this._modes[mode] as TerraDrawBaseDrawMode<any>).styles = styles;\n\t}\n\n\t/**\n\t * Allow updating of the current options passed to the mode dynamically\n\t * after the mode has been started. You can also use this method to update styles\n\t * as these are passed from the options object.\n\t * @param mode - the mode name you wish to update (the mode name is the public 'mode' property of the mode class)\n\t * @param options - the options object - this allows _partial_ updating of the modes options (i.e. you do not need to pass the whole options object)\n\t */\n\tupdateModeOptions<Mode extends { new (...args: any[]): any }>(\n\t\tmode: InstanceType<Mode>[\"mode\"],\n\t\toptions: ConstructorParameters<Mode>[0],\n\t) {\n\t\tthis.checkEnabled();\n\t\tif (!this._modes[mode]) {\n\t\t\tthrow new Error(\"No mode with this name present\");\n\t\t}\n\n\t\tthis._modes[mode].updateOptions(\n\t\t\toptions as TerraDrawExtend.BaseModeOptions<any>,\n\t\t);\n\t}\n\n\t/**\n\t * Allows the user to get a snapshot (copy) of all given features\n\t *\n\t * @returns An array of all given Feature Geometries in the instances store\n\t */\n\tgetSnapshot() {\n\t\t// This is a read only method so we do not need to check if enabled\n\t\treturn this._store.copyAll();\n\t}\n\n\t/**\n\t * Allows the user to get a snapshot (copy) of a given feature by id\n\t *\n\t * @returns A copy of the feature geometry in the instances store\n\t */\n\tgetSnapshotFeature(id: FeatureId) {\n\t\tif (!this._store.has(id)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._store.copy(id);\n\t}\n\n\t/**\n\t * Removes all data from the current store and ensures any rendered data is cleared\n\t * from the map.\n\t */\n\tclear() {\n\t\tthis.checkEnabled();\n\t\tthis._adapter.clear();\n\t}\n\n\t/**\n\t * A property used to determine whether the instance is active or not. You\n\t * can use the start method to set this to true, and stop method to set this to false.\n\t * This is a read only property.\n\t *\n\t * @return true or false depending on if the instance is stopped or started\n\t * @readonly\n\t */\n\tget enabled(): boolean {\n\t\treturn this._enabled;\n\t}\n\n\t/**\n\t * enabled is a read only property and will throw and error if you try and set it.\n\t */\n\tset enabled(_) {\n\t\tthrow new Error(\"Enabled is read only\");\n\t}\n\n\t/**\n\t * A method for getting the current mode name\n\t * @return the current mode name\n\t */\n\tgetMode(): string {\n\t\t// This is a read only method so we do not need to check if enabled\n\t\treturn this._mode.mode;\n\t}\n\n\t/**\n\t * Get the state of the mode i.e. if we are currently unregistered, registered, drawing etc. This can\n\t * be used to make decisions based on what the current mode is doing.\n\t * @returns the current mode state as a string\n\t */\n\tgetModeState() {\n\t\treturn this._mode.state;\n\t}\n\n\t/**\n\t * A method for setting the current mode by name. Under the hood this will stop\n\t * the previous mode and start the new one.\n\t * @param mode - The mode name you wish to start\n\t */\n\tsetMode(mode: string) {\n\t\tthis.checkEnabled();\n\n\t\tif (this._modes[mode]) {\n\t\t\t// Before we swap modes we want to\n\t\t\t// clean up any state that has been left behind,\n\t\t\t// for example current drawing geometries\n\t\t\t// and mode state\n\t\t\tthis._mode.stop();\n\n\t\t\t// Swap the mode to the new mode\n\t\t\tthis._mode = this._modes[mode];\n\n\t\t\t// Start the new mode\n\t\t\tthis._mode.start();\n\t\t} else {\n\t\t\t// If the mode doesn't exist, we throw an error\n\t\t\tthrow new Error(\"No mode with this name present\");\n\t\t}\n\t}\n\n\t/**\n\t * A method for removing features to the store\n\t * @param ids\n\t * @returns\n\t */\n\tremoveFeatures(ids: FeatureId[]) {\n\t\tthis.checkEnabled();\n\n\t\tconst coordinatePointsToDelete: FeatureId[] = [];\n\n\t\tids.forEach((id) => {\n\t\t\t// Deselect any passed features - this removes all selection points and midpoints\n\t\t\tif (!this._store.has(id)) {\n\t\t\t\tthrow new Error(`No feature with id ${id}, can not delete`);\n\t\t\t}\n\n\t\t\tconst feature = this._store.copy(id);\n\t\t\tif (feature.properties[SELECT_PROPERTIES.SELECTED]) {\n\t\t\t\tthis.deselectFeature(id);\n\t\t\t}\n\n\t\t\t// If the feature has coordinate points, we want to remove them as well\n\t\t\tif (feature.properties[COMMON_PROPERTIES.COORDINATE_POINT_IDS]) {\n\t\t\t\tcoordinatePointsToDelete.push(\n\t\t\t\t\t...(feature.properties[\n\t\t\t\t\t\tCOMMON_PROPERTIES.COORDINATE_POINT_IDS\n\t\t\t\t\t] as FeatureId[]),\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tthis._store.delete([...ids, ...coordinatePointsToDelete], {\n\t\t\torigin: \"api\",\n\t\t});\n\t}\n\n\t/**\n\t * Provides the ability to programmatically select a feature using the instances provided select mode.\n\t * If not select mode is provided in the instance, an error will be thrown. If the instance is not currently\n\t * in the select mode, it will switch to it.\n\t * @param id - the id of the feature to select\n\t */\n\tselectFeature(id: FeatureId) {\n\t\tconst selectMode = this.getSelectModeOrThrow();\n\t\tselectMode.selectFeature(id);\n\t}\n\n\t/**\n\t * Provides the ability to programmatically deselect a feature using the instances provided select mode.\n\t * If not select mode is provided in the instance, an error will be thrown. If the instance is not currently\n\t * in the select mode, it will switch to it.\n\t * @param id  - the id of the feature to deselect\n\t */\n\tdeselectFeature(id: FeatureId) {\n\t\tconst selectMode = this.getSelectModeOrThrow();\n\t\tselectMode.deselectFeature(id);\n\t}\n\n\t/**\n\t * Returns the next feature id from the store - defaults to UUID4 unless you have\n\t * set a custom idStrategy. This method can be useful if you are needing creating features\n\t * outside of the Terra Draw instance but want to add them in to the store.\n\t * @returns a id, either number of string based on whatever the configured idStrategy is\n\t *\n\t */\n\tgetFeatureId(): FeatureId {\n\t\treturn this._store.getId();\n\t}\n\n\t/**\n\t * Returns true or false depending on if the Terra Draw instance has a feature with a given id\n\t * @returns a boolean determining if the instance has a feature with the given id\n\t */\n\thasFeature(id: FeatureId): boolean {\n\t\treturn this._store.has(id);\n\t}\n\n\t/**\n\t * Checks if a property name is reserved and cannot be used.\n\t * @param propertyName - the property name to check\n\t * @returns\n\t */\n\tprivate checkIsReservedProperty(propertyName: string) {\n\t\tconst UNAVAILABLE_PROPERTIES = [\n\t\t\t...Object.values(SELECT_PROPERTIES),\n\t\t\t...Object.values(COMMON_PROPERTIES),\n\t\t] as const;\n\n\t\treturn !UNAVAILABLE_PROPERTIES.includes(\n\t\t\tpropertyName as unknown as (typeof UNAVAILABLE_PROPERTIES)[number],\n\t\t);\n\t}\n\n\t/**\n\t * Updates a features properties. This can be used to programmatically change the properties of a feature.\n\t * The update is a shallow merge so only the properties you provide will be updated. Certain internal properties\n\t * are reserved and cannot be updated.\n\t * @param id - the id of the feature to update the property for\n\t * @param properties - an object of key value pairs that will be shallowly merged in to the features properties\n\t */\n\tupdateFeatureProperties(\n\t\tid: FeatureId,\n\t\tproperties: Record<string, JSON | undefined>,\n\t) {\n\t\tif (!this._store.has(id)) {\n\t\t\tthrow new Error(`No feature with id ${id} present in store`);\n\t\t}\n\n\t\tconst feature = this._store.copy(id);\n\n\t\t// We don't want users to be able to update guidance features directly\n\t\tif (this.isGuidanceFeature(feature)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Guidance features are not allowed to be updated directly.`,\n\t\t\t);\n\t\t}\n\n\t\tconst mode = feature.properties.mode;\n\t\tconst modeToUpdate = this._modes[mode as string];\n\n\t\tif (!modeToUpdate) {\n\t\t\tthrow new Error(`No mode with name ${mode} present in instance`);\n\t\t}\n\n\t\tconst entries = Object.entries(properties);\n\n\t\t// Check that none of the properties are reserved\n\t\tentries.forEach(([propertyName, value]) => {\n\t\t\tconst isReservedProperty = this.checkIsReservedProperty(propertyName);\n\n\t\t\tif (!isReservedProperty) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`You are trying to update a reserved property name: ${propertyName}. Please choose another name.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (value !== undefined && !isValidJSONValue(value)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid JSON value provided for property ${propertyName}`,\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tthis._store.updateProperty(\n\t\t\tentries.map(([propertyName, value]) => ({\n\t\t\t\tid: feature.id as FeatureId,\n\t\t\t\tproperty: propertyName,\n\t\t\t\tvalue,\n\t\t\t})),\n\t\t\t{ origin: \"api\" }, // origin is used to indicate that this update has come from an API call\n\t\t);\n\t}\n\n\t/**\n\t * Updates a features geometry. This an be used to programmatically change the coordinates of a feature. This\n\t * can be useful for if you want to modify a geometry via a button or some similar user interaction.\n\t * @param id - the id of the feature to update the geometry for\n\t * @param geometry - the new geometry that will replace the existing geometry\n\t */\n\tupdateFeatureGeometry(id: FeatureId, geometry: GeoJSONStoreGeometries) {\n\t\tif (!this._store.has(id)) {\n\t\t\tthrow new Error(`No feature with id ${id} present in store`);\n\t\t}\n\n\t\tconst feature = this._store.copy(id);\n\n\t\t// We don't want users to be able to update guidance features directly\n\t\tif (this.isGuidanceFeature(feature)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Guidance features are not allowed to be updated directly.`,\n\t\t\t);\n\t\t}\n\n\t\t// Ensure that the geometry is valid\n\t\tif (!feature || !geometry || !geometry.type || !geometry.coordinates) {\n\t\t\tthrow new Error(\"Invalid geometry provided\");\n\t\t}\n\t\tif (geometry.type !== feature.geometry.type) {\n\t\t\tthrow new Error(\n\t\t\t\t`Geometry type mismatch: expected ${feature.geometry.type}, got ${geometry.type}`,\n\t\t\t);\n\t\t}\n\n\t\tconst mode = feature.properties.mode;\n\t\tconst modeToUpdate = this._modes[mode as string];\n\n\t\tif (!modeToUpdate) {\n\t\t\tthrow new Error(`No mode with name ${mode} present in instance`);\n\t\t}\n\n\t\tconst updatedFeature = { ...feature, geometry };\n\n\t\tconst validationResult = modeToUpdate.validateFeature(updatedFeature);\n\n\t\tif (!validationResult.valid) {\n\t\t\tthrow new Error(\n\t\t\t\t`Feature validation failed: ${validationResult.reason || \"Unknown reason\"}`,\n\t\t\t);\n\t\t}\n\n\t\tthis._store.updateGeometry(\n\t\t\t[{ id: feature.id as FeatureId, geometry }],\n\t\t\t{ origin: \"api\" }, // origin is used to indicate that this update has come from an API call\n\t\t);\n\n\t\t// If the mode has an afterFeatureUpdated method, we call it\n\t\tif (modeToUpdate.afterFeatureUpdated) {\n\t\t\tmodeToUpdate.afterFeatureUpdated(updatedFeature);\n\n\t\t\tconst featureIsSelected =\n\t\t\t\tupdatedFeature.properties[SELECT_PROPERTIES.SELECTED];\n\t\t\tconst selectModePresent = this.getSelectMode({\n\t\t\t\tswitchToSelectMode: false,\n\t\t\t});\n\n\t\t\tif (selectModePresent && featureIsSelected) {\n\t\t\t\tselectModePresent.afterFeatureUpdated(updatedFeature);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A method for transforming a feature's geometry. This can be used to rotate or scale a feature's geometry.\n\t * This matches the functionality of the scale and rotate behaviors in the select mode.\n\t * @param id - the id of the feature to transform\n\t * @param transformation - the transformation to apply to the feature's geometry\n\t */\n\ttransformFeatureGeometry(\n\t\tid: FeatureId,\n\t\ttransformation:\n\t\t\t| {\n\t\t\t\t\tprojection?: Exclude<Projection, \"globe\">;\n\t\t\t\t\torigin: Position;\n\t\t\t\t\ttype: \"rotate\";\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tangle: number;\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\tprojection?: Exclude<Projection, \"globe\">;\n\t\t\t\t\torigin: Position;\n\t\t\t\t\ttype: \"scale\";\n\t\t\t\t\toptions: {\n\t\t\t\t\t\txScale: number;\n\t\t\t\t\t\tyScale: number;\n\t\t\t\t\t};\n\t\t\t  },\n\t) {\n\t\tif (!this._store.has(id)) {\n\t\t\tthrow new Error(`No feature with id ${id} present in store`);\n\t\t}\n\n\t\tlet feature = this._store.copy(id);\n\n\t\t// We don't want users to be able to update guidance features directly\n\t\tif (this.isGuidanceFeature(feature)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Guidance features are not allowed to be updated directly.`,\n\t\t\t);\n\t\t}\n\n\t\tconst mode = feature.properties.mode;\n\t\tconst modeToUpdate = this._modes[mode as string];\n\n\t\tif (!modeToUpdate) {\n\t\t\tthrow new Error(`No mode with name ${mode} present in instance`);\n\t\t}\n\n\t\tlet coordinates: Position[];\n\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`Feature geometry type ${feature.geometry.type} is not supported for transformation`,\n\t\t\t);\n\t\t}\n\n\t\tif (transformation.projection == \"web-mercator\") {\n\t\t\tif (transformation.type === \"scale\") {\n\t\t\t\tconst { x: originX, y: originY } = lngLatToWebMercatorXY(\n\t\t\t\t\ttransformation.origin[0],\n\t\t\t\t\ttransformation.origin[1],\n\t\t\t\t);\n\n\t\t\t\tconst xScale = transformation.options.xScale || 1;\n\t\t\t\tconst yScale = transformation.options.yScale || 1;\n\n\t\t\t\ttransformScaleWebMercatorCoordinates({\n\t\t\t\t\tcoordinates,\n\t\t\t\t\toriginX,\n\t\t\t\t\toriginY,\n\t\t\t\t\txScale,\n\t\t\t\t\tyScale,\n\t\t\t\t});\n\t\t\t} else if (transformation.type === \"rotate\") {\n\t\t\t\tconst angle = transformation.options.angle || 0;\n\t\t\t\tfeature = transformRotateWebMercator(\n\t\t\t\t\tfeature as Feature<Polygon> | Feature<LineString>,\n\t\t\t\t\tangle,\n\t\t\t\t) as GeoJSONStoreFeatures;\n\n\t\t\t\tcoordinates =\n\t\t\t\t\tfeature.geometry.type === \"Polygon\"\n\t\t\t\t\t\t? (feature.geometry as Polygon).coordinates[0]\n\t\t\t\t\t\t: (feature.geometry as LineString).coordinates;\n\t\t\t}\n\n\t\t\tcoordinates = coordinates.map((coord) => [\n\t\t\t\tlimitPrecision(coord[0], this._adapter.getCoordinatePrecision()),\n\t\t\t\tlimitPrecision(coord[1], this._adapter.getCoordinatePrecision()),\n\t\t\t]);\n\n\t\t\tfeature.geometry.coordinates =\n\t\t\t\tfeature.geometry.type === \"Polygon\" ? [coordinates] : coordinates;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`Projection ${transformation.projection} is not currently supported for transformation`,\n\t\t\t);\n\t\t}\n\n\t\tthis._store.updateGeometry(\n\t\t\t[{ id: feature.id as FeatureId, geometry: feature.geometry }],\n\t\t\t{ origin: \"api\" }, // origin is used to indicate that this update has come from an API call\n\t\t);\n\n\t\tif (modeToUpdate.afterFeatureUpdated) {\n\t\t\tmodeToUpdate.afterFeatureUpdated(feature);\n\t\t\tconst featureIsSelected = feature.properties[SELECT_PROPERTIES.SELECTED];\n\t\t\tconst selectModePresent = this.getSelectMode({\n\t\t\t\tswitchToSelectMode: false,\n\t\t\t});\n\n\t\t\tif (selectModePresent && featureIsSelected) {\n\t\t\t\tselectModePresent.afterFeatureUpdated(feature);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A method for adding features to the store. This method will validate the features\n\t * returning an array of validation results. Features must match one of the modes enabled\n\t * in the instance.\n\t * @param features - an array of GeoJSON features\n\t * @returns an array of validation results\n\t */\n\taddFeatures(features: GeoJSONStoreFeatures[]): StoreValidation[] {\n\t\tthis.checkEnabled();\n\n\t\tif (features.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this._store.load(\n\t\t\tfeatures,\n\t\t\t(feature) => {\n\t\t\t\t// If the feature has a mode property, we use that to validate the feature\n\t\t\t\tif (hasModeProperty(feature)) {\n\t\t\t\t\tconst featureMode = feature.properties.mode;\n\t\t\t\t\tconst modeToAddTo = this._modes[featureMode];\n\n\t\t\t\t\t// if the mode does not exist, we return false\n\t\t\t\t\tif (!modeToAddTo) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tid: (feature as { id?: FeatureId }).id,\n\t\t\t\t\t\t\tvalid: false,\n\t\t\t\t\t\t\treason: `${featureMode} mode is not in the list of instantiated modes`,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// use the inbuilt validation of the mode\n\t\t\t\t\tconst validation = modeToAddTo.validateFeature.bind(modeToAddTo);\n\t\t\t\t\tconst validationResult = validation(feature);\n\t\t\t\t\tconst valid = validationResult.valid;\n\t\t\t\t\tconst reason = validationResult.reason\n\t\t\t\t\t\t? validationResult.reason\n\t\t\t\t\t\t: !validationResult.valid\n\t\t\t\t\t\t\t? \"Feature is invalid\"\n\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: (feature as { id?: FeatureId }).id,\n\t\t\t\t\t\tvalid,\n\t\t\t\t\t\treason,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// If the feature does not have a mode property, we return false\n\t\t\t\treturn {\n\t\t\t\t\tid: (feature as { id?: FeatureId }).id,\n\t\t\t\t\tvalid: false,\n\t\t\t\t\treason: \"Mode property does not exist\",\n\t\t\t\t};\n\t\t\t},\n\t\t\t(feature) => {\n\t\t\t\tif (hasModeProperty(feature)) {\n\t\t\t\t\tconst featureMode = feature.properties.mode;\n\t\t\t\t\tconst modeToAddTo = this._modes[featureMode];\n\t\t\t\t\tif (modeToAddTo && modeToAddTo.afterFeatureAdded) {\n\t\t\t\t\t\tmodeToAddTo.afterFeatureAdded(feature);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ origin: \"api\" },\n\t\t);\n\t}\n\n\t/**\n\t * A method starting Terra Draw. It put the instance into a started state, and\n\t * in registers the passed adapter giving it all the callbacks required to operate.\n\t */\n\tstart() {\n\t\t// If the instance is already enabled, we do nothing\n\t\tif (this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._enabled = true;\n\t\tthis._adapter.register({\n\t\t\tonReady: () => {\n\t\t\t\tthis._eventListeners.ready.forEach((listener) => {\n\t\t\t\t\tlistener();\n\t\t\t\t});\n\t\t\t},\n\t\t\tgetState: () => {\n\t\t\t\treturn this._mode.state;\n\t\t\t},\n\t\t\tonClick: (event) => {\n\t\t\t\tthis._mode.onClick(event);\n\t\t\t},\n\t\t\tonMouseMove: (event) => {\n\t\t\t\tthis._mode.onMouseMove(event);\n\t\t\t},\n\t\t\tonKeyDown: (event) => {\n\t\t\t\tthis._mode.onKeyDown(event);\n\t\t\t},\n\t\t\tonKeyUp: (event) => {\n\t\t\t\tthis._mode.onKeyUp(event);\n\t\t\t},\n\t\t\tonDragStart: (event, setMapDraggability) => {\n\t\t\t\tthis._mode.onDragStart(event, setMapDraggability);\n\t\t\t},\n\t\t\tonDrag: (event, setMapDraggability) => {\n\t\t\t\tthis._mode.onDrag(event, setMapDraggability);\n\t\t\t},\n\t\t\tonDragEnd: (event, setMapDraggability) => {\n\t\t\t\tthis._mode.onDragEnd(event, setMapDraggability);\n\t\t\t},\n\t\t\tonClear: () => {\n\t\t\t\t// Ensure that the mode resets its state\n\t\t\t\t// as it may be storing feature ids internally in it's instance\n\t\t\t\tthis._mode.cleanUp();\n\n\t\t\t\t// Remove all features from the store\n\t\t\t\tthis._store.clear();\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Gets the features at a given longitude and latitude.\n\t * Will return point and linestrings that are a given pixel distance\n\t * away from the lng/lat and any polygons which contain it.\n\t */\n\tgetFeaturesAtLngLat(\n\t\tlngLat: { lng: number; lat: number },\n\t\toptions?: GetFeatureOptions,\n\t) {\n\t\tconst { lng, lat } = lngLat;\n\n\t\treturn this.featuresAtLocation(\n\t\t\t{\n\t\t\t\tlng,\n\t\t\t\tlat,\n\t\t\t},\n\t\t\toptions,\n\t\t);\n\t}\n\n\t/**\n\t * Takes a given pointer event and will return point and linestrings that are\n\t * a given pixel distance away from the longitude/latitude, and any polygons which contain it.\n\t */\n\tgetFeaturesAtPointerEvent(\n\t\tevent: PointerEvent | MouseEvent,\n\t\toptions?: GetFeatureOptions,\n\t) {\n\t\tconst getLngLatFromEvent = this._adapter.getLngLatFromEvent.bind(\n\t\t\tthis._adapter,\n\t\t);\n\n\t\tconst lngLat = getLngLatFromEvent(event);\n\n\t\t// If the pointer event is outside the container or the underlying library is\n\t\t// not ready we can get null as a returned value\n\t\tif (lngLat === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.featuresAtLocation(lngLat, options);\n\t}\n\n\t/**\n\t * A method for stopping Terra Draw. Will clear the store, deregister the adapter and\n\t * remove any rendered layers in the process.\n\t */\n\tstop() {\n\t\t// If the instance is already stopped, we do nothing\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._enabled = false;\n\t\tthis._adapter.unregister();\n\t}\n\n\t/**\n\t * Registers a Terra Draw event\n\t *\n\t * @param event - The name of the event you wish to listen for\n\t * @param callback - The callback with you wish to be called when this event occurs\n\t *\n\t */\n\ton<T extends TerraDrawEvents>(\n\t\tevent: T,\n\t\tcallback: TerraDrawEventListeners[T],\n\t) {\n\t\tconst listeners = this._eventListeners[\n\t\t\tevent\n\t\t] as TerraDrawEventListeners[T][];\n\t\tif (!listeners.includes(callback)) {\n\t\t\tlisteners.push(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Unregisters a Terra Draw event\n\t *\n\t * @param event - The name of the event you wish to unregister\n\t * @param callback - The callback you originally provided to the 'on' method\n\t *\n\t */\n\toff<T extends TerraDrawEvents>(\n\t\tevent: TerraDrawEvents,\n\t\tcallback: TerraDrawEventListeners[T],\n\t) {\n\t\tconst listeners = this._eventListeners[\n\t\t\tevent\n\t\t] as TerraDrawEventListeners[T][];\n\t\tif (listeners.includes(callback)) {\n\t\t\tlisteners.splice(listeners.indexOf(callback), 1);\n\t\t}\n\t}\n}\n\nexport {\n\tTerraDraw,\n\ttype IdStrategy,\n\ttype TerraDrawEvents,\n\ttype TerraDrawEventListeners,\n\n\t// Modes\n\tTerraDrawSelectMode,\n\tTerraDrawPointMode,\n\tTerraDrawLineStringMode,\n\tTerraDrawPolygonMode,\n\tTerraDrawCircleMode,\n\tTerraDrawFreehandMode,\n\tTerraDrawFreehandLineStringMode,\n\tTerraDrawRenderMode,\n\tTerraDrawRectangleMode,\n\tTerraDrawAngledRectangleMode,\n\tTerraDrawSectorMode,\n\tTerraDrawSensorMode,\n\n\t// Types that are required for 3rd party developers to extend\n\tTerraDrawExtend,\n\n\t// TerraDrawBaseMode\n\ttype BehaviorConfig,\n\ttype GeoJSONStoreFeatures,\n\ttype GeoJSONStoreGeometries,\n\ttype HexColor,\n\ttype TerraDrawMouseEvent,\n\ttype TerraDrawAdapterStyling,\n\ttype TerraDrawKeyboardEvent,\n\n\t// TerraDrawBaseAdapter\n\ttype TerraDrawChanges,\n\ttype TerraDrawStylingFunction,\n\ttype Project,\n\ttype Unproject,\n\ttype SetCursor,\n\ttype GetLngLatFromEvent,\n\n\t// Validations\n\tValidateMinAreaSquareMeters,\n\tValidateMaxAreaSquareMeters,\n\tValidateNotSelfIntersecting,\n\tValidationReasons,\n};\n"],"names":["UpdateTypes","SELECT_PROPERTIES","SELECTED","MID_POINT","SELECTION_POINT_FEATURE_ID","SELECTION_POINT","COMMON_PROPERTIES","MODE","CURRENTLY_DRAWING","EDITED","CLOSING_POINT","SNAPPING_POINT","COORDINATE_POINT","COORDINATE_POINT_FEATURE_ID","COORDINATE_POINT_IDS","PROVISIONAL_COORDINATE_COUNT","COMMITTED_COORDINATE_COUNT","Z_INDEX","isObject","feature","Boolean","Array","isArray","hasModeProperty","properties","isValidTimestamp","timestamp","isNaN","Date","valueOf","dateIsValid","ValidationReasonFeatureNotPolygon","ValidationReasonModeMismatch","ModeTypes","DefaultPointerEvents","rightClick","contextMenu","leftClick","onDragStart","onDrag","onDragEnd","TerraDrawBaseDrawMode","state","this","_state","_","Error","styles","_styles","styling","onStyleChange","registerBehaviors","behaviorConfig","constructor","options","willCallUpdateOptionsInParentClass","pointerEvents","behaviors","validate","pointerDistance","coordinatePrecision","store","projection","setDoubleClickToZoom","unproject","project","setCursor","type","Drawing","mode","updateOptions","_extends","validation","undefined","allowPointerEvent","pointerEvent","event","setDrawing","setStarted","setStopped","register","config","registerOnChange","onChange","onSelect","onDeselect","onFinish","validateFeature","performFeatureValidation","afterFeatureAdded","afterFeatureUpdated","validStoreFeature","isValidId","error","id","geometry","includes","coordinates","valid","reason","isValidStoreFeature","idStrategy","updateType","Provisional","validateModeFeature","modeValidationFn","finishedId","context","deselectedId","selectedId","onKeyDown","onKeyUp","onMouseMove","onClick","setMapDraggability","getHexColorStylingValue","value","defaultValue","getStylingValue","getNumericStylingValue","TerraDrawBaseSelectMode","args","super","Select","haversineDistanceKilometers","pointOne","pointTwo","toRadians","latOrLng","Math","PI","phiOne","lambdaOne","phiTwo","deltaPhi","deltalambda","a","sin","cos","atan2","sqrt","earthRadius","degreesToRadians","degrees","lengthToRadians","distance","radiansToDegrees","radians","limitPrecision","num","decimalLimit","decimals","pow","round","RADIANS_TO_DEGREES","DEGREES_TO_RADIANS","R","lngLatToWebMercatorXY","lng","lat","x","y","log","tan","webMercatorXYToLngLat","atan","exp","destination","origin","bearing","longitude1","latitude1","bearingRad","latitude2","asin","circle","center","radiusKilometers","steps","i","circleCoordinate","push","selfIntersects","coord","output","ring0","length","edge0","ring1","edge1","ifInteresctionAddToOutput","isOutside","frac","start0","end0","start1","end1","intersection","equalArrays","x0","y0","x1","y1","x2","y2","x3","y3","denom","intersect","frac0","frac1","toString","array1","array2","coordinatePrecisionIsValid","coordinate","getDecimalPlaces","coordinateIsValid","Infinity","current","precision","ValidationReasonFeatureHasHoles","ValidationReasonFeatureLessThanFourCoordinates","ValidationReasonFeatureHasInvalidCoordinates","ValidationReasonFeatureCoordinatesNotClosed","ValidatePolygonFeature","coordinateOne","coordinateTwo","ValidateNonIntersectingPolygonFeature","validatePolygonFeature","defaultKeyEvents","cancel","finish","defaultCursors","start","TerraDrawCircleMode","clickCount","currentCircleId","keyEvents","cursors","startingRadiusKilometers","cursorMovedAfterInitialCursorDown","close","updateProperty","property","currentGeometry","getGeometryCopy","Finish","action","stop","cleanUp","button","isContextMenu","startingCircle","createdId","create","updateCircle","key","cleanUpId","delete","_unused","styleFeature","getDefaultStyling","polygonFillColor","polygonOutlineColor","polygonOutlineWidth","polygonFillOpacity","pointColor","pointOutlineColor","pointOutlineWidth","pointWidth","lineStringColor","lineStringWidth","zIndex","fillColor","outlineColor","outlineWidth","fillOpacity","baseValidatedFeature","newRadius","updatedCircle","distortion","source","target","geodesicDistance","calculateWebMercatorDistortion","radiusMeters","angle","dx","dy","wx","wy","circleWebMercator","updateGeometry","cartesianDistance","ensureRightHandRule","polygon","isFollowingRightHandRule","outerRing","sum","followsRightHandRule","reverse","TerraDrawFreehandMode","startingClick","currentId","closingPointId","minDistance","preventPointsNearClose","autoClose","autoCloseTimeout","hasLeftStartingPoint","preventNewFeature","correctedGeometry","currentLineGeometry","previousIndex","previousLng","previousLat","containerX","containerY","closingLng","closingLat","closingX","closingY","setTimeout","pop","newGeometry","cleanUpClosingPointId","closingPointWidth","closingPointColor","closingPointOutlineColor","closingPointOutlineWidth","TerraDrawModeBehavior","createBBoxFromPoint","point","halfDist","map","c","ClickBoundingBoxBehavior","PixelDistanceBehavior","measure","clickEvent","secondCoordinate","CoordinateSnappingBehavior","pixelDistance","clickBoundingBox","getSnappableCoordinateFirstClick","getSnappable","getSnappableCoordinate","currentFeatureId","filter","bbox","features","search","closest","featureId","featureCoordinateIndex","minDist","forEach","coordIndex","dist","webMercatorDestination","end","lon1","lon2","lat1","lat2","b","webMercatorBearing","deltaX","deltaY","normalizeBearing","lineSliceAlong","coords","startDist","stopDist","slice","origCoordsLength","overshot","direction","interpolated","travelled","last","toDegrees","InsertCoordinatesBehavior","generateInsertionCoordinates","segmentLength","line","lineLength","numberOfSegments","Number","isInteger","floor","segments","outline","limitCoordinates","generateInsertionGeodesicCoordinates","numberOfPoints","points","d","f","A","B","z","lon","generateGreatCircleCoordinates","coordinatesIdentical","ValidateLineStringFeature","magnitude","v","v1","v2","theta","v1x","v1y","v1z","v2x","v2y","v2z","dot","acos","min","max","lngLatToVector","vectorToLngLat","nearestPointOnSegment","posA","posB","posC","C","Cx","Cy","Cz","D","E","F","cross","g","h","t","I1","I2","angleAB","angleAI1","angleBI1","angleAI2","angleBI2","I","findNearestPointOnLine","pointA","pointB","lineVector","LineSnappingBehavior","snappable","boundingBox","lines","nearest","lngLat","inputCoordinate","closestPoint","closestDistance","lineIndex","startPosition","stopPosition","intersectPosition","intersectDistance","indexOf","webMercatorNearestPointOnLine","nearestPointOnLine","dragStart","dragEnd","TerraDrawLineStringMode","currentCoordinate","snapping","mouseMove","insertCoordinates","lastCommittedCoordinates","snappedPointId","lastMouseMoveEvent","editable","editedFeatureId","editedFeatureCoordinateIndex","editedSnapType","editedInsertIndex","editedPointId","coordinateSnapping","insertPoint","lineSnapping","updateSnappedCoordinate","snappedCoordinate","snapCoordinate","updateGeometries","Commit","closingPointCoordinate","updatedGeometry","geometries","generateInsertCoordinates","startCoord","endCoord","strategy","segmentDistance","insertedCoordinates","createLine","startingCoord","firstUpdateToLine","updatedCoord","currentCoordinates","pointId","initialLineCoordinates","updateToLine","cursorXY","updatedLineCoordinates","onRightClick","coordinateIndex","lineStringFilter","splice","onLeftClick","updatedCoordinate","lineSnapped","coordinateSnapped","featureCopy","newLineStringGeometry","getPropertiesCopy","cleanupClosingPointId","isClosingPoint","snappingPointColor","snappingPointWidth","snappingPointOutlineColor","snappingPointOutlineWidth","_this$snapping","_this$snapping2","_this$snapping3","toLine","snapped","toCoordinate","toCustom","getCurrentGeometrySnapshot","ValidationReasonFeatureNotPoint","ValidationReasonFeatureInvalidCoordinates","ValidationReasonFeatureInvalidCoordinatePrecision","ValidatePointFeature","TerraDrawPointMode","nearestPointFeature","getNearestPointFeature","isEdited","editedPointWidth","editedPointColor","editedPointOutlineColor","editedPointOutlineWidth","clickedFeature","distanceToFeature","ClosingPointsBehavior","_startEndPoints","ids","concat","selectedCoords","update","updatedCoordinates","opening","closing","distancePrevious","isClosing","isPreviousClosing","CoordinatePointBehavior","createOrUpdate","existingFeature","existingProperties","existingFeatureProps","existingCoordinatePointIds","coordinatePointIds","every","has","existingCoordinates","existingCoordinatePoints","deleteCoordinatePoints","createPoints","setFeatureCoordinatePoints","existingPoints","deletePointsByFeatureIds","deleteIfPresent","getUpdated","featureProperties","index","coordinatePoints","TerraDrawPolygonMode","showCoordinatePoints","closingPoints","copyAllWhere","featuresWithCoordinates","currentPolygonCoordinates","updatePolygonGeometry","epsilon","offset","polygonFilter","shift","newId","currentPolygonGeometry","updatedPolygon","createPolygon","featureCoordinates","newPolygonGeometry","editedPoint","coordinatePoint","pointType","styleMap","width","color","closingPoint","snappingPoint","coordinatePointWidth","coordinatePointColor","coordinatePointOutlineColor","coordinatePointOutlineWidth","TerraDrawRectangleMode","currentRectangleId","updateRectangle","firstCoord","TerraDrawRenderMode","modeName","Render","validationResult","validatedFeature","featureIsValid","rhumbBearing","from","to","phi1","phi2","deltaLambda","deltaPsi","bear360","rhumbDestination","distanceMeters","distanceInMeters","abs","delta","lambda1","DeltaPhi","DeltaPsi","q","midpointCoordinate","coordinates1","coordinates2","projectedCoordinateOne","projectedCoordinateTwo","geodesicMidpointCoordinate","midpoint","getMidPointCoordinates","featureCoords","midPointCoords","mid","MidPointBehavior","selectionPointBehavior","coordinatePointBehavior","_midPoints","insert","midPointId","midPoint","midPointFeatureId","midPointSegment","getMidPoints","updatedMidPointCoord","SelectionPointBehavior","_selectionPoints","geometryType","selectionPoints","getCoordinatesAsPoints","getOneUpdated","pointInPolygon","rings","inside","len","ring","j","len2","k","p1","p","p2","pixelDistanceToLine","linePointOne","linePointTwo","square","dist2","w","distToSegmentSquared","l2","FeatureAtPointerEventBehavior","createClickBoundingBox","find","hasSelection","clickedPoint","clickedLineString","clickedMidPoint","clickedPolygon","clickedPointDistance","clickedLineStringDistance","clickedMidPointDistance","selectionPoint","nextCoord","distanceToLine","DragFeatureBehavior","featuresAtCursorEvent","midPoints","draggedFeatureId","dragPosition","startDragging","stopDragging","isDragging","canDrag","drag","cursorCoord","updatedCoords","upToCoord","updatedLng","updatedLat","webMercatorDragPosition","webMercatorCursorCoord","webMercatorCoordinate","updatedX","updatedY","updatedSelectionPoints","updatedMidPoints","updatedCoordinatePoints","DragCoordinateBehavior","draggedCoordinate","getClosestCoordinate","closestCoordinate","isFirstOrLastPolygonCoord","geomCoordinates","getDraggableIndex","draggedFeature","allowSelfIntersection","lastCoordIndex","updatedSelectionPoint","centroid","geojson","xSum","ySum","transformRotateWebMercator","angleRad","webMercatorCoords","reduce","acc","rotatedCoordinates","webMercatorCentroid","webMercatorCoordinates","area","centroidX","centroidY","n","crossProduct","calculatePolygonCentroid","lineString","totalX","totalY","calculateLineStringMidpoint","RotateFeatureBehavior","lastBearing","selectedGeometry","selectedGeometryCentroid","selectedGeometryWebMercatorCentroid","reset","rotate","mouseCoord","cursorWebMercator","pivot","pointCoords","finalAngle","DeltaLambda","rhumbDistance","newCoords","transformRotate","ScaleFeatureBehavior","dragCoordinateResizeBehavior","scale","transformScaleWebMercatorCoordinates","originX","originY","xScale","yScale","DragCoordinateResizeBehavior","minimumScale","boundingBoxMaps","opposite","isValidDragWebMercator","distanceX","distanceY","getSelectedFeatureDataWebMercator","getFeature","getNormalisedCoordinates","getBBoxWebMercator","selectedCoordinate","centerWebMercatorDrag","featureData","webMercatorOrigin","webMercatorSelected","closestBBoxIndex","getIndexesWebMercator","webMercatorCursor","scaleWebMercator","centerFixedWebMercatorDrag","scaleFixedWebMercator","oppositeFixedWebMercatorDrag","oppositeBboxIndex","oppositeWebMercatorDrag","cursorDistanceX","cursorDistanceY","validateScale","performWebMercatorScale","validX","MAX_SAFE_INTEGER","validY","west","south","east","north","selectedXY","closestIndex","resizeOption","deselect","pointerOver","insertMidpoint","TerraDrawSelectMode","allowManualDeselection","dragEventThrottle","dragEventCount","selected","flags","validations","coordinateSnap","featuresAtMouseEvent","dragFeature","dragCoordinate","rotateFeature","scaleFeature","dragCoordinateResizeFeature","lineSnap","selectFeature","select","setSelecting","deselectFeature","updateSelectedFeatures","deleteSelected","clickedSelectionPointProps","clickedFeatureDistance","selectionPointFeatureId","modeFlags","deletable","deletePoints","midpoints","fromCursor","previouslySelectedId","canScale","heldKeys","canRotate","preventDefaultKeyEvent","isRotationKeys","isScaleKeys","preventDefault","draggable","resizable","draggableCoordinateIndex","draggedMidPoint","draggableCoordinateIndexAfterInsert","canSelfIntersect","selfIntersectable","rotateable","scaleable","_modeFlags$feature","snapOptions","nearbyMidPoint","nearbySelectionPoint","featureUnderPointer","selectionPointColor","selectionPointOutlineColor","selectionPointWidth","selectionPointOutlineWidth","midPointColor","midPointOutlineColor","midPointWidth","midPointOutlineWidth","selectedPolygonColor","selectedPolygonOutlineWidth","selectedPolygonOutlineColor","selectedPolygonFillOpacity","selectedLineStringColor","selectedLineStringWidth","selectedPointWidth","selectedPointColor","selectedPointOutlineColor","selectedPointOutlineWidth","_flags$feature","_flags$feature2","TerraDrawStaticMode","Static","quickselect","arr","left","right","compare","m","s","sd","swap","tmp","calcBBox","node","toBBox","distBBox","children","destNode","createNode","minX","minY","maxX","maxY","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersectionArea","contains","intersects","height","multiSelect","stack","ceil","RBush","maxEntries","_maxEntries","_minEntries","data","clear","result","nodesToSearch","childBBox","_all","collides","load","_build","_splitRoot","tmpNode","_insert","item","remove","path","indexes","parent","goingUp","_condense","compareMinX","compareMinY","items","N","M","N2","N1","right2","right3","_chooseSubtree","level","targetNode","minArea","minEnlargement","enlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","bbox2","overlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","SpatialIndex","tree","idToNode","nodeToId","Map","setMaps","set","longitudes","latitudes","minLat","maxLat","get","String","seenIds","Set","add","defaultIdStrategy","getId","replace","r","random","GeoJSONStore","tracked","spatialIndex","_onChange","clone","obj","JSON","parse","stringify","featureValidation","clonedInputFeatures","createdFeatures","createdAt","updatedAt","changes","change","propertiesToUpdate","geometriesToUpdate","createdProperties","copy","copyAll","Object","keys","equals","size","polygonAreaSquareMeters","total","ringArea","FACTOR","PI_OVER_180","coordsLength","ValidationReasonFeatureLessThanMinSize","ValidateMinAreaSquareMeters","minSize","ValidateMaxAreaSquareMeters","maxSize","ValidationReasonFeatureNotPolygonOrLineString","ValidationReasonFeatureSelfIntersects","ValidateNotSelfIntersecting","calculateRelativeAngle","bearingAB","relativeAngle","TerraDrawAngledRectangleMode","firstCoordinate","ACloserThanC","hypotenuse","adjacent","rectangleAngle","lineStart","lineEnd","determineHalfPlane","thirdCoordinateXY","fourthCoordinateXY","thirdCoordinate","fourthCoordinate","isClockwiseWebMercator","secondCoord","thirdCoord","TerraDrawSectorMode","arcPoints","arcCoordOne","arcCoordTwo","webMercatorCenter","webMercatorArcCoordOne","webMercatorArcCoordTwo","clockwise","radius","startBearing","endBearing","normalizedStart","normalizedEnd","deltaBearing","bearingStep","pointOnArc","TerraDrawSensorMode","currentInitialArcId","currentStartingPointId","finishedCurrentStartingPointId","finishedInitialArcId","finishedCurrentId","updateLineStringGeometry","lastCoord","webMercatorCoordOne","webMercatorCoordTwo","innerRadius","radiusCalculationPosition","cursorBearing","normalizedCursor","notInSector","getDeltaBearing","finalArc","unshift","centerPointColor","centerPointWidth","centerPointOutlineColor","centerPointOutlineWidth","AdapterListener","name","callback","unregister","registered","_nextKeyUpIsContextMenu","_minPixelDragDistance","_minPixelDragDistanceDrawing","_minPixelDragDistanceSelecting","_lastDrawEvent","_coordinatePrecision","_heldKeys","_listeners","_dragState","_currentModeCallbacks","minPixelDragDistance","minPixelDragDistanceSelecting","minPixelDragDistanceDrawing","getButton","getMapElementXYPosition","mapElement","getMapEventElement","top","getBoundingClientRect","clientX","clientY","getDrawEventFromEvent","latLng","getLngLatFromEvent","callbacks","getAdapterListeners","listener","getCoordinatePrecision","isPrimary","drawEvent","addEventListener","removeEventListener","lastEventXY","currentEventXY","modeState","getState","pixelDistanceToCheck","isMicroDrag","enabled","setDraggability","bind","ValidationReasons","TerraDrawFreehandLineStringMode","closingDistance","isValidJSONValue","isFinite","RegExp","proto","getPrototypeOf","prototype","ArrayBuffer","isView","DataView","TerraDraw","_modes","_mode","_adapter","_enabled","_store","_eventListeners","_instanceSelectMode","adapter","duplicateModeTracker","modesMap","modes","modeMap","currentMode","modeKeys","static","ready","getChanged","changed","unchanged","render","created","deletedIds","updated","getModeStyles","modeId","checkEnabled","modeStyles","featuresAtLocation","ignoreSelectFeatures","ignoreCoordinatePoints","ignoreCurrentlyDrawing","ignoreClosingPoints","inputPoint","pointCoordinates","pointXY","includePolygonsWithinPointerDistance","projectedStart","projectedEnd","addClosestCoordinateInfoToProperties","closestCoordinateIndexToEvent","closestCoordinatePixelDistanceToEvent","closestCoordinateDistanceKmToEvent","getSelectModeOrThrow","selectMode","getSelectMode","switchToSelectMode","getMode","setMode","isGuidanceFeature","setModeStyles","updateModeOptions","getSnapshot","getSnapshotFeature","getModeState","removeFeatures","coordinatePointsToDelete","getFeatureId","hasFeature","checkIsReservedProperty","propertyName","values","updateFeatureProperties","entries","updateFeatureGeometry","modeToUpdate","updatedFeature","featureIsSelected","selectModePresent","transformFeatureGeometry","transformation","addFeatures","featureMode","modeToAddTo","onReady","onClear","getFeaturesAtLngLat","getFeaturesAtPointerEvent","on","listeners","off"],"mappings":"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"}