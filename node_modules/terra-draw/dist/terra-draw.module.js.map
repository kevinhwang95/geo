{"version":3,"file":"terra-draw.module.js","sources":["../src/common.ts","../src/store/store-feature-validation.ts","../src/validations/common-validations.ts","../src/modes/base.mode.ts","../src/geometry/measure/haversine-distance.ts","../src/geometry/helpers.ts","../src/geometry/limit-decimal-precision.ts","../src/geometry/project/web-mercator.ts","../src/geometry/shape/create-circle.ts","../src/geometry/boolean/self-intersects.ts","../src/geometry/boolean/is-valid-coordinate.ts","../src/validations/polygon.validation.ts","../src/modes/circle/circle.mode.ts","../src/util/styling.ts","../src/geometry/shape/web-mercator-distortion.ts","../src/geometry/measure/pixel-distance.ts","../src/geometry/ensure-right-hand-rule.ts","../src/geometry/boolean/right-hand-rule.ts","../src/modes/freehand/freehand.mode.ts","../src/modes/base.behavior.ts","../src/geometry/shape/create-bbox.ts","../src/modes/click-bounding-box.behavior.ts","../src/modes/pixel-distance.behavior.ts","../src/modes/coordinate-snapping.behavior.ts","../src/geometry/measure/destination.ts","../src/geometry/measure/bearing.ts","../src/geometry/measure/slice-along.ts","../src/geometry/shape/great-circle-coordinates.ts","../src/modes/insert-coordinates.behavior.ts","../src/geometry/coordinates-identical.ts","../src/validations/linestring.validation.ts","../src/geometry/point-on-line.ts","../src/modes/line-snapping.behavior.ts","../src/geometry/web-mercator-point-on-line.ts","../src/modes/linestring/linestring.mode.ts","../src/validations/point.validation.ts","../src/modes/point/point.mode.ts","../src/modes/polygon/behaviors/closing-points.behavior.ts","../src/modes/select/behaviors/coordinate-point.behavior.ts","../src/modes/polygon/polygon.mode.ts","../src/util/geoms.ts","../src/modes/rectangle/rectangle.mode.ts","../src/modes/render/render.mode.ts","../src/geometry/measure/rhumb-bearing.ts","../src/geometry/measure/rhumb-destination.ts","../src/geometry/midpoint-coordinate.ts","../src/geometry/get-midpoints.ts","../src/modes/select/behaviors/midpoint.behavior.ts","../src/modes/select/behaviors/selection-point.behavior.ts","../src/geometry/get-coordinates-as-points.ts","../src/geometry/boolean/point-in-polygon.ts","../src/geometry/measure/pixel-distance-to-line.ts","../src/modes/select/behaviors/feature-at-pointer-event.behavior.ts","../src/modes/select/behaviors/drag-feature.behavior.ts","../src/modes/select/behaviors/drag-coordinate.behavior.ts","../src/geometry/centroid.ts","../src/geometry/transform/rotate.ts","../src/geometry/web-mercator-centroid.ts","../src/modes/select/behaviors/rotate-feature.behavior.ts","../src/geometry/measure/rhumb-distance.ts","../src/modes/select/behaviors/scale-feature.behavior.ts","../src/geometry/transform/scale.ts","../src/modes/select/behaviors/drag-coordinate-resize.behavior.ts","../src/modes/select/select.mode.ts","../src/modes/static/static.mode.ts","../src/store/spatial-index/quickselect.ts","../src/store/spatial-index/rbush.ts","../src/store/spatial-index/spatial-index.ts","../src/store/store.ts","../src/util/id.ts","../src/geometry/measure/area.ts","../src/validations/min-size.validation.ts","../src/validations/max-size.validation.ts","../src/validations/not-self-intersecting.validation.ts","../src/geometry/calculate-relative-angle.ts","../src/modes/angled-rectangle/angled-rectangle.mode.ts","../src/geometry/determine-halfplane.ts","../src/geometry/clockwise.ts","../src/modes/sector/sector.mode.ts","../src/modes/sensor/sensor.mode.ts","../src/common/adapter-listener.ts","../src/common/base.adapter.ts","../src/validation-reasons.ts","../src/modes/freehand-linestring/freehand-linestring.mode.ts","../src/store/valid-json.ts","../src/terra-draw.ts"],"sourcesContent":["import { LineString, Polygon, Position } from \"geojson\";\nimport {\n\tStoreChangeHandler,\n\tGeoJSONStore,\n\tGeoJSONStoreFeatures,\n\tFeatureId,\n} from \"./store/store\";\n\nexport type HexColor = `#${string}`;\n\nexport type HexColorStyling =\n\t| HexColor\n\t| ((feature: GeoJSONStoreFeatures) => HexColor);\n\nexport type NumericStyling =\n\t| number\n\t| ((feature: GeoJSONStoreFeatures) => number);\n\nexport interface TerraDrawAdapterStyling {\n\tpointColor: HexColor;\n\tpointWidth: number;\n\tpointOutlineColor: HexColor;\n\tpointOutlineWidth: number;\n\tpolygonFillColor: HexColor;\n\tpolygonFillOpacity: number;\n\tpolygonOutlineColor: HexColor;\n\tpolygonOutlineWidth: number;\n\tlineStringWidth: number;\n\tlineStringColor: HexColor;\n\tzIndex: number;\n}\n\nexport type CartesianPoint = { x: number; y: number };\n\n// Neither buttons nor touch/pen contact changed since last event\t-1\n// Mouse move with no buttons pressed, Pen moved while hovering with no buttons pressed\t—\n// Left Mouse, Touch Contact, Pen contact\t0\n// Middle Mouse\t1\n// Right Mouse, Pen barrel button\t2\nexport interface TerraDrawMouseEvent {\n\tlng: number;\n\tlat: number;\n\tcontainerX: number;\n\tcontainerY: number;\n\tbutton: \"neither\" | \"left\" | \"middle\" | \"right\";\n\theldKeys: string[];\n\tisContextMenu: boolean;\n}\n\nexport interface TerraDrawKeyboardEvent {\n\tkey: string;\n\theldKeys: string[];\n\tpreventDefault: () => void;\n}\n\nexport type Cursor = Parameters<SetCursor>[0];\n\nexport type SetCursor = (\n\tcursor:\n\t\t| \"unset\"\n\t\t| \"grab\"\n\t\t| \"grabbing\"\n\t\t| \"crosshair\"\n\t\t| \"pointer\"\n\t\t| \"wait\"\n\t\t| \"move\",\n) => void;\n\nexport type Project = (lng: number, lat: number) => CartesianPoint;\nexport type Unproject = (x: number, y: number) => { lat: number; lng: number };\nexport type GetLngLatFromEvent = (event: PointerEvent | MouseEvent) => {\n\tlng: number;\n\tlat: number;\n} | null;\n\nexport type Projection = \"web-mercator\" | \"globe\";\n\nexport type OnFinishContext = { mode: string; action: string };\n\nexport type OnChangeContext = { origin: \"api\" };\n\nexport type TerraDrawGeoJSONStore = GeoJSONStore<\n\tOnChangeContext | undefined,\n\tFeatureId\n>;\n\nexport interface TerraDrawModeRegisterConfig {\n\tmode: string;\n\tstore: TerraDrawGeoJSONStore;\n\tsetDoubleClickToZoom: (enabled: boolean) => void;\n\tsetCursor: SetCursor;\n\tonChange: StoreChangeHandler<OnChangeContext | undefined>;\n\tonSelect: (selectedId: string) => void;\n\tonDeselect: (deselectedId: string) => void;\n\tonFinish: (finishedId: string, context: OnFinishContext) => void;\n\tproject: Project;\n\tunproject: Unproject;\n\tcoordinatePrecision: number;\n}\n\nexport enum UpdateTypes {\n\tCommit = \"commit\",\n\tProvisional = \"provisional\",\n\tFinish = \"finish\",\n}\n\ntype ValidationContext = Pick<\n\tTerraDrawModeRegisterConfig,\n\t\"project\" | \"unproject\" | \"coordinatePrecision\"\n> & {\n\tupdateType: UpdateTypes;\n};\n\nexport type Validation = (\n\tfeature: GeoJSONStoreFeatures,\n\tcontext: ValidationContext,\n) => {\n\tvalid: boolean;\n\treason?: string;\n};\n\nexport interface Snapping {\n\ttoLine?: boolean;\n\ttoCoordinate?: boolean;\n\ttoCustom?: (\n\t\tevent: TerraDrawMouseEvent,\n\t\tcontext: {\n\t\t\tcurrentId?: FeatureId;\n\t\t\tcurrentCoordinate?: number;\n\t\t\tgetCurrentGeometrySnapshot: () => (Polygon | LineString) | null;\n\t\t\tproject: Project;\n\t\t\tunproject: Unproject;\n\t\t},\n\t) => Position | undefined;\n}\n\nexport type TerraDrawModeState =\n\t| \"unregistered\"\n\t| \"registered\"\n\t| \"started\"\n\t| \"drawing\"\n\t| \"selecting\"\n\t| \"stopped\";\n\nexport interface TerraDrawCallbacks {\n\tgetState: () => TerraDrawModeState;\n\tonKeyUp: (event: TerraDrawKeyboardEvent) => void;\n\tonKeyDown: (event: TerraDrawKeyboardEvent) => void;\n\tonClick: (event: TerraDrawMouseEvent) => void;\n\tonMouseMove: (event: TerraDrawMouseEvent) => void;\n\tonDragStart: (\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) => void;\n\tonDrag: (\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) => void;\n\tonDragEnd: (\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) => void;\n\tonClear: () => void;\n\tonReady?(): void;\n}\n\nexport interface TerraDrawChanges {\n\tcreated: GeoJSONStoreFeatures[];\n\tupdated: GeoJSONStoreFeatures[];\n\tunchanged: GeoJSONStoreFeatures[];\n\tdeletedIds: FeatureId[];\n}\n\nexport type TerraDrawStylingFunction = {\n\t[mode: string]: (feature: GeoJSONStoreFeatures) => TerraDrawAdapterStyling;\n};\n\nexport interface TerraDrawAdapter {\n\tproject: Project;\n\tunproject: Unproject;\n\tsetCursor: SetCursor;\n\tgetLngLatFromEvent: GetLngLatFromEvent;\n\tsetDoubleClickToZoom: (enabled: boolean) => void;\n\tgetMapEventElement: () => HTMLElement;\n\tregister(callbacks: TerraDrawCallbacks): void;\n\tunregister(): void;\n\trender(changes: TerraDrawChanges, styling: TerraDrawStylingFunction): void;\n\tclear(): void;\n\tgetCoordinatePrecision(): number;\n}\n\nexport const SELECT_PROPERTIES = {\n\tSELECTED: \"selected\",\n\tMID_POINT: \"midPoint\",\n\tSELECTION_POINT_FEATURE_ID: \"selectionPointFeatureId\",\n\tSELECTION_POINT: \"selectionPoint\",\n} as const;\n\nexport const COMMON_PROPERTIES = {\n\tMODE: \"mode\",\n\tCURRENTLY_DRAWING: \"currentlyDrawing\",\n\tEDITED: \"edited\",\n\tCLOSING_POINT: \"closingPoint\",\n\tSNAPPING_POINT: \"snappingPoint\",\n\tCOORDINATE_POINT: \"coordinatePoint\",\n\tCOORDINATE_POINT_FEATURE_ID: \"coordinatePointFeatureId\",\n\tCOORDINATE_POINT_IDS: \"coordinatePointIds\",\n\tPROVISIONAL_COORDINATE_COUNT: \"provisionalCoordinateCount\",\n\tCOMMITTED_COORDINATE_COUNT: \"committedCoordinateCount\",\n} as const;\n\n/**\n * Lower z-index represents layers that are lower in the stack\n * and higher z-index represents layers that are higher in the stack\n * i.e. a layer with z-index 10 will be rendered below a layer with z-index 20\n */\nexport const Z_INDEX = {\n\tLAYER_ONE: 10,\n\tLAYER_TWO: 20,\n\tLAYER_THREE: 30,\n\tLAYER_FOUR: 40,\n\tLAYER_FIVE: 50,\n} as const;\n","import { Validation } from \"../common\";\nimport { FeatureId, IdStrategy } from \"./store\";\n\nexport const StoreValidationErrors = {\n\tFeatureHasNoId: \"Feature has no id\",\n\tFeatureIsNotObject: \"Feature is not object\",\n\tInvalidTrackedProperties: \"updatedAt and createdAt are not valid timestamps\",\n\tFeatureHasNoMode: \"Feature does not have a set mode\",\n\tFeatureIdIsNotValidGeoJSON: `Feature must be string or number as per GeoJSON spec`,\n\tFeatureIdIsNotValid: `Feature must match the id strategy (default is UUID4)`,\n\tFeatureHasNoGeometry: \"Feature has no geometry\",\n\tFeatureHasNoProperties: \"Feature has no properties\",\n\tFeatureGeometryNotSupported: \"Feature is not Point, LineString or Polygon\",\n\tFeatureCoordinatesNotAnArray: \"Feature coordinates is not an array\",\n\tInvalidModeProperty: \"Feature does not have a valid mode property\",\n} as const;\n\nfunction isObject(\n\tfeature: unknown,\n): feature is Record<string | number, unknown> {\n\treturn Boolean(\n\t\tfeature &&\n\t\t\ttypeof feature === \"object\" &&\n\t\t\tfeature !== null &&\n\t\t\t!Array.isArray(feature),\n\t);\n}\n\nexport function hasModeProperty(\n\tfeature: unknown,\n): feature is { properties: { mode: string } } {\n\treturn Boolean(\n\t\tfeature &&\n\t\t\ttypeof feature === \"object\" &&\n\t\t\t\"properties\" in feature &&\n\t\t\ttypeof feature.properties === \"object\" &&\n\t\t\tfeature.properties !== null &&\n\t\t\t\"mode\" in feature.properties,\n\t);\n}\n\nfunction dateIsValid(timestamp: unknown): boolean {\n\treturn (\n\t\ttypeof timestamp === \"number\" &&\n\t\t!isNaN(new Date(timestamp as number).valueOf())\n\t);\n}\n\nexport function isValidTimestamp(timestamp: unknown): boolean {\n\tif (!dateIsValid(timestamp)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport function isValidStoreFeature(\n\tfeature: unknown,\n\tisValidId: IdStrategy<FeatureId>[\"isValidId\"],\n): ReturnType<Validation> {\n\tlet error;\n\tif (!isObject(feature)) {\n\t\terror = StoreValidationErrors.FeatureIsNotObject;\n\t} else if (feature.id === null || feature.id === undefined) {\n\t\terror = StoreValidationErrors.FeatureHasNoId;\n\t} else if (typeof feature.id !== \"string\" && typeof feature.id !== \"number\") {\n\t\terror = StoreValidationErrors.FeatureIdIsNotValidGeoJSON;\n\t} else if (!isValidId(feature.id)) {\n\t\terror = StoreValidationErrors.FeatureIdIsNotValid;\n\t} else if (!isObject(feature.geometry)) {\n\t\terror = StoreValidationErrors.FeatureHasNoGeometry;\n\t} else if (!isObject(feature.properties)) {\n\t\terror = StoreValidationErrors.FeatureHasNoProperties;\n\t} else if (\n\t\ttypeof feature.geometry.type !== \"string\" ||\n\t\t![\"Polygon\", \"LineString\", \"Point\"].includes(feature.geometry.type)\n\t) {\n\t\terror = StoreValidationErrors.FeatureGeometryNotSupported;\n\t} else if (!Array.isArray(feature.geometry.coordinates)) {\n\t\terror = StoreValidationErrors.FeatureCoordinatesNotAnArray;\n\t} else if (\n\t\t!feature.properties.mode ||\n\t\ttypeof feature.properties.mode !== \"string\"\n\t) {\n\t\treturn { valid: false, reason: StoreValidationErrors.InvalidModeProperty };\n\t}\n\n\tif (error) {\n\t\treturn { valid: false, reason: error };\n\t}\n\n\treturn { valid: true };\n}\n","export const ValidationReasonFeatureNotPolygon = \"Feature is not a Polygon\";\nexport const ValidationReasonModeMismatch =\n\t\"Feature mode property does not match the mode being added to\";\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport {\n\tOnChangeContext,\n\tHexColor,\n\tOnFinishContext,\n\tProjection,\n\tTerraDrawAdapterStyling,\n\tTerraDrawGeoJSONStore,\n\tTerraDrawKeyboardEvent,\n\tTerraDrawModeRegisterConfig,\n\tTerraDrawModeState,\n\tTerraDrawMouseEvent,\n\tUpdateTypes,\n\tValidation,\n} from \"../common\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreChangeHandler,\n} from \"../store/store\";\nimport { isValidStoreFeature } from \"../store/store-feature-validation\";\nimport { ValidationReasonModeMismatch } from \"../validations/common-validations\";\n\nexport type CustomStyling = Record<\n\tstring,\n\t| string\n\t| number\n\t| ((feature: GeoJSONStoreFeatures) => HexColor)\n\t| ((feature: GeoJSONStoreFeatures) => number)\n>;\n\nexport enum ModeTypes {\n\tDrawing = \"drawing\",\n\tSelect = \"select\",\n\tStatic = \"static\",\n\tRender = \"render\",\n}\n\nexport const DefaultPointerEvents = {\n\trightClick: true,\n\tcontextMenu: false,\n\tleftClick: true,\n\tonDragStart: true,\n\tonDrag: true,\n\tonDragEnd: true,\n} as const;\n\ntype AllowPointerEvent = boolean | ((event: TerraDrawMouseEvent) => boolean);\n\nexport interface PointerEvents {\n\tleftClick: AllowPointerEvent;\n\trightClick: AllowPointerEvent;\n\tcontextMenu: AllowPointerEvent;\n\tonDragStart: AllowPointerEvent;\n\tonDrag: AllowPointerEvent;\n\tonDragEnd: AllowPointerEvent;\n}\n\nexport type BaseModeOptions<Styling extends CustomStyling> = {\n\tstyles?: Partial<Styling>;\n\tpointerDistance?: number;\n\tvalidation?: Validation;\n\tprojection?: Projection;\n\tpointerEvents?: PointerEvents;\n};\n\nexport abstract class TerraDrawBaseDrawMode<Styling extends CustomStyling> {\n\t// State\n\tprotected _state: TerraDrawModeState = \"unregistered\";\n\tget state() {\n\t\treturn this._state;\n\t}\n\tset state(_) {\n\t\tthrow new Error(\"Please use the modes lifecycle methods\");\n\t}\n\n\t// Styles\n\tprotected _styles: Partial<Styling> = {};\n\tget styles(): Partial<Styling> {\n\t\treturn this._styles;\n\t}\n\tset styles(styling: Partial<Styling>) {\n\t\tif (typeof styling !== \"object\") {\n\t\t\tthrow new Error(\"Styling must be an object\");\n\t\t}\n\n\t\t// Note: This may not be initialised yet as styles can be set/changed pre-registration\n\t\tif (this.onStyleChange) {\n\t\t\tthis.onStyleChange([], \"styling\");\n\t\t}\n\t\tthis._styles = styling;\n\t}\n\n\tprotected pointerEvents: PointerEvents = DefaultPointerEvents;\n\tprotected behaviors: TerraDrawModeBehavior[] = [];\n\tprotected validate: Validation | undefined;\n\tprotected pointerDistance: number = 40;\n\tprotected coordinatePrecision!: number;\n\tprotected onStyleChange!: StoreChangeHandler<OnChangeContext | undefined>;\n\tprotected store!: TerraDrawGeoJSONStore;\n\tprotected projection: Projection = \"web-mercator\";\n\n\tprotected setDoubleClickToZoom!: TerraDrawModeRegisterConfig[\"setDoubleClickToZoom\"];\n\tprotected unproject!: TerraDrawModeRegisterConfig[\"unproject\"];\n\tprotected project!: TerraDrawModeRegisterConfig[\"project\"];\n\tprotected setCursor!: TerraDrawModeRegisterConfig[\"setCursor\"];\n\tprotected registerBehaviors(behaviorConfig: BehaviorConfig): void {}\n\n\tconstructor(\n\t\toptions?: BaseModeOptions<Styling>,\n\t\twillCallUpdateOptionsInParentClass = false,\n\t) {\n\t\t// Note: We want to updateOptions on the base class by default, but we don't want it to be\n\t\t// called twice if the extending class is going to call it as well\n\t\tif (!willCallUpdateOptionsInParentClass) {\n\t\t\tthis.updateOptions(options);\n\t\t}\n\t}\n\n\tupdateOptions(options?: BaseModeOptions<Styling>) {\n\t\tif (options?.styles) {\n\t\t\t// Note: we are updating this.styles and not this._styles - this is because\n\t\t\t// once registered we want to trigger the onStyleChange\n\t\t\tthis.styles = { ...this._styles, ...options.styles };\n\t\t}\n\n\t\tif (options?.pointerDistance) {\n\t\t\tthis.pointerDistance = options.pointerDistance;\n\t\t}\n\t\tif (options?.validation) {\n\t\t\tthis.validate = options && options.validation;\n\t\t}\n\t\tif (options?.projection) {\n\t\t\tthis.projection = options.projection;\n\t\t}\n\n\t\tif (options?.pointerEvents !== undefined) {\n\t\t\tthis.pointerEvents = options.pointerEvents;\n\t\t}\n\t}\n\n\tprotected allowPointerEvent(\n\t\tpointerEvent: AllowPointerEvent,\n\t\tevent: TerraDrawMouseEvent,\n\t) {\n\t\tif (typeof pointerEvent === \"boolean\") {\n\t\t\treturn pointerEvent;\n\t\t}\n\t\tif (typeof pointerEvent === \"function\") {\n\t\t\treturn pointerEvent(event);\n\t\t}\n\t\treturn true;\n\t}\n\n\ttype = ModeTypes.Drawing;\n\tmode = \"base\";\n\n\tprotected setDrawing() {\n\t\tif (this._state === \"started\") {\n\t\t\tthis._state = \"drawing\";\n\t\t} else {\n\t\t\tthrow new Error(\"Mode must be unregistered or stopped to start\");\n\t\t}\n\t}\n\n\tprotected setStarted() {\n\t\tif (\n\t\t\tthis._state === \"stopped\" ||\n\t\t\tthis._state === \"registered\" ||\n\t\t\tthis._state === \"drawing\" ||\n\t\t\tthis._state === \"selecting\"\n\t\t) {\n\t\t\tthis._state = \"started\";\n\t\t\tthis.setDoubleClickToZoom(false);\n\t\t} else {\n\t\t\tthrow new Error(\"Mode must be unregistered or stopped to start\");\n\t\t}\n\t}\n\n\tprotected setStopped() {\n\t\tif (this._state === \"started\") {\n\t\t\tthis._state = \"stopped\";\n\t\t\tthis.setDoubleClickToZoom(true);\n\t\t} else {\n\t\t\tthrow new Error(\"Mode must be started to be stopped\");\n\t\t}\n\t}\n\n\tregister(config: TerraDrawModeRegisterConfig) {\n\t\tif (this._state === \"unregistered\") {\n\t\t\tthis._state = \"registered\";\n\t\t\tthis.store = config.store;\n\t\t\tthis.store.registerOnChange(config.onChange);\n\t\t\tthis.setDoubleClickToZoom = config.setDoubleClickToZoom;\n\t\t\tthis.project = config.project;\n\t\t\tthis.unproject = config.unproject;\n\t\t\tthis.onSelect = config.onSelect;\n\t\t\tthis.onDeselect = config.onDeselect;\n\t\t\tthis.setCursor = config.setCursor;\n\t\t\tthis.onStyleChange = config.onChange;\n\t\t\tthis.onFinish = config.onFinish;\n\t\t\tthis.coordinatePrecision = config.coordinatePrecision;\n\n\t\t\tthis.registerBehaviors({\n\t\t\t\tmode: config.mode,\n\t\t\t\tstore: this.store,\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t\tpointerDistance: this.pointerDistance,\n\t\t\t\tcoordinatePrecision: config.coordinatePrecision,\n\t\t\t\tprojection: this.projection,\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error(\"Can not register unless mode is unregistered\");\n\t\t}\n\t}\n\n\tvalidateFeature(feature: unknown): ReturnType<Validation> {\n\t\treturn this.performFeatureValidation(feature);\n\t}\n\n\tafterFeatureAdded(feature: GeoJSONStoreFeatures) {}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {}\n\n\tprivate performFeatureValidation(feature: unknown): ReturnType<Validation> {\n\t\tif (this._state === \"unregistered\") {\n\t\t\tthrow new Error(\"Mode must be registered\");\n\t\t}\n\n\t\tconst validStoreFeature = isValidStoreFeature(\n\t\t\tfeature,\n\t\t\tthis.store.idStrategy.isValidId,\n\t\t);\n\n\t\t// We also want tp validate based on any specific valdiations passed in\n\t\tif (this.validate) {\n\t\t\tconst validation = this.validate(feature as GeoJSONStoreFeatures, {\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\t// validatedFeature: feature as GeoJSONStoreFeatures,\n\t\t\t\tvalid: validStoreFeature.valid && validation.valid,\n\t\t\t\treason: validation.reason,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t// validatedFeature: feature as GeoJSONStoreFeatures,\n\t\t\tvalid: validStoreFeature.valid,\n\t\t\treason: validStoreFeature.reason,\n\t\t};\n\t}\n\n\tprotected validateModeFeature(\n\t\tfeature: unknown,\n\t\tmodeValidationFn: (feature: GeoJSONStoreFeatures) => ReturnType<Validation>,\n\t): ReturnType<Validation> {\n\t\tconst validation = this.performFeatureValidation(feature);\n\t\tif (validation.valid) {\n\t\t\tconst validatedFeature = feature as GeoJSONStoreFeatures;\n\t\t\tconst matches = validatedFeature.properties.mode === this.mode;\n\t\t\tif (!matches) {\n\t\t\t\treturn {\n\t\t\t\t\tvalid: false,\n\t\t\t\t\treason: ValidationReasonModeMismatch,\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst modeValidation = modeValidationFn(validatedFeature);\n\t\t\treturn modeValidation;\n\t\t}\n\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: validation.reason,\n\t\t};\n\t}\n\n\tabstract start(): void;\n\tabstract stop(): void;\n\tabstract cleanUp(): void;\n\tabstract styleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling;\n\n\tonFinish(finishedId: FeatureId, context: OnFinishContext) {}\n\tonDeselect(deselectedId: FeatureId) {}\n\tonSelect(selectedId: FeatureId) {}\n\tonKeyDown(event: TerraDrawKeyboardEvent) {}\n\tonKeyUp(event: TerraDrawKeyboardEvent) {}\n\tonMouseMove(event: TerraDrawMouseEvent) {}\n\tonClick(event: TerraDrawMouseEvent) {}\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {}\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {}\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {}\n\n\tprotected getHexColorStylingValue(\n\t\tvalue: HexColor | ((feature: GeoJSONStoreFeatures) => HexColor) | undefined,\n\t\tdefaultValue: HexColor,\n\t\tfeature: GeoJSONStoreFeatures,\n\t): HexColor {\n\t\treturn this.getStylingValue(value, defaultValue, feature);\n\t}\n\n\tprotected getNumericStylingValue(\n\t\tvalue: number | ((feature: GeoJSONStoreFeatures) => number) | undefined,\n\t\tdefaultValue: number,\n\t\tfeature: GeoJSONStoreFeatures,\n\t): number {\n\t\treturn this.getStylingValue(value, defaultValue, feature);\n\t}\n\n\tprivate getStylingValue<T extends string | number>(\n\t\tvalue: T | ((feature: GeoJSONStoreFeatures) => T) | undefined,\n\t\tdefaultValue: T,\n\t\tfeature: GeoJSONStoreFeatures,\n\t) {\n\t\tif (value === undefined) {\n\t\t\treturn defaultValue;\n\t\t} else if (typeof value === \"function\") {\n\t\t\treturn value(feature);\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nexport abstract class TerraDrawBaseSelectMode<\n\tStyling extends CustomStyling,\n> extends TerraDrawBaseDrawMode<Styling> {\n\tpublic type = ModeTypes.Select;\n\n\tpublic abstract selectFeature(featureId: FeatureId): void;\n\tpublic abstract deselectFeature(featureId: FeatureId): void;\n}\n","import { Position } from \"geojson\";\n\nexport function haversineDistanceKilometers(\n\tpointOne: Position,\n\tpointTwo: Position,\n) {\n\tconst toRadians = (latOrLng: number) => (latOrLng * Math.PI) / 180;\n\n\tconst phiOne = toRadians(pointOne[1]);\n\tconst lambdaOne = toRadians(pointOne[0]);\n\tconst phiTwo = toRadians(pointTwo[1]);\n\tconst lambdaTwo = toRadians(pointTwo[0]);\n\tconst deltaPhi = phiTwo - phiOne;\n\tconst deltalambda = lambdaTwo - lambdaOne;\n\n\tconst a =\n\t\tMath.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\n\t\tMath.cos(phiOne) *\n\t\t\tMath.cos(phiTwo) *\n\t\t\tMath.sin(deltalambda / 2) *\n\t\t\tMath.sin(deltalambda / 2);\n\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n\tconst radius = 6371e3;\n\tconst distance = radius * c;\n\n\treturn distance / 1000;\n}\n","export const earthRadius = 6371008.8;\n\nexport function degreesToRadians(degrees: number): number {\n\tconst radians = degrees % 360;\n\treturn (radians * Math.PI) / 180;\n}\n\nexport function lengthToRadians(distance: number): number {\n\tconst factor = earthRadius / 1000;\n\treturn distance / factor;\n}\n\nexport function radiansToDegrees(radians: number): number {\n\tconst degrees = radians % (2 * Math.PI);\n\treturn (degrees * 180) / Math.PI;\n}\n","export function limitPrecision(num: number, decimalLimit = 9) {\n\tconst decimals = Math.pow(10, decimalLimit);\n\treturn Math.round(num * decimals) / decimals;\n}\n","import { CartesianPoint } from \"../../common\";\n\nconst RADIANS_TO_DEGREES = 57.29577951308232 as const; // 180 / Math.PI\nconst DEGREES_TO_RADIANS = 0.017453292519943295 as const; // Math.PI / 180\nconst R = 6378137 as const;\n\n/**\n * Convert longitude and latitude to web mercator x and y\n * @param lng\n * @param lat\n * @returns - web mercator x and y\n */\nexport const lngLatToWebMercatorXY = (\n\tlng: number,\n\tlat: number,\n): CartesianPoint => ({\n\tx: lng === 0 ? 0 : lng * DEGREES_TO_RADIANS * R,\n\ty:\n\t\tlat === 0\n\t\t\t? 0\n\t\t\t: Math.log(Math.tan(Math.PI / 4 + (lat * DEGREES_TO_RADIANS) / 2)) * R,\n});\n\n/**\n * Convert web mercator x and y to longitude and latitude\n * @param x - web mercator x\n * @param y - web mercator y\n * @returns - longitude and latitude\n */\nexport const webMercatorXYToLngLat = (\n\tx: number,\n\ty: number,\n): { lng: number; lat: number } => ({\n\tlng: x === 0 ? 0 : RADIANS_TO_DEGREES * (x / R),\n\tlat:\n\t\ty === 0\n\t\t\t? 0\n\t\t\t: (2 * Math.atan(Math.exp(y / R)) - Math.PI / 2) * RADIANS_TO_DEGREES,\n});\n","import { Feature, Polygon, Position } from \"geojson\";\nimport {\n\tdegreesToRadians,\n\tlengthToRadians,\n\tradiansToDegrees,\n} from \"../helpers\";\nimport { limitPrecision } from \"../limit-decimal-precision\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../project/web-mercator\";\n\n// Adapted from the @turf/circle module which is MIT Licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-circle/index.ts\n\nfunction destination(\n\torigin: Position,\n\tdistance: number,\n\tbearing: number,\n): Position {\n\tconst longitude1 = degreesToRadians(origin[0]);\n\tconst latitude1 = degreesToRadians(origin[1]);\n\tconst bearingRad = degreesToRadians(bearing);\n\tconst radians = lengthToRadians(distance);\n\n\t// Main\n\tconst latitude2 = Math.asin(\n\t\tMath.sin(latitude1) * Math.cos(radians) +\n\t\t\tMath.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad),\n\t);\n\tconst longitude2 =\n\t\tlongitude1 +\n\t\tMath.atan2(\n\t\t\tMath.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\n\t\t\tMath.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2),\n\t\t);\n\tconst lng = radiansToDegrees(longitude2);\n\tconst lat = radiansToDegrees(latitude2);\n\n\treturn [lng, lat];\n}\n\nexport function circle(options: {\n\tcenter: Position;\n\tradiusKilometers: number;\n\tcoordinatePrecision: number;\n\tsteps?: number;\n}): Feature<Polygon> {\n\tconst { center, radiusKilometers, coordinatePrecision } = options;\n\tconst steps = options.steps ? options.steps : 64;\n\n\tconst coordinates: Position[] = [];\n\tfor (let i = 0; i < steps; i++) {\n\t\tconst circleCoordinate = destination(\n\t\t\tcenter,\n\t\t\tradiusKilometers,\n\t\t\t(i * -360) / steps,\n\t\t);\n\n\t\tcoordinates.push([\n\t\t\tlimitPrecision(circleCoordinate[0], coordinatePrecision),\n\t\t\tlimitPrecision(circleCoordinate[1], coordinatePrecision),\n\t\t]);\n\t}\n\tcoordinates.push(coordinates[0]);\n\n\treturn {\n\t\ttype: \"Feature\",\n\t\tgeometry: { type: \"Polygon\", coordinates: [coordinates] },\n\t\tproperties: {},\n\t};\n}\n\nexport function circleWebMercator(options: {\n\tcenter: Position;\n\tradiusKilometers: number;\n\tcoordinatePrecision: number;\n\tsteps?: number;\n}): GeoJSON.Feature<GeoJSON.Polygon> {\n\tconst { center, radiusKilometers, coordinatePrecision } = options;\n\tconst steps = options.steps ? options.steps : 64;\n\n\tconst radiusMeters = radiusKilometers * 1000;\n\n\tconst [lng, lat] = center;\n\tconst { x, y } = lngLatToWebMercatorXY(lng, lat);\n\n\tconst coordinates: Position[] = [];\n\tfor (let i = 0; i < steps; i++) {\n\t\tconst angle = (((i * 360) / steps) * Math.PI) / 180;\n\t\tconst dx = radiusMeters * Math.cos(angle);\n\t\tconst dy = radiusMeters * Math.sin(angle);\n\t\tconst [wx, wy] = [x + dx, y + dy];\n\t\tconst { lng, lat } = webMercatorXYToLngLat(wx, wy);\n\t\tcoordinates.push([\n\t\t\tlimitPrecision(lng, coordinatePrecision),\n\t\t\tlimitPrecision(lat, coordinatePrecision),\n\t\t]);\n\t}\n\n\t// Close the circle by adding the first point at the end\n\tcoordinates.push(coordinates[0]);\n\n\treturn {\n\t\ttype: \"Feature\",\n\t\tgeometry: { type: \"Polygon\", coordinates: [coordinates] },\n\t\tproperties: {},\n\t};\n}\n","// Based on - https://github.com/mclaeysb/geojson-polygon-self-intersections\n// MIT License - Copyright (c) 2016 Manuel Claeys Bouuaert\n\nimport { Feature, LineString, Polygon, Position } from \"geojson\";\n// import * as rbush from \"rbush\";\n\ntype SelfIntersectsOptions = {\n\tepsilon: number;\n\t// reportVertexOnVertex: boolean;\n\t// reportVertexOnEdge: boolean;\n};\n\nexport function selfIntersects(\n\tfeature: Feature<Polygon> | Feature<LineString>,\n): boolean {\n\tconst options: SelfIntersectsOptions = {\n\t\tepsilon: 0,\n\t\t// reportVertexOnVertex: false,\n\t\t// reportVertexOnEdge: false,\n\t};\n\n\tlet coord: number[][][];\n\n\tif (feature.geometry.type === \"Polygon\") {\n\t\tcoord = feature.geometry.coordinates;\n\t} else if (feature.geometry.type === \"LineString\") {\n\t\tcoord = [feature.geometry.coordinates];\n\t} else {\n\t\tthrow new Error(\"Self intersects only accepts Polygons and LineStrings\");\n\t}\n\n\tconst output: number[][] = [];\n\tconst seen: { [key: string]: boolean } = {};\n\n\tfor (let ring0 = 0; ring0 < coord.length; ring0++) {\n\t\tfor (let edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {\n\t\t\tfor (let ring1 = 0; ring1 < coord.length; ring1++) {\n\t\t\t\tfor (let edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {\n\t\t\t\t\t// speedup possible if only interested in unique: start last two loops at ring0 and edge0+1\n\t\t\t\t\tifInteresctionAddToOutput(ring0, edge0, ring1, edge1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.length > 0;\n\n\t// true if frac is (almost) 1.0 or 0.0\n\t// function isBoundaryCase(frac: number) {\n\t//   const e2 = options.epsilon * options.epsilon;\n\t//   return e2 >= (frac - 1) * (frac - 1) || e2 >= frac * frac;\n\t// }\n\n\tfunction isOutside(frac: number) {\n\t\treturn frac < 0 - options.epsilon || frac > 1 + options.epsilon;\n\t}\n\t// Function to check if two edges intersect and add the intersection to the output\n\tfunction ifInteresctionAddToOutput(\n\t\tring0: number,\n\t\tedge0: number,\n\t\tring1: number,\n\t\tedge1: number,\n\t) {\n\t\tconst start0 = coord[ring0][edge0];\n\t\tconst end0 = coord[ring0][edge0 + 1];\n\t\tconst start1 = coord[ring1][edge1];\n\t\tconst end1 = coord[ring1][edge1 + 1];\n\n\t\tconst intersection = intersect(start0, end0, start1, end1);\n\n\t\tif (intersection === null) {\n\t\t\treturn; // discard parallels and coincidence\n\t\t}\n\n\t\tlet frac0;\n\t\tlet frac1;\n\n\t\tif (end0[0] !== start0[0]) {\n\t\t\tfrac0 = (intersection[0] - start0[0]) / (end0[0] - start0[0]);\n\t\t} else {\n\t\t\tfrac0 = (intersection[1] - start0[1]) / (end0[1] - start0[1]);\n\t\t}\n\t\tif (end1[0] !== start1[0]) {\n\t\t\tfrac1 = (intersection[0] - start1[0]) / (end1[0] - start1[0]);\n\t\t} else {\n\t\t\tfrac1 = (intersection[1] - start1[1]) / (end1[1] - start1[1]);\n\t\t}\n\n\t\t// There are roughly three cases we need to deal with.\n\t\t// 1. If at least one of the fracs lies outside [0,1], there is no intersection.\n\t\tif (isOutside(frac0) || isOutside(frac1)) {\n\t\t\treturn; // require segment intersection\n\t\t}\n\n\t\t// 2. If both are either exactly 0 or exactly 1, this is not an intersection but just\n\t\t// two edge segments sharing a common vertex.\n\t\t// if (isBoundaryCase(frac0) && isBoundaryCase(frac1)) {\n\t\t//   if (!options.reportVertexOnVertex) {\n\t\t//     return;\n\t\t//   }\n\t\t// }\n\n\t\t// // 3. If only one of the fractions is exactly 0 or 1, this is\n\t\t// // a vertex-on-edge situation.\n\t\t// if (isBoundaryCase(frac0) || isBoundaryCase(frac1)) {\n\t\t//   if (!options.reportVertexOnEdge) {\n\t\t//     return;\n\t\t//   }\n\t\t// }\n\n\t\tconst key = intersection.toString();\n\t\tconst unique = !seen[key];\n\t\tif (unique) {\n\t\t\tseen[key] = true;\n\t\t}\n\n\t\toutput.push(intersection);\n\t}\n}\n\nfunction equalArrays(array1: Position, array2: Position) {\n\treturn array1[0] === array2[0] && array1[1] === array2[1];\n}\n\n// Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\nfunction intersect(\n\tstart0: Position,\n\tend0: Position,\n\tstart1: Position,\n\tend1: Position,\n) {\n\tif (\n\t\tequalArrays(start0, start1) ||\n\t\tequalArrays(start0, end1) ||\n\t\tequalArrays(end0, start1) ||\n\t\tequalArrays(end1, start1)\n\t) {\n\t\treturn null;\n\t}\n\n\tconst x0 = start0[0],\n\t\ty0 = start0[1],\n\t\tx1 = end0[0],\n\t\ty1 = end0[1],\n\t\tx2 = start1[0],\n\t\ty2 = start1[1],\n\t\tx3 = end1[0],\n\t\ty3 = end1[1];\n\n\tconst denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);\n\tif (denom === 0) {\n\t\treturn null;\n\t}\n\n\tconst x4 =\n\t\t((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;\n\n\tconst y4 =\n\t\t((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;\n\n\treturn [x4, y4];\n}\n","import { Position } from \"geojson\";\n\nexport function validLatitude(lat: number) {\n\treturn lat >= -90 && lat <= 90;\n}\n\nexport function validLongitude(lng: number) {\n\treturn lng >= -180 && lng <= 180;\n}\n\nexport function coordinatePrecisionIsValid(\n\tcoordinate: Position,\n\tcoordinatePrecision: number,\n) {\n\treturn (\n\t\tgetDecimalPlaces(coordinate[0]) <= coordinatePrecision &&\n\t\tgetDecimalPlaces(coordinate[1]) <= coordinatePrecision\n\t);\n}\n\nexport function coordinateIsValid(coordinate: unknown[]) {\n\treturn (\n\t\tcoordinate.length === 2 &&\n\t\ttypeof coordinate[0] === \"number\" &&\n\t\ttypeof coordinate[1] === \"number\" &&\n\t\tcoordinate[0] !== Infinity &&\n\t\tcoordinate[1] !== Infinity &&\n\t\tvalidLongitude(coordinate[0]) &&\n\t\tvalidLatitude(coordinate[1])\n\t);\n}\n\nexport function getDecimalPlaces(value: number): number {\n\tlet current = 1;\n\tlet precision = 0;\n\twhile (Math.round(value * current) / current !== value) {\n\t\tcurrent *= 10;\n\t\tprecision++;\n\t}\n\n\treturn precision;\n}\n","import { Feature, Polygon, Position } from \"geojson\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport { selfIntersects } from \"../geometry/boolean/self-intersects\";\nimport {\n\tcoordinateIsValid,\n\tcoordinatePrecisionIsValid,\n} from \"../geometry/boolean/is-valid-coordinate\";\nimport { Validation } from \"../common\";\n\nexport const ValidationReasonFeatureNotPolygon = \"Feature is not a Polygon\";\nexport const ValidationReasonFeatureHasHoles = \"Feature has holes\";\nexport const ValidationReasonFeatureLessThanFourCoordinates =\n\t\"Feature has less than 4 coordinates\";\nexport const ValidationReasonFeatureHasInvalidCoordinates =\n\t\"Feature has invalid coordinates\";\nexport const ValidationReasonFeatureCoordinatesNotClosed =\n\t\"Feature coordinates are not closed\";\nexport const ValidationReasonFeatureInvalidCoordinatePrecision =\n\t\"Feature has coordinates with excessive precision\";\n\nexport function ValidatePolygonFeature(\n\tfeature: GeoJSONStoreFeatures,\n\tcoordinatePrecision: number,\n): ReturnType<Validation> {\n\tif (feature.geometry.type !== \"Polygon\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPolygon,\n\t\t};\n\t}\n\n\tif (feature.geometry.coordinates.length !== 1) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureHasHoles,\n\t\t};\n\t}\n\n\tif (feature.geometry.coordinates[0].length < 4) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureLessThanFourCoordinates,\n\t\t};\n\t}\n\n\tfor (let i = 0; i < feature.geometry.coordinates[0].length; i++) {\n\t\tif (!coordinateIsValid(feature.geometry.coordinates[0][i])) {\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\treason: ValidationReasonFeatureHasInvalidCoordinates,\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\t!coordinatePrecisionIsValid(\n\t\t\t\tfeature.geometry.coordinates[0][i],\n\t\t\t\tcoordinatePrecision,\n\t\t\t)\n\t\t) {\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\treason: ValidationReasonFeatureInvalidCoordinatePrecision,\n\t\t\t};\n\t\t}\n\t}\n\n\tif (\n\t\t!coordinatesMatch(\n\t\t\tfeature.geometry.coordinates[0][0],\n\t\t\tfeature.geometry.coordinates[0][\n\t\t\t\tfeature.geometry.coordinates[0].length - 1\n\t\t\t],\n\t\t)\n\t) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureCoordinatesNotClosed,\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n\nexport function ValidateNonIntersectingPolygonFeature(\n\tfeature: GeoJSONStoreFeatures,\n\tcoordinatePrecision: number,\n): ReturnType<Validation> {\n\tconst validatePolygonFeature = ValidatePolygonFeature(\n\t\tfeature,\n\t\tcoordinatePrecision,\n\t);\n\n\tif (!validatePolygonFeature.valid) {\n\t\treturn validatePolygonFeature;\n\t}\n\n\tif (selfIntersects(feature as Feature<Polygon>)) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: \"Feature intersects itself\",\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n\n/**\n * Check if two coordinates are identical\n * @param coordinateOne - coordinate to compare\n * @param coordinateTwo - coordinate to compare with\n * @returns boolean\n */\nfunction coordinatesMatch(coordinateOne: Position, coordinateTwo: Position) {\n\treturn (\n\t\tcoordinateOne[0] === coordinateTwo[0] &&\n\t\tcoordinateOne[1] === coordinateTwo[1]\n\t);\n}\n","import { Feature, Position } from \"geojson\";\nimport {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tProjection,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { haversineDistanceKilometers } from \"../../geometry/measure/haversine-distance\";\nimport { circle, circleWebMercator } from \"../../geometry/shape/create-circle\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { Polygon } from \"geojson\";\nimport { calculateWebMercatorDistortion } from \"../../geometry/shape/web-mercator-distortion\";\n\ntype TerraDrawCircleModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype CirclePolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawCircleModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tkeyEvents?: TerraDrawCircleModeKeyEvents | null;\n\tcursors?: Cursors;\n\tstartingRadiusKilometers?: number;\n\tprojection?: Projection;\n}\n\nexport class TerraDrawCircleMode extends TerraDrawBaseDrawMode<CirclePolygonStyling> {\n\tmode = \"circle\" as const;\n\tprivate center: Position | undefined;\n\tprivate clickCount = 0;\n\tprivate currentCircleId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawCircleModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate startingRadiusKilometers = 0.00001;\n\tprivate cursorMovedAfterInitialCursorDown = false;\n\n\t/**\n\t * Create a new circle mode instance\n\t * @param options - Options to customize the behavior of the circle mode\n\t * @param options.keyEvents - Key events to cancel or finish the mode\n\t * @param options.cursors - Cursors to use for the mode\n\t * @param options.styles - Custom styling for the circle\n\t * @param options.pointerDistance - Distance in pixels to consider a pointer close to a vertex\n\t */\n\tconstructor(options?: TerraDrawCircleModeOptions<CirclePolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawCircleModeOptions<CirclePolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.startingRadiusKilometers) {\n\t\t\tthis.startingRadiusKilometers = options.startingRadiusKilometers;\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentCircleId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentCircleId,\n\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\tvalue: undefined,\n\t\t\t},\n\t\t]);\n\n\t\tconst finishedId = this.currentCircleId;\n\n\t\tif (this.validate && finishedId) {\n\t\t\tconst currentGeometry = this.store.getGeometryCopy<Polygon>(finishedId);\n\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: finishedId,\n\t\t\t\t\tgeometry: currentGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.cursorMovedAfterInitialCursorDown = false;\n\t\tthis.center = undefined;\n\t\tthis.currentCircleId = undefined;\n\t\tthis.clickCount = 0;\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\t// Ensure that any listerers are triggered with the main created geometry\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tif (this.clickCount === 0) {\n\t\t\t\tthis.center = [event.lng, event.lat];\n\t\t\t\tconst startingCircle = circle({\n\t\t\t\t\tcenter: this.center,\n\t\t\t\t\tradiusKilometers: this.startingRadiusKilometers,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t});\n\n\t\t\t\tconst [createdId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: startingCircle.geometry,\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\tradiusKilometers: this.startingRadiusKilometers,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentCircleId = createdId;\n\t\t\t\tthis.clickCount++;\n\t\t\t\tthis.cursorMovedAfterInitialCursorDown = false;\n\t\t\t\tthis.setDrawing();\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tthis.clickCount === 1 &&\n\t\t\t\t\tthis.center &&\n\t\t\t\t\tthis.currentCircleId !== undefined &&\n\t\t\t\t\tthis.cursorMovedAfterInitialCursorDown\n\t\t\t\t) {\n\t\t\t\t\tthis.updateCircle(event);\n\t\t\t\t}\n\n\t\t\t\t// Finish drawing\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.cursorMovedAfterInitialCursorDown = true;\n\t\tthis.updateCircle(event);\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentCircleId;\n\n\t\tthis.center = undefined;\n\t\tthis.currentCircleId = undefined;\n\t\tthis.clickCount = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t} catch {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Polygon\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.fillColor,\n\t\t\t\tstyles.polygonFillColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.outlineColor,\n\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tprivate updateCircle(event: TerraDrawMouseEvent) {\n\t\tif (this.clickCount === 1 && this.center && this.currentCircleId) {\n\t\t\tconst newRadius = haversineDistanceKilometers(this.center, [\n\t\t\t\tevent.lng,\n\t\t\t\tevent.lat,\n\t\t\t]);\n\n\t\t\tlet updatedCircle: Feature<Polygon>;\n\n\t\t\tif (this.projection === \"web-mercator\") {\n\t\t\t\t// We want to track the mouse cursor, but we need to adjust the radius based\n\t\t\t\t// on the distortion of the web mercator projection\n\t\t\t\tconst distortion = calculateWebMercatorDistortion(this.center, [\n\t\t\t\t\tevent.lng,\n\t\t\t\t\tevent.lat,\n\t\t\t\t]);\n\n\t\t\t\tupdatedCircle = circleWebMercator({\n\t\t\t\t\tcenter: this.center,\n\t\t\t\t\tradiusKilometers: newRadius * distortion,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t});\n\t\t\t} else if (this.projection === \"globe\") {\n\t\t\t\tupdatedCircle = circle({\n\t\t\t\t\tcenter: this.center,\n\t\t\t\t\tradiusKilometers: newRadius,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Invalid projection\");\n\t\t\t}\n\n\t\t\tif (this.validate) {\n\t\t\t\tconst valid = this.validate(\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\t\tid: this.currentCircleId,\n\t\t\t\t\t\tgeometry: updatedCircle.geometry,\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tradiusKilometers: newRadius,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tproject: this.project,\n\t\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!valid.valid) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{ id: this.currentCircleId, geometry: updatedCircle.geometry },\n\t\t\t]);\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentCircleId,\n\t\t\t\t\tproperty: \"radiusKilometers\",\n\t\t\t\t\tvalue: newRadius,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a circle and the feature being updated is the current circle,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentCircleId === feature.id) {\n\t\t\tthis.cursorMovedAfterInitialCursorDown = false;\n\t\t\tthis.center = undefined;\n\t\t\tthis.currentCircleId = undefined;\n\t\t\tthis.clickCount = 0;\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { TerraDrawAdapterStyling } from \"../common\";\n\nexport const getDefaultStyling = (): TerraDrawAdapterStyling => {\n\treturn {\n\t\tpolygonFillColor: \"#3f97e0\",\n\t\tpolygonOutlineColor: \"#3f97e0\",\n\t\tpolygonOutlineWidth: 4,\n\t\tpolygonFillOpacity: 0.3,\n\t\tpointColor: \"#3f97e0\",\n\t\tpointOutlineColor: \"#ffffff\",\n\t\tpointOutlineWidth: 0,\n\t\tpointWidth: 6,\n\t\tlineStringColor: \"#3f97e0\",\n\t\tlineStringWidth: 4,\n\t\tzIndex: 0,\n\t};\n};\n","import { Position } from \"geojson\";\nimport { haversineDistanceKilometers } from \"../measure/haversine-distance\";\nimport { lngLatToWebMercatorXY } from \"../project/web-mercator\";\n\n/*\n * Function to calculate the web mercator vs geodesic distortion between two coordinates\n * Value of 1 means no distortion, higher values mean higher distortion\n * */\nexport function calculateWebMercatorDistortion(\n\tsource: Position,\n\ttarget: Position,\n): number {\n\tconst geodesicDistance = haversineDistanceKilometers(source, target) * 1000;\n\tif (geodesicDistance === 0) {\n\t\treturn 1;\n\t}\n\n\tconst { x: x1, y: y1 } = lngLatToWebMercatorXY(source[0], source[1]);\n\tconst { x: x2, y: y2 } = lngLatToWebMercatorXY(target[0], target[1]);\n\tconst euclideanDistance = Math.sqrt(\n\t\tMath.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2),\n\t);\n\treturn euclideanDistance / geodesicDistance;\n}\n","import { CartesianPoint } from \"../../common\";\n\nexport const cartesianDistance = (\n\tpointOne: CartesianPoint,\n\tpointTwo: CartesianPoint,\n) => {\n\tconst { x: x1, y: y1 } = pointOne;\n\tconst { x: x2, y: y2 } = pointTwo;\n\tconst y = x2 - x1;\n\tconst x = y2 - y1;\n\treturn Math.sqrt(x * x + y * y);\n};\n","import { Feature, Polygon } from \"geojson\";\nimport { followsRightHandRule } from \"./boolean/right-hand-rule\";\n\nexport function ensureRightHandRule(polygon: Polygon): undefined | Polygon {\n\tconst isFollowingRightHandRule = followsRightHandRule(polygon);\n\tif (!isFollowingRightHandRule) {\n\t\treturn {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [polygon.coordinates[0].reverse()],\n\t\t} as Polygon;\n\t}\n}\n","import { Polygon } from \"geojson\";\n\n/**\n * Checks if a GeoJSON Polygon follows the right-hand rule.\n * @param polygon - The GeoJSON Polygon to check.\n * @returns {boolean} - True if the polygon follows the right-hand rule (counterclockwise outer ring), otherwise false.\n */\nexport function followsRightHandRule(polygon: Polygon): boolean {\n\tconst outerRing = polygon.coordinates[0];\n\n\tlet sum = 0;\n\tfor (let i = 0; i < outerRing.length - 1; i++) {\n\t\tconst [x1, y1] = outerRing[i];\n\t\tconst [x2, y2] = outerRing[i + 1];\n\t\tsum += (x2 - x1) * (y2 + y1);\n\t}\n\n\treturn sum < 0; // Right-hand rule: counterclockwise = negative area\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tCOMMON_PROPERTIES,\n\tZ_INDEX,\n} from \"../../common\";\nimport { Polygon } from \"geojson\";\n\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { ValidatePolygonFeature } from \"../../validations/polygon.validation\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\n\ntype TerraDrawFreehandModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype FreehandPolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n\tclosingPointColor: HexColorStyling;\n\tclosingPointWidth: NumericStyling;\n\tclosingPointOutlineColor: HexColorStyling;\n\tclosingPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawFreehandModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tminDistance?: number;\n\tpreventPointsNearClose?: boolean;\n\tautoClose?: boolean;\n\tautoCloseTimeout?: number;\n\tkeyEvents?: TerraDrawFreehandModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawFreehandMode extends TerraDrawBaseDrawMode<FreehandPolygonStyling> {\n\tmode = \"freehand\" as const;\n\n\tprivate startingClick = false;\n\tprivate currentId: FeatureId | undefined;\n\tprivate closingPointId: FeatureId | undefined;\n\tprivate minDistance: number = 20;\n\tprivate keyEvents: TerraDrawFreehandModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate preventPointsNearClose: boolean = true;\n\tprivate autoClose: boolean = false;\n\tprivate autoCloseTimeout = 500;\n\tprivate hasLeftStartingPoint = false;\n\tprivate preventNewFeature = false;\n\n\tconstructor(options?: TerraDrawFreehandModeOptions<FreehandPolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tpublic updateOptions(\n\t\toptions?: TerraDrawFreehandModeOptions<FreehandPolygonStyling> | undefined,\n\t): void {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.minDistance) {\n\t\t\tthis.minDistance = options.minDistance;\n\t\t}\n\n\t\tif (options?.preventPointsNearClose !== undefined) {\n\t\t\tthis.preventPointsNearClose = options.preventPointsNearClose;\n\t\t}\n\n\t\tif (options?.autoClose !== undefined) {\n\t\t\tthis.autoClose = options.autoClose;\n\t\t}\n\n\t\tif (options?.autoCloseTimeout) {\n\t\t\tthis.autoCloseTimeout = options.autoCloseTimeout;\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fix right hand rule if necessary\n\t\tif (this.currentId) {\n\t\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId),\n\t\t\t);\n\t\t\tif (correctedGeometry) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{ id: this.currentId, geometry: correctedGeometry },\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tconst finishedId = this.currentId;\n\n\t\tif (this.validate && finishedId) {\n\t\t\tconst currentGeometry = this.store.getGeometryCopy<Polygon>(finishedId);\n\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: finishedId,\n\t\t\t\t\tgeometry: currentGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.closingPointId) {\n\t\t\tthis.store.delete([this.closingPointId]);\n\t\t}\n\t\tthis.startingClick = false;\n\t\tthis.currentId = undefined;\n\t\tthis.closingPointId = undefined;\n\t\tthis.hasLeftStartingPoint = false;\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\t// Ensure that any listerers are triggered with the main created geometry\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tif (this.currentId === undefined || this.startingClick === false) {\n\t\t\tthis.setCursor(this.cursors.start);\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst previousIndex = currentLineGeometry.coordinates[0].length - 2;\n\t\tconst [previousLng, previousLat] =\n\t\t\tcurrentLineGeometry.coordinates[0][previousIndex];\n\t\tconst { x, y } = this.project(previousLng, previousLat);\n\t\tconst distance = cartesianDistance(\n\t\t\t{ x, y },\n\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t);\n\n\t\tconst [closingLng, closingLat] = currentLineGeometry.coordinates[0][0];\n\t\tconst { x: closingX, y: closingY } = this.project(closingLng, closingLat);\n\t\tconst closingDistance = cartesianDistance(\n\t\t\t{ x: closingX, y: closingY },\n\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t);\n\n\t\tif (closingDistance < this.pointerDistance) {\n\t\t\t// We only want to close the polygon if the users cursor has left the\n\t\t\t// region of the starting point\n\t\t\tif (this.autoClose && this.hasLeftStartingPoint) {\n\t\t\t\t// If we have an autoCloseTimeout, we want to prevent new features\n\t\t\t\t// being created by accidental clicks for a short period of time\n\t\t\t\tthis.preventNewFeature = true;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.preventNewFeature = false;\n\t\t\t\t}, this.autoCloseTimeout);\n\n\t\t\t\tthis.close();\n\t\t\t}\n\n\t\t\tthis.setCursor(this.cursors.close);\n\n\t\t\t// We want to prohibit drawing new points at or around the closing\n\t\t\t// point as it can be non user friendly\n\t\t\tif (this.preventPointsNearClose) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.hasLeftStartingPoint = true;\n\t\t\tthis.setCursor(this.cursors.start);\n\t\t}\n\n\t\t// The cusor must have moved a minimum distance\n\t\t// before we add another coordinate\n\t\tif (distance < this.minDistance) {\n\t\t\treturn;\n\t\t}\n\n\t\tcurrentLineGeometry.coordinates[0].pop();\n\n\t\tconst newGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [\n\t\t\t\t[\n\t\t\t\t\t...currentLineGeometry.coordinates[0],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tcurrentLineGeometry.coordinates[0][0],\n\t\t\t\t],\n\t\t\t],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tgeometry: newGeometry,\n\t\t\t},\n\t\t]);\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tif (this.preventNewFeature) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.startingClick === false) {\n\t\t\t\tconst [createdId, closingPointId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\tthis.currentId = createdId;\n\t\t\t\tthis.closingPointId = closingPointId;\n\t\t\t\tthis.startingClick = true;\n\n\t\t\t\t// We could already be in drawing due to updating the existing polygon\n\t\t\t\t// via afterFeatureUpdated\n\t\t\t\tif (this.state !== \"drawing\") {\n\t\t\t\t\tthis.setDrawing();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tif (this.startingClick === true) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentId;\n\t\tconst cleanUpClosingPointId = this.closingPointId;\n\n\t\tthis.closingPointId = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.startingClick = false;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t\tif (cleanUpClosingPointId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpClosingPointId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Polygon\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.fillColor,\n\t\t\t\tstyles.polygonFillColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.outlineColor,\n\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t} else if (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.closingPointWidth,\n\t\t\t\tstyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.closingPointColor,\n\t\t\t\tstyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.closingPointOutlineColor,\n\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.closingPointOutlineWidth,\n\t\t\t\t2,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_FIVE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidatePolygonFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// NOTE: This handles the case we are currently drawing a polygon\n\t\t// We need to reset the drawing state because it is very complicated (impossible?)\n\t\t// to recover the drawing state after a feature update\n\t\tif (this.currentId === feature.id) {\n\t\t\tif (this.closingPointId) {\n\t\t\t\tthis.store.delete([this.closingPointId]);\n\t\t\t}\n\t\t\tthis.startingClick = false;\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.closingPointId = undefined;\n\t\t\tthis.hasLeftStartingPoint = false;\n\t\t}\n\t}\n}\n","import {\n\tProject,\n\tProjection,\n\tTerraDrawGeoJSONStore,\n\tUnproject,\n} from \"../common\";\n\nexport type BehaviorConfig = {\n\tstore: TerraDrawGeoJSONStore;\n\tmode: string;\n\tproject: Project;\n\tunproject: Unproject;\n\tpointerDistance: number;\n\tcoordinatePrecision: number;\n\tprojection: Projection;\n};\n\nexport class TerraDrawModeBehavior {\n\tprotected store: TerraDrawGeoJSONStore;\n\tprotected mode: string;\n\tprotected project: Project;\n\tprotected unproject: Unproject;\n\tprotected pointerDistance: number;\n\tprotected coordinatePrecision: number;\n\tprotected projection: Projection;\n\n\tconstructor({\n\t\tstore,\n\t\tmode,\n\t\tproject,\n\t\tunproject,\n\t\tpointerDistance,\n\t\tcoordinatePrecision,\n\t\tprojection,\n\t}: BehaviorConfig) {\n\t\tthis.store = store;\n\t\tthis.mode = mode;\n\t\tthis.project = project;\n\t\tthis.unproject = unproject;\n\t\tthis.pointerDistance = pointerDistance;\n\t\tthis.coordinatePrecision = coordinatePrecision;\n\t\tthis.projection = projection;\n\t}\n}\n","import { Feature, Polygon } from \"geojson\";\nimport { Unproject } from \"../../common\";\n\nexport function createBBoxFromPoint({\n\tunproject,\n\tpoint,\n\tpointerDistance,\n}: {\n\tpoint: {\n\t\tx: number;\n\t\ty: number;\n\t};\n\tunproject: Unproject;\n\tpointerDistance: number;\n}) {\n\tconst halfDist = pointerDistance / 2;\n\tconst { x, y } = point;\n\n\treturn {\n\t\ttype: \"Feature\",\n\t\tproperties: {},\n\t\tgeometry: {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [\n\t\t\t\t[\n\t\t\t\t\tunproject(x - halfDist, y - halfDist), // TopLeft\n\t\t\t\t\tunproject(x + halfDist, y - halfDist), // TopRight\n\t\t\t\t\tunproject(x + halfDist, y + halfDist), // BottomRight\n\t\t\t\t\tunproject(x - halfDist, y + halfDist), // BottomLeft\n\t\t\t\t\tunproject(x - halfDist, y - halfDist), // TopLeft\n\t\t\t\t].map((c) => [c.lng, c.lat]),\n\t\t\t],\n\t\t},\n\t} as Feature<Polygon>;\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { TerraDrawMouseEvent } from \"../common\";\nimport { createBBoxFromPoint } from \"../geometry/shape/create-bbox\";\n\nexport class ClickBoundingBoxBehavior extends TerraDrawModeBehavior {\n\tconstructor(config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\n\tpublic create(event: TerraDrawMouseEvent) {\n\t\tconst { containerX: x, containerY: y } = event;\n\t\treturn createBBoxFromPoint({\n\t\t\tunproject: this.unproject,\n\t\t\tpoint: { x, y },\n\t\t\tpointerDistance: this.pointerDistance,\n\t\t});\n\t}\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { TerraDrawMouseEvent } from \"../common\";\n\nimport { Position } from \"geojson\";\nimport { cartesianDistance } from \"../geometry/measure/pixel-distance\";\n\nexport class PixelDistanceBehavior extends TerraDrawModeBehavior {\n\tconstructor(config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\tpublic measure(clickEvent: TerraDrawMouseEvent, secondCoordinate: Position) {\n\t\tconst { x, y } = this.project(secondCoordinate[0], secondCoordinate[1]);\n\n\t\tconst distance = cartesianDistance(\n\t\t\t{ x, y },\n\t\t\t{ x: clickEvent.containerX, y: clickEvent.containerY },\n\t\t);\n\n\t\treturn distance;\n\t}\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { TerraDrawMouseEvent } from \"../common\";\nimport { Feature, Position } from \"geojson\";\nimport { ClickBoundingBoxBehavior } from \"./click-bounding-box.behavior\";\nimport { BBoxPolygon, FeatureId } from \"../store/store\";\nimport { PixelDistanceBehavior } from \"./pixel-distance.behavior\";\n\nexport class CoordinateSnappingBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t\tprivate readonly clickBoundingBox: ClickBoundingBoxBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\t/** Returns the nearest snappable coordinate - on first click there is no currentId so no need to provide */\n\tpublic getSnappableCoordinateFirstClick = (event: TerraDrawMouseEvent) => {\n\t\tconst snappble = this.getSnappable(event, (feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties && feature.properties.mode === this.mode,\n\t\t\t);\n\t\t});\n\n\t\treturn snappble.coordinate;\n\t};\n\n\tpublic getSnappableCoordinate = (\n\t\tevent: TerraDrawMouseEvent,\n\t\tcurrentFeatureId: FeatureId,\n\t) => {\n\t\tconst snappable = this.getSnappable(event, (feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties &&\n\t\t\t\t\tfeature.properties.mode === this.mode &&\n\t\t\t\t\tfeature.id !== currentFeatureId,\n\t\t\t);\n\t\t});\n\n\t\treturn snappable.coordinate;\n\t};\n\n\tpublic getSnappable(\n\t\tevent: TerraDrawMouseEvent,\n\t\tfilter?: (feature: Feature) => boolean,\n\t) {\n\t\tconst bbox = this.clickBoundingBox.create(event) as BBoxPolygon;\n\n\t\tconst features = this.store.search(bbox, filter);\n\n\t\tconst closest: {\n\t\t\tcoordinate: undefined | Position;\n\t\t\tminDist: number;\n\t\t\tfeatureId: undefined | FeatureId;\n\t\t\tfeatureCoordinateIndex: undefined | number;\n\t\t} = {\n\t\t\tfeatureId: undefined,\n\t\t\tfeatureCoordinateIndex: undefined,\n\t\t\tcoordinate: undefined,\n\t\t\tminDist: Infinity,\n\t\t};\n\n\t\tfeatures.forEach((feature) => {\n\t\t\tlet coordinates: Position[];\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcoordinates.forEach((coord, coordIndex) => {\n\t\t\t\tconst dist = this.pixelDistance.measure(event, coord);\n\t\t\t\tif (dist < closest.minDist && dist < this.pointerDistance) {\n\t\t\t\t\tclosest.coordinate = coord;\n\t\t\t\t\tclosest.minDist = dist;\n\t\t\t\t\tclosest.featureId = feature.id;\n\t\t\t\t\tclosest.featureCoordinateIndex = coordIndex;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn closest;\n\t}\n}\n","import { Position } from \"geojson\";\nimport {\n\tdegreesToRadians,\n\tlengthToRadians,\n\tradiansToDegrees,\n} from \"../helpers\";\nimport { CartesianPoint } from \"../../common\";\n\n// Adapted from @turf/destination module which is MIT Licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-desination/index.ts\n\nexport function destination(\n\torigin: Position,\n\tdistance: number,\n\tbearing: number,\n): Position {\n\tconst longitude1 = degreesToRadians(origin[0]);\n\tconst latitude1 = degreesToRadians(origin[1]);\n\tconst bearingRad = degreesToRadians(bearing);\n\tconst radians = lengthToRadians(distance);\n\n\tconst latitude2 = Math.asin(\n\t\tMath.sin(latitude1) * Math.cos(radians) +\n\t\t\tMath.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad),\n\t);\n\tconst longitude2 =\n\t\tlongitude1 +\n\t\tMath.atan2(\n\t\t\tMath.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\n\t\t\tMath.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2),\n\t\t);\n\tconst lng = radiansToDegrees(longitude2);\n\tconst lat = radiansToDegrees(latitude2);\n\n\treturn [lng, lat];\n}\n\n// Function to create a destination point in Web Mercator projection\nexport function webMercatorDestination(\n\t{ x, y }: CartesianPoint,\n\tdistance: number,\n\tbearing: number,\n): CartesianPoint {\n\t// Convert origin to Web Mercator\n\tconst bearingRad = degreesToRadians(bearing);\n\n\t// Calculate the destination coordinates\n\tconst deltaX = distance * Math.cos(bearingRad);\n\tconst deltaY = distance * Math.sin(bearingRad);\n\n\tconst newX = x + deltaX;\n\tconst newY = y + deltaY;\n\n\treturn { x: newX, y: newY };\n}\n","import { Position } from \"geojson\";\nimport { degreesToRadians, radiansToDegrees } from \"../helpers\";\nimport { CartesianPoint } from \"../../common\";\n\n// Adapted from the @turf/bearing module which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-bearing\n\nexport function bearing(start: Position, end: Position): number {\n\tconst lon1 = degreesToRadians(start[0]);\n\tconst lon2 = degreesToRadians(end[0]);\n\tconst lat1 = degreesToRadians(start[1]);\n\tconst lat2 = degreesToRadians(end[1]);\n\tconst a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n\tconst b =\n\t\tMath.cos(lat1) * Math.sin(lat2) -\n\t\tMath.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n\treturn radiansToDegrees(Math.atan2(a, b));\n}\n\nexport function webMercatorBearing(\n\t{ x: x1, y: y1 }: CartesianPoint,\n\t{ x: x2, y: y2 }: CartesianPoint,\n): number {\n\tconst deltaX = x2 - x1;\n\tconst deltaY = y2 - y1;\n\n\tif (deltaX === 0 && deltaY === 0) {\n\t\treturn 0; // No movement\n\t}\n\n\t// Calculate the angle in radians\n\tlet angle = Math.atan2(deltaY, deltaX);\n\n\t// Convert the angle to degrees\n\tangle = angle * (180 / Math.PI);\n\n\t// Normalize to -180 to 180\n\tif (angle > 180) {\n\t\tangle -= 360;\n\t} else if (angle < -180) {\n\t\tangle += 360;\n\t}\n\n\treturn angle;\n}\n\nexport function normalizeBearing(bearing: number): number {\n\treturn (bearing + 360) % 360;\n}\n","import { LineString, Position } from \"geojson\";\nimport { destination } from \"./destination\";\nimport { bearing } from \"./bearing\";\nimport { haversineDistanceKilometers } from \"./haversine-distance\";\n\n// Adapted from @turf/line-slice-along module which is MIT licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-line-slice-along/index.ts\n\nexport function lineSliceAlong(\n\tcoords: LineString[\"coordinates\"],\n\tstartDist: number,\n\tstopDist: number,\n): Position[] {\n\tconst slice: Position[] = [];\n\n\tconst origCoordsLength = coords.length;\n\n\tlet travelled = 0;\n\tlet overshot, direction, interpolated;\n\tfor (let i = 0; i < coords.length; i++) {\n\t\tif (startDist >= travelled && i === coords.length - 1) {\n\t\t\tbreak;\n\t\t} else if (travelled > startDist && slice.length === 0) {\n\t\t\tovershot = startDist - travelled;\n\t\t\tif (!overshot) {\n\t\t\t\tslice.push(coords[i]);\n\t\t\t\treturn slice;\n\t\t\t}\n\t\t\tdirection = bearing(coords[i], coords[i - 1]) - 180;\n\t\t\tinterpolated = destination(coords[i], overshot, direction);\n\t\t\tslice.push(interpolated);\n\t\t}\n\n\t\tif (travelled >= stopDist) {\n\t\t\tovershot = stopDist - travelled;\n\t\t\tif (!overshot) {\n\t\t\t\tslice.push(coords[i]);\n\t\t\t\treturn slice;\n\t\t\t}\n\t\t\tdirection = bearing(coords[i], coords[i - 1]) - 180;\n\t\t\tinterpolated = destination(coords[i], overshot, direction);\n\t\t\tslice.push(interpolated);\n\t\t\treturn slice;\n\t\t}\n\n\t\tif (travelled >= startDist) {\n\t\t\tslice.push(coords[i]);\n\t\t}\n\n\t\tif (i === coords.length - 1) {\n\t\t\treturn slice;\n\t\t}\n\n\t\ttravelled += haversineDistanceKilometers(coords[i], coords[i + 1]);\n\t}\n\n\tif (travelled < startDist && coords.length === origCoordsLength) {\n\t\tthrow new Error(\"Start position is beyond line\");\n\t}\n\n\tconst last = coords[coords.length - 1];\n\treturn [last, last];\n}\n","import { Position } from \"geojson\";\n\nfunction toRadians(degrees: number): number {\n\treturn degrees * (Math.PI / 180);\n}\n\nfunction toDegrees(radians: number): number {\n\treturn radians * (180 / Math.PI);\n}\n\nexport function generateGreatCircleCoordinates(\n\tstart: Position,\n\tend: Position,\n\tnumberOfPoints: number,\n): Position[] {\n\tconst points: Position[] = [];\n\n\tconst lat1 = toRadians(start[1]);\n\tconst lon1 = toRadians(start[0]);\n\tconst lat2 = toRadians(end[1]);\n\tconst lon2 = toRadians(end[0]);\n\n\tnumberOfPoints += 1;\n\n\t// Calculate the angular distance between the two points using the Haversine formula\n\tconst d =\n\t\t2 *\n\t\tMath.asin(\n\t\t\tMath.sqrt(\n\t\t\t\tMath.sin((lat2 - lat1) / 2) ** 2 +\n\t\t\t\t\tMath.cos(lat1) * Math.cos(lat2) * Math.sin((lon2 - lon1) / 2) ** 2,\n\t\t\t),\n\t\t);\n\n\tif (d === 0 || isNaN(d)) {\n\t\t// Start and end coordinates are the same, or distance calculation failed, return empty array\n\t\treturn points;\n\t}\n\n\tfor (let i = 0; i <= numberOfPoints; i++) {\n\t\tconst f = i / numberOfPoints; // Fraction of the total distance for the current point\n\t\tconst A = Math.sin((1 - f) * d) / Math.sin(d); // Interpolation factor A\n\t\tconst B = Math.sin(f * d) / Math.sin(d); // Interpolation factor B\n\n\t\t// Calculate the x, y, z coordinates of the intermediate point\n\t\tconst x =\n\t\t\tA * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);\n\t\tconst y =\n\t\t\tA * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);\n\t\tconst z = A * Math.sin(lat1) + B * Math.sin(lat2);\n\n\t\t// Calculate the latitude and longitude of the intermediate point from the x, y, z coordinates\n\t\tif (isNaN(x) || isNaN(y) || isNaN(z)) {\n\t\t\t// Skip this point if any coordinate is NaN\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst lat = Math.atan2(z, Math.sqrt(x ** 2 + y ** 2));\n\t\tconst lon = Math.atan2(y, x);\n\n\t\tif (isNaN(lat) || isNaN(lon)) {\n\t\t\t// Skip this point if any coordinate is NaN\n\t\t\tcontinue;\n\t\t}\n\n\t\tpoints.push([toDegrees(lon), toDegrees(lat)]);\n\t}\n\n\treturn points.slice(1, -1);\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { Position } from \"geojson\";\nimport { haversineDistanceKilometers } from \"../geometry/measure/haversine-distance\";\nimport { lineSliceAlong } from \"../geometry/measure/slice-along\";\nimport { limitPrecision } from \"../geometry/limit-decimal-precision\";\nimport { generateGreatCircleCoordinates } from \"../geometry/shape/great-circle-coordinates\";\n\nexport class InsertCoordinatesBehavior extends TerraDrawModeBehavior {\n\tconstructor(readonly config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\n\tpublic generateInsertionCoordinates(\n\t\tcoordinateOne: Position,\n\t\tcoordinateTwo: Position,\n\t\tsegmentLength: number,\n\t): Position[] {\n\t\tconst line = [coordinateOne, coordinateTwo];\n\n\t\tlet lineLength = 0;\n\t\tfor (let i = 0; i < line.length - 1; i++) {\n\t\t\tlineLength += haversineDistanceKilometers(line[0], line[1]);\n\t\t}\n\n\t\t// If the line is shorter than the segment length then the original line is returned.\n\t\tif (lineLength <= segmentLength) {\n\t\t\treturn line;\n\t\t}\n\n\t\tlet numberOfSegments = lineLength / segmentLength - 1;\n\n\t\t// If numberOfSegments is integer, no need to plus 1\n\t\tif (!Number.isInteger(numberOfSegments)) {\n\t\t\tnumberOfSegments = Math.floor(numberOfSegments) + 1;\n\t\t}\n\n\t\tconst segments: Position[][] = [];\n\t\tfor (let i = 0; i < numberOfSegments; i++) {\n\t\t\tconst outline = lineSliceAlong(\n\t\t\t\tline,\n\t\t\t\tsegmentLength * i,\n\t\t\t\tsegmentLength * (i + 1),\n\t\t\t);\n\t\t\tsegments.push(outline);\n\t\t}\n\n\t\tconst coordinates: Position[] = [];\n\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\tconst line = segments[i];\n\t\t\tcoordinates.push(line[1]);\n\t\t}\n\n\t\tconst limitedCoordinates = this.limitCoordinates(coordinates);\n\n\t\treturn limitedCoordinates;\n\t}\n\n\tpublic generateInsertionGeodesicCoordinates(\n\t\tcoordinateOne: Position,\n\t\tcoordinateTwo: Position,\n\t\tsegmentLength: number,\n\t): Position[] {\n\t\tconst distance = haversineDistanceKilometers(coordinateOne, coordinateTwo);\n\t\tconst numberOfPoints = Math.floor(distance / segmentLength);\n\t\tconst coordinates = generateGreatCircleCoordinates(\n\t\t\tcoordinateOne,\n\t\t\tcoordinateTwo,\n\t\t\tnumberOfPoints,\n\t\t);\n\t\tconst limitedCoordinates = this.limitCoordinates(coordinates);\n\n\t\treturn limitedCoordinates;\n\t}\n\n\tprivate limitCoordinates(coordinates: Position[]) {\n\t\treturn coordinates.map((coordinate) => [\n\t\t\tlimitPrecision(coordinate[0], this.config.coordinatePrecision),\n\t\t\tlimitPrecision(coordinate[1], this.config.coordinatePrecision),\n\t\t]);\n\t}\n}\n","import { Position } from \"geojson\";\n\nexport function coordinatesIdentical(\n\tcoordinate: Position,\n\tcoordinateTwo: Position,\n) {\n\treturn (\n\t\tcoordinate[0] === coordinateTwo[0] && coordinate[1] === coordinateTwo[1]\n\t);\n}\n","import { Validation } from \"../common\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport {\n\tcoordinateIsValid,\n\tcoordinatePrecisionIsValid,\n} from \"../geometry/boolean/is-valid-coordinate\";\n\nexport const ValidationReasonFeatureIsNotALineString =\n\t\"Feature is not a LineString\";\nexport const ValidationReasonFeatureHasLessThanTwoCoordinates =\n\t\"Feature has less than 2 coordinates\";\nexport const ValidationReasonFeatureInvalidCoordinates =\n\t\"Feature has invalid coordinates\";\nexport const ValidationReasonFeatureInvalidCoordinatePrecision =\n\t\"Feature has coordinates with excessive precision\";\n\nexport function ValidateLineStringFeature(\n\tfeature: GeoJSONStoreFeatures,\n\tcoordinatePrecision: number,\n): ReturnType<Validation> {\n\tif (feature.geometry.type !== \"LineString\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureIsNotALineString,\n\t\t};\n\t}\n\n\tif (feature.geometry.coordinates.length < 2) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureHasLessThanTwoCoordinates,\n\t\t};\n\t}\n\n\tfor (let i = 0; i < feature.geometry.coordinates.length; i++) {\n\t\tif (!coordinateIsValid(feature.geometry.coordinates[i])) {\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\treason: ValidationReasonFeatureInvalidCoordinates,\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\t!coordinatePrecisionIsValid(\n\t\t\t\tfeature.geometry.coordinates[i],\n\t\t\t\tcoordinatePrecision,\n\t\t\t)\n\t\t) {\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\treason: ValidationReasonFeatureInvalidCoordinatePrecision,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn { valid: true };\n}\n","import { Feature, Point, Position, LineString } from \"geojson\";\nimport { degreesToRadians, radiansToDegrees } from \"./helpers\";\nimport { haversineDistanceKilometers } from \"./measure/haversine-distance\";\n\n// nearestPointOnLine is adapted from the @turf/midpoint which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-nearest-point-on-line\n\nexport function nearestPointOnLine(\n\tinputCoordinate: Position,\n\tlines: [Position, Position][],\n):\n\t| {\n\t\t\tcoordinate: Position;\n\t\t\tdistance: number;\n\t\t\tlineIndex: number;\n\t  }\n\t| undefined {\n\tlet closestPoint: Position = [Infinity, Infinity];\n\tlet closestDistance = Infinity;\n\tlet lineIndex = 0;\n\n\tfor (let line of lines) {\n\t\tconst startPosition: Position = line[0];\n\t\tconst stopPosition: Position = line[1];\n\n\t\t// sectionLength\n\t\tlet intersectPosition: Position;\n\t\tlet intersectDistance: number = Infinity;\n\n\t\t// Short circuit if snap point is start or end position of the line segment.\n\t\tif (\n\t\t\tstartPosition[0] === inputCoordinate[0] &&\n\t\t\tstartPosition[1] === inputCoordinate[1]\n\t\t) {\n\t\t\tintersectPosition = startPosition;\n\t\t} else if (\n\t\t\tstopPosition[0] === inputCoordinate[0] &&\n\t\t\tstopPosition[1] === inputCoordinate[1]\n\t\t) {\n\t\t\tintersectPosition = stopPosition;\n\t\t} else {\n\t\t\t// Otherwise, find the nearest point the hard way.\n\t\t\t[intersectPosition] = nearestPointOnSegment(\n\t\t\t\tstartPosition,\n\t\t\t\tstopPosition,\n\t\t\t\tinputCoordinate,\n\t\t\t);\n\t\t}\n\n\t\tif (intersectPosition) {\n\t\t\tintersectDistance = haversineDistanceKilometers(\n\t\t\t\tinputCoordinate,\n\t\t\t\tintersectPosition,\n\t\t\t);\n\n\t\t\tif (intersectDistance < closestDistance) {\n\t\t\t\tclosestPoint = intersectPosition;\n\t\t\t\tclosestDistance = intersectDistance;\n\t\t\t\tlineIndex = lines.indexOf(line);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn closestDistance === Infinity\n\t\t? undefined\n\t\t: { coordinate: closestPoint, distance: closestDistance, lineIndex };\n}\n\n/*\n * Plan is to externalise these vector functions to a simple third party\n * library.\n * Possible candidate is @amandaghassaei/vector-math though having some import\n * issues.\n */\ntype Vector = [number, number, number];\n\nfunction dot(v1: Vector, v2: Vector): number {\n\tconst [v1x, v1y, v1z] = v1;\n\tconst [v2x, v2y, v2z] = v2;\n\treturn v1x * v2x + v1y * v2y + v1z * v2z;\n}\n\n// https://en.wikipedia.org/wiki/Cross_product\nfunction cross(v1: Vector, v2: Vector): Vector {\n\tconst [v1x, v1y, v1z] = v1;\n\tconst [v2x, v2y, v2z] = v2;\n\treturn [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];\n}\n\nfunction magnitude(v: Vector) {\n\treturn Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));\n}\n\nfunction angle(v1: Vector, v2: Vector): number {\n\tconst theta = dot(v1, v2) / (magnitude(v1) * magnitude(v2));\n\treturn Math.acos(Math.min(Math.max(theta, -1), 1));\n}\n\nfunction lngLatToVector(a: Position): Vector {\n\tconst lat = degreesToRadians(a[1]);\n\tconst lng = degreesToRadians(a[0]);\n\treturn [\n\t\tMath.cos(lat) * Math.cos(lng),\n\t\tMath.cos(lat) * Math.sin(lng),\n\t\tMath.sin(lat),\n\t];\n}\n\nfunction vectorToLngLat(v: Vector): Position {\n\tconst [x, y, z] = v;\n\tconst lat = radiansToDegrees(Math.asin(z));\n\tconst lng = radiansToDegrees(Math.atan2(y, x));\n\n\treturn [lng, lat];\n}\n\nfunction nearestPointOnSegment(\n\tposA: Position, // start point of segment to measure to\n\tposB: Position, // end point of segment to measure to\n\tposC: Position, // point to measure from\n): [Position, boolean, boolean] {\n\t// Based heavily on this article on finding cross track distance to an arc:\n\t// https://gis.stackexchange.com/questions/209540/projecting-cross-track-distance-on-great-circle\n\n\t// Convert spherical (lng, lat) to cartesian vector coords (x, y, z)\n\t// In the below https://tikz.net/spherical_1/ we convert lng (𝜙) and lat (𝜃)\n\t// into vectors with x, y, and z components with a length (r) of 1.\n\tconst A = lngLatToVector(posA); // the vector from 0,0,0 to posA\n\tconst B = lngLatToVector(posB); // ... to posB\n\tconst C = lngLatToVector(posC); // ... to posC\n\n\t// Components of target point.\n\tconst [Cx, Cy, Cz] = C;\n\n\t// Calculate coefficients.\n\tconst [D, E, F] = cross(A, B);\n\tconst a = E * Cz - F * Cy;\n\tconst b = F * Cx - D * Cz;\n\tconst c = D * Cy - E * Cx;\n\n\tconst f = c * E - b * F;\n\tconst g = a * F - c * D;\n\tconst h = b * D - a * E;\n\n\tconst t = 1 / Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2) + Math.pow(h, 2));\n\n\t// Vectors to the two points these great circles intersect.\n\tconst I1: Vector = [f * t, g * t, h * t];\n\tconst I2: Vector = [-1 * f * t, -1 * g * t, -1 * h * t];\n\n\t// Figure out which is the closest intersection to this segment of the great\n\t// circle.\n\tconst angleAB = angle(A, B);\n\tconst angleAI1 = angle(A, I1);\n\tconst angleBI1 = angle(B, I1);\n\tconst angleAI2 = angle(A, I2);\n\tconst angleBI2 = angle(B, I2);\n\n\tlet I: Vector;\n\n\tif (\n\t\t(angleAI1 < angleAI2 && angleAI1 < angleBI2) ||\n\t\t(angleBI1 < angleAI2 && angleBI1 < angleBI2)\n\t) {\n\t\tI = I1;\n\t} else {\n\t\tI = I2;\n\t}\n\n\t// I is the closest intersection to the segment, though might not actually be\n\t// ON the segment.\n\n\t// If angle AI or BI is greater than angleAB, I lies on the circle *beyond* A\n\t// and B so use the closest of A or B as the intersection\n\tif (angle(A, I) > angleAB || angle(B, I) > angleAB) {\n\t\tif (\n\t\t\thaversineDistanceKilometers(vectorToLngLat(I), vectorToLngLat(A)) <=\n\t\t\thaversineDistanceKilometers(vectorToLngLat(I), vectorToLngLat(B))\n\t\t) {\n\t\t\treturn [vectorToLngLat(A), true, false];\n\t\t} else {\n\t\t\treturn [vectorToLngLat(B), false, true];\n\t\t}\n\t}\n\n\t// As angleAI nor angleBI don't exceed angleAB, I is on the segment\n\treturn [vectorToLngLat(I), false, false];\n}\n","import { BehaviorConfig, TerraDrawModeBehavior } from \"./base.behavior\";\nimport { TerraDrawMouseEvent } from \"../common\";\nimport { Feature, Position } from \"geojson\";\nimport { ClickBoundingBoxBehavior } from \"./click-bounding-box.behavior\";\nimport { BBoxPolygon, FeatureId } from \"../store/store\";\nimport { PixelDistanceBehavior } from \"./pixel-distance.behavior\";\nimport { nearestPointOnLine } from \"../geometry/point-on-line\";\nimport { webMercatorNearestPointOnLine } from \"../geometry/web-mercator-point-on-line\";\nimport { limitPrecision } from \"../geometry/limit-decimal-precision\";\n\nexport class LineSnappingBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t\tprivate readonly clickBoundingBox: ClickBoundingBoxBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\t/** Returns the nearest snappable coordinate - on first click there is no currentId so no need to provide */\n\tpublic getSnappableCoordinateFirstClick = (event: TerraDrawMouseEvent) => {\n\t\tconst snappable = this.getSnappable(event, (feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties && feature.properties.mode === this.mode,\n\t\t\t);\n\t\t});\n\n\t\treturn snappable.coordinate\n\t\t\t? [\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tsnappable.coordinate[0],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tsnappable.coordinate[1],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t]\n\t\t\t: undefined;\n\t};\n\n\tpublic getSnappableCoordinate = (\n\t\tevent: TerraDrawMouseEvent,\n\t\tcurrentFeatureId: FeatureId,\n\t) => {\n\t\tconst snappable = this.getSnappable(event, (feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties &&\n\t\t\t\t\tfeature.properties.mode === this.mode &&\n\t\t\t\t\tfeature.id !== currentFeatureId,\n\t\t\t);\n\t\t});\n\n\t\treturn snappable.coordinate\n\t\t\t? [\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tsnappable.coordinate[0],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tsnappable.coordinate[1],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t]\n\t\t\t: undefined;\n\t};\n\n\tpublic getSnappable(\n\t\tevent: TerraDrawMouseEvent,\n\t\tfilter?: (feature: Feature) => boolean,\n\t) {\n\t\tconst boundingBox = this.clickBoundingBox.create(event) as BBoxPolygon;\n\t\tconst features = this.store.search(boundingBox, filter);\n\t\tconst closest: {\n\t\t\tcoordinate: undefined | Position;\n\t\t\tminDistance: number;\n\t\t\tfeatureId: undefined | FeatureId;\n\t\t\tfeatureCoordinateIndex: undefined | number;\n\t\t} = {\n\t\t\tfeatureId: undefined,\n\t\t\tfeatureCoordinateIndex: undefined,\n\t\t\tcoordinate: undefined,\n\t\t\tminDistance: Infinity,\n\t\t};\n\t\tfeatures.forEach((feature) => {\n\t\t\tlet coordinates: Position[];\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst lines: [Position, Position][] = [];\n\n\t\t\tfor (let i = 0; i < coordinates.length - 1; i++) {\n\t\t\t\tlines.push([coordinates[i], coordinates[i + 1]]);\n\t\t\t}\n\n\t\t\tlet nearest:\n\t\t\t\t| {\n\t\t\t\t\t\tcoordinate: Position;\n\t\t\t\t\t\tlineIndex: number;\n\t\t\t\t\t\tdistance: number;\n\t\t\t\t  }\n\t\t\t\t| undefined;\n\n\t\t\tconst lngLat: Position = [event.lng, event.lat];\n\n\t\t\tif (this.config.projection === \"web-mercator\") {\n\t\t\t\tnearest = webMercatorNearestPointOnLine(lngLat, lines);\n\t\t\t} else if (this.config.projection === \"globe\") {\n\t\t\t\tnearest = nearestPointOnLine(lngLat, lines);\n\t\t\t}\n\n\t\t\tif (!nearest) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst distance = this.pixelDistance.measure(event, nearest.coordinate);\n\t\t\tif (distance < closest.minDistance && distance < this.pointerDistance) {\n\t\t\t\tclosest.featureId = feature.id;\n\t\t\t\tclosest.coordinate = [\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tnearest.coordinate[0],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t\tlimitPrecision(\n\t\t\t\t\t\tnearest.coordinate[1],\n\t\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t\t),\n\t\t\t\t];\n\t\t\t\tclosest.featureCoordinateIndex = nearest.lineIndex;\n\t\t\t\tclosest.minDistance = distance;\n\t\t\t}\n\t\t});\n\n\t\treturn closest;\n\t}\n}\n","import { Position } from \"geojson\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"./project/web-mercator\";\nimport { cartesianDistance } from \"./measure/pixel-distance\";\nimport { CartesianPoint } from \"../common\";\n\n// nearestPointOnLine is adapted from the @turf/midpoint which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-nearest-point-on-line\n\n/**\n * Takes two points and finds the closest point on the line between them to a third point.\n * @param lines\n * @param inputCoordinate\n * @returns\n */\nexport function webMercatorNearestPointOnLine(\n\tinputCoordinate: Position,\n\tlines: [Position, Position][],\n):\n\t| {\n\t\t\tcoordinate: Position;\n\t\t\tlineIndex: number;\n\t\t\tdistance: number;\n\t  }\n\t| undefined {\n\tlet closestPoint: Position = [Infinity, Infinity];\n\tlet closestDistance = Infinity;\n\tlet lineIndex = 0;\n\n\tfor (let line of lines) {\n\t\tconst startPosition: Position = line[0];\n\t\tconst stopPosition: Position = line[1];\n\n\t\t// sectionLength\n\t\tlet intersectPosition: Position;\n\t\tlet intersectDistance: number = Infinity;\n\n\t\tconst start = lngLatToWebMercatorXY(startPosition[0], startPosition[1]);\n\t\tconst stop = lngLatToWebMercatorXY(stopPosition[0], stopPosition[1]);\n\t\tconst source = lngLatToWebMercatorXY(\n\t\t\tinputCoordinate[0],\n\t\t\tinputCoordinate[1],\n\t\t);\n\n\t\t// Short circuit if snap point is start or end position of the line segment.\n\t\tif (\n\t\t\tstartPosition[0] === inputCoordinate[0] &&\n\t\t\tstartPosition[1] === inputCoordinate[1]\n\t\t) {\n\t\t\tintersectPosition = startPosition;\n\t\t} else if (\n\t\t\tstopPosition[0] === inputCoordinate[0] &&\n\t\t\tstopPosition[1] === inputCoordinate[1]\n\t\t) {\n\t\t\tintersectPosition = stopPosition;\n\t\t} else {\n\t\t\t// Otherwise, find the nearest point the hard way.\n\t\t\tconst { x, y } = findNearestPointOnLine(start, stop, source);\n\n\t\t\tconst { lng, lat } = webMercatorXYToLngLat(x, y);\n\t\t\tintersectPosition = [lng, lat];\n\t\t}\n\n\t\tif (intersectPosition) {\n\t\t\tintersectDistance = cartesianDistance(\n\t\t\t\tsource,\n\t\t\t\tlngLatToWebMercatorXY(intersectPosition[0], intersectPosition[1]),\n\t\t\t);\n\n\t\t\tif (intersectDistance < closestDistance) {\n\t\t\t\tclosestPoint = intersectPosition;\n\t\t\t\tclosestDistance = intersectDistance;\n\t\t\t\tlineIndex = lines.indexOf(line);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn closestDistance === Infinity\n\t\t? undefined\n\t\t: {\n\t\t\t\tcoordinate: closestPoint,\n\t\t\t\tlineIndex: lineIndex,\n\t\t\t\tdistance: closestDistance,\n\t\t\t};\n}\n\n/**\n * Finds the nearest Web Mercator coordinate on a line to a given coordinate.\n * @param pointA - The first point of the line (Web Mercator coordinate).\n * @param pointB - The second point of the line (Web Mercator coordinate).\n * @param target - The target point to which the nearest point on the line is calculated.\n * @returns The nearest Web Mercator coordinate on the line to the target.\n */\nfunction findNearestPointOnLine(\n\tpointA: CartesianPoint,\n\tpointB: CartesianPoint,\n\ttarget: CartesianPoint,\n): CartesianPoint {\n\t// Vector from pointA to pointB\n\tconst lineVector = {\n\t\tx: pointB.x - pointA.x,\n\t\ty: pointB.y - pointA.y,\n\t};\n\n\t// Vector from pointA to the target point\n\tconst targetVector = {\n\t\tx: target.x - pointA.x,\n\t\ty: target.y - pointA.y,\n\t};\n\n\t// Compute the dot product of the target vector with the line vector\n\tconst dotProduct =\n\t\ttargetVector.x * lineVector.x + targetVector.y * lineVector.y;\n\n\t// Compute the length squared of the line vector\n\tconst lineLengthSquared =\n\t\tlineVector.x * lineVector.x + lineVector.y * lineVector.y;\n\n\t// Find the projection of the target vector onto the line vector\n\tconst t = Math.max(0, Math.min(1, dotProduct / lineLengthSquared));\n\n\t// Compute the nearest point on the line\n\tconst nearestPoint = {\n\t\tx: pointA.x + t * lineVector.x,\n\t\ty: pointA.y + t * lineVector.y,\n\t};\n\n\treturn nearestPoint;\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tCartesianPoint,\n\tZ_INDEX,\n\tSnapping,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { Feature, LineString, Point, Position } from \"geojson\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../click-bounding-box.behavior\";\nimport { PixelDistanceBehavior } from \"../pixel-distance.behavior\";\nimport { CoordinateSnappingBehavior } from \"../coordinate-snapping.behavior\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tGeoJSONStoreGeometries,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { InsertCoordinatesBehavior } from \"../insert-coordinates.behavior\";\nimport { haversineDistanceKilometers } from \"../../geometry/measure/haversine-distance\";\nimport { coordinatesIdentical } from \"../../geometry/coordinates-identical\";\nimport { ValidateLineStringFeature } from \"../../validations/linestring.validation\";\nimport { LineSnappingBehavior } from \"../line-snapping.behavior\";\n\ntype TerraDrawLineStringModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" } as const;\n\ntype LineStringStyling = {\n\tlineStringWidth: NumericStyling;\n\tlineStringColor: HexColorStyling;\n\tclosingPointColor: HexColorStyling;\n\tclosingPointWidth: NumericStyling;\n\tclosingPointOutlineColor: HexColorStyling;\n\tclosingPointOutlineWidth: NumericStyling;\n\tsnappingPointColor: HexColorStyling;\n\tsnappingPointWidth: NumericStyling;\n\tsnappingPointOutlineColor: HexColorStyling;\n\tsnappingPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n\tdragStart?: Cursor;\n\tdragEnd?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n\tdragStart: \"grabbing\",\n\tdragEnd: \"crosshair\",\n} as Required<Cursors>;\n\ninterface InertCoordinates {\n\tstrategy: \"amount\"; // In future this could be extended\n\tvalue: number;\n}\n\ninterface TerraDrawLineStringModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tsnapping?: Snapping;\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawLineStringModeKeyEvents | null;\n\tcursors?: Cursors;\n\tinsertCoordinates?: InertCoordinates;\n\teditable?: boolean;\n}\n\nexport class TerraDrawLineStringMode extends TerraDrawBaseDrawMode<LineStringStyling> {\n\tmode = \"linestring\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate closingPointId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawLineStringModeKeyEvents = defaultKeyEvents;\n\tprivate snapping: Snapping | undefined;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\tprivate insertCoordinates: InertCoordinates | undefined;\n\tprivate lastCommittedCoordinates: Position[] | undefined;\n\tprivate snappedPointId: FeatureId | undefined;\n\tprivate lastMouseMoveEvent: TerraDrawMouseEvent | undefined;\n\n\t// Editable properties\n\tprivate editable: boolean = false;\n\tprivate editedFeatureId: FeatureId | undefined;\n\tprivate editedFeatureCoordinateIndex: number | undefined;\n\tprivate editedSnapType: \"line\" | \"coordinate\" | undefined;\n\tprivate editedInsertIndex: number | undefined;\n\tprivate editedPointId: FeatureId | undefined;\n\n\t// Behaviors\n\tprivate coordinateSnapping!: CoordinateSnappingBehavior;\n\tprivate insertPoint!: InsertCoordinatesBehavior;\n\tprivate lineSnapping!: LineSnappingBehavior;\n\tprivate pixelDistance!: PixelDistanceBehavior;\n\tprivate clickBoundingBox!: ClickBoundingBoxBehavior;\n\n\tconstructor(options?: TerraDrawLineStringModeOptions<LineStringStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tupdateOptions(\n\t\toptions?: TerraDrawLineStringModeOptions<LineStringStyling> | undefined,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.snapping) {\n\t\t\tthis.snapping = options.snapping;\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.insertCoordinates) {\n\t\t\tthis.insertCoordinates = options.insertCoordinates;\n\t\t}\n\n\t\tif (options && options.editable) {\n\t\t\tthis.editable = options.editable;\n\t\t}\n\t}\n\n\tprivate updateSnappedCoordinate(event: TerraDrawMouseEvent) {\n\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\tif (snappedCoordinate) {\n\t\t\tif (this.snappedPointId) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{\n\t\t\t\t\t\tid: this.snappedPointId,\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tconst [snappedPointId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.SNAPPING_POINT]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\tthis.snappedPointId = snappedPointId;\n\t\t\t}\n\n\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\tevent.lat = snappedCoordinate[1];\n\t\t} else if (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\treturn snappedCoordinate;\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\t// Finish off the drawing\n\t\tcurrentLineGeometry.coordinates.pop();\n\n\t\tthis.updateGeometries(\n\t\t\t[...currentLineGeometry.coordinates],\n\t\t\tundefined,\n\t\t\tUpdateTypes.Commit,\n\t\t);\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\tvalue: undefined,\n\t\t\t},\n\t\t]);\n\n\t\tconst finishedId = this.currentId;\n\n\t\t// Reset the state back to starting state\n\t\tif (this.closingPointId) {\n\t\t\tthis.store.delete([this.closingPointId]);\n\t\t}\n\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t}\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentId = undefined;\n\t\tthis.closingPointId = undefined;\n\t\tthis.snappedPointId = undefined;\n\t\tthis.lastCommittedCoordinates = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\t// Ensure that any listeners are triggered with the main created geometry\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\tprivate updateGeometries(\n\t\tcoordinates: LineString[\"coordinates\"],\n\t\tclosingPointCoordinate: Point[\"coordinates\"] | undefined,\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tif (!this.currentId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst updatedGeometry = { type: \"LineString\", coordinates } as LineString;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: updateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst geometries = [\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tgeometry: updatedGeometry,\n\t\t\t},\n\t\t] as {\n\t\t\tid: FeatureId;\n\t\t\tgeometry: GeoJSONStoreGeometries;\n\t\t}[];\n\n\t\tif (this.closingPointId && closingPointCoordinate) {\n\t\t\tgeometries.push({\n\t\t\t\tid: this.closingPointId,\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: closingPointCoordinate,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tif (updateType === \"commit\") {\n\t\t\tthis.lastCommittedCoordinates = updatedGeometry.coordinates;\n\t\t}\n\n\t\tthis.store.updateGeometry(geometries);\n\t}\n\n\tprivate generateInsertCoordinates(startCoord: Position, endCoord: Position) {\n\t\tif (!this.insertCoordinates || !this.lastCommittedCoordinates) {\n\t\t\tthrow new Error(\"Not able to insert coordinates\");\n\t\t}\n\n\t\t// Other strategies my be implemented in the future\n\t\tif (this.insertCoordinates.strategy !== \"amount\") {\n\t\t\tthrow new Error(\"Strategy does not exist\");\n\t\t}\n\n\t\tconst distance = haversineDistanceKilometers(startCoord, endCoord);\n\t\tconst segmentDistance = distance / (this.insertCoordinates.value + 1);\n\t\tlet insertedCoordinates: Position[] = [];\n\n\t\tif (this.projection === \"globe\") {\n\t\t\tinsertedCoordinates =\n\t\t\t\tthis.insertPoint.generateInsertionGeodesicCoordinates(\n\t\t\t\t\tstartCoord,\n\t\t\t\t\tendCoord,\n\t\t\t\t\tsegmentDistance,\n\t\t\t\t);\n\t\t} else if (this.projection === \"web-mercator\") {\n\t\t\tinsertedCoordinates = this.insertPoint.generateInsertionCoordinates(\n\t\t\t\tstartCoord,\n\t\t\t\tendCoord,\n\t\t\t\tsegmentDistance,\n\t\t\t);\n\t\t}\n\n\t\treturn insertedCoordinates;\n\t}\n\n\tprivate createLine(startingCoord: Position) {\n\t\tconst [createdId] = this.store.create([\n\t\t\t{\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"LineString\",\n\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\tstartingCoord,\n\t\t\t\t\t\tstartingCoord, // This is the 'live' point that changes on mouse move\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\tproperties: {\n\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true, // This is the current line being drawn\n\t\t\t\t},\n\t\t\t},\n\t\t]);\n\t\tthis.lastCommittedCoordinates = [startingCoord, startingCoord];\n\t\tthis.currentId = createdId;\n\t\tthis.currentCoordinate++;\n\t\tthis.setDrawing();\n\t}\n\n\tprivate firstUpdateToLine(updatedCoord: Position) {\n\t\tif (!this.currentId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst currentCoordinates = currentLineGeometry.coordinates;\n\n\t\tconst [pointId] = this.store.create([\n\t\t\t{\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: [...updatedCoord],\n\t\t\t\t},\n\t\t\t\tproperties: {\n\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t},\n\t\t\t},\n\t\t]);\n\t\tthis.closingPointId = pointId;\n\n\t\t// We are creating the point so we immediately want\n\t\t// to set the point cursor to show it can be closed\n\t\tthis.setCursor(this.cursors.close);\n\n\t\tconst initialLineCoordinates = [...currentCoordinates, updatedCoord];\n\t\tconst closingPointCoordinate = undefined; // We don't need this until second click\n\n\t\tthis.updateGeometries(\n\t\t\tinitialLineCoordinates,\n\t\t\tclosingPointCoordinate,\n\t\t\tUpdateTypes.Commit,\n\t\t);\n\n\t\tthis.currentCoordinate++;\n\t}\n\n\tprivate updateToLine(updatedCoord: Position, cursorXY: CartesianPoint) {\n\t\tif (!this.currentId) {\n\t\t\treturn;\n\t\t}\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst currentCoordinates = currentLineGeometry.coordinates;\n\n\t\t// If we are not inserting points we can get the penultimate coordinated\n\t\tconst [previousLng, previousLat] = this.lastCommittedCoordinates\n\t\t\t? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1]\n\t\t\t: currentCoordinates[currentCoordinates.length - 2];\n\n\t\t// Determine if the click closes the line and finished drawing\n\t\tconst { x, y } = this.project(previousLng, previousLat);\n\t\tconst distance = cartesianDistance(\n\t\t\t{ x, y },\n\t\t\t{ x: cursorXY.x, y: cursorXY.y },\n\t\t);\n\t\tconst isClosingClick = distance < this.pointerDistance;\n\n\t\tif (isClosingClick) {\n\t\t\tthis.close();\n\t\t\treturn;\n\t\t}\n\n\t\t// The cursor will immediately change to closing because the\n\t\t// closing point will be underneath the cursor\n\t\tthis.setCursor(this.cursors.close);\n\n\t\tconst updatedLineCoordinates = [...currentCoordinates, updatedCoord];\n\t\tconst updatedClosingPointCoordinate =\n\t\t\tcurrentCoordinates[currentCoordinates.length - 1];\n\n\t\tthis.updateGeometries(\n\t\t\tupdatedLineCoordinates,\n\t\t\tupdatedClosingPointCoordinate,\n\t\t\tUpdateTypes.Commit,\n\t\t);\n\n\t\tthis.currentCoordinate++;\n\t}\n\n\t/** @internal */\n\tregisterBehaviors(config: BehaviorConfig) {\n\t\tthis.coordinateSnapping = new CoordinateSnappingBehavior(\n\t\t\tconfig,\n\t\t\tnew PixelDistanceBehavior(config),\n\t\t\tnew ClickBoundingBoxBehavior(config),\n\t\t);\n\n\t\tthis.insertPoint = new InsertCoordinatesBehavior(config);\n\n\t\tthis.clickBoundingBox = new ClickBoundingBoxBehavior(config);\n\t\tthis.pixelDistance = new PixelDistanceBehavior(config);\n\t\tthis.lineSnapping = new LineSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.coordinateSnapping = new CoordinateSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\t\tthis.lastMouseMoveEvent = event;\n\n\t\tconst snappedCoordinate = this.updateSnappedCoordinate(event);\n\n\t\tconst updatedCoord = snappedCoordinate\n\t\t\t? snappedCoordinate\n\t\t\t: [event.lng, event.lat];\n\n\t\tif (this.currentId === undefined || this.currentCoordinate === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst currentCoordinates = currentLineGeometry.coordinates;\n\n\t\t// Remove the 'live' point that changes on mouse move\n\t\tcurrentCoordinates.pop();\n\n\t\t// We want to ensure that when we are hovering over\n\t\t// the closing point that the pointer cursor is shown\n\t\tif (this.closingPointId) {\n\t\t\tconst [previousLng, previousLat] =\n\t\t\t\tcurrentCoordinates[currentCoordinates.length - 1];\n\t\t\tconst { x, y } = this.project(previousLng, previousLat);\n\t\t\tconst distance = cartesianDistance(\n\t\t\t\t{ x, y },\n\t\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t\t);\n\n\t\t\tconst isClosingClick = distance < this.pointerDistance;\n\n\t\t\tif (isClosingClick) {\n\t\t\t\tthis.setCursor(this.cursors.close);\n\t\t\t}\n\t\t}\n\n\t\tlet line = [...currentCoordinates, updatedCoord];\n\n\t\tif (\n\t\t\tthis.insertCoordinates &&\n\t\t\tthis.currentId &&\n\t\t\tthis.lastCommittedCoordinates\n\t\t) {\n\t\t\tconst startCoord =\n\t\t\t\tthis.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1];\n\t\t\tconst endCoord = updatedCoord;\n\t\t\tif (!coordinatesIdentical(startCoord, endCoord)) {\n\t\t\t\tconst insertedCoordinates = this.generateInsertCoordinates(\n\t\t\t\t\tstartCoord,\n\t\t\t\t\tendCoord,\n\t\t\t\t);\n\t\t\t\tline = [\n\t\t\t\t\t...this.lastCommittedCoordinates.slice(0, -1),\n\t\t\t\t\t...insertedCoordinates,\n\t\t\t\t\tupdatedCoord,\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\t// Update the 'live' point\n\t\tthis.updateGeometries(line, undefined, UpdateTypes.Provisional);\n\t}\n\n\tprivate onRightClick(event: TerraDrawMouseEvent) {\n\t\tif (!this.editable || this.state !== \"started\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { featureId, featureCoordinateIndex: coordinateIndex } =\n\t\t\tthis.coordinateSnapping.getSnappable(event, (feature) =>\n\t\t\t\tthis.lineStringFilter(feature),\n\t\t\t);\n\n\t\tif (!featureId || coordinateIndex === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(featureId);\n\n\t\tlet coordinates;\n\t\tif (geometry.type === \"LineString\") {\n\t\t\tcoordinates = geometry.coordinates;\n\n\t\t\t// Prevent creating an invalid linestring\n\t\t\tif (coordinates.length <= 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove coordinate from array\n\t\tcoordinates.splice(coordinateIndex, 1);\n\n\t\t// Validate the new geometry\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\tid: featureId,\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Commit,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// The geometry has changed, so if we were snapped to a point we need to remove it\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: featureId,\n\t\t\t\tgeometry,\n\t\t\t},\n\t\t]);\n\n\t\tthis.onFinish(featureId, { mode: this.mode, action: \"edit\" });\n\t}\n\n\tprivate onLeftClick(event: TerraDrawMouseEvent) {\n\t\t// Reset the snapping point\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\t\tconst updatedCoordinate = snappedCoordinate\n\t\t\t? snappedCoordinate\n\t\t\t: [event.lng, event.lat];\n\n\t\tif (this.currentCoordinate === 0) {\n\t\t\tthis.createLine(updatedCoordinate);\n\t\t} else if (this.currentCoordinate === 1 && this.currentId) {\n\t\t\tthis.firstUpdateToLine(updatedCoordinate);\n\t\t} else if (this.currentId) {\n\t\t\tthis.updateToLine(updatedCoordinate, {\n\t\t\t\tx: event.containerX,\n\t\t\t\ty: event.containerY,\n\t\t\t});\n\t\t}\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\t// We want pointer devices (mobile/tablet) to have\n\t\t\t// similar behaviour to mouse based devices so we\n\t\t\t// trigger a mousemove event before every click\n\t\t\t// if one has not been triggered to emulate this\n\t\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\t\tthis.onMouseMove(event);\n\t\t\t}\n\t\t\tthis.mouseMove = false;\n\n\t\t\tif (event.button === \"right\") {\n\t\t\t\tthis.onRightClick(event);\n\t\t\t} else if (event.button === \"left\") {\n\t\t\t\tthis.onLeftClick(event);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t}\n\n\t\tif (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragStart, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.editable) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet snappedCoordinate: Position | undefined = undefined;\n\n\t\tif (this.state === \"started\") {\n\t\t\tconst lineSnapped = this.lineSnapping.getSnappable(event, (feature) =>\n\t\t\t\tthis.lineStringFilter(feature),\n\t\t\t);\n\n\t\t\tif (lineSnapped.coordinate) {\n\t\t\t\tthis.editedSnapType = \"line\";\n\t\t\t\tthis.editedFeatureCoordinateIndex = lineSnapped.featureCoordinateIndex;\n\t\t\t\tthis.editedFeatureId = lineSnapped.featureId;\n\t\t\t\tsnappedCoordinate = lineSnapped.coordinate;\n\t\t\t}\n\n\t\t\tconst coordinateSnapped = this.coordinateSnapping.getSnappable(\n\t\t\t\tevent,\n\t\t\t\t(feature) => this.lineStringFilter(feature),\n\t\t\t);\n\n\t\t\tif (coordinateSnapped.coordinate) {\n\t\t\t\tthis.editedSnapType = \"coordinate\";\n\t\t\t\tthis.editedFeatureCoordinateIndex =\n\t\t\t\t\tcoordinateSnapped.featureCoordinateIndex;\n\t\t\t\tthis.editedFeatureId = coordinateSnapped.featureId;\n\t\t\t\tsnappedCoordinate = coordinateSnapped.coordinate;\n\t\t\t}\n\t\t}\n\n\t\t// We only need to stop the map dragging if\n\t\t// we actually have something selected\n\t\tif (!this.editedFeatureId || !snappedCoordinate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create a point to drag when editing\n\t\tif (!this.editedPointId) {\n\t\t\tconst [editedPointId] = this.store.create([\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t},\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.EDITED]: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.editedPointId = editedPointId;\n\t\t}\n\n\t\t// Drag Feature\n\t\tthis.setCursor(this.cursors.dragStart);\n\n\t\tsetMapDraggability(false);\n\t}\n\n\t/** @internal */\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDrag, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tthis.editedFeatureId === undefined ||\n\t\t\tthis.editedFeatureCoordinateIndex === undefined\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst featureCopy: LineString = this.store.getGeometryCopy(\n\t\t\tthis.editedFeatureId,\n\t\t);\n\t\tconst featureCoordinates = featureCopy.coordinates;\n\n\t\t// Either it's a coordinate drag or a line drag where the line coordinate has already been inserted\n\t\tif (\n\t\t\tthis.editedSnapType === \"coordinate\" ||\n\t\t\t(this.editedSnapType === \"line\" && this.editedInsertIndex !== undefined)\n\t\t) {\n\t\t\tfeatureCoordinates[this.editedFeatureCoordinateIndex] = [\n\t\t\t\tevent.lng,\n\t\t\t\tevent.lat,\n\t\t\t];\n\t\t} else if (\n\t\t\tthis.editedSnapType === \"line\" &&\n\t\t\tthis.editedInsertIndex === undefined\n\t\t) {\n\t\t\t// Splice inserts _before_ the index, so we need to add 1\n\t\t\tthis.editedInsertIndex = this.editedFeatureCoordinateIndex + 1;\n\n\t\t\t// Insert the new dragged snapped line coordinate\n\t\t\tfeatureCopy.coordinates.splice(this.editedInsertIndex, 0, [\n\t\t\t\tevent.lng,\n\t\t\t\tevent.lat,\n\t\t\t]);\n\n\t\t\t// We have inserted a point, need to change the edit index\n\t\t\t// so it can be moved correctly when it gets dragged again\n\t\t\tthis.editedFeatureCoordinateIndex++;\n\t\t}\n\n\t\tconst newLineStringGeometry = {\n\t\t\ttype: \"LineString\",\n\t\t\tcoordinates: featureCopy.coordinates,\n\t\t} as LineString;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: newLineStringGeometry,\n\t\t\t\t\tproperties: this.store.getPropertiesCopy(this.editedFeatureId),\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping && this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tgeometry: newLineStringGeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (this.editedPointId) {\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.editedPointId,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t]);\n\t}\n\n\t/** @internal */\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragEnd, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editedFeatureId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setCursor(this.cursors.dragEnd);\n\n\t\tif (this.editedPointId) {\n\t\t\tthis.store.delete([this.editedPointId]);\n\t\t\tthis.editedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: false,\n\t\t\t},\n\t\t]);\n\n\t\tthis.onFinish(this.editedFeatureId, { mode: this.mode, action: \"edit\" });\n\n\t\t// Reset edit state\n\t\tthis.editedFeatureId = undefined;\n\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\tthis.editedInsertIndex = undefined;\n\t\tthis.editedSnapType = undefined;\n\n\t\tsetMapDraggability(true);\n\t}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentId;\n\t\tconst cleanupClosingPointId = this.closingPointId;\n\t\tconst snappedPointId = this.snappedPointId;\n\n\t\tthis.closingPointId = undefined;\n\t\tthis.snappedPointId = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.currentCoordinate = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t\tif (snappedPointId !== undefined) {\n\t\t\t\tthis.store.delete([snappedPointId]);\n\t\t\t}\n\t\t\tif (cleanupClosingPointId !== undefined) {\n\t\t\t\tthis.store.delete([cleanupClosingPointId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"LineString\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.lineStringColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.lineStringColor,\n\t\t\t\tstyles.lineStringColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.lineStringWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.lineStringWidth,\n\t\t\t\tstyles.lineStringWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t} else if (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tconst isClosingPoint =\n\t\t\t\tfeature.properties[COMMON_PROPERTIES.CLOSING_POINT];\n\n\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\tisClosingPoint\n\t\t\t\t\t? this.styles.closingPointColor\n\t\t\t\t\t: this.styles.snappingPointColor,\n\t\t\t\tstyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\tisClosingPoint\n\t\t\t\t\t? this.styles.closingPointWidth\n\t\t\t\t\t: this.styles.snappingPointWidth,\n\t\t\t\tstyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tisClosingPoint\n\t\t\t\t\t? this.styles.closingPointOutlineColor\n\t\t\t\t\t: this.styles.snappingPointOutlineColor,\n\t\t\t\t\"#ffffff\",\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tisClosingPoint\n\t\t\t\t\t? this.styles.closingPointOutlineWidth\n\t\t\t\t\t: this.styles.snappingPointOutlineWidth,\n\t\t\t\t2,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_FIVE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateLineStringFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n\n\tprivate lineStringFilter(feature: Feature) {\n\t\treturn Boolean(\n\t\t\tfeature.geometry.type === \"LineString\" &&\n\t\t\t\tfeature.properties &&\n\t\t\t\tfeature.properties.mode === this.mode,\n\t\t);\n\t}\n\n\tprivate snapCoordinate(event: TerraDrawMouseEvent) {\n\t\tlet snappedCoordinate: Position | undefined;\n\n\t\tif (this.snapping?.toLine) {\n\t\t\tlet snapped: Position | undefined;\n\t\t\tif (this.currentId) {\n\t\t\t\tsnapped = this.lineSnapping.getSnappableCoordinate(\n\t\t\t\t\tevent,\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tsnapped = this.lineSnapping.getSnappableCoordinateFirstClick(event);\n\t\t\t}\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping?.toCoordinate) {\n\t\t\tif (this.currentId) {\n\t\t\t\tsnappedCoordinate = this.coordinateSnapping.getSnappableCoordinate(\n\t\t\t\t\tevent,\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tsnappedCoordinate =\n\t\t\t\t\tthis.coordinateSnapping.getSnappableCoordinateFirstClick(event);\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping?.toCustom) {\n\t\t\tsnappedCoordinate = this.snapping.toCustom(event, {\n\t\t\t\tcurrentCoordinate: this.currentCoordinate,\n\t\t\t\tcurrentId: this.currentId,\n\t\t\t\tgetCurrentGeometrySnapshot: this.currentId\n\t\t\t\t\t? () =>\n\t\t\t\t\t\t\tthis.store.getGeometryCopy<LineString>(\n\t\t\t\t\t\t\t\tthis.currentId as FeatureId,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t: () => null,\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t});\n\t\t}\n\n\t\treturn snappedCoordinate;\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// Clean up here is important to get right as we need to make a best effort to avoid erroneous\n\t\t// internal state.\n\n\t\t// If we are editing a feature by dragging one of its points\n\t\t// we want to clear that state up as new polygon might be completely\n\t\t// different in terms of it's coordinates\n\t\tif (this.editedFeatureId === feature.id && this.editedPointId) {\n\t\t\tthis.store.delete([this.editedPointId]);\n\t\t\tthis.editedPointId = undefined;\n\t\t\tthis.editedFeatureId = undefined;\n\t\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\t\tthis.editedSnapType = undefined;\n\t\t}\n\n\t\t// We can recalculate the snapped point from the last mouse event if there was one\n\t\tif (this.snappedPointId && this.lastMouseMoveEvent) {\n\t\t\tthis.updateSnappedCoordinate(\n\t\t\t\tthis.lastMouseMoveEvent as TerraDrawMouseEvent,\n\t\t\t);\n\t\t}\n\n\t\t// NOTE: This handles the case we are currently drawing a polygon\n\t\t// We need to reset the drawing state because it is very complicated (impossible?)\n\t\t// to recover the drawing state after a feature update\n\t\tif (this.currentId === feature.id) {\n\t\t\tif (this.closingPointId) {\n\t\t\t\tthis.store.delete([this.closingPointId]);\n\t\t\t\tthis.closingPointId = undefined;\n\t\t\t}\n\n\t\t\tthis.currentCoordinate = 0;\n\t\t\tthis.currentId = undefined;\n\n\t\t\t// Go back to started state\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { Validation } from \"../common\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport {\n\tcoordinateIsValid,\n\tcoordinatePrecisionIsValid,\n} from \"../geometry/boolean/is-valid-coordinate\";\n\nexport const ValidationReasonFeatureNotPoint = \"Feature is not a Point\";\nexport const ValidationReasonFeatureInvalidCoordinates =\n\t\"Feature has invalid coordinates\";\nexport const ValidationReasonFeatureInvalidCoordinatePrecision =\n\t\"Feature has coordinates with excessive precision\";\n\nexport function ValidatePointFeature(\n\tfeature: GeoJSONStoreFeatures,\n\tcoordinatePrecision: number,\n): ReturnType<Validation> {\n\tif (feature.geometry.type !== \"Point\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPoint,\n\t\t};\n\t}\n\n\tif (!coordinateIsValid(feature.geometry.coordinates)) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureInvalidCoordinates,\n\t\t};\n\t}\n\n\tif (\n\t\t!coordinatePrecisionIsValid(\n\t\t\tfeature.geometry.coordinates,\n\t\t\tcoordinatePrecision,\n\t\t)\n\t) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureInvalidCoordinatePrecision,\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tNumericStyling,\n\tHexColorStyling,\n\tCursor,\n\tUpdateTypes,\n\tCOMMON_PROPERTIES,\n\tZ_INDEX,\n} from \"../../common\";\nimport {\n\tBBoxPolygon,\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { ValidatePointFeature } from \"../../validations/point.validation\";\nimport { Point, Position } from \"geojson\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../click-bounding-box.behavior\";\nimport { PixelDistanceBehavior } from \"../pixel-distance.behavior\";\n\ntype PointModeStyling = {\n\tpointWidth: NumericStyling;\n\tpointColor: HexColorStyling;\n\tpointOutlineColor: HexColorStyling;\n\tpointOutlineWidth: NumericStyling;\n\teditedPointColor: HexColorStyling;\n\teditedPointWidth: NumericStyling;\n\teditedPointOutlineColor: HexColorStyling;\n\teditedPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tcreate?: Cursor;\n\tdragStart?: Cursor;\n\tdragEnd?: Cursor;\n}\n\nconst defaultCursors = {\n\tcreate: \"crosshair\",\n\tdragStart: \"grabbing\",\n\tdragEnd: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawPointModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tcursors?: Cursors;\n\teditable?: boolean;\n}\n\nexport class TerraDrawPointMode extends TerraDrawBaseDrawMode<PointModeStyling> {\n\tmode = \"point\" as const;\n\n\t// Options\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate editable: boolean = false;\n\n\t// Internal state\n\tprivate editedFeatureId: FeatureId | undefined;\n\n\t// Behaviors\n\tprivate pixelDistance!: PixelDistanceBehavior;\n\tprivate clickBoundingBox!: ClickBoundingBoxBehavior;\n\n\tconstructor(options?: TerraDrawPointModeOptions<PointModeStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tupdateOptions(\n\t\toptions?: TerraDrawPointModeOptions<PointModeStyling> | undefined,\n\t): void {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.editable) {\n\t\t\tthis.editable = options.editable;\n\t\t}\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.create);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tthis.onRightClick(event);\n\t\t\treturn;\n\t\t} else if (\n\t\t\tevent.button === \"left\" &&\n\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)\n\t\t) {\n\t\t\tthis.onLeftClick(event);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @internal */\n\tonMouseMove() {}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tthis.editedFeatureId = undefined;\n\t}\n\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragStart, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editable) {\n\t\t\tconst nearestPointFeature = this.getNearestPointFeature(event);\n\t\t\tthis.editedFeatureId = nearestPointFeature?.id;\n\t\t}\n\n\t\t// We only need to stop the map dragging if\n\t\t// we actually have something selected\n\t\tif (!this.editedFeatureId) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Drag Feature\n\t\tthis.setCursor(this.cursors.dragStart);\n\n\t\tsetMapDraggability(false);\n\t}\n\n\t/** @internal */\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDrag, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editedFeatureId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst newGeometry = {\n\t\t\ttype: \"Point\",\n\t\t\tcoordinates: [event.lng, event.lat],\n\t\t};\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t\tproperties: this.store.getPropertiesCopy(this.editedFeatureId),\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// For cursor points we can simply move it\n\t\t// to the dragged position\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t},\n\t\t\t},\n\t\t]);\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t]);\n\t}\n\n\t/** @internal */\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragEnd, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editedFeatureId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.onFinish(this.editedFeatureId, { mode: this.mode, action: \"edit\" });\n\n\t\tthis.setCursor(this.cursors.dragEnd);\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: false,\n\t\t\t},\n\t\t]);\n\t\tthis.editedFeatureId = undefined;\n\t\tsetMapDraggability(true);\n\t}\n\n\tregisterBehaviors(config: BehaviorConfig) {\n\t\tthis.pixelDistance = new PixelDistanceBehavior(config);\n\t\tthis.clickBoundingBox = new ClickBoundingBoxBehavior(config);\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tconst isEdited = Boolean(\n\t\t\t\tfeature.id && this.editedFeatureId === feature.id,\n\t\t\t);\n\n\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\tisEdited ? this.styles.editedPointWidth : this.styles.pointWidth,\n\t\t\t\tstyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\tisEdited ? this.styles.editedPointColor : this.styles.pointColor,\n\t\t\t\tstyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tisEdited\n\t\t\t\t\t? this.styles.editedPointOutlineColor\n\t\t\t\t\t: this.styles.pointOutlineColor,\n\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tisEdited\n\t\t\t\t\t? this.styles.editedPointOutlineWidth\n\t\t\t\t\t: this.styles.pointOutlineWidth,\n\t\t\t\t2,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_THREE;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidatePointFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n\n\tprivate onLeftClick(event: TerraDrawMouseEvent) {\n\t\tconst geometry = {\n\t\t\ttype: \"Point\",\n\t\t\tcoordinates: [event.lng, event.lat],\n\t\t} as Point;\n\n\t\tconst properties = { mode: this.mode };\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst [pointId] = this.store.create([{ geometry, properties }]);\n\n\t\t// Ensure that any listerers are triggered with the main created geometry\n\t\tthis.onFinish(pointId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\tprivate onRightClick(event: TerraDrawMouseEvent) {\n\t\t// We only want to be able to delete points if the mode is editable\n\t\tif (!this.editable) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst clickedFeature = this.getNearestPointFeature(event);\n\n\t\tif (clickedFeature) {\n\t\t\tthis.store.delete([clickedFeature.id as FeatureId]);\n\t\t}\n\t}\n\n\tprivate getNearestPointFeature(event: TerraDrawMouseEvent) {\n\t\tconst bbox = this.clickBoundingBox.create(event) as BBoxPolygon;\n\t\tconst features = this.store.search(bbox);\n\n\t\tlet distance = Infinity;\n\t\tlet clickedFeature: GeoJSONStoreFeatures | undefined = undefined;\n\n\t\tfor (let i = 0; i < features.length; i++) {\n\t\t\tconst feature = features[i];\n\t\t\tconst isPoint =\n\t\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\t\tfeature.properties.mode === this.mode;\n\n\t\t\tif (!isPoint) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst position = feature.geometry.coordinates as Position;\n\t\t\tconst distanceToFeature = this.pixelDistance.measure(event, position);\n\n\t\t\tif (\n\t\t\t\tdistanceToFeature > distance ||\n\t\t\t\tdistanceToFeature > this.pointerDistance\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdistance = distanceToFeature;\n\t\t\tclickedFeature = feature;\n\t\t}\n\n\t\treturn clickedFeature;\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// If we are editing a point by dragging it we want to clear that state\n\t\t// up as new point location might be completely  different in terms of it's location\n\t\tif (this.editedFeatureId === feature.id) {\n\t\t\tthis.editedFeatureId = undefined;\n\t\t\tthis.setCursor(this.cursors.create);\n\t\t}\n\t}\n}\n","import { Point, Position } from \"geojson\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { COMMON_PROPERTIES, TerraDrawMouseEvent } from \"../../../common\";\nimport { PixelDistanceBehavior } from \"../../pixel-distance.behavior\";\n\nexport class ClosingPointsBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate _startEndPoints: string[] = [];\n\n\tget ids() {\n\t\treturn this._startEndPoints.concat();\n\t}\n\n\tset ids(_: string[]) {}\n\n\tpublic create(selectedCoords: Position[], mode: string) {\n\t\tif (this.ids.length) {\n\t\t\tthrow new Error(\"Opening and closing points already created\");\n\t\t}\n\n\t\tif (selectedCoords.length <= 3) {\n\t\t\tthrow new Error(\"Requires at least 4 coordinates\");\n\t\t}\n\n\t\tthis._startEndPoints = this.store.create(\n\t\t\t// Opening coordinate\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: selectedCoords[0],\n\t\t\t\t\t} as Point,\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t// Final coordinate\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: selectedCoords[selectedCoords.length - 2],\n\t\t\t\t\t} as Point,\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t);\n\t}\n\n\tpublic delete() {\n\t\tif (this.ids.length) {\n\t\t\tthis.store.delete(this.ids);\n\t\t\tthis._startEndPoints = [];\n\t\t}\n\t}\n\n\tpublic update(updatedCoordinates: Position[]) {\n\t\tif (this.ids.length !== 2) {\n\t\t\tthrow new Error(\"No closing points to update\");\n\t\t}\n\n\t\tthis.store.updateGeometry(\n\t\t\t// Opening coordinate\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tid: this.ids[0],\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: updatedCoordinates[0],\n\t\t\t\t\t} as Point,\n\t\t\t\t},\n\t\t\t\t// Final coordinate\n\t\t\t\t{\n\t\t\t\t\tid: this.ids[1],\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: updatedCoordinates[updatedCoordinates.length - 3],\n\t\t\t\t\t} as Point,\n\t\t\t\t},\n\t\t\t],\n\t\t);\n\t}\n\n\tpublic isClosingPoint(event: TerraDrawMouseEvent) {\n\t\tconst opening = this.store.getGeometryCopy(this.ids[0]);\n\t\tconst closing = this.store.getGeometryCopy(this.ids[1]);\n\n\t\tconst distance = this.pixelDistance.measure(\n\t\t\tevent,\n\t\t\topening.coordinates as Position,\n\t\t);\n\n\t\tconst distancePrevious = this.pixelDistance.measure(\n\t\t\tevent,\n\t\t\tclosing.coordinates as Position,\n\t\t);\n\n\t\tconst isClosing = distance < this.pointerDistance;\n\t\tconst isPreviousClosing = distancePrevious < this.pointerDistance;\n\n\t\treturn { isClosing, isPreviousClosing };\n\t}\n}\n","import { Point, Position } from \"geojson\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { FeatureId } from \"../../../store/store\";\nimport { COMMON_PROPERTIES } from \"../../../common\";\n\nexport class CoordinatePointBehavior extends TerraDrawModeBehavior {\n\tconstructor(config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\n\tpublic createOrUpdate(featureId: FeatureId) {\n\t\tconst existingFeature = this.store.getGeometryCopy(featureId);\n\t\tconst existingProperties = this.store.getPropertiesCopy(featureId);\n\n\t\tlet coordinates: Position[];\n\n\t\tif (existingFeature.type === \"Polygon\") {\n\t\t\tcoordinates = existingFeature.coordinates[0].slice(0, -1) as Position[];\n\t\t} else if (existingFeature.type === \"LineString\") {\n\t\t\tcoordinates = existingFeature.coordinates as Position[];\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tconst existingFeatureProps = this.store.getPropertiesCopy(featureId);\n\n\t\tconst existingCoordinatePointIds =\n\t\t\texistingFeatureProps.coordinatePointIds as FeatureId[];\n\n\t\t// If no existing coordinate points, create them\n\t\tif (!existingCoordinatePointIds) {\n\t\t\tconst coordinatePointIds = this.createPoints(\n\t\t\t\tcoordinates,\n\t\t\t\texistingProperties.mode as string,\n\t\t\t\tfeatureId,\n\t\t\t);\n\t\t\tthis.setFeatureCoordinatePoints(featureId, coordinatePointIds);\n\t\t}\n\t\t// If the existing coordinate points are present in the store, update them\n\t\telse if (\n\t\t\texistingCoordinatePointIds &&\n\t\t\texistingCoordinatePointIds.every((id) => this.store.has(id))\n\t\t) {\n\t\t\t// Check if the coordinates have changed\n\t\t\tconst existingCoordinates =\n\t\t\t\texistingFeatureProps.coordinatePointIds as FeatureId[];\n\t\t\tconst existingCoordinatePoints = existingCoordinates.map(\n\t\t\t\t(id) => this.store.getGeometryCopy(id).coordinates as Position,\n\t\t\t);\n\n\t\t\t// If the number of coordinates has changed, delete and recreate as it's too\n\t\t\t// complex to update the existing coordinates unless someone is feeling brave\n\t\t\tif (existingCoordinates.length !== coordinates.length) {\n\t\t\t\tthis.deleteCoordinatePoints(existingCoordinates);\n\t\t\t\tconst coordinatePointIds = this.createPoints(\n\t\t\t\t\tcoordinates,\n\t\t\t\t\texistingProperties.mode as string,\n\t\t\t\t\tfeatureId,\n\t\t\t\t);\n\t\t\t\tthis.setFeatureCoordinatePoints(featureId, coordinatePointIds);\n\t\t\t} else {\n\t\t\t\t// Update the coordinates\n\t\t\t\tcoordinates.forEach((coordinate, i) => {\n\t\t\t\t\t// If the coordinates are the same, don't update\n\t\t\t\t\tif (\n\t\t\t\t\t\tcoordinate[0] === existingCoordinatePoints[i][0] &&\n\t\t\t\t\t\tcoordinate[1] === existingCoordinatePoints[i][1]\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Only update the coordinates that have changed\n\t\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: existingCoordinates[i],\n\t\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\t\tcoordinates: coordinate,\n\t\t\t\t\t\t\t} as Point,\n\t\t\t\t\t\t},\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// If the existing coordinate points are not present in the store, delete them and recreate\n\t\telse {\n\t\t\t// If there are any leftover coordinate points we remove them\n\t\t\tconst existingPoints = existingCoordinatePointIds.filter((id) =>\n\t\t\t\tthis.store.has(id),\n\t\t\t);\n\t\t\tif (existingPoints.length) {\n\t\t\t\tthis.deleteCoordinatePoints(existingPoints);\n\t\t\t}\n\n\t\t\t// Create new coordinate points\n\t\t\tconst coordinatePointIds = this.createPoints(\n\t\t\t\tcoordinates,\n\t\t\t\texistingProperties.mode as string,\n\t\t\t\tfeatureId,\n\t\t\t);\n\t\t\tthis.setFeatureCoordinatePoints(featureId, coordinatePointIds);\n\t\t}\n\t}\n\n\tpublic deletePointsByFeatureIds(features: FeatureId[]) {\n\t\tfor (const featureId of features) {\n\t\t\tthis.deleteIfPresent(featureId);\n\t\t}\n\t}\n\n\tpublic getUpdated(featureId: FeatureId, updatedCoordinates: Position[]) {\n\t\tconst featureProperties = this.store.getPropertiesCopy(featureId);\n\n\t\tif (!featureProperties.coordinatePointIds) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn (featureProperties.coordinatePointIds as FeatureId[]).map(\n\t\t\t(id, i) => {\n\t\t\t\treturn {\n\t\t\t\t\tid,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t...this.store.getGeometryCopy(id),\n\t\t\t\t\t\tcoordinates: updatedCoordinates[i],\n\t\t\t\t\t} as Point,\n\t\t\t\t};\n\t\t\t},\n\t\t) as {\n\t\t\tid: FeatureId;\n\t\t\tgeometry: Point;\n\t\t}[];\n\t}\n\n\tprivate createPoints(\n\t\tcoordinates: Position[],\n\t\tmode: string,\n\t\tfeatureId: FeatureId,\n\t) {\n\t\treturn this.store.create(\n\t\t\tcoordinates.map((coordinate, i) => ({\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: coordinate,\n\t\t\t\t},\n\t\t\t\tproperties: {\n\t\t\t\t\tmode,\n\t\t\t\t\t[COMMON_PROPERTIES.COORDINATE_POINT]: true,\n\t\t\t\t\t[COMMON_PROPERTIES.COORDINATE_POINT_FEATURE_ID]: featureId,\n\t\t\t\t\tindex: i,\n\t\t\t\t},\n\t\t\t})),\n\t\t);\n\t}\n\n\tprivate setFeatureCoordinatePoints(\n\t\tfeatureId: FeatureId,\n\t\tvalue: FeatureId[] | null,\n\t) {\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: featureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.COORDINATE_POINT_IDS,\n\t\t\t\tvalue: value,\n\t\t\t},\n\t\t]);\n\t}\n\n\tprivate deleteCoordinatePoints(coordinatePointIds: FeatureId[]) {\n\t\t// We have to account for someone manually deleting the coordinate points or only partially restoring them\n\t\t// from some persistent storage. Essentially we cannot assume they are all present in the store.\n\t\tconst existingCoordinatePointIds = coordinatePointIds.filter((id) =>\n\t\t\tthis.store.has(id),\n\t\t) as FeatureId[];\n\t\tthis.store.delete(existingCoordinatePointIds);\n\t}\n\n\tprivate deleteIfPresent(featureId: FeatureId) {\n\t\tconst existingFeatureProps = this.store.getPropertiesCopy(featureId);\n\t\tconst coordinatePoints =\n\t\t\texistingFeatureProps.coordinatePointIds as FeatureId[];\n\n\t\tif (coordinatePoints) {\n\t\t\tthis.deleteCoordinatePoints(coordinatePoints);\n\t\t\tthis.setFeatureCoordinatePoints(featureId, null);\n\t\t}\n\t}\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tCOMMON_PROPERTIES,\n\tProject,\n\tUnproject,\n\tZ_INDEX,\n\tSnapping,\n} from \"../../common\";\nimport { Feature, Polygon, Position } from \"geojson\";\nimport {\n\tTerraDrawBaseDrawMode,\n\tBaseModeOptions,\n\tCustomStyling,\n\tPointerEvents,\n} from \"../base.mode\";\nimport { PixelDistanceBehavior } from \"../pixel-distance.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../click-bounding-box.behavior\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { createPolygon } from \"../../util/geoms\";\nimport { coordinatesIdentical } from \"../../geometry/coordinates-identical\";\nimport { ClosingPointsBehavior } from \"./behaviors/closing-points.behavior\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { ValidatePolygonFeature } from \"../../validations/polygon.validation\";\nimport { LineSnappingBehavior } from \"../line-snapping.behavior\";\nimport { CoordinateSnappingBehavior } from \"../coordinate-snapping.behavior\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\nimport { CoordinatePointBehavior } from \"../select/behaviors/coordinate-point.behavior\";\n\ntype TerraDrawPolygonModeKeyEvents = {\n\tcancel?: KeyboardEvent[\"key\"] | null;\n\tfinish?: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype PolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n\tclosingPointWidth: NumericStyling;\n\tclosingPointColor: HexColorStyling;\n\tclosingPointOutlineWidth: NumericStyling;\n\tclosingPointOutlineColor: HexColorStyling;\n\tsnappingPointWidth: NumericStyling;\n\tsnappingPointColor: HexColorStyling;\n\tsnappingPointOutlineWidth: NumericStyling;\n\tsnappingPointOutlineColor: HexColorStyling;\n\teditedPointWidth: NumericStyling;\n\teditedPointColor: HexColorStyling;\n\teditedPointOutlineWidth: NumericStyling;\n\teditedPointOutlineColor: HexColorStyling;\n\tcoordinatePointWidth: NumericStyling;\n\tcoordinatePointColor: HexColorStyling;\n\tcoordinatePointOutlineWidth: NumericStyling;\n\tcoordinatePointOutlineColor: HexColorStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n\tdragStart?: Cursor;\n\tdragEnd?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n\tdragStart: \"grabbing\",\n\tdragEnd: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawPolygonModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tsnapping?: Snapping;\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawPolygonModeKeyEvents | null;\n\tpointerEvents?: PointerEvents;\n\tcursors?: Cursors;\n\teditable?: boolean;\n\tshowCoordinatePoints?: boolean;\n}\n\nexport class TerraDrawPolygonMode extends TerraDrawBaseDrawMode<PolygonStyling> {\n\tmode = \"polygon\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawPolygonModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\tprivate showCoordinatePoints = false;\n\tprivate lastMouseMoveEvent: TerraDrawMouseEvent | undefined;\n\n\t// Snapping\n\tprivate snapping: Snapping | undefined;\n\tprivate snappedPointId: FeatureId | undefined;\n\n\t// Editable\n\tprivate editable: boolean = false;\n\tprivate editedFeatureId: FeatureId | undefined;\n\tprivate editedFeatureCoordinateIndex: number | undefined;\n\tprivate editedSnapType: \"line\" | \"coordinate\" | undefined;\n\tprivate editedInsertIndex: number | undefined;\n\tprivate editedPointId: FeatureId | undefined;\n\n\t// Behaviors\n\tprivate coordinatePoints!: CoordinatePointBehavior;\n\tprivate lineSnapping!: LineSnappingBehavior;\n\tprivate coordinateSnapping!: CoordinateSnappingBehavior;\n\tprivate pixelDistance!: PixelDistanceBehavior;\n\tprivate closingPoints!: ClosingPointsBehavior;\n\tprivate clickBoundingBox!: ClickBoundingBoxBehavior;\n\n\tconstructor(options?: TerraDrawPolygonModeOptions<PolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawPolygonModeOptions<PolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\t// null is the case where we want to explicitly turn key bindings off\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.snapping) {\n\t\t\tthis.snapping = options.snapping;\n\t\t}\n\n\t\tif (options?.editable !== undefined) {\n\t\t\tthis.editable = options.editable;\n\t\t}\n\n\t\tif (options?.pointerEvents !== undefined) {\n\t\t\tthis.pointerEvents = options.pointerEvents;\n\t\t}\n\n\t\tif (options?.showCoordinatePoints !== undefined) {\n\t\t\tthis.showCoordinatePoints = options.showCoordinatePoints;\n\n\t\t\t// If we are not showing coordinate points, we need to add them all\n\t\t\tif (this.coordinatePoints && options.showCoordinatePoints === true) {\n\t\t\t\tconst features = this.store.copyAllWhere(\n\t\t\t\t\t(properties) => properties.mode === this.mode,\n\t\t\t\t);\n\t\t\t\tconst polygonIds = features.map((feature) => feature.id as FeatureId);\n\t\t\t\tpolygonIds.forEach((id) => {\n\t\t\t\t\tthis.coordinatePoints.createOrUpdate(id);\n\t\t\t\t});\n\t\t\t} else if (this.coordinatePoints && this.showCoordinatePoints === false) {\n\t\t\t\tconst featuresWithCoordinates = this.store.copyAllWhere(\n\t\t\t\t\t(properties) =>\n\t\t\t\t\t\tproperties.mode === this.mode &&\n\t\t\t\t\t\tBoolean(\n\t\t\t\t\t\t\tproperties[COMMON_PROPERTIES.COORDINATE_POINT_IDS] as FeatureId[],\n\t\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\t\tthis.coordinatePoints.deletePointsByFeatureIds(\n\t\t\t\t\tfeaturesWithCoordinates.map((f) => f.id as FeatureId),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t).coordinates[0];\n\n\t\t// We don't want to allow closing if there is not enough\n\t\t// coordinates. We have extra because we insert them on mouse\n\t\t// move\n\t\tif (currentPolygonCoordinates.length < 5) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t[...currentPolygonCoordinates.slice(0, -2), currentPolygonCoordinates[0]],\n\t\t\tUpdateTypes.Finish,\n\t\t);\n\n\t\tif (!updated) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst finishedId = this.currentId;\n\n\t\t// Fix right hand rule if necessary\n\t\tif (this.currentId) {\n\t\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId),\n\t\t\t);\n\n\t\t\tif (correctedGeometry) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{ id: this.currentId, geometry: correctedGeometry },\n\t\t\t\t]);\n\n\t\t\t\t// Create or update coordinate points to reflect the new geometry\n\t\t\t\tif (this.showCoordinatePoints) {\n\t\t\t\t\tthis.coordinatePoints.createOrUpdate(this.currentId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.PROVISIONAL_COORDINATE_COUNT,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t}\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentId = undefined;\n\t\tthis.snappedPointId = undefined;\n\t\tthis.closingPoints.delete();\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tregisterBehaviors(config: BehaviorConfig) {\n\t\tthis.clickBoundingBox = new ClickBoundingBoxBehavior(config);\n\t\tthis.pixelDistance = new PixelDistanceBehavior(config);\n\t\tthis.lineSnapping = new LineSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.coordinateSnapping = new CoordinateSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.closingPoints = new ClosingPointsBehavior(config, this.pixelDistance);\n\n\t\tthis.coordinatePoints = new CoordinatePointBehavior(config);\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\tprivate updateSnappedCoordinate(event: TerraDrawMouseEvent) {\n\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\tif (snappedCoordinate) {\n\t\t\tif (this.snappedPointId) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{\n\t\t\t\t\t\tid: this.snappedPointId,\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tconst [snappedPointId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.SNAPPING_POINT]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\tthis.snappedPointId = snappedPointId;\n\t\t\t}\n\n\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\tevent.lat = snappedCoordinate[1];\n\t\t} else if (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\n\t\tthis.lastMouseMoveEvent = event;\n\t\tthis.updateSnappedCoordinate(event);\n\n\t\tif (this.currentId === undefined || this.currentCoordinate === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t).coordinates[0];\n\n\t\tlet updatedCoordinates;\n\n\t\tif (this.currentCoordinate === 1) {\n\t\t\t// We must add a very small epsilon value so that Mapbox GL\n\t\t\t// renders the polygon - There might be a cleaner solution?\n\t\t\tconst epsilon = 1 / Math.pow(10, this.coordinatePrecision - 1);\n\t\t\tconst offset = Math.max(0.000001, epsilon);\n\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\t[event.lng, event.lat - offset],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t} else if (this.currentCoordinate === 2) {\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\tcurrentPolygonCoordinates[1],\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t} else {\n\t\t\tconst { isClosing, isPreviousClosing } =\n\t\t\t\tthis.closingPoints.isClosingPoint(event);\n\n\t\t\tif (isPreviousClosing || isClosing) {\n\t\t\t\tif (this.snappedPointId) {\n\t\t\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\t\t\tthis.snappedPointId = undefined;\n\t\t\t\t}\n\n\t\t\t\tthis.setCursor(this.cursors.close);\n\n\t\t\t\tupdatedCoordinates = [\n\t\t\t\t\t...currentPolygonCoordinates.slice(0, -2),\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tupdatedCoordinates = [\n\t\t\t\t\t...currentPolygonCoordinates.slice(0, -2),\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tproperty: COMMON_PROPERTIES.PROVISIONAL_COORDINATE_COUNT,\n\t\t\t\tvalue: this.currentCoordinate + 1,\n\t\t\t},\n\t\t]);\n\n\t\tthis.updatePolygonGeometry(updatedCoordinates, UpdateTypes.Provisional);\n\t}\n\n\tprivate updatePolygonGeometry(\n\t\tcoordinates: Polygon[\"coordinates\"][0],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tif (!this.currentId) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [coordinates],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{ id: this.currentId, geometry: updatedGeometry },\n\t\t]);\n\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(this.currentId);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate snapCoordinate(event: TerraDrawMouseEvent): undefined | Position {\n\t\tlet snappedCoordinate: Position | undefined = undefined;\n\n\t\tif (this.snapping?.toLine) {\n\t\t\tlet snapped: Position | undefined;\n\t\t\tif (this.currentId) {\n\t\t\t\tsnapped = this.lineSnapping.getSnappableCoordinate(\n\t\t\t\t\tevent,\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tsnapped = this.lineSnapping.getSnappableCoordinateFirstClick(event);\n\t\t\t}\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping?.toCoordinate) {\n\t\t\tlet snapped: Position | undefined = undefined;\n\t\t\tif (this.currentId) {\n\t\t\t\tsnapped = this.coordinateSnapping.getSnappableCoordinate(\n\t\t\t\t\tevent,\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tsnapped =\n\t\t\t\t\tthis.coordinateSnapping.getSnappableCoordinateFirstClick(event);\n\t\t\t}\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping?.toCustom) {\n\t\t\tsnappedCoordinate = this.snapping.toCustom(event, {\n\t\t\t\tcurrentCoordinate: this.currentCoordinate,\n\t\t\t\tcurrentId: this.currentId,\n\t\t\t\tgetCurrentGeometrySnapshot: this.currentId\n\t\t\t\t\t? () =>\n\t\t\t\t\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId as FeatureId)\n\t\t\t\t\t: () => null,\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t});\n\t\t}\n\n\t\treturn snappedCoordinate;\n\t}\n\n\tprivate polygonFilter(feature: Feature) {\n\t\treturn Boolean(\n\t\t\tfeature.geometry.type === \"Polygon\" &&\n\t\t\t\tfeature.properties &&\n\t\t\t\tfeature.properties.mode === this.mode,\n\t\t);\n\t}\n\n\tprivate onRightClick(event: TerraDrawMouseEvent) {\n\t\t// Right click is only relevant when editable is true\n\t\tif (!this.editable || this.state !== \"started\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { featureId, featureCoordinateIndex: coordinateIndex } =\n\t\t\tthis.coordinateSnapping.getSnappable(event, (feature) =>\n\t\t\t\tthis.polygonFilter(feature),\n\t\t\t);\n\n\t\tif (!featureId || coordinateIndex === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(featureId);\n\n\t\tlet coordinates;\n\t\tif (geometry.type === \"Polygon\") {\n\t\t\tcoordinates = geometry.coordinates[0];\n\n\t\t\t// Prevent creating an invalid polygon\n\t\t\tif (coordinates.length <= 4) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isFinalPolygonCoordinate =\n\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t(coordinateIndex === 0 || coordinateIndex === coordinates.length - 1);\n\n\t\tif (isFinalPolygonCoordinate) {\n\t\t\t// Deleting the final coordinate in a polygon breaks it\n\t\t\t// because GeoJSON expects a duplicate, so we need to fix\n\t\t\t// it by adding the new first coordinate to the end\n\t\t\tcoordinates.shift();\n\t\t\tcoordinates.pop();\n\t\t\tcoordinates.push([coordinates[0][0], coordinates[0][1]]);\n\t\t} else {\n\t\t\t// Remove coordinate from array\n\t\t\tcoordinates.splice(coordinateIndex, 1);\n\t\t}\n\n\t\t// Validate the new geometry\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\tid: featureId,\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Commit,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// The geometry has changed, so if we were snapped to a point we need to remove it\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: featureId,\n\t\t\t\tgeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(featureId);\n\t\t}\n\n\t\tthis.onFinish(featureId, { mode: this.mode, action: \"edit\" });\n\t}\n\n\tprivate onLeftClick(event: TerraDrawMouseEvent) {\n\t\t// Reset the snapping point\n\t\tif (this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tif (this.currentCoordinate === 0) {\n\t\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\t\tif (snappedCoordinate) {\n\t\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\t\tevent.lat = snappedCoordinate[1];\n\t\t\t}\n\n\t\t\tconst [newId] = this.store.create([\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t[COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT]:\n\t\t\t\t\t\t\tthis.currentCoordinate + 1,\n\t\t\t\t\t\t[COMMON_PROPERTIES.PROVISIONAL_COORDINATE_COUNT]:\n\t\t\t\t\t\t\tthis.currentCoordinate + 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\t\t\tthis.currentId = newId;\n\t\t\tthis.currentCoordinate++;\n\n\t\t\tif (this.showCoordinatePoints) {\n\t\t\t\tthis.coordinatePoints.createOrUpdate(newId);\n\t\t\t}\n\n\t\t\t// Ensure the state is updated to reflect drawing has started\n\t\t\tthis.setDrawing();\n\t\t} else if (this.currentCoordinate === 1 && this.currentId) {\n\t\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\t\tif (snappedCoordinate) {\n\t\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\t\tevent.lat = snappedCoordinate[1];\n\t\t\t}\n\n\t\t\tconst currentPolygonGeometry = this.store.getGeometryCopy<Polygon>(\n\t\t\t\tthis.currentId,\n\t\t\t);\n\n\t\t\tconst previousCoordinate = currentPolygonGeometry.coordinates[0][0];\n\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\tpreviousCoordinate,\n\t\t\t);\n\n\t\t\tif (isIdentical) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t[\n\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t],\n\t\t\t\tUpdateTypes.Commit,\n\t\t\t);\n\n\t\t\tif (!updated) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT,\n\t\t\t\t\tvalue: this.currentCoordinate + 1,\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.currentCoordinate++;\n\t\t} else if (this.currentCoordinate === 2 && this.currentId) {\n\t\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\t\tif (snappedCoordinate) {\n\t\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\t\tevent.lat = snappedCoordinate[1];\n\t\t\t}\n\n\t\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\t\tthis.currentId,\n\t\t\t).coordinates[0];\n\n\t\t\tconst previousCoordinate = currentPolygonCoordinates[1];\n\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\tpreviousCoordinate,\n\t\t\t);\n\n\t\t\tif (isIdentical) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t[\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t\tcurrentPolygonCoordinates[1],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t],\n\t\t\t\tUpdateTypes.Commit,\n\t\t\t);\n\n\t\t\tif (!updated) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.currentCoordinate === 2) {\n\t\t\t\tthis.closingPoints.create(currentPolygonCoordinates, \"polygon\");\n\t\t\t}\n\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT,\n\t\t\t\t\tvalue: this.currentCoordinate + 1,\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.currentCoordinate++;\n\t\t} else if (this.currentId) {\n\t\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\t\tthis.currentId,\n\t\t\t).coordinates[0];\n\n\t\t\tconst { isClosing, isPreviousClosing } =\n\t\t\t\tthis.closingPoints.isClosingPoint(event);\n\n\t\t\tif (isPreviousClosing || isClosing) {\n\t\t\t\tthis.close();\n\t\t\t} else {\n\t\t\t\tconst snappedCoordinate = this.snapCoordinate(event);\n\n\t\t\t\tif (snappedCoordinate) {\n\t\t\t\t\tevent.lng = snappedCoordinate[0];\n\t\t\t\t\tevent.lat = snappedCoordinate[1];\n\t\t\t\t}\n\n\t\t\t\tconst previousCoordinate =\n\t\t\t\t\tcurrentPolygonCoordinates[this.currentCoordinate - 1];\n\t\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tpreviousCoordinate,\n\t\t\t\t);\n\n\t\t\t\tif (isIdentical) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst updatedPolygon = createPolygon([\n\t\t\t\t\t[\n\t\t\t\t\t\t...currentPolygonCoordinates.slice(0, -1),\n\t\t\t\t\t\t[event.lng, event.lat], // New point that onMouseMove can manipulate\n\t\t\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t\t],\n\t\t\t\t]);\n\n\t\t\t\t// If not close to the final point, keep adding points\n\t\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t\tupdatedPolygon.geometry.coordinates[0],\n\t\t\t\t\tUpdateTypes.Commit,\n\t\t\t\t);\n\t\t\t\tif (!updated) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.store.updateProperty([\n\t\t\t\t\t{\n\t\t\t\t\t\tid: this.currentId,\n\t\t\t\t\t\tproperty: COMMON_PROPERTIES.COMMITTED_COORDINATE_COUNT,\n\t\t\t\t\t\tvalue: this.currentCoordinate + 1,\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentCoordinate++;\n\n\t\t\t\t// Update closing points straight away\n\t\t\t\tif (this.closingPoints.ids.length) {\n\t\t\t\t\tthis.closingPoints.update(updatedPolygon.geometry.coordinates[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\t// We want pointer devices (mobile/tablet) to have\n\t\t// similar behaviour to mouse based devices so we\n\t\t// trigger a mousemove event before every click\n\t\t// if one has not been trigged to emulate this\n\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\tthis.onMouseMove(event);\n\t\t}\n\t\tthis.mouseMove = false;\n\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tthis.onRightClick(event);\n\t\t\treturn;\n\t\t} else if (\n\t\t\tevent.button === \"left\" &&\n\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)\n\t\t) {\n\t\t\tthis.onLeftClick(event);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragStart, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.editable) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet snappedCoordinate: Position | undefined = undefined;\n\n\t\tif (this.state === \"started\") {\n\t\t\t// Here we reuse the snapping logic to find the feature and coordinate\n\t\t\t// that we want to edit. We can drag a arbitrary polygon coordinate point\n\t\t\t// or an arbitrary point on one of its 'lines\n\n\t\t\tconst lineSnapped = this.lineSnapping.getSnappable(event, (feature) =>\n\t\t\t\tthis.polygonFilter(feature),\n\t\t\t);\n\n\t\t\tif (lineSnapped.coordinate) {\n\t\t\t\tthis.editedSnapType = \"line\";\n\t\t\t\tthis.editedFeatureCoordinateIndex = lineSnapped.featureCoordinateIndex;\n\t\t\t\tthis.editedFeatureId = lineSnapped.featureId;\n\t\t\t\tsnappedCoordinate = lineSnapped.coordinate;\n\t\t\t}\n\n\t\t\tconst coordinateSnapped = this.coordinateSnapping.getSnappable(\n\t\t\t\tevent,\n\t\t\t\t(feature) => this.polygonFilter(feature),\n\t\t\t);\n\n\t\t\tif (coordinateSnapped.coordinate) {\n\t\t\t\tthis.editedSnapType = \"coordinate\";\n\t\t\t\tthis.editedFeatureCoordinateIndex =\n\t\t\t\t\tcoordinateSnapped.featureCoordinateIndex;\n\t\t\t\tthis.editedFeatureId = coordinateSnapped.featureId;\n\t\t\t\tsnappedCoordinate = coordinateSnapped.coordinate;\n\t\t\t}\n\t\t}\n\n\t\t// We only need to stop the map dragging if\n\t\t// we actually have something selected\n\t\tif (!this.editedFeatureId || !snappedCoordinate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create a point to drag when editing\n\t\tif (!this.editedPointId) {\n\t\t\tconst [editedPointId] = this.store.create([\n\t\t\t\t{\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: snappedCoordinate,\n\t\t\t\t\t},\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t[COMMON_PROPERTIES.EDITED]: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.editedPointId = editedPointId;\n\t\t}\n\n\t\t// Drag Feature\n\t\tthis.setCursor(this.cursors.dragStart);\n\n\t\tsetMapDraggability(false);\n\t}\n\n\t/** @internal */\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDrag, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tthis.editedFeatureId === undefined ||\n\t\t\tthis.editedFeatureCoordinateIndex === undefined\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst featureCopy: Polygon = this.store.getGeometryCopy(\n\t\t\tthis.editedFeatureId,\n\t\t);\n\t\tconst featureCoordinates = featureCopy.coordinates[0];\n\n\t\t// Either it's a coordinate drag or a line drag where the line coordinate has already been inserted\n\t\tif (\n\t\t\tthis.editedSnapType === \"coordinate\" ||\n\t\t\t(this.editedSnapType === \"line\" && this.editedInsertIndex !== undefined)\n\t\t) {\n\t\t\t// Account for the first and last point being the same\n\t\t\tconst isStartingOrEndingCoordinate =\n\t\t\t\tthis.editedFeatureCoordinateIndex === 0 ||\n\t\t\t\tthis.editedFeatureCoordinateIndex ===\n\t\t\t\t\tfeatureCopy.coordinates[0].length - 1;\n\n\t\t\tif (isStartingOrEndingCoordinate) {\n\t\t\t\tfeatureCoordinates[0] = [event.lng, event.lat];\n\t\t\t\tfeatureCoordinates[featureCoordinates.length - 1] = [\n\t\t\t\t\tevent.lng,\n\t\t\t\t\tevent.lat,\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tfeatureCoordinates[this.editedFeatureCoordinateIndex] = [\n\t\t\t\t\tevent.lng,\n\t\t\t\t\tevent.lat,\n\t\t\t\t];\n\t\t\t}\n\t\t} else if (\n\t\t\tthis.editedSnapType === \"line\" &&\n\t\t\tthis.editedInsertIndex === undefined\n\t\t) {\n\t\t\t// Splice inserts _before_ the index, so we need to add 1\n\t\t\tthis.editedInsertIndex = this.editedFeatureCoordinateIndex + 1;\n\n\t\t\t// Insert the new dragged snapped line coordinate\n\t\t\tfeatureCopy.coordinates[0].splice(this.editedInsertIndex, 0, [\n\t\t\t\tevent.lng,\n\t\t\t\tevent.lat,\n\t\t\t]);\n\n\t\t\t// We have inserted a point, need to change the edit index\n\t\t\t// so it can be moved correctly when it gets dragged again\n\t\t\tthis.editedFeatureCoordinateIndex++;\n\t\t}\n\n\t\tconst newPolygonGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: featureCopy.coordinates,\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: newPolygonGeometry,\n\t\t\t\t\tproperties: this.store.getPropertiesCopy(this.editedFeatureId),\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.snapping && this.snappedPointId) {\n\t\t\tthis.store.delete([this.snappedPointId]);\n\t\t\tthis.snappedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tgeometry: newPolygonGeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(this.editedFeatureId);\n\t\t}\n\n\t\tif (this.editedPointId) {\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.editedPointId,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t]);\n\t}\n\n\t/** @internal */\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragEnd, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editedFeatureId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setCursor(this.cursors.dragEnd);\n\n\t\tif (this.editedPointId) {\n\t\t\tthis.store.delete([this.editedPointId]);\n\t\t\tthis.editedPointId = undefined;\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.editedFeatureId,\n\t\t\t\tproperty: COMMON_PROPERTIES.EDITED,\n\t\t\t\tvalue: false,\n\t\t\t},\n\t\t]);\n\n\t\tthis.onFinish(this.editedFeatureId, { mode: this.mode, action: \"edit\" });\n\n\t\t// Reset edit state\n\t\tthis.editedFeatureId = undefined;\n\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\tthis.editedInsertIndex = undefined;\n\t\tthis.editedSnapType = undefined;\n\n\t\tsetMapDraggability(true);\n\t}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentId;\n\t\tconst snappedPointId = this.snappedPointId;\n\t\tconst editedPointId = this.editedPointId;\n\n\t\tthis.currentId = undefined;\n\t\tthis.snappedPointId = undefined;\n\t\tthis.editedPointId = undefined;\n\t\tthis.editedFeatureId = undefined;\n\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\tthis.editedInsertIndex = undefined;\n\t\tthis.editedSnapType = undefined;\n\t\tthis.currentCoordinate = 0;\n\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId) {\n\t\t\t\tthis.coordinatePoints.deletePointsByFeatureIds([cleanUpId]);\n\t\t\t}\n\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t\tif (editedPointId !== undefined) {\n\t\t\t\tthis.store.delete([editedPointId]);\n\t\t\t}\n\t\t\tif (snappedPointId !== undefined) {\n\t\t\t\tthis.store.delete([snappedPointId]);\n\t\t\t}\n\t\t\tif (this.closingPoints.ids.length) {\n\t\t\t\tthis.closingPoints.delete();\n\t\t\t}\n\t\t} catch (error) {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (feature.properties.mode === this.mode) {\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.fillColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t\treturn styles;\n\t\t\t} else if (feature.geometry.type === \"Point\") {\n\t\t\t\tconst editedPoint = feature.properties[COMMON_PROPERTIES.EDITED];\n\t\t\t\tconst closingPoint =\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.CLOSING_POINT];\n\t\t\t\tconst snappingPoint =\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.SNAPPING_POINT];\n\t\t\t\tconst coordinatePoint =\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.COORDINATE_POINT];\n\n\t\t\t\tconst pointType = editedPoint\n\t\t\t\t\t? \"editedPoint\"\n\t\t\t\t\t: closingPoint\n\t\t\t\t\t\t? \"closingPoint\"\n\t\t\t\t\t\t: snappingPoint\n\t\t\t\t\t\t\t? \"snappingPoint\"\n\t\t\t\t\t\t\t: coordinatePoint\n\t\t\t\t\t\t\t\t? \"coordinatePoint\"\n\t\t\t\t\t\t\t\t: undefined;\n\n\t\t\t\tif (!pointType) {\n\t\t\t\t\treturn styles;\n\t\t\t\t}\n\n\t\t\t\tconst styleMap = {\n\t\t\t\t\teditedPoint: {\n\t\t\t\t\t\twidth: this.styles.editedPointOutlineWidth,\n\t\t\t\t\t\tcolor: this.styles.editedPointColor,\n\t\t\t\t\t\toutlineColor: this.styles.editedPointOutlineColor,\n\t\t\t\t\t\toutlineWidth: this.styles.editedPointOutlineWidth,\n\t\t\t\t\t},\n\t\t\t\t\tclosingPoint: {\n\t\t\t\t\t\twidth: this.styles.closingPointWidth,\n\t\t\t\t\t\tcolor: this.styles.closingPointColor,\n\t\t\t\t\t\toutlineColor: this.styles.closingPointOutlineColor,\n\t\t\t\t\t\toutlineWidth: this.styles.closingPointOutlineWidth,\n\t\t\t\t\t},\n\t\t\t\t\tsnappingPoint: {\n\t\t\t\t\t\twidth: this.styles.snappingPointWidth,\n\t\t\t\t\t\tcolor: this.styles.snappingPointColor,\n\t\t\t\t\t\toutlineColor: this.styles.snappingPointOutlineColor,\n\t\t\t\t\t\toutlineWidth: this.styles.snappingPointOutlineWidth,\n\t\t\t\t\t},\n\t\t\t\t\tcoordinatePoint: {\n\t\t\t\t\t\twidth: this.styles.coordinatePointWidth,\n\t\t\t\t\t\tcolor: this.styles.coordinatePointColor,\n\t\t\t\t\t\toutlineColor: this.styles.coordinatePointOutlineColor,\n\t\t\t\t\t\toutlineWidth: this.styles.coordinatePointOutlineWidth,\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tstyleMap[pointType].width,\n\t\t\t\t\tstyles.pointWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tstyleMap[pointType].color,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tstyleMap[pointType].outlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tstyleMap[pointType].outlineWidth,\n\t\t\t\t\t2,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tif (editedPoint) {\n\t\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_FOUR;\n\t\t\t\t} else if (coordinatePoint) {\n\t\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_TWO;\n\t\t\t\t} else {\n\t\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_THREE;\n\t\t\t\t}\n\n\t\t\t\treturn styles;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tafterFeatureAdded(feature: GeoJSONStoreFeatures) {\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(feature.id as FeatureId);\n\t\t}\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// Clean up here is important to get right as we need to make a best effort to avoid erroneous\n\t\t// internal state.\n\n\t\t// IF we have coordinate points showing these need to be completely recreated\n\t\tif (this.showCoordinatePoints) {\n\t\t\tthis.coordinatePoints.createOrUpdate(feature.id as FeatureId);\n\t\t}\n\n\t\t// If we are editing a feature by dragging one of its points\n\t\t// we want to clear that state up as new polygon might be completely\n\t\t// different in terms of it's coordinates\n\t\tif (this.editedFeatureId === feature.id && this.editedPointId) {\n\t\t\tthis.store.delete([this.editedPointId]);\n\t\t\tthis.editedPointId = undefined;\n\t\t\tthis.editedFeatureId = undefined;\n\t\t\tthis.editedFeatureCoordinateIndex = undefined;\n\t\t\tthis.editedSnapType = undefined;\n\t\t}\n\n\t\t// We can recalculate the snapped point from the last mouse event if there was one\n\t\tif (this.snappedPointId && this.lastMouseMoveEvent) {\n\t\t\tthis.updateSnappedCoordinate(\n\t\t\t\tthis.lastMouseMoveEvent as TerraDrawMouseEvent,\n\t\t\t);\n\t\t}\n\n\t\t// NOTE: This handles the case we are currently drawing a polygon\n\t\t// We need to reset the drawing state because it is very complicated (impossible?)\n\t\t// to recover the drawing state after a feature update\n\t\tif (this.currentId === feature.id) {\n\t\t\tthis.currentCoordinate = 0;\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.closingPoints.delete();\n\n\t\t\t// Go back to started state\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidatePolygonFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n}\n","import { Feature, LineString, Polygon, Position } from \"geojson\";\n\nexport function createPolygon(\n\tcoordinates: Position[][] = [\n\t\t[\n\t\t\t[0, 0],\n\t\t\t[0, 1],\n\t\t\t[1, 1],\n\t\t\t[1, 0],\n\t\t\t[0, 0],\n\t\t],\n\t],\n): Feature<Polygon> {\n\treturn {\n\t\ttype: \"Feature\",\n\t\tgeometry: {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates,\n\t\t},\n\t\tproperties: {},\n\t};\n}\n\nexport function createLineString(coordinates: Position[]): Feature<LineString> {\n\treturn {\n\t\ttype: \"Feature\",\n\t\tgeometry: {\n\t\t\ttype: \"LineString\",\n\t\t\tcoordinates,\n\t\t},\n\t\tproperties: {},\n\t};\n}\n","import { Polygon, Position } from \"geojson\";\nimport {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\n\ntype TerraDrawRectangleModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype RectanglePolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawRectangleModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tkeyEvents?: TerraDrawRectangleModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawRectangleMode extends TerraDrawBaseDrawMode<RectanglePolygonStyling> {\n\tmode = \"rectangle\" as const;\n\tprivate center: Position | undefined;\n\tprivate clickCount = 0;\n\tprivate currentRectangleId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawRectangleModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\n\tconstructor(\n\t\toptions?: TerraDrawRectangleModeOptions<RectanglePolygonStyling>,\n\t) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawRectangleModeOptions<RectanglePolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\t}\n\n\tprivate updateRectangle(event: TerraDrawMouseEvent, updateType: UpdateTypes) {\n\t\tif (this.clickCount === 1 && this.center && this.currentRectangleId) {\n\t\t\tconst geometry = this.store.getGeometryCopy(this.currentRectangleId);\n\n\t\t\tconst firstCoord = (geometry.coordinates as Position[][])[0][0];\n\n\t\t\tconst newGeometry = {\n\t\t\t\ttype: \"Polygon\",\n\t\t\t\tcoordinates: [\n\t\t\t\t\t[\n\t\t\t\t\t\tfirstCoord,\n\t\t\t\t\t\t[event.lng, firstCoord[1]],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t[firstCoord[0], event.lat],\n\t\t\t\t\t\tfirstCoord,\n\t\t\t\t\t],\n\t\t\t\t],\n\t\t\t} as Polygon;\n\n\t\t\tif (this.validate) {\n\t\t\t\tconst validationResult = this.validate(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: this.currentRectangleId,\n\t\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t\t{\n\t\t\t\t\t\tproject: this.project,\n\t\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\t\tupdateType,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!validationResult.valid) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentRectangleId,\n\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tconst finishedId = this.currentRectangleId;\n\n\t\t// Fix right hand rule if necessary\n\t\tif (finishedId) {\n\t\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\t\tthis.store.getGeometryCopy<Polygon>(finishedId),\n\t\t\t);\n\t\t\tif (correctedGeometry) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{ id: finishedId, geometry: correctedGeometry },\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: finishedId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tthis.center = undefined;\n\t\tthis.currentRectangleId = undefined;\n\t\tthis.clickCount = 0;\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tif (finishedId !== undefined) {\n\t\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t\t}\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tif (this.clickCount === 0) {\n\t\t\t\tthis.center = [event.lng, event.lat];\n\t\t\t\tconst [createdId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentRectangleId = createdId;\n\t\t\t\tthis.clickCount++;\n\t\t\t\tthis.setDrawing();\n\t\t\t} else {\n\t\t\t\tthis.updateRectangle(event, UpdateTypes.Finish);\n\t\t\t\t// Finish drawing\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.updateRectangle(event, UpdateTypes.Provisional);\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentRectangleId;\n\n\t\tthis.center = undefined;\n\t\tthis.currentRectangleId = undefined;\n\t\tthis.clickCount = 0;\n\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tif (cleanUpId !== undefined) {\n\t\t\tthis.store.delete([cleanUpId]);\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Polygon\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.fillColor,\n\t\t\t\tstyles.polygonFillColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.outlineColor,\n\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a rectangle and the feature being updated is the current rectangle,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentRectangleId === feature.id) {\n\t\t\tthis.center = undefined;\n\t\t\tthis.currentRectangleId = undefined;\n\t\t\tthis.clickCount = 0;\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {\n\tHexColorStyling,\n\tNumericStyling,\n\tTerraDrawAdapterStyling,\n} from \"../../common\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tModeTypes,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport { GeoJSONStoreFeatures } from \"../../terra-draw\";\nimport { ValidatePointFeature } from \"../../validations/point.validation\";\nimport { ValidatePolygonFeature } from \"../../validations/polygon.validation\";\nimport { ValidateLineStringFeature } from \"../../validations/linestring.validation\";\nimport { StoreValidation } from \"../../store/store\";\n\ntype RenderModeStyling = {\n\tpointColor: HexColorStyling;\n\tpointWidth: NumericStyling;\n\tpointOutlineColor: HexColorStyling;\n\tpointOutlineWidth: NumericStyling;\n\tpolygonFillColor: HexColorStyling;\n\tpolygonFillOpacity: NumericStyling;\n\tpolygonOutlineColor: HexColorStyling;\n\tpolygonOutlineWidth: NumericStyling;\n\tlineStringWidth: NumericStyling;\n\tlineStringColor: HexColorStyling;\n\tzIndex: NumericStyling;\n};\n\ninterface TerraDrawRenderModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tmodeName?: string;\n\t// styles need to be there else we could fall back to BaseModeOptions\n\tstyles: Partial<T>;\n}\n\nexport class TerraDrawRenderMode extends TerraDrawBaseDrawMode<RenderModeStyling> {\n\tpublic type = ModeTypes.Render; // The type of the mode\n\tpublic mode = \"render\"; // This gets changed dynamically\n\n\tconstructor(options: TerraDrawRenderModeOptions<RenderModeStyling>) {\n\t\tif (!options.modeName) {\n\t\t\tthrow new Error(\"Mode name is required for TerraDrawRenderMode\");\n\t\t}\n\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tupdateOptions(\n\t\toptions?: TerraDrawRenderModeOptions<RenderModeStyling> | undefined,\n\t): void {\n\t\tsuper.updateOptions(options);\n\t\tif (options?.modeName) {\n\t\t\tthis.mode = options.modeName;\n\t\t}\n\t}\n\n\t/** @internal */\n\tregisterBehaviors(behaviorConfig: BehaviorConfig) {\n\t\t// TODO: this is probably abusing\n\t\t// registerBehaviors but it works quite well conceptually\n\n\t\t// We can set the mode name dynamically\n\t\tthis.mode = behaviorConfig.mode;\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.setStopped();\n\t}\n\n\t/** @internal */\n\tonKeyUp() {}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonClick() {}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tonMouseMove() {}\n\n\t/** @internal */\n\tcleanUp() {}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst defaultStyles = getDefaultStyling();\n\n\t\treturn {\n\t\t\tpointColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.pointColor,\n\t\t\t\tdefaultStyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpointWidth: this.getNumericStylingValue(\n\t\t\t\tthis.styles.pointWidth,\n\t\t\t\tdefaultStyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpointOutlineColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.pointOutlineColor,\n\t\t\t\tdefaultStyles.pointOutlineColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpointOutlineWidth: this.getNumericStylingValue(\n\t\t\t\tthis.styles.pointOutlineWidth,\n\t\t\t\tdefaultStyles.pointOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpolygonFillColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.polygonFillColor,\n\t\t\t\tdefaultStyles.polygonFillColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpolygonFillOpacity: this.getNumericStylingValue(\n\t\t\t\tthis.styles.polygonFillOpacity,\n\t\t\t\tdefaultStyles.polygonFillOpacity,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpolygonOutlineColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.polygonOutlineColor,\n\t\t\t\tdefaultStyles.polygonOutlineColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tpolygonOutlineWidth: this.getNumericStylingValue(\n\t\t\t\tthis.styles.polygonOutlineWidth,\n\t\t\t\tdefaultStyles.polygonOutlineWidth,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tlineStringWidth: this.getNumericStylingValue(\n\t\t\t\tthis.styles.lineStringWidth,\n\t\t\t\tdefaultStyles.lineStringWidth,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tlineStringColor: this.getHexColorStylingValue(\n\t\t\t\tthis.styles.lineStringColor,\n\t\t\t\tdefaultStyles.lineStringColor,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t\tzIndex: this.getNumericStylingValue(\n\t\t\t\tthis.styles.zIndex,\n\t\t\t\tdefaultStyles.zIndex,\n\t\t\t\tfeature,\n\t\t\t),\n\t\t};\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\tconst validationResult = super.validateFeature(feature);\n\t\tif (validationResult.valid) {\n\t\t\tconst validatedFeature = feature as GeoJSONStoreFeatures;\n\n\t\t\tconst featureIsValid =\n\t\t\t\tValidatePointFeature(validatedFeature, this.coordinatePrecision)\n\t\t\t\t\t.valid ||\n\t\t\t\tValidatePolygonFeature(validatedFeature, this.coordinatePrecision)\n\t\t\t\t\t.valid ||\n\t\t\t\tValidateLineStringFeature(validatedFeature, this.coordinatePrecision)\n\t\t\t\t\t.valid;\n\n\t\t\tif (featureIsValid) {\n\t\t\t\treturn { valid: true };\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tvalid: featureIsValid,\n\t\t\t\treason: \"Feature is not a valid Point, Polygon or LineString feature\",\n\t\t\t};\n\t\t}\n\n\t\treturn validationResult;\n\t}\n}\n","import { Position } from \"geojson\";\nimport { degreesToRadians, radiansToDegrees } from \"../helpers\";\n\n// Based on Turf.js Rhumb Bearing module which is MIT Licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-rhumb-bearing/index.ts\n\nexport function rhumbBearing(start: Position, end: Position): number {\n\tconst from = start;\n\tconst to = end;\n\n\t// φ => phi\n\t// Δλ => deltaLambda\n\t// Δψ => deltaPsi\n\t// θ => theta\n\tconst phi1 = degreesToRadians(from[1]);\n\tconst phi2 = degreesToRadians(to[1]);\n\tlet deltaLambda = degreesToRadians(to[0] - from[0]);\n\n\t// if deltaLambdaon over 180° take shorter rhumb line across the anti-meridian:\n\tif (deltaLambda > Math.PI) {\n\t\tdeltaLambda -= 2 * Math.PI;\n\t}\n\tif (deltaLambda < -Math.PI) {\n\t\tdeltaLambda += 2 * Math.PI;\n\t}\n\n\tconst deltaPsi = Math.log(\n\t\tMath.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4),\n\t);\n\n\tconst theta = Math.atan2(deltaLambda, deltaPsi);\n\n\tconst bear360 = (radiansToDegrees(theta) + 360) % 360;\n\n\tconst bear180 = bear360 > 180 ? -(360 - bear360) : bear360;\n\n\treturn bear180;\n}\n","import { Position } from \"geojson\";\nimport { degreesToRadians, earthRadius } from \"../helpers\";\n\n// Based on @turf/rhumb-destination module which is MIT Licensed\n// https://github.com/Turfjs/turf/blob/master/packages/turf-rhumb-destination/index.ts\n\nexport function rhumbDestination(\n\torigin: Position,\n\tdistanceMeters: number,\n\tbearing: number,\n): Position {\n\tconst wasNegativeDistance = distanceMeters < 0;\n\tlet distanceInMeters = distanceMeters;\n\n\tif (wasNegativeDistance) {\n\t\tdistanceInMeters = -Math.abs(distanceInMeters);\n\t}\n\n\tconst delta = distanceInMeters / earthRadius; // angular distance in radians\n\tconst lambda1 = (origin[0] * Math.PI) / 180; // to radians, but without normalize to 𝜋\n\tconst phi1 = degreesToRadians(origin[1]);\n\tconst theta = degreesToRadians(bearing);\n\n\tconst DeltaPhi = delta * Math.cos(theta);\n\tlet phi2 = phi1 + DeltaPhi;\n\n\t// check for going past the pole, normalise latitude if so\n\tif (Math.abs(phi2) > Math.PI / 2) {\n\t\tphi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;\n\t}\n\n\tconst DeltaPsi = Math.log(\n\t\tMath.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4),\n\t);\n\t// E-W course becomes ill-conditioned with 0/0\n\tconst q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n\n\tconst DeltaLambda = (delta * Math.sin(theta)) / q;\n\tconst lambda2 = lambda1 + DeltaLambda;\n\n\t// normalise to −180..+180°\n\tconst destination = [\n\t\t(((lambda2 * 180) / Math.PI + 540) % 360) - 180,\n\t\t(phi2 * 180) / Math.PI,\n\t];\n\n\t// compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n\t// solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n\tdestination[0] +=\n\t\tdestination[0] - origin[0] > 180\n\t\t\t? -360\n\t\t\t: origin[0] - destination[0] > 180\n\t\t\t\t? 360\n\t\t\t\t: 0;\n\treturn destination;\n}\n","import { Position } from \"geojson\";\nimport { limitPrecision } from \"./limit-decimal-precision\";\nimport { Project, Unproject } from \"../common\";\nimport { haversineDistanceKilometers } from \"./measure/haversine-distance\";\nimport { rhumbBearing } from \"./measure/rhumb-bearing\";\nimport { rhumbDestination } from \"./measure/rhumb-destination\";\n\n// midpointCoordinate is adapted from the @turf/midpoint which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-midpoint\n\nexport function midpointCoordinate(\n\tcoordinates1: Position,\n\tcoordinates2: Position,\n\tprecision: number,\n\tproject: Project,\n\tunproject: Unproject,\n) {\n\tconst projectedCoordinateOne = project(coordinates1[0], coordinates1[1]);\n\tconst projectedCoordinateTwo = project(coordinates2[0], coordinates2[1]);\n\n\tconst { lng, lat } = unproject(\n\t\t(projectedCoordinateOne.x + projectedCoordinateTwo.x) / 2,\n\t\t(projectedCoordinateOne.y + projectedCoordinateTwo.y) / 2,\n\t);\n\n\treturn [limitPrecision(lng, precision), limitPrecision(lat, precision)];\n}\n\n/* Get the geodesic midpoint coordinate between two coordinates */\nexport function geodesicMidpointCoordinate(\n\tcoordinates1: Position,\n\tcoordinates2: Position,\n\tprecision: number,\n) {\n\tconst dist = haversineDistanceKilometers(coordinates1, coordinates2) * 1000;\n\tconst heading = rhumbBearing(coordinates1, coordinates2);\n\tconst midpoint = rhumbDestination(coordinates1, dist / 2, heading);\n\treturn [\n\t\tlimitPrecision(midpoint[0], precision),\n\t\tlimitPrecision(midpoint[1], precision),\n\t];\n}\n","import { Point, Position } from \"geojson\";\nimport { Project, Projection, Unproject } from \"../common\";\nimport { JSONObject } from \"../store/store\";\nimport {\n\tmidpointCoordinate,\n\tgeodesicMidpointCoordinate,\n} from \"./midpoint-coordinate\";\n\nexport function getMidPointCoordinates({\n\tfeatureCoords,\n\tprecision,\n\tunproject,\n\tproject,\n\tprojection,\n}: {\n\tfeatureCoords: Position[];\n\tprecision: number;\n\tproject: Project;\n\tunproject: Unproject;\n\tprojection: Projection;\n}) {\n\tconst midPointCoords: Position[] = [];\n\tfor (let i = 0; i < featureCoords.length - 1; i++) {\n\t\tlet mid;\n\t\tif (projection === \"web-mercator\") {\n\t\t\tmid = midpointCoordinate(\n\t\t\t\tfeatureCoords[i],\n\t\t\t\tfeatureCoords[i + 1],\n\t\t\t\tprecision,\n\t\t\t\tproject,\n\t\t\t\tunproject,\n\t\t\t);\n\t\t} else if (projection === \"globe\") {\n\t\t\tmid = geodesicMidpointCoordinate(\n\t\t\t\tfeatureCoords[i],\n\t\t\t\tfeatureCoords[i + 1],\n\t\t\t\tprecision,\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid projection\");\n\t\t}\n\n\t\tmidPointCoords.push(mid);\n\t}\n\treturn midPointCoords;\n}\n\nexport function getMidPoints(\n\tselectedCoords: Position[],\n\tproperties: (index: number) => JSONObject,\n\tprecision: number,\n\tproject: Project,\n\tunproject: Unproject,\n\tprojection: Projection,\n) {\n\treturn getMidPointCoordinates({\n\t\tfeatureCoords: selectedCoords,\n\t\tprecision,\n\t\tproject,\n\t\tunproject,\n\t\tprojection,\n\t}).map((coord, i) => ({\n\t\tgeometry: { type: \"Point\", coordinates: coord } as Point,\n\t\tproperties: properties(i),\n\t}));\n}\n","import { LineString, Point, Polygon, Position } from \"geojson\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport {\n\tgetMidPointCoordinates,\n\tgetMidPoints,\n} from \"../../../geometry/get-midpoints\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport {\n\tCOMMON_PROPERTIES,\n\tProjection,\n\tSELECT_PROPERTIES,\n} from \"../../../common\";\nimport { FeatureId } from \"../../../store/store\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\n\nexport class MidPointBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly selectionPointBehavior: SelectionPointBehavior,\n\t\tprivate readonly coordinatePointBehavior: CoordinatePointBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate _midPoints: string[] = [];\n\n\tget ids() {\n\t\treturn this._midPoints.concat();\n\t}\n\n\tset ids(_: string[]) {}\n\n\tpublic insert(\n\t\tfeatureId: FeatureId,\n\t\tmidPointId: FeatureId,\n\t\tcoordinatePrecision: number,\n\t) {\n\t\tconst midPoint = this.store.getGeometryCopy(midPointId);\n\t\tconst { midPointFeatureId, midPointSegment } =\n\t\t\tthis.store.getPropertiesCopy(midPointId);\n\t\tconst geometry = this.store.getGeometryCopy<Polygon | LineString>(\n\t\t\tmidPointFeatureId as FeatureId,\n\t\t);\n\n\t\t// Update the coordinates to include inserted midpoint\n\t\tconst updatedCoordinates =\n\t\t\tgeometry.type === \"Polygon\"\n\t\t\t\t? geometry.coordinates[0]\n\t\t\t\t: geometry.coordinates;\n\n\t\tupdatedCoordinates.splice(\n\t\t\t(midPointSegment as number) + 1,\n\t\t\t0,\n\t\t\tmidPoint.coordinates as Position,\n\t\t);\n\n\t\t// Update geometry coordinates depending\n\t\t// on if a polygon or linestring\n\t\tgeometry.coordinates =\n\t\t\tgeometry.type === \"Polygon\" ? [updatedCoordinates] : updatedCoordinates;\n\n\t\t// Update the selected features geometry to insert\n\t\t// the new midpoint\n\t\tthis.store.updateGeometry([{ id: midPointFeatureId as string, geometry }]);\n\n\t\t// We need to update the coordinate points to reflect the new midpoint\n\t\tconst featureProperties = this.store.getPropertiesCopy(featureId as string);\n\n\t\tif (featureProperties[COMMON_PROPERTIES.COORDINATE_POINT_IDS]) {\n\t\t\tthis.coordinatePointBehavior.createOrUpdate(featureId);\n\t\t}\n\n\t\t// TODO: is there a way of just updating the selection points rather\n\t\t// than fully deleting / recreating?\n\t\t// Recreate the selection points\n\n\t\tthis.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]);\n\n\t\t// We don't need to check if flags are correct\n\t\t// because selection points are prerequisite for midpoints\n\t\tthis.create(\n\t\t\tupdatedCoordinates,\n\t\t\tmidPointFeatureId as string,\n\t\t\tcoordinatePrecision,\n\t\t);\n\t\tthis.selectionPointBehavior.create(\n\t\t\tupdatedCoordinates,\n\t\t\tgeometry.type,\n\t\t\tmidPointFeatureId as string,\n\t\t);\n\t}\n\n\tpublic create(\n\t\tselectedCoords: Position[],\n\t\tfeatureId: FeatureId,\n\t\tcoordinatePrecision: number,\n\t) {\n\t\tif (!this.store.has(featureId)) {\n\t\t\tthrow new Error(\"Store does not have feature with this id\");\n\t\t}\n\n\t\tthis._midPoints = this.store.create(\n\t\t\tgetMidPoints(\n\t\t\t\tselectedCoords,\n\t\t\t\t(i) => ({\n\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t[SELECT_PROPERTIES.MID_POINT]: true,\n\t\t\t\t\tmidPointSegment: i,\n\t\t\t\t\tmidPointFeatureId: featureId,\n\t\t\t\t}),\n\t\t\t\tcoordinatePrecision,\n\t\t\t\tthis.config.project,\n\t\t\t\tthis.config.unproject,\n\t\t\t\tthis.projection,\n\t\t\t),\n\t\t);\n\t}\n\n\tpublic delete() {\n\t\tif (this._midPoints.length) {\n\t\t\tthis.store.delete(this._midPoints);\n\t\t\tthis._midPoints = [];\n\t\t}\n\t}\n\n\tpublic getUpdated(updatedCoordinates: Position[]) {\n\t\tif (this._midPoints.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn getMidPointCoordinates({\n\t\t\tfeatureCoords: updatedCoordinates,\n\t\t\tprecision: this.coordinatePrecision,\n\t\t\tproject: this.config.project,\n\t\t\tunproject: this.config.unproject,\n\t\t\tprojection: this.config.projection as Projection,\n\t\t}).map((updatedMidPointCoord, i) => ({\n\t\t\tid: this._midPoints[i] as string,\n\t\t\tgeometry: {\n\t\t\t\ttype: \"Point\",\n\t\t\t\tcoordinates: updatedMidPointCoord,\n\t\t\t} as Point,\n\t\t}));\n\t}\n}\n","import { LineString, Point, Polygon, Position } from \"geojson\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { getCoordinatesAsPoints } from \"../../../geometry/get-coordinates-as-points\";\nimport { FeatureId } from \"../../../store/store\";\nimport { SELECT_PROPERTIES } from \"../../../common\";\n\nexport type SelectionPointProperties = {\n\tmode: string;\n\tindex: number;\n\t[SELECT_PROPERTIES.SELECTION_POINT_FEATURE_ID]: string;\n\t[SELECT_PROPERTIES.SELECTION_POINT]: true;\n};\n\nexport class SelectionPointBehavior extends TerraDrawModeBehavior {\n\tconstructor(config: BehaviorConfig) {\n\t\tsuper(config);\n\t}\n\n\tprivate _selectionPoints: FeatureId[] = [];\n\n\tget ids() {\n\t\treturn this._selectionPoints.concat();\n\t}\n\n\tset ids(_: FeatureId[]) {}\n\n\tpublic create(\n\t\tselectedCoords: Position[],\n\t\ttype: Polygon[\"type\"] | LineString[\"type\"],\n\t\tfeatureId: FeatureId,\n\t) {\n\t\tthis._selectionPoints = this.store.create(\n\t\t\tgetCoordinatesAsPoints(selectedCoords, type, (i) => ({\n\t\t\t\tmode: this.mode,\n\t\t\t\tindex: i,\n\t\t\t\t[SELECT_PROPERTIES.SELECTION_POINT]: true,\n\t\t\t\t[SELECT_PROPERTIES.SELECTION_POINT_FEATURE_ID]: featureId,\n\t\t\t})),\n\t\t);\n\t}\n\n\tpublic delete() {\n\t\tif (this.ids.length) {\n\t\t\tthis.store.delete(this.ids);\n\t\t\tthis._selectionPoints = [];\n\t\t}\n\t}\n\n\tpublic getUpdated(updatedCoordinates: Position[]) {\n\t\tif (this._selectionPoints.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._selectionPoints.map((id, i) => {\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\tcoordinates: updatedCoordinates[i],\n\t\t\t\t} as Point,\n\t\t\t};\n\t\t});\n\t}\n\n\tpublic getOneUpdated(index: number, updatedCoordinate: Position) {\n\t\tif (this._selectionPoints[index] === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tid: this._selectionPoints[index] as string,\n\t\t\tgeometry: {\n\t\t\t\ttype: \"Point\",\n\t\t\t\tcoordinates: updatedCoordinate,\n\t\t\t} as Point,\n\t\t};\n\t}\n}\n","import { Point, Position } from \"geojson\";\nimport { JSONObject } from \"../store/store\";\n\nexport function getCoordinatesAsPoints<Properties extends JSONObject>(\n\tselectedCoords: Position[],\n\tgeometryType: \"Polygon\" | \"LineString\",\n\tproperties: (index: number) => Properties,\n) {\n\tconst selectionPoints = [];\n\n\t// We can skip the last point for polygons\n\t// as it's a duplicate of the first\n\tconst length =\n\t\tgeometryType === \"Polygon\"\n\t\t\t? selectedCoords.length - 1\n\t\t\t: selectedCoords.length;\n\n\tfor (let i = 0; i < length; i++) {\n\t\tselectionPoints.push({\n\t\t\tgeometry: {\n\t\t\t\ttype: \"Point\",\n\t\t\t\tcoordinates: selectedCoords[i],\n\t\t\t} as Point,\n\t\t\tproperties: properties(i),\n\t\t});\n\t}\n\n\treturn selectionPoints;\n}\n","import { Position } from \"geojson\";\n\n// Based on which-polygon (Mapbox)\n// https://github.com/mapbox/which-polygon/blob/2eb5b8a427d018ebd964c05acd3b9166c4558b2c/index.js#L81\n// ISC License - Copyright (c) 2017, Mapbox\n\nexport function pointInPolygon(point: Position, rings: Position[][]) {\n\tlet inside = false;\n\tfor (let i = 0, len = rings.length; i < len; i++) {\n\t\tconst ring = rings[i];\n\t\tfor (let j = 0, len2 = ring.length, k = len2 - 1; j < len2; k = j++) {\n\t\t\tif (rayIntersect(point, ring[j], ring[k])) {\n\t\t\t\tinside = !inside;\n\t\t\t}\n\t\t}\n\t}\n\treturn inside;\n}\n\nfunction rayIntersect(p: Position, p1: Position, p2: Position) {\n\treturn (\n\t\tp1[1] > p[1] !== p2[1] > p[1] &&\n\t\tp[0] < ((p2[0] - p1[0]) * (p[1] - p1[1])) / (p2[1] - p1[1]) + p1[0]\n\t);\n}\n","import { CartesianPoint } from \"../../common\";\n\nexport const pixelDistanceToLine = (\n\tpoint: CartesianPoint,\n\tlinePointOne: CartesianPoint,\n\tlinePointTwo: CartesianPoint,\n) => {\n\tconst square = (x: number) => {\n\t\treturn x * x;\n\t};\n\tconst dist2 = (v: CartesianPoint, w: CartesianPoint) => {\n\t\treturn square(v.x - w.x) + square(v.y - w.y);\n\t};\n\tconst distToSegmentSquared = (\n\t\tp: CartesianPoint,\n\t\tv: CartesianPoint,\n\t\tw: CartesianPoint,\n\t) => {\n\t\tconst l2 = dist2(v, w);\n\n\t\tif (l2 === 0) {\n\t\t\treturn dist2(p, v);\n\t\t}\n\n\t\tlet t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n\t\tt = Math.max(0, Math.min(1, t));\n\n\t\treturn dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });\n\t};\n\n\treturn Math.sqrt(distToSegmentSquared(point, linePointOne, linePointTwo));\n};\n","import { SELECT_PROPERTIES, TerraDrawMouseEvent } from \"../../../common\";\nimport { BBoxPolygon, GeoJSONStoreFeatures } from \"../../../store/store\";\n\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../../click-bounding-box.behavior\";\n\nimport { pointInPolygon } from \"../../../geometry/boolean/point-in-polygon\";\nimport { PixelDistanceBehavior } from \"../../pixel-distance.behavior\";\nimport { pixelDistanceToLine } from \"../../../geometry/measure/pixel-distance-to-line\";\n\nexport class FeatureAtPointerEventBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly createClickBoundingBox: ClickBoundingBoxBehavior,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tpublic find(event: TerraDrawMouseEvent, hasSelection: boolean) {\n\t\tlet clickedPoint: GeoJSONStoreFeatures | undefined = undefined;\n\t\tlet clickedPointDistance = Infinity;\n\t\tlet clickedLineString: GeoJSONStoreFeatures | undefined = undefined;\n\t\tlet clickedLineStringDistance = Infinity;\n\t\tlet clickedMidPoint: GeoJSONStoreFeatures | undefined = undefined;\n\t\tlet clickedMidPointDistance = Infinity;\n\t\tlet clickedPolygon: GeoJSONStoreFeatures | undefined = undefined;\n\n\t\tconst bbox = this.createClickBoundingBox.create(event);\n\t\tconst features = this.store.search(bbox as BBoxPolygon);\n\n\t\tfor (let i = 0; i < features.length; i++) {\n\t\t\tconst feature = features[i];\n\t\t\tconst geometry = feature.geometry;\n\n\t\t\tif (geometry.type === \"Point\") {\n\t\t\t\t// Ignore selection points always, and ignore mid points\n\t\t\t\t// when nothing is selected\n\t\t\t\tconst isSelectionPoint = feature.properties.selectionPoint;\n\t\t\t\tconst isCoordinatePoint = feature.properties.coordinatePoint;\n\t\t\t\tconst isNonSelectedMidPoint =\n\t\t\t\t\t!hasSelection && feature.properties[SELECT_PROPERTIES.MID_POINT];\n\n\t\t\t\tif (isSelectionPoint || isCoordinatePoint || isNonSelectedMidPoint) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst distance = this.pixelDistance.measure(\n\t\t\t\t\tevent,\n\t\t\t\t\tgeometry.coordinates,\n\t\t\t\t);\n\n\t\t\t\t// We want to catch both clicked\n\t\t\t\t// features but also any midpoints\n\t\t\t\t// in the clicked area\n\t\t\t\tif (\n\t\t\t\t\tfeature.properties[SELECT_PROPERTIES.MID_POINT] &&\n\t\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\t\tdistance < clickedMidPointDistance\n\t\t\t\t) {\n\t\t\t\t\tclickedMidPointDistance = distance;\n\t\t\t\t\tclickedMidPoint = feature;\n\t\t\t\t} else if (\n\t\t\t\t\t!feature.properties[SELECT_PROPERTIES.MID_POINT] &&\n\t\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\t\tdistance < clickedPointDistance\n\t\t\t\t) {\n\t\t\t\t\tclickedPointDistance = distance;\n\t\t\t\t\tclickedPoint = feature;\n\t\t\t\t}\n\t\t\t} else if (geometry.type === \"LineString\") {\n\t\t\t\tif (clickedPoint) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < geometry.coordinates.length - 1; i++) {\n\t\t\t\t\tconst coord = geometry.coordinates[i];\n\t\t\t\t\tconst nextCoord = geometry.coordinates[i + 1];\n\t\t\t\t\tconst distanceToLine = pixelDistanceToLine(\n\t\t\t\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t\t\t\t\tthis.project(coord[0], coord[1]),\n\t\t\t\t\t\tthis.project(nextCoord[0], nextCoord[1]),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tdistanceToLine < this.pointerDistance &&\n\t\t\t\t\t\tdistanceToLine < clickedLineStringDistance\n\t\t\t\t\t) {\n\t\t\t\t\t\tclickedLineStringDistance = distanceToLine;\n\t\t\t\t\t\tclickedLineString = feature;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (geometry.type === \"Polygon\") {\n\t\t\t\tif (clickedPoint || clickedLineString) {\n\t\t\t\t\t// We already have a clicked feature\n\t\t\t\t\t// so we can ignore the polygon\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst clickInsidePolygon = pointInPolygon(\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tgeometry.coordinates,\n\t\t\t\t);\n\n\t\t\t\tif (clickInsidePolygon) {\n\t\t\t\t\tclickedPolygon = feature;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tclickedFeature: clickedPoint || clickedLineString || clickedPolygon,\n\t\t\tclickedMidPoint,\n\t\t};\n\t}\n}\n","import { TerraDrawMouseEvent, UpdateTypes, Validation } from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { FeatureAtPointerEventBehavior } from \"./feature-at-pointer-event.behavior\";\nimport { Position } from \"geojson\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport { MidPointBehavior } from \"./midpoint.behavior\";\nimport { limitPrecision } from \"../../../geometry/limit-decimal-precision\";\nimport { FeatureId } from \"../../../store/store\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../../geometry/project/web-mercator\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\n\nexport class DragFeatureBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly featuresAtCursorEvent: FeatureAtPointerEventBehavior,\n\t\tprivate readonly selectionPoints: SelectionPointBehavior,\n\t\tprivate readonly midPoints: MidPointBehavior,\n\t\tprivate readonly coordinatePoints: CoordinatePointBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate draggedFeatureId: FeatureId | null = null;\n\n\tprivate dragPosition: Position | undefined;\n\n\tstartDragging(event: TerraDrawMouseEvent, id: FeatureId) {\n\t\tthis.draggedFeatureId = id;\n\t\tthis.dragPosition = [event.lng, event.lat];\n\t}\n\n\tstopDragging() {\n\t\tthis.draggedFeatureId = null;\n\t\tthis.dragPosition = undefined;\n\t}\n\n\tisDragging() {\n\t\treturn this.draggedFeatureId !== null;\n\t}\n\n\tcanDrag(event: TerraDrawMouseEvent, selectedId: FeatureId) {\n\t\tconst { clickedFeature } = this.featuresAtCursorEvent.find(event, true);\n\n\t\t// If the cursor is not over the selected\n\t\t// feature then we don't want to drag\n\t\tif (!clickedFeature || clickedFeature.id !== selectedId) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tdrag(event: TerraDrawMouseEvent, validateFeature?: Validation) {\n\t\tif (!this.draggedFeatureId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(this.draggedFeatureId);\n\t\tconst cursorCoord = [event.lng, event.lat];\n\n\t\t// Update the geometry of the dragged feature\n\t\tif (geometry.type === \"Polygon\" || geometry.type === \"LineString\") {\n\t\t\tlet updatedCoords: Position[];\n\t\t\tlet upToCoord: number;\n\n\t\t\tif (geometry.type === \"Polygon\") {\n\t\t\t\tupdatedCoords = geometry.coordinates[0];\n\t\t\t\tupToCoord = updatedCoords.length - 1;\n\t\t\t} else {\n\t\t\t\t// Must be LineString here\n\t\t\t\tupdatedCoords = geometry.coordinates;\n\t\t\t\tupToCoord = updatedCoords.length;\n\t\t\t}\n\n\t\t\tif (!this.dragPosition) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < upToCoord; i++) {\n\t\t\t\tconst coordinate = updatedCoords[i];\n\n\t\t\t\tlet updatedLng: number;\n\t\t\t\tlet updatedLat: number;\n\n\t\t\t\tif (this.config.projection === \"web-mercator\") {\n\t\t\t\t\tconst webMercatorDragPosition = lngLatToWebMercatorXY(\n\t\t\t\t\t\tthis.dragPosition[0],\n\t\t\t\t\t\tthis.dragPosition[1],\n\t\t\t\t\t);\n\t\t\t\t\tconst webMercatorCursorCoord = lngLatToWebMercatorXY(\n\t\t\t\t\t\tcursorCoord[0],\n\t\t\t\t\t\tcursorCoord[1],\n\t\t\t\t\t);\n\t\t\t\t\tconst webMercatorCoordinate = lngLatToWebMercatorXY(\n\t\t\t\t\t\tcoordinate[0],\n\t\t\t\t\t\tcoordinate[1],\n\t\t\t\t\t);\n\n\t\t\t\t\tconst delta = {\n\t\t\t\t\t\tx: webMercatorDragPosition.x - webMercatorCursorCoord.x,\n\t\t\t\t\t\ty: webMercatorDragPosition.y - webMercatorCursorCoord.y,\n\t\t\t\t\t};\n\n\t\t\t\t\tconst updatedX = webMercatorCoordinate.x - delta.x;\n\t\t\t\t\tconst updatedY = webMercatorCoordinate.y - delta.y;\n\n\t\t\t\t\tconst { lng, lat } = webMercatorXYToLngLat(updatedX, updatedY);\n\n\t\t\t\t\tupdatedLng = lng;\n\t\t\t\t\tupdatedLat = lat;\n\t\t\t\t} else {\n\t\t\t\t\tconst delta = [\n\t\t\t\t\t\tthis.dragPosition[0] - cursorCoord[0],\n\t\t\t\t\t\tthis.dragPosition[1] - cursorCoord[1],\n\t\t\t\t\t];\n\t\t\t\t\tupdatedLng = coordinate[0] - delta[0];\n\t\t\t\t\tupdatedLat = coordinate[1] - delta[1];\n\t\t\t\t}\n\n\t\t\t\t// Keep precision limited when calculating new coordinates\n\t\t\t\tupdatedLng = limitPrecision(\n\t\t\t\t\tupdatedLng,\n\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t);\n\n\t\t\t\tupdatedLat = limitPrecision(\n\t\t\t\t\tupdatedLat,\n\t\t\t\t\tthis.config.coordinatePrecision,\n\t\t\t\t);\n\n\t\t\t\t// Ensure that coordinates do not exceed\n\t\t\t\t// lng lat limits. Long term we may want to figure out\n\t\t\t\t// proper handling of anti meridian crossings\n\t\t\t\tif (\n\t\t\t\t\tupdatedLng > 180 ||\n\t\t\t\t\tupdatedLng < -180 ||\n\t\t\t\t\tupdatedLat > 90 ||\n\t\t\t\t\tupdatedLat < -90\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tupdatedCoords[i] = [updatedLng, updatedLat];\n\t\t\t}\n\n\t\t\t// Set final coordinate identical to first\n\t\t\t// We only want to do this for polygons!\n\t\t\tif (geometry.type === \"Polygon\") {\n\t\t\t\tupdatedCoords[updatedCoords.length - 1] = [\n\t\t\t\t\tupdatedCoords[0][0],\n\t\t\t\t\tupdatedCoords[0][1],\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tconst updatedSelectionPoints =\n\t\t\t\tthis.selectionPoints.getUpdated(updatedCoords) || [];\n\n\t\t\tconst updatedMidPoints = this.midPoints.getUpdated(updatedCoords) || [];\n\n\t\t\tconst updatedCoordinatePoints =\n\t\t\t\tthis.coordinatePoints.getUpdated(\n\t\t\t\t\tthis.draggedFeatureId,\n\t\t\t\t\tupdatedCoords,\n\t\t\t\t) || [];\n\n\t\t\tif (validateFeature) {\n\t\t\t\tconst validationResult = validateFeature(\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\t\tid: this.draggedFeatureId,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tproperties: {},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tproject: this.config.project,\n\t\t\t\t\t\tunproject: this.config.unproject,\n\t\t\t\t\t\tcoordinatePrecision: this.config.coordinatePrecision,\n\t\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!validationResult.valid) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Issue the update to the selected feature\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{ id: this.draggedFeatureId, geometry },\n\t\t\t\t...updatedSelectionPoints,\n\t\t\t\t...updatedMidPoints,\n\t\t\t\t...updatedCoordinatePoints,\n\t\t\t]);\n\n\t\t\tthis.dragPosition = [event.lng, event.lat];\n\n\t\t\t// Update mid point positions\n\t\t} else if (geometry.type === \"Point\") {\n\t\t\t// For cursor points we can simply move it\n\t\t\t// to the dragged position\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.draggedFeatureId,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: cursorCoord,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\tthis.dragPosition = [event.lng, event.lat];\n\t\t}\n\t}\n}\n","import {\n\tSnapping,\n\tTerraDrawMouseEvent,\n\tUpdateTypes,\n\tValidation,\n} from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\n\nimport { LineString, Polygon, Position, Point, Feature } from \"geojson\";\nimport { PixelDistanceBehavior } from \"../../pixel-distance.behavior\";\nimport { MidPointBehavior } from \"./midpoint.behavior\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport { selfIntersects } from \"../../../geometry/boolean/self-intersects\";\nimport { FeatureId, GeoJSONStoreFeatures } from \"../../../store/store\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\nimport { CoordinateSnappingBehavior } from \"../../coordinate-snapping.behavior\";\nimport { LineSnappingBehavior } from \"../../line-snapping.behavior\";\n\nexport class DragCoordinateBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t\tprivate readonly selectionPoints: SelectionPointBehavior,\n\t\tprivate readonly midPoints: MidPointBehavior,\n\t\tprivate readonly coordinatePoints: CoordinatePointBehavior,\n\t\tprivate readonly coordinateSnapping: CoordinateSnappingBehavior,\n\t\tprivate readonly lineSnapping: LineSnappingBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate draggedCoordinate: { id: null | FeatureId; index: number } = {\n\t\tid: null,\n\t\tindex: -1,\n\t};\n\n\tprivate getClosestCoordinate(\n\t\tevent: TerraDrawMouseEvent,\n\t\tgeometry: Polygon | LineString | Point,\n\t) {\n\t\tconst closestCoordinate = {\n\t\t\tdist: Infinity,\n\t\t\tindex: -1,\n\t\t\tisFirstOrLastPolygonCoord: false,\n\t\t};\n\n\t\tlet geomCoordinates: Position[] | undefined;\n\n\t\tif (geometry.type === \"LineString\") {\n\t\t\tgeomCoordinates = geometry.coordinates;\n\t\t} else if (geometry.type === \"Polygon\") {\n\t\t\tgeomCoordinates = geometry.coordinates[0];\n\t\t} else {\n\t\t\t// We don't want to handle dragging\n\t\t\t// points here\n\t\t\treturn closestCoordinate;\n\t\t}\n\n\t\t// Look through the selected features coordinates\n\t\t// and try to find a coordinate that is draggable\n\t\tfor (let i = 0; i < geomCoordinates.length; i++) {\n\t\t\tconst coord = geomCoordinates[i];\n\t\t\tconst distance = this.pixelDistance.measure(event, coord);\n\n\t\t\tif (\n\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\tdistance < closestCoordinate.dist\n\t\t\t) {\n\t\t\t\t// We don't create a point for the final\n\t\t\t\t// polygon coord, so we must set it to the first\n\t\t\t\t// coordinate instead\n\t\t\t\tconst isFirstOrLastPolygonCoord =\n\t\t\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t\t\t(i === geomCoordinates.length - 1 || i === 0);\n\n\t\t\t\tclosestCoordinate.dist = distance;\n\t\t\t\tclosestCoordinate.index = isFirstOrLastPolygonCoord ? 0 : i;\n\t\t\t\tclosestCoordinate.isFirstOrLastPolygonCoord = isFirstOrLastPolygonCoord;\n\t\t\t}\n\t\t}\n\n\t\treturn closestCoordinate;\n\t}\n\n\tpublic getDraggableIndex(\n\t\tevent: TerraDrawMouseEvent,\n\t\tselectedId: FeatureId,\n\t): number {\n\t\tconst geometry = this.store.getGeometryCopy(selectedId);\n\t\tconst closestCoordinate = this.getClosestCoordinate(event, geometry);\n\n\t\t// No coordinate was within the pointer distance\n\t\tif (closestCoordinate.index === -1) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn closestCoordinate.index;\n\t}\n\n\tprivate snapCoordinate(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsnapping: Snapping,\n\t\tdraggedFeature: GeoJSONStoreFeatures,\n\t): Position {\n\t\tlet snappedCoordinate: Position = [event.lng, event.lat];\n\n\t\t// This is a uniform filter we can use across all snapping behaviors\n\t\tconst filter = (feature: Feature) => {\n\t\t\treturn Boolean(\n\t\t\t\tfeature.properties &&\n\t\t\t\t\tfeature.properties.mode === draggedFeature.properties.mode &&\n\t\t\t\t\tfeature.id !== this.draggedCoordinate.id,\n\t\t\t);\n\t\t};\n\n\t\tif (snapping?.toLine) {\n\t\t\tlet snapped: Position | undefined;\n\n\t\t\tsnapped = this.lineSnapping.getSnappable(event, filter).coordinate;\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (snapping.toCoordinate) {\n\t\t\tlet snapped: Position | undefined = undefined;\n\n\t\t\tsnapped = this.coordinateSnapping.getSnappable(event, filter).coordinate;\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\tif (snapping?.toCustom) {\n\t\t\tlet snapped: Position | undefined = undefined;\n\n\t\t\tsnapped = snapping.toCustom(event, {\n\t\t\t\tcurrentCoordinate: this.draggedCoordinate.index,\n\t\t\t\tcurrentId: draggedFeature.id,\n\t\t\t\tgetCurrentGeometrySnapshot: draggedFeature.id\n\t\t\t\t\t? () =>\n\t\t\t\t\t\t\tthis.store.getGeometryCopy<Polygon>(\n\t\t\t\t\t\t\t\tdraggedFeature.id as FeatureId,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t: () => null,\n\t\t\t\tproject: this.project,\n\t\t\t\tunproject: this.unproject,\n\t\t\t});\n\n\t\t\tif (snapped) {\n\t\t\t\tsnappedCoordinate = snapped;\n\t\t\t}\n\t\t}\n\n\t\treturn snappedCoordinate;\n\t}\n\n\tdrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tallowSelfIntersection: boolean,\n\t\tvalidateFeature: Validation,\n\t\tsnapping: Snapping,\n\t): boolean {\n\t\tconst draggedFeatureId = this.draggedCoordinate.id;\n\n\t\tif (draggedFeatureId === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst index = this.draggedCoordinate.index;\n\t\tconst geometry = this.store.getGeometryCopy(draggedFeatureId);\n\t\tconst properties = this.store.getPropertiesCopy(draggedFeatureId);\n\n\t\tconst geomCoordinates = (\n\t\t\tgeometry.type === \"LineString\"\n\t\t\t\t? geometry.coordinates\n\t\t\t\t: geometry.coordinates[0]\n\t\t) as Position[];\n\n\t\tconst isFirstOrLastPolygonCoord =\n\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t(index === geomCoordinates.length - 1 || index === 0);\n\n\t\tconst draggedFeature: GeoJSONStoreFeatures = {\n\t\t\ttype: \"Feature\",\n\t\t\tid: draggedFeatureId,\n\t\t\tgeometry,\n\t\t\tproperties,\n\t\t};\n\n\t\tconst updatedCoordinate = this.snapCoordinate(\n\t\t\tevent,\n\t\t\tsnapping,\n\t\t\tdraggedFeature,\n\t\t);\n\n\t\t// Ensure that coordinates do not exceed\n\t\t// lng lat limits. Long term we may want to figure out\n\t\t// proper handling of anti meridian crossings\n\t\tif (\n\t\t\tevent.lng > 180 ||\n\t\t\tevent.lng < -180 ||\n\t\t\tevent.lat > 90 ||\n\t\t\tevent.lat < -90\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We want to update the actual Polygon/LineString itself -\n\t\t// for Polygons we want the first and last coordinates to match\n\t\tif (isFirstOrLastPolygonCoord) {\n\t\t\tconst lastCoordIndex = geomCoordinates.length - 1;\n\t\t\tgeomCoordinates[0] = updatedCoordinate;\n\t\t\tgeomCoordinates[lastCoordIndex] = updatedCoordinate;\n\t\t} else {\n\t\t\tgeomCoordinates[index] = updatedCoordinate;\n\t\t}\n\n\t\tconst updatedSelectionPoint = this.selectionPoints.getOneUpdated(\n\t\t\tindex,\n\t\t\tupdatedCoordinate,\n\t\t);\n\n\t\tconst updatedSelectionPoints = updatedSelectionPoint\n\t\t\t? [updatedSelectionPoint]\n\t\t\t: [];\n\n\t\tconst updatedMidPoints = this.midPoints.getUpdated(geomCoordinates) || [];\n\n\t\tconst updatedCoordinatePoints =\n\t\t\tthis.coordinatePoints.getUpdated(draggedFeatureId, geomCoordinates) || [];\n\n\t\tif (\n\t\t\tgeometry.type !== \"Point\" &&\n\t\t\t!allowSelfIntersection &&\n\t\t\tselfIntersects({\n\t\t\t\ttype: \"Feature\",\n\t\t\t\tgeometry: geometry,\n\t\t\t\tproperties: {},\n\t\t\t} as Feature<Polygon>)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (validateFeature) {\n\t\t\tconst validationResult = validateFeature(draggedFeature, {\n\t\t\t\tproject: this.config.project,\n\t\t\t\tunproject: this.config.unproject,\n\t\t\t\tcoordinatePrecision: this.config.coordinatePrecision,\n\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t});\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Apply all the updates\n\t\tthis.store.updateGeometry([\n\t\t\t// Update feature\n\t\t\t{\n\t\t\t\tid: draggedFeatureId,\n\t\t\t\tgeometry: geometry,\n\t\t\t},\n\t\t\t// Update selection and mid points\n\t\t\t...updatedSelectionPoints,\n\t\t\t...updatedMidPoints,\n\t\t\t...updatedCoordinatePoints,\n\t\t]);\n\n\t\treturn true;\n\t}\n\n\tisDragging() {\n\t\treturn this.draggedCoordinate.id !== null;\n\t}\n\n\tstartDragging(id: FeatureId, index: number) {\n\t\tthis.draggedCoordinate = {\n\t\t\tid,\n\t\t\tindex,\n\t\t};\n\t}\n\n\tstopDragging() {\n\t\tthis.draggedCoordinate = {\n\t\t\tid: null,\n\t\t\tindex: -1,\n\t\t};\n\t}\n}\n","import { Feature, LineString, Polygon, Position } from \"geojson\";\n\n// Adapter from the @turf/bearing which is MIT Licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-centroid\n\nexport function centroid(geojson: Feature<Polygon | LineString>): Position {\n\tlet xSum = 0;\n\tlet ySum = 0;\n\tlet len = 0;\n\n\tconst coordinates =\n\t\tgeojson.geometry.type === \"Polygon\"\n\t\t\t? geojson.geometry.coordinates[0].slice(0, -1)\n\t\t\t: geojson.geometry.coordinates;\n\n\tcoordinates.forEach((coord: Position) => {\n\t\txSum += coord[0];\n\t\tySum += coord[1];\n\t\tlen++;\n\t}, true);\n\n\treturn [xSum / len, ySum / len];\n}\n","import { Feature, LineString, Polygon, Position } from \"geojson\";\nimport { centroid } from \"../centroid\";\nimport { rhumbBearing } from \"../measure/rhumb-bearing\";\nimport { rhumbDestination } from \"../measure/rhumb-destination\";\nimport { rhumbDistance } from \"../measure/rhumb-distance\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../project/web-mercator\";\nimport { CartesianPoint } from \"../../common\";\n\n// Adapted on @turf/transform-rotate module which is MIT licensed\n// https://github.com/Turfjs/turf/tree/master/packages/turf-transform-rotate\n\nexport function transformRotate(\n\tfeature: Feature<Polygon | LineString>,\n\tangle: number,\n) {\n\t// Shortcut no-rotation\n\tif (angle === 0 || angle === 360 || angle === -360) {\n\t\treturn feature;\n\t}\n\n\t// Use centroid of GeoJSON if pivot is not provided\n\tconst pivot = centroid(feature);\n\n\tconst coordinates =\n\t\tfeature.geometry.type === \"Polygon\"\n\t\t\t? feature.geometry.coordinates[0]\n\t\t\t: feature.geometry.coordinates;\n\n\tcoordinates.forEach((pointCoords: Position) => {\n\t\tconst initialAngle = rhumbBearing(pivot, pointCoords);\n\t\tconst finalAngle = initialAngle + angle;\n\t\tconst distance = rhumbDistance(pivot, pointCoords);\n\t\tconst newCoords = rhumbDestination(pivot, distance, finalAngle);\n\t\tpointCoords[0] = newCoords[0];\n\t\tpointCoords[1] = newCoords[1];\n\t});\n\n\treturn feature;\n}\n\n/**\n * Rotate a GeoJSON Polygon geometry in web mercator\n * @param polygon - GeoJSON Polygon geometry\n * @param angle - rotation angle in degrees\n * @returns - rotated GeoJSON Polygon geometry\n */\nexport const transformRotateWebMercator = (\n\tfeature: Feature<Polygon> | Feature<LineString>,\n\tangle: number,\n) => {\n\tif (angle === 0 || angle === 360 || angle === -360) {\n\t\treturn feature;\n\t}\n\n\tconst DEGREES_TO_RADIANS = 0.017453292519943295 as const; // Math.PI / 180\n\n\tconst coordinates =\n\t\tfeature.geometry.type === \"Polygon\"\n\t\t\t? feature.geometry.coordinates[0]\n\t\t\t: feature.geometry.coordinates;\n\tconst angleRad = angle * DEGREES_TO_RADIANS;\n\n\t// Convert polygon coordinates to Web Mercator\n\tconst webMercatorCoords = coordinates.map(([lng, lat]) =>\n\t\tlngLatToWebMercatorXY(lng, lat),\n\t);\n\n\t// Find centroid of the polygon in Web Mercator\n\tconst centroid = webMercatorCoords.reduce(\n\t\t(acc: CartesianPoint, coord: CartesianPoint) => ({\n\t\t\tx: acc.x + coord.x,\n\t\t\ty: acc.y + coord.y,\n\t\t}),\n\t\t{ x: 0, y: 0 },\n\t);\n\tcentroid.x /= webMercatorCoords.length;\n\tcentroid.y /= webMercatorCoords.length;\n\n\t// Rotate the coordinates around the centroid\n\tconst rotatedWebMercatorCoords = webMercatorCoords.map((coord) => ({\n\t\tx:\n\t\t\tcentroid.x +\n\t\t\t(coord.x - centroid.x) * Math.cos(angleRad) -\n\t\t\t(coord.y - centroid.y) * Math.sin(angleRad),\n\t\ty:\n\t\t\tcentroid.y +\n\t\t\t(coord.x - centroid.x) * Math.sin(angleRad) +\n\t\t\t(coord.y - centroid.y) * Math.cos(angleRad),\n\t}));\n\n\t// Convert rotated Web Mercator coordinates back to geographic\n\tconst rotatedCoordinates = rotatedWebMercatorCoords.map(\n\t\t({ x, y }) =>\n\t\t\t[\n\t\t\t\twebMercatorXYToLngLat(x, y).lng,\n\t\t\t\twebMercatorXYToLngLat(x, y).lat,\n\t\t\t] as Position,\n\t);\n\n\tif (feature.geometry.type === \"Polygon\") {\n\t\tfeature.geometry.coordinates[0] = rotatedCoordinates;\n\t} else {\n\t\tfeature.geometry.coordinates = rotatedCoordinates;\n\t}\n\n\treturn feature;\n};\n","import { Feature, LineString, Polygon, Position } from \"geojson\";\nimport { lngLatToWebMercatorXY } from \"./project/web-mercator\";\nimport { CartesianPoint } from \"../common\";\n\n/**\n * Calculates the centroid of a GeoJSON Polygon or LineString in Web Mercator\n\n * @param {Feature<Polygon | LineString>} feature - The GeoJSON Feature containing either a Polygon or LineString\n * @returns {{ x: number, y: number }} The centroid of the polygon or line string in Web Mercator coordinates.\n */\nexport function webMercatorCentroid(feature: Feature<Polygon | LineString>) {\n\tconst coordinates =\n\t\tfeature.geometry.type === \"Polygon\"\n\t\t\t? feature.geometry.coordinates[0]\n\t\t\t: feature.geometry.coordinates;\n\n\tconst webMercatorCoordinates = coordinates.map((coord) => {\n\t\tconst { x, y } = lngLatToWebMercatorXY(coord[0], coord[1]);\n\t\treturn [x, y];\n\t});\n\n\tif (feature.geometry.type === \"Polygon\") {\n\t\treturn calculatePolygonCentroid(webMercatorCoordinates);\n\t} else {\n\t\treturn calculateLineStringMidpoint(webMercatorCoordinates);\n\t}\n}\n\nfunction calculatePolygonCentroid(\n\twebMercatorCoordinates: Position[],\n): CartesianPoint {\n\tlet area = 0;\n\tlet centroidX = 0;\n\tlet centroidY = 0;\n\n\tconst n = webMercatorCoordinates.length;\n\n\tfor (let i = 0; i < n - 1; i++) {\n\t\tconst [x1, y1] = webMercatorCoordinates[i];\n\t\tconst [x2, y2] = webMercatorCoordinates[i + 1];\n\n\t\tconst crossProduct = x1 * y2 - x2 * y1;\n\t\tarea += crossProduct;\n\t\tcentroidX += (x1 + x2) * crossProduct;\n\t\tcentroidY += (y1 + y2) * crossProduct;\n\t}\n\n\tarea /= 2;\n\tcentroidX /= 6 * area;\n\tcentroidY /= 6 * area;\n\n\treturn { x: centroidX, y: centroidY };\n}\n\nfunction calculateLineStringMidpoint(lineString: Position[]): CartesianPoint {\n\tconst n = lineString.length;\n\tlet totalX = 0;\n\tlet totalY = 0;\n\n\tfor (let i = 0; i < n; i++) {\n\t\tconst [x, y] = lineString[i];\n\t\ttotalX += x;\n\t\ttotalY += y;\n\t}\n\n\treturn { x: totalX / n, y: totalY / n };\n}\n","import {\n\tCartesianPoint,\n\tTerraDrawMouseEvent,\n\tUpdateTypes,\n\tValidation,\n} from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { Feature, LineString, Polygon, Position } from \"geojson\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport { MidPointBehavior } from \"./midpoint.behavior\";\nimport {\n\ttransformRotate,\n\ttransformRotateWebMercator,\n} from \"../../../geometry/transform/rotate\";\nimport { centroid } from \"../../../geometry/centroid\";\nimport { rhumbBearing } from \"../../../geometry/measure/rhumb-bearing\";\nimport { limitPrecision } from \"../../../geometry/limit-decimal-precision\";\nimport { FeatureId } from \"../../../store/store\";\nimport { webMercatorCentroid } from \"../../../geometry/web-mercator-centroid\";\nimport { lngLatToWebMercatorXY } from \"../../../geometry/project/web-mercator\";\nimport { webMercatorBearing } from \"../../../geometry/measure/bearing\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\n\nexport class RotateFeatureBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly selectionPoints: SelectionPointBehavior,\n\t\tprivate readonly midPoints: MidPointBehavior,\n\t\tprivate readonly coordinatePoints: CoordinatePointBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate lastBearing: number | undefined;\n\tprivate selectedGeometry: Polygon | LineString | undefined;\n\tprivate selectedGeometryCentroid: Position | undefined;\n\tprivate selectedGeometryWebMercatorCentroid: CartesianPoint | undefined;\n\n\treset() {\n\t\tthis.lastBearing = undefined;\n\t\tthis.selectedGeometry = undefined;\n\t\tthis.selectedGeometryWebMercatorCentroid = undefined;\n\t\tthis.selectedGeometryCentroid = undefined;\n\t}\n\n\trotate(\n\t\tevent: TerraDrawMouseEvent,\n\t\tselectedId: FeatureId,\n\t\tvalidateFeature?: Validation,\n\t) {\n\t\tif (!this.selectedGeometry) {\n\t\t\tthis.selectedGeometry = this.store.getGeometryCopy<LineString | Polygon>(\n\t\t\t\tselectedId,\n\t\t\t);\n\t\t}\n\n\t\tconst geometry = this.selectedGeometry;\n\n\t\t// Update the geometry of the dragged feature\n\t\tif (geometry.type !== \"Polygon\" && geometry.type !== \"LineString\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mouseCoord = [event.lng, event.lat];\n\n\t\tlet bearing: number;\n\t\tconst feature = { type: \"Feature\", geometry, properties: {} } as\n\t\t\t| Feature<Polygon>\n\t\t\t| Feature<LineString>;\n\n\t\tif (this.config.projection === \"web-mercator\") {\n\t\t\t// Cache the centroid of the selected geometry\n\t\t\t// to avoid recalculating it on every cursor move\n\t\t\tif (!this.selectedGeometryWebMercatorCentroid) {\n\t\t\t\tthis.selectedGeometryWebMercatorCentroid = webMercatorCentroid(feature);\n\t\t\t}\n\n\t\t\tconst cursorWebMercator = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\t\tbearing = webMercatorBearing(\n\t\t\t\tthis.selectedGeometryWebMercatorCentroid,\n\t\t\t\tcursorWebMercator,\n\t\t\t);\n\n\t\t\tif (bearing === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!this.lastBearing) {\n\t\t\t\tthis.lastBearing = bearing;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst angle = this.lastBearing - bearing;\n\n\t\t\ttransformRotateWebMercator(feature, -angle);\n\t\t} else if (this.config.projection === \"globe\") {\n\t\t\t// Cache the centroid of the selected geometry\n\t\t\t// to avoid recalculating it on every cursor move\n\t\t\tif (!this.selectedGeometryCentroid) {\n\t\t\t\tthis.selectedGeometryCentroid = centroid({\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tbearing = rhumbBearing(this.selectedGeometryCentroid, mouseCoord);\n\n\t\t\t// We need an original bearing to compare against\n\t\t\tif (!this.lastBearing) {\n\t\t\t\tthis.lastBearing = bearing + 180;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst angle = this.lastBearing - (bearing + 180);\n\n\t\t\ttransformRotate(feature, -angle);\n\t\t} else {\n\t\t\tthrow new Error(\"Unsupported projection\");\n\t\t}\n\n\t\t// Coordinates are either polygon or linestring at this point\n\t\tconst updatedCoords: Position[] =\n\t\t\tgeometry.type === \"Polygon\"\n\t\t\t\t? geometry.coordinates[0]\n\t\t\t\t: geometry.coordinates;\n\n\t\t// Ensure that coordinate precision is maintained\n\t\tupdatedCoords.forEach((coordinate) => {\n\t\t\tcoordinate[0] = limitPrecision(coordinate[0], this.coordinatePrecision);\n\t\t\tcoordinate[1] = limitPrecision(coordinate[1], this.coordinatePrecision);\n\t\t});\n\n\t\tconst updatedMidPoints = this.midPoints.getUpdated(updatedCoords) || [];\n\n\t\tconst updatedSelectionPoints =\n\t\t\tthis.selectionPoints.getUpdated(updatedCoords) || [];\n\n\t\tconst updatedCoordinatePoints =\n\t\t\tthis.coordinatePoints.getUpdated(selectedId, updatedCoords) || [];\n\n\t\tif (validateFeature) {\n\t\t\tif (\n\t\t\t\t!validateFeature(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: selectedId,\n\t\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tproperties: {},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tproject: this.config.project,\n\t\t\t\t\t\tunproject: this.config.unproject,\n\t\t\t\t\t\tcoordinatePrecision: this.config.coordinatePrecision,\n\t\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Issue the update to the selected feature\n\t\tthis.store.updateGeometry([\n\t\t\t{ id: selectedId, geometry },\n\t\t\t...updatedSelectionPoints,\n\t\t\t...updatedMidPoints,\n\t\t\t...updatedCoordinatePoints,\n\t\t]);\n\n\t\tif (this.projection === \"web-mercator\") {\n\t\t\tthis.lastBearing = bearing;\n\t\t} else if (this.projection === \"globe\") {\n\t\t\tthis.lastBearing = bearing + 180;\n\t\t}\n\t}\n}\n","import { Position } from \"geojson\";\nimport { earthRadius } from \"../helpers\";\n\n// Adapted from @turf/rhumb-distance module\n// https://github.com/Turfjs/turf/blob/master/packages/turf-rhumb-distance/index.ts\n\nexport function rhumbDistance(destination: Position, origin: Position): number {\n\t// compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n\t// solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n\tdestination[0] +=\n\t\tdestination[0] - origin[0] > 180\n\t\t\t? -360\n\t\t\t: origin[0] - destination[0] > 180\n\t\t\t\t? 360\n\t\t\t\t: 0;\n\n\t// see www.edwilliams.org/avform.htm#Rhumb\n\n\tconst R = earthRadius;\n\tconst phi1 = (origin[1] * Math.PI) / 180;\n\tconst phi2 = (destination[1] * Math.PI) / 180;\n\tconst DeltaPhi = phi2 - phi1;\n\tlet DeltaLambda = (Math.abs(destination[0] - origin[0]) * Math.PI) / 180;\n\n\t// if dLon over 180° take shorter rhumb line across the anti-meridian:\n\tif (DeltaLambda > Math.PI) {\n\t\tDeltaLambda -= 2 * Math.PI;\n\t}\n\n\t// on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\n\t// q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\n\tconst DeltaPsi = Math.log(\n\t\tMath.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4),\n\t);\n\tconst q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n\n\t// distance is pythagoras on 'stretched' Mercator projection\n\tconst delta = Math.sqrt(\n\t\tDeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda,\n\t); // angular distance in radians\n\n\tconst distanceMeters = delta * R;\n\n\treturn distanceMeters;\n}\n","import { TerraDrawMouseEvent, Validation } from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { FeatureId } from \"../../../store/store\";\nimport { DragCoordinateResizeBehavior } from \"./drag-coordinate-resize.behavior\";\n\nexport class ScaleFeatureBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly dragCoordinateResizeBehavior: DragCoordinateResizeBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tpublic scale(\n\t\tevent: TerraDrawMouseEvent,\n\t\tfeatureId: FeatureId,\n\t\tvalidation?: Validation,\n\t) {\n\t\tif (!this.dragCoordinateResizeBehavior.isDragging()) {\n\t\t\tconst index = this.dragCoordinateResizeBehavior.getDraggableIndex(\n\t\t\t\tevent,\n\t\t\t\tfeatureId,\n\t\t\t);\n\t\t\tthis.dragCoordinateResizeBehavior.startDragging(featureId, index);\n\t\t}\n\n\t\tthis.dragCoordinateResizeBehavior.drag(event, \"center-fixed\", validation);\n\t}\n\n\tpublic reset() {\n\t\tthis.dragCoordinateResizeBehavior.stopDragging();\n\t}\n}\n","import { Position } from \"geojson\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../project/web-mercator\";\n\nexport function transformScaleWebMercatorCoordinates({\n\tcoordinates,\n\toriginX,\n\toriginY,\n\txScale,\n\tyScale,\n}: {\n\tcoordinates: Position[];\n\toriginX: number;\n\toriginY: number;\n\txScale: number;\n\tyScale: number;\n}): void {\n\tif (xScale === 1 && yScale === 1) {\n\t\t// No scaling needed, return early\n\t\treturn;\n\t}\n\n\tcoordinates.forEach((coordinate) => {\n\t\tconst { x, y } = lngLatToWebMercatorXY(coordinate[0], coordinate[1]);\n\n\t\tconst updatedX = originX + (x - originX) * xScale;\n\t\tconst updatedY = originY + (y - originY) * yScale;\n\n\t\tconst { lng, lat } = webMercatorXYToLngLat(updatedX, updatedY);\n\n\t\tcoordinate[0] = lng;\n\t\tcoordinate[1] = lat;\n\t});\n}\n","import {\n\tCartesianPoint,\n\tTerraDrawMouseEvent,\n\tUpdateTypes,\n\tValidation,\n} from \"../../../common\";\nimport { BehaviorConfig, TerraDrawModeBehavior } from \"../../base.behavior\";\nimport { LineString, Polygon, Position, Point, Feature } from \"geojson\";\nimport { PixelDistanceBehavior } from \"../../pixel-distance.behavior\";\nimport { MidPointBehavior } from \"./midpoint.behavior\";\nimport { SelectionPointBehavior } from \"./selection-point.behavior\";\nimport { FeatureId, GeoJSONStoreGeometries } from \"../../../store/store\";\nimport { limitPrecision } from \"../../../geometry/limit-decimal-precision\";\nimport { cartesianDistance } from \"../../../geometry/measure/pixel-distance\";\nimport { coordinatePrecisionIsValid } from \"../../../geometry/boolean/is-valid-coordinate\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../../geometry/project/web-mercator\";\nimport { webMercatorCentroid } from \"../../../geometry/web-mercator-centroid\";\nimport { CoordinatePointBehavior } from \"./coordinate-point.behavior\";\nimport { transformScaleWebMercatorCoordinates } from \"../../../geometry/transform/scale\";\n\nexport type ResizeOptions =\n\t| \"center\"\n\t| \"opposite\"\n\t| \"center-fixed\"\n\t| \"opposite-fixed\";\n\ntype BoundingBoxIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\n\ntype BoundingBox = readonly [\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n\tnumber[],\n];\n\nexport class DragCoordinateResizeBehavior extends TerraDrawModeBehavior {\n\tconstructor(\n\t\treadonly config: BehaviorConfig,\n\t\tprivate readonly pixelDistance: PixelDistanceBehavior,\n\t\tprivate readonly selectionPoints: SelectionPointBehavior,\n\t\tprivate readonly midPoints: MidPointBehavior,\n\t\tprivate readonly coordinatePoints: CoordinatePointBehavior,\n\t) {\n\t\tsuper(config);\n\t}\n\n\tprivate minimumScale = 0.0001;\n\n\tprivate draggedCoordinate: { id: null | FeatureId; index: number } = {\n\t\tid: null,\n\t\tindex: -1,\n\t};\n\n\t// This map provides the oppsite corner of the bbox\n\t// to the index of the coordinate provided\n\t//   0    1    2\n\t//   *----*----*\n\t// \t |\t\t   |\n\t// 7 *\t\t   *  3\n\t//   |\t\t   |\n\t//   *----*----*\n\t// \t 6    5    4\n\t//\n\tprivate boundingBoxMaps = {\n\t\topposite: {\n\t\t\t0: 4,\n\t\t\t1: 5,\n\t\t\t2: 6,\n\t\t\t3: 7,\n\t\t\t4: 0,\n\t\t\t5: 1,\n\t\t\t6: 2,\n\t\t\t7: 3,\n\t\t},\n\t};\n\n\tprivate getClosestCoordinate(\n\t\tevent: TerraDrawMouseEvent,\n\t\tgeometry: Polygon | LineString | Point,\n\t) {\n\t\tconst closestCoordinate = {\n\t\t\tdist: Infinity,\n\t\t\tindex: -1,\n\t\t\tisFirstOrLastPolygonCoord: false,\n\t\t};\n\n\t\tlet geomCoordinates: Position[] | undefined;\n\n\t\tif (geometry.type === \"LineString\") {\n\t\t\tgeomCoordinates = geometry.coordinates;\n\t\t} else if (geometry.type === \"Polygon\") {\n\t\t\tgeomCoordinates = geometry.coordinates[0];\n\t\t} else {\n\t\t\t// We don't want to handle dragging\n\t\t\t// points here\n\t\t\treturn closestCoordinate;\n\t\t}\n\n\t\t// Look through the selected features coordinates\n\t\t// and try to find a coordinate that is draggable\n\t\tfor (let i = 0; i < geomCoordinates.length; i++) {\n\t\t\tconst coord = geomCoordinates[i];\n\t\t\tconst distance = this.pixelDistance.measure(event, coord);\n\n\t\t\tif (\n\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\tdistance < closestCoordinate.dist\n\t\t\t) {\n\t\t\t\t// We don't create a point for the final\n\t\t\t\t// polygon coord, so we must set it to the first\n\t\t\t\t// coordinate instead\n\t\t\t\tconst isFirstOrLastPolygonCoord =\n\t\t\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t\t\t(i === geomCoordinates.length - 1 || i === 0);\n\n\t\t\t\tclosestCoordinate.dist = distance;\n\t\t\t\tclosestCoordinate.index = isFirstOrLastPolygonCoord ? 0 : i;\n\t\t\t\tclosestCoordinate.isFirstOrLastPolygonCoord = isFirstOrLastPolygonCoord;\n\t\t\t}\n\t\t}\n\n\t\treturn closestCoordinate;\n\t}\n\n\tprivate isValidDragWebMercator(\n\t\tindex: BoundingBoxIndex,\n\t\tdistanceX: number,\n\t\tdistanceY: number,\n\t) {\n\t\tswitch (index) {\n\t\t\tcase 0:\n\t\t\t\tif (distanceX <= 0 || distanceY >= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (distanceY >= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (distanceX >= 0 || distanceY >= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (distanceX >= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (distanceX >= 0 || distanceY <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (distanceY <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (distanceX <= 0 || distanceY <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tif (distanceX <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate getSelectedFeatureDataWebMercator() {\n\t\tif (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst feature = this.getFeature(this.draggedCoordinate.id);\n\t\tif (!feature) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst updatedCoords = this.getNormalisedCoordinates(feature.geometry);\n\t\tconst boundingBox = this.getBBoxWebMercator(updatedCoords);\n\n\t\treturn {\n\t\t\tboundingBox,\n\t\t\tfeature,\n\t\t\tupdatedCoords,\n\t\t\tselectedCoordinate: updatedCoords[this.draggedCoordinate.index],\n\t\t};\n\t}\n\n\tprivate centerWebMercatorDrag(event: TerraDrawMouseEvent) {\n\t\tconst featureData = this.getSelectedFeatureDataWebMercator();\n\t\tif (!featureData) {\n\t\t\treturn null;\n\t\t}\n\t\tconst { feature, boundingBox, updatedCoords, selectedCoordinate } =\n\t\t\tfeatureData;\n\n\t\tconst webMercatorOrigin = webMercatorCentroid(feature);\n\n\t\tif (!webMercatorOrigin) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst webMercatorSelected = lngLatToWebMercatorXY(\n\t\t\tselectedCoordinate[0],\n\t\t\tselectedCoordinate[1],\n\t\t);\n\n\t\tconst { closestBBoxIndex } = this.getIndexesWebMercator(\n\t\t\tboundingBox,\n\t\t\twebMercatorSelected,\n\t\t);\n\n\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\tthis.scaleWebMercator({\n\t\t\tclosestBBoxIndex,\n\t\t\tupdatedCoords,\n\t\t\twebMercatorCursor,\n\t\t\twebMercatorSelected,\n\t\t\twebMercatorOrigin,\n\t\t});\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate centerFixedWebMercatorDrag(event: TerraDrawMouseEvent) {\n\t\tconst featureData = this.getSelectedFeatureDataWebMercator();\n\t\tif (!featureData) {\n\t\t\treturn null;\n\t\t}\n\t\tconst { feature, boundingBox, updatedCoords, selectedCoordinate } =\n\t\t\tfeatureData;\n\n\t\tconst webMercatorOrigin = webMercatorCentroid(feature);\n\n\t\tif (!webMercatorOrigin) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst webMercatorSelected = lngLatToWebMercatorXY(\n\t\t\tselectedCoordinate[0],\n\t\t\tselectedCoordinate[1],\n\t\t);\n\n\t\tconst { closestBBoxIndex } = this.getIndexesWebMercator(\n\t\t\tboundingBox,\n\t\t\twebMercatorSelected,\n\t\t);\n\n\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\tthis.scaleFixedWebMercator({\n\t\t\tclosestBBoxIndex,\n\t\t\tupdatedCoords,\n\t\t\twebMercatorCursor,\n\t\t\twebMercatorSelected,\n\t\t\twebMercatorOrigin,\n\t\t});\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate scaleFixedWebMercator({\n\t\tclosestBBoxIndex,\n\t\twebMercatorOrigin,\n\t\twebMercatorSelected,\n\t\twebMercatorCursor,\n\t\tupdatedCoords,\n\t}: {\n\t\tclosestBBoxIndex: BoundingBoxIndex;\n\t\tupdatedCoords: Position[];\n\t\twebMercatorCursor: CartesianPoint;\n\t\twebMercatorSelected: CartesianPoint;\n\t\twebMercatorOrigin: CartesianPoint;\n\t}) {\n\t\tconst cursorDistanceX = webMercatorOrigin.x - webMercatorCursor.x;\n\t\tconst cursorDistanceY = webMercatorOrigin.y - webMercatorCursor.y;\n\n\t\tconst valid = this.isValidDragWebMercator(\n\t\t\tclosestBBoxIndex,\n\t\t\tcursorDistanceX,\n\t\t\tcursorDistanceY,\n\t\t);\n\n\t\tif (!valid) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet scale =\n\t\t\tcartesianDistance(webMercatorOrigin, webMercatorCursor) /\n\t\t\tcartesianDistance(webMercatorOrigin, webMercatorSelected);\n\n\t\tif (scale < 0) {\n\t\t\tscale = this.minimumScale;\n\t\t}\n\n\t\ttransformScaleWebMercatorCoordinates({\n\t\t\tcoordinates: updatedCoords,\n\t\t\toriginX: webMercatorOrigin.x,\n\t\t\toriginY: webMercatorOrigin.y,\n\t\t\txScale: scale,\n\t\t\tyScale: scale,\n\t\t});\n\n\t\t// this.performWebMercatorScale(\n\t\t// \tupdatedCoords,\n\t\t// \twebMercatorOrigin.x,\n\t\t// \twebMercatorOrigin.y,\n\t\t// \tscale,\n\t\t// \tscale,\n\t\t// );\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate oppositeFixedWebMercatorDrag(event: TerraDrawMouseEvent) {\n\t\tconst featureData = this.getSelectedFeatureDataWebMercator();\n\t\tif (!featureData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { boundingBox, updatedCoords, selectedCoordinate } = featureData;\n\n\t\tconst webMercatorSelected = lngLatToWebMercatorXY(\n\t\t\tselectedCoordinate[0],\n\t\t\tselectedCoordinate[1],\n\t\t);\n\n\t\tconst { oppositeBboxIndex, closestBBoxIndex } = this.getIndexesWebMercator(\n\t\t\tboundingBox,\n\t\t\twebMercatorSelected,\n\t\t);\n\n\t\tconst webMercatorOrigin = {\n\t\t\tx: boundingBox[oppositeBboxIndex][0],\n\t\t\ty: boundingBox[oppositeBboxIndex][1],\n\t\t};\n\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\tthis.scaleFixedWebMercator({\n\t\t\tclosestBBoxIndex,\n\t\t\tupdatedCoords,\n\t\t\twebMercatorCursor,\n\t\t\twebMercatorSelected,\n\t\t\twebMercatorOrigin,\n\t\t});\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate oppositeWebMercatorDrag(event: TerraDrawMouseEvent) {\n\t\tconst featureData = this.getSelectedFeatureDataWebMercator();\n\t\tif (!featureData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { boundingBox, updatedCoords, selectedCoordinate } = featureData;\n\n\t\tconst webMercatorSelected = lngLatToWebMercatorXY(\n\t\t\tselectedCoordinate[0],\n\t\t\tselectedCoordinate[1],\n\t\t);\n\n\t\tconst { oppositeBboxIndex, closestBBoxIndex } = this.getIndexesWebMercator(\n\t\t\tboundingBox,\n\t\t\twebMercatorSelected,\n\t\t);\n\n\t\tconst webMercatorOrigin = {\n\t\t\tx: boundingBox[oppositeBboxIndex][0],\n\t\t\ty: boundingBox[oppositeBboxIndex][1],\n\t\t};\n\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\tthis.scaleWebMercator({\n\t\t\tclosestBBoxIndex,\n\t\t\tupdatedCoords,\n\t\t\twebMercatorCursor,\n\t\t\twebMercatorSelected,\n\t\t\twebMercatorOrigin,\n\t\t});\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate scaleWebMercator({\n\t\tclosestBBoxIndex,\n\t\twebMercatorOrigin,\n\t\twebMercatorSelected,\n\t\twebMercatorCursor,\n\t\tupdatedCoords,\n\t}: {\n\t\tclosestBBoxIndex: BoundingBoxIndex;\n\t\tupdatedCoords: Position[];\n\t\twebMercatorCursor: CartesianPoint;\n\t\twebMercatorSelected: CartesianPoint;\n\t\twebMercatorOrigin: CartesianPoint;\n\t}) {\n\t\tconst cursorDistanceX = webMercatorOrigin.x - webMercatorCursor.x;\n\t\tconst cursorDistanceY = webMercatorOrigin.y - webMercatorCursor.y;\n\n\t\tconst valid = this.isValidDragWebMercator(\n\t\t\tclosestBBoxIndex,\n\t\t\tcursorDistanceX,\n\t\t\tcursorDistanceY,\n\t\t);\n\n\t\tif (!valid) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet xScale = 1;\n\t\tif (\n\t\t\tcursorDistanceX !== 0 &&\n\t\t\tclosestBBoxIndex !== 1 &&\n\t\t\tclosestBBoxIndex !== 5\n\t\t) {\n\t\t\tconst currentDistanceX = webMercatorOrigin.x - webMercatorSelected.x;\n\t\t\txScale = 1 - (currentDistanceX - cursorDistanceX) / cursorDistanceX;\n\t\t}\n\n\t\tlet yScale = 1;\n\t\tif (\n\t\t\tcursorDistanceY !== 0 &&\n\t\t\tclosestBBoxIndex !== 3 &&\n\t\t\tclosestBBoxIndex !== 7\n\t\t) {\n\t\t\tconst currentDistanceY = webMercatorOrigin.y - webMercatorSelected.y;\n\t\t\tyScale = 1 - (currentDistanceY - cursorDistanceY) / cursorDistanceY;\n\t\t}\n\n\t\tif (!this.validateScale(xScale, yScale)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (xScale < 0) {\n\t\t\txScale = this.minimumScale;\n\t\t}\n\n\t\tif (yScale < 0) {\n\t\t\tyScale = this.minimumScale;\n\t\t}\n\n\t\tthis.performWebMercatorScale(\n\t\t\tupdatedCoords,\n\t\t\twebMercatorOrigin.x,\n\t\t\twebMercatorOrigin.y,\n\t\t\txScale,\n\t\t\tyScale,\n\t\t);\n\n\t\treturn updatedCoords;\n\t}\n\n\tprivate getFeature(id: FeatureId) {\n\t\tif (this.draggedCoordinate.id === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(id);\n\n\t\t// Update the geometry of the dragged feature\n\t\tif (geometry.type !== \"Polygon\" && geometry.type !== \"LineString\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst feature = {\n\t\t\tid,\n\t\t\ttype: \"Feature\",\n\t\t\tgeometry,\n\t\t\tproperties: {},\n\t\t} as Feature<Polygon | LineString>;\n\n\t\treturn feature;\n\t}\n\n\tprivate getNormalisedCoordinates(geometry: Polygon | LineString) {\n\t\t// Coordinates are either polygon or linestring at this point\n\t\treturn geometry.type === \"Polygon\"\n\t\t\t? geometry.coordinates[0]\n\t\t\t: geometry.coordinates;\n\t}\n\n\tprivate validateScale(xScale: number, yScale: number) {\n\t\tconst validX = !isNaN(xScale) && yScale < Number.MAX_SAFE_INTEGER;\n\t\tconst validY = !isNaN(yScale) && yScale < Number.MAX_SAFE_INTEGER;\n\n\t\treturn validX && validY;\n\t}\n\n\tprivate performWebMercatorScale(\n\t\tcoordinates: Position[],\n\t\toriginX: number,\n\t\toriginY: number,\n\t\txScale: number,\n\t\tyScale: number,\n\t) {\n\t\tcoordinates.forEach((coordinate) => {\n\t\t\tconst { x, y } = lngLatToWebMercatorXY(coordinate[0], coordinate[1]);\n\n\t\t\tconst updatedX = originX + (x - originX) * xScale;\n\t\t\tconst updatedY = originY + (y - originY) * yScale;\n\n\t\t\tconst { lng, lat } = webMercatorXYToLngLat(updatedX, updatedY);\n\n\t\t\tcoordinate[0] = lng;\n\t\t\tcoordinate[1] = lat;\n\t\t});\n\t}\n\n\tprivate getBBoxWebMercator(coordinates: Position[]) {\n\t\tconst bbox: [number, number, number, number] = [\n\t\t\tInfinity,\n\t\t\tInfinity,\n\t\t\t-Infinity,\n\t\t\t-Infinity,\n\t\t];\n\n\t\t// Convert from [lng, lat] -> [x, y]\n\t\tcoordinates = coordinates.map((coord) => {\n\t\t\tconst { x, y } = lngLatToWebMercatorXY(coord[0], coord[1]);\n\t\t\treturn [x, y];\n\t\t});\n\n\t\tcoordinates.forEach(([x, y]) => {\n\t\t\tif (x < bbox[0]) {\n\t\t\t\tbbox[0] = x;\n\t\t\t}\n\n\t\t\tif (y < bbox[1]) {\n\t\t\t\tbbox[1] = y;\n\t\t\t}\n\n\t\t\tif (x > bbox[2]) {\n\t\t\t\tbbox[2] = x;\n\t\t\t}\n\n\t\t\tif (y > bbox[3]) {\n\t\t\t\tbbox[3] = y;\n\t\t\t}\n\t\t});\n\n\t\tconst [west, south, east, north] = bbox;\n\n\t\t//   Bounding box is represented as follows:\n\t\t//\n\t\t//   0    1    2\n\t\t//   *----*----*\n\t\t// \t |\t\t   |\n\t\t// 7 *\t\t   *  3\n\t\t//   |\t\t   |\n\t\t//   *----*----*\n\t\t// \t 6    5    4\n\t\t//\n\t\tconst topLeft = [west, north];\n\t\tconst topRight = [east, north];\n\t\tconst lowRight = [east, south];\n\t\tconst lowLeft = [west, south];\n\n\t\tconst midTop = [(west + east) / 2, north];\n\t\tconst midRight = [east, north + (south - north) / 2];\n\t\tconst midBottom = [(west + east) / 2, south];\n\t\tconst midLeft = [west, north + (south - north) / 2];\n\n\t\treturn [\n\t\t\ttopLeft, // 0\n\t\t\tmidTop, // 1\n\t\t\ttopRight, // 2\n\t\t\tmidRight, // 3\n\t\t\tlowRight, // 4\n\t\t\tmidBottom, // 5\n\t\t\tlowLeft, // 6\n\t\t\tmidLeft, // 7\n\t\t] as const;\n\t}\n\n\tprivate getIndexesWebMercator(\n\t\tboundingBox: BoundingBox,\n\t\tselectedXY: CartesianPoint,\n\t) {\n\t\tlet closestIndex: BoundingBoxIndex | undefined;\n\t\tlet closestDistance = Infinity;\n\n\t\tfor (let i = 0; i < boundingBox.length; i++) {\n\t\t\tconst distance = cartesianDistance(\n\t\t\t\t{ x: selectedXY.x, y: selectedXY.y },\n\t\t\t\t{ x: boundingBox[i][0], y: boundingBox[i][1] },\n\t\t\t);\n\n\t\t\tif (distance < closestDistance) {\n\t\t\t\tclosestIndex = i as BoundingBoxIndex;\n\t\t\t\tclosestDistance = distance;\n\t\t\t}\n\t\t}\n\n\t\tif (closestIndex === undefined) {\n\t\t\tthrow new Error(\"No closest coordinate found\");\n\t\t}\n\n\t\t// Depending on where what the origin is set to, we need to find the position to\n\t\t// scale from\n\t\tconst oppositeIndex = this.boundingBoxMaps[\"opposite\"][\n\t\t\tclosestIndex\n\t\t] as BoundingBoxIndex;\n\n\t\treturn {\n\t\t\toppositeBboxIndex: oppositeIndex,\n\t\t\tclosestBBoxIndex: closestIndex,\n\t\t} as const;\n\t}\n\n\t/**\n\t * @returns - true if the feature is being dragged (resized), false otherwise\n\t */\n\tpublic isDragging() {\n\t\treturn this.draggedCoordinate.id !== null;\n\t}\n\n\t/**\n\t * Starts the resizing of the feature\n\t * @param id - feature id of the feature that is being dragged\n\t * @param index - index of the coordinate that is being dragged\n\t * @returns - void\n\t */\n\tpublic startDragging(id: FeatureId, index: number) {\n\t\tthis.draggedCoordinate = {\n\t\t\tid,\n\t\t\tindex,\n\t\t};\n\t}\n\n\t/**\n\t * Stops the resizing of the feature\n\t * @returns - void\t *\n\t */\n\tpublic stopDragging() {\n\t\tthis.draggedCoordinate = {\n\t\t\tid: null,\n\t\t\tindex: -1,\n\t\t};\n\t}\n\n\t/**\n\t * Returns the index of the coordinate that is going to be dragged\n\t * @param event - cursor event\n\t * @param selectedId - feature id of the feature that is selected\n\t * @returns - the index to be dragged\n\t */\n\tpublic getDraggableIndex(\n\t\tevent: TerraDrawMouseEvent,\n\t\tselectedId: FeatureId,\n\t): number {\n\t\tconst geometry = this.store.getGeometryCopy(selectedId);\n\t\tconst closestCoordinate = this.getClosestCoordinate(event, geometry);\n\n\t\t// No coordinate was within the pointer distance\n\t\tif (closestCoordinate.index === -1) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn closestCoordinate.index;\n\t}\n\n\t/**\n\t * Resizes the feature based on the cursor event\n\t * @param event - cursor event\n\t * @param resizeOption - the resize option, either \"center\" or \"opposite\"\n\t * @returns - true is resize was successful, false otherwise\n\t */\n\tpublic drag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tresizeOption: ResizeOptions,\n\t\tvalidateFeature?: Validation,\n\t): boolean {\n\t\tif (!this.draggedCoordinate.id) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst feature = this.getFeature(this.draggedCoordinate.id);\n\t\tif (!feature) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet updatedCoords: Position[] | null = null;\n\n\t\tif (resizeOption === \"center\") {\n\t\t\tupdatedCoords = this.centerWebMercatorDrag(event);\n\t\t} else if (resizeOption === \"opposite\") {\n\t\t\tupdatedCoords = this.oppositeWebMercatorDrag(event);\n\t\t} else if (resizeOption === \"center-fixed\") {\n\t\t\tupdatedCoords = this.centerFixedWebMercatorDrag(event);\n\t\t} else if (resizeOption === \"opposite-fixed\") {\n\t\t\tupdatedCoords = this.oppositeFixedWebMercatorDrag(event);\n\t\t}\n\n\t\tif (!updatedCoords) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Ensure that coordinate precision is maintained\n\t\tfor (let i = 0; i < updatedCoords.length; i++) {\n\t\t\tconst coordinate = updatedCoords[i];\n\t\t\tcoordinate[0] = limitPrecision(coordinate[0], this.coordinatePrecision);\n\t\t\tcoordinate[1] = limitPrecision(coordinate[1], this.coordinatePrecision);\n\n\t\t\t// Ensure the coordinate we are about to update with is valid\n\t\t\tif (!coordinatePrecisionIsValid(coordinate, this.coordinatePrecision)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Perform the update to the midpoints and selection points\n\t\tconst updatedMidPoints = this.midPoints.getUpdated(updatedCoords) || [];\n\t\tconst updatedSelectionPoints =\n\t\t\tthis.selectionPoints.getUpdated(updatedCoords) || [];\n\t\tconst updatedCoordinatePoints =\n\t\t\tthis.coordinatePoints.getUpdated(\n\t\t\t\tfeature.id as FeatureId,\n\t\t\t\tupdatedCoords,\n\t\t\t) || [];\n\n\t\tconst updatedGeometry = {\n\t\t\ttype: feature.geometry.type as \"Polygon\" | \"LineString\",\n\t\t\tcoordinates:\n\t\t\t\tfeature.geometry.type === \"Polygon\" ? [updatedCoords] : updatedCoords,\n\t\t} as GeoJSONStoreGeometries;\n\n\t\tif (validateFeature) {\n\t\t\tconst validationResult = validateFeature(\n\t\t\t\t{\n\t\t\t\t\tid: this.draggedCoordinate.id,\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.config.project,\n\t\t\t\t\tunproject: this.config.unproject,\n\t\t\t\t\tcoordinatePrecision: this.config.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Issue the update to the selected feature\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.draggedCoordinate.id,\n\t\t\t\tgeometry: updatedGeometry,\n\t\t\t},\n\t\t\t...updatedSelectionPoints,\n\t\t\t...updatedMidPoints,\n\t\t\t...updatedCoordinatePoints,\n\t\t]);\n\n\t\treturn true;\n\t}\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawKeyboardEvent,\n\tSELECT_PROPERTIES,\n\tTerraDrawAdapterStyling,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tValidation,\n\tUpdateTypes,\n\tZ_INDEX,\n\tSnapping,\n} from \"../../common\";\nimport { Point, Position } from \"geojson\";\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseSelectMode,\n} from \"../base.mode\";\nimport { MidPointBehavior } from \"./behaviors/midpoint.behavior\";\nimport {\n\tSelectionPointBehavior,\n\tSelectionPointProperties,\n} from \"./behaviors/selection-point.behavior\";\nimport { FeatureAtPointerEventBehavior } from \"./behaviors/feature-at-pointer-event.behavior\";\nimport { PixelDistanceBehavior } from \"../pixel-distance.behavior\";\nimport { ClickBoundingBoxBehavior } from \"../click-bounding-box.behavior\";\nimport { DragFeatureBehavior } from \"./behaviors/drag-feature.behavior\";\nimport { DragCoordinateBehavior } from \"./behaviors/drag-coordinate.behavior\";\nimport { BehaviorConfig } from \"../base.behavior\";\nimport { RotateFeatureBehavior } from \"./behaviors/rotate-feature.behavior\";\nimport { ScaleFeatureBehavior } from \"./behaviors/scale-feature.behavior\";\nimport { FeatureId, GeoJSONStoreFeatures } from \"../../store/store\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tDragCoordinateResizeBehavior,\n\tResizeOptions,\n} from \"./behaviors/drag-coordinate-resize.behavior\";\nimport { CoordinatePointBehavior } from \"./behaviors/coordinate-point.behavior\";\nimport { CoordinateSnappingBehavior } from \"../coordinate-snapping.behavior\";\nimport { LineSnappingBehavior } from \"../line-snapping.behavior\";\n\ntype TerraDrawSelectModeKeyEvents = {\n\tdeselect: KeyboardEvent[\"key\"] | null;\n\tdelete: KeyboardEvent[\"key\"] | null;\n\trotate: KeyboardEvent[\"key\"][] | null;\n\tscale: KeyboardEvent[\"key\"][] | null;\n};\n\nconst defaultKeyEvents = {\n\tdeselect: \"Escape\",\n\tdelete: \"Delete\",\n\trotate: [\"Control\", \"r\"],\n\tscale: [\"Control\", \"s\"],\n};\n\ntype ModeFlags = {\n\tfeature?: {\n\t\tvalidation?: Validation;\n\t\tdraggable?: boolean;\n\t\trotateable?: boolean;\n\t\tscaleable?: boolean;\n\t\tselfIntersectable?: boolean;\n\t\tcoordinates?: {\n\t\t\tsnappable?: boolean | Snapping;\n\t\t\tmidpoints?:\n\t\t\t\t| boolean\n\t\t\t\t| {\n\t\t\t\t\t\tdraggable?: boolean;\n\t\t\t\t  };\n\t\t\tdraggable?: boolean;\n\t\t\tresizable?: ResizeOptions;\n\t\t\tdeletable?: boolean;\n\t\t};\n\t};\n};\n\ntype SelectionStyling = {\n\t// Point\n\tselectedPointColor: HexColorStyling;\n\tselectedPointWidth: NumericStyling;\n\tselectedPointOutlineColor: HexColorStyling;\n\tselectedPointOutlineWidth: NumericStyling;\n\n\t// LineString\n\tselectedLineStringColor: HexColorStyling;\n\tselectedLineStringWidth: NumericStyling;\n\n\t// Polygon\n\tselectedPolygonColor: HexColorStyling;\n\tselectedPolygonFillOpacity: NumericStyling;\n\tselectedPolygonOutlineColor: HexColorStyling;\n\tselectedPolygonOutlineWidth: NumericStyling;\n\n\t// Selection Points (points at vertices of a polygon/linestring feature)\n\tselectionPointWidth: NumericStyling;\n\tselectionPointColor: HexColorStyling;\n\tselectionPointOutlineColor: HexColorStyling;\n\tselectionPointOutlineWidth: NumericStyling;\n\n\t// Mid points (points at mid point of a polygon/linestring feature)\n\tmidPointColor: HexColorStyling;\n\tmidPointOutlineColor: HexColorStyling;\n\tmidPointWidth: NumericStyling;\n\tmidPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tpointerOver?: Cursor;\n\tdragStart?: Cursor;\n\tdragEnd?: Cursor;\n\tinsertMidpoint?: Cursor;\n}\n\nconst defaultCursors = {\n\tpointerOver: \"move\",\n\tdragStart: \"move\",\n\tdragEnd: \"move\",\n\tinsertMidpoint: \"crosshair\",\n} as Required<Cursors>;\n\ninterface TerraDrawSelectModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tpointerDistance?: number;\n\tflags?: { [mode: string]: ModeFlags };\n\tkeyEvents?: TerraDrawSelectModeKeyEvents | null;\n\tdragEventThrottle?: number;\n\tcursors?: Cursors;\n\tallowManualDeselection?: boolean;\n}\n\nexport class TerraDrawSelectMode extends TerraDrawBaseSelectMode<SelectionStyling> {\n\tpublic mode = \"select\" as const;\n\n\tprivate allowManualDeselection = true;\n\tprivate dragEventThrottle = 5;\n\tprivate dragEventCount = 0;\n\tprivate selected: FeatureId[] = [];\n\n\tprivate flags: { [mode: string]: ModeFlags } = {};\n\tprivate keyEvents: TerraDrawSelectModeKeyEvents = defaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate validations: Record<string, Validation> = {};\n\n\t// Behaviors\n\tprivate selectionPoints!: SelectionPointBehavior;\n\tprivate midPoints!: MidPointBehavior;\n\tprivate coordinateSnap!: CoordinateSnappingBehavior;\n\tprivate featuresAtMouseEvent!: FeatureAtPointerEventBehavior;\n\tprivate pixelDistance!: PixelDistanceBehavior;\n\tprivate clickBoundingBox!: ClickBoundingBoxBehavior;\n\tprivate dragFeature!: DragFeatureBehavior;\n\tprivate dragCoordinate!: DragCoordinateBehavior;\n\tprivate rotateFeature!: RotateFeatureBehavior;\n\tprivate scaleFeature!: ScaleFeatureBehavior;\n\tprivate dragCoordinateResizeFeature!: DragCoordinateResizeBehavior;\n\tprivate coordinatePoints!: CoordinatePointBehavior;\n\tprivate lineSnap!: LineSnappingBehavior;\n\n\tconstructor(options?: TerraDrawSelectModeOptions<SelectionStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawSelectModeOptions<SelectionStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options && options.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t} else {\n\t\t\tthis.cursors = defaultCursors;\n\t\t}\n\n\t\t// We want to have some defaults, but also allow key bindings\n\t\t// to be explicitly turned off\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = {\n\t\t\t\tdeselect: null,\n\t\t\t\tdelete: null,\n\t\t\t\trotate: null,\n\t\t\t\tscale: null,\n\t\t\t};\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.dragEventThrottle !== undefined) {\n\t\t\tthis.dragEventThrottle = options.dragEventThrottle;\n\t\t}\n\n\t\tif (options?.allowManualDeselection !== undefined) {\n\t\t\tthis.allowManualDeselection = options.allowManualDeselection;\n\t\t}\n\n\t\t// Flags and Validations\n\t\tif (options?.flags) {\n\t\t\tthis.flags = { ...this.flags, ...options.flags };\n\t\t\tthis.validations = {};\n\n\t\t\tfor (const mode in this.flags) {\n\t\t\t\tconst feature = this.flags[mode].feature;\n\t\t\t\tif (feature && feature.validation) {\n\t\t\t\t\tthis.validations[mode] = feature.validation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tselectFeature(featureId: FeatureId) {\n\t\tthis.select(featureId, false);\n\t}\n\n\tsetSelecting() {\n\t\tif (this._state === \"started\") {\n\t\t\tthis._state = \"selecting\";\n\t\t} else {\n\t\t\tthrow new Error(\"Mode must be started to move to selecting state\");\n\t\t}\n\t}\n\n\tregisterBehaviors(config: BehaviorConfig) {\n\t\tthis.pixelDistance = new PixelDistanceBehavior(config);\n\t\tthis.clickBoundingBox = new ClickBoundingBoxBehavior(config);\n\t\tthis.featuresAtMouseEvent = new FeatureAtPointerEventBehavior(\n\t\t\tconfig,\n\t\t\tthis.clickBoundingBox,\n\t\t\tthis.pixelDistance,\n\t\t);\n\n\t\tthis.selectionPoints = new SelectionPointBehavior(config);\n\t\tthis.coordinatePoints = new CoordinatePointBehavior(config);\n\t\tthis.midPoints = new MidPointBehavior(\n\t\t\tconfig,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.coordinatePoints,\n\t\t);\n\t\tthis.coordinateSnap = new CoordinateSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.lineSnap = new LineSnappingBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.clickBoundingBox,\n\t\t);\n\t\tthis.rotateFeature = new RotateFeatureBehavior(\n\t\t\tconfig,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.midPoints,\n\t\t\tthis.coordinatePoints,\n\t\t);\n\n\t\tthis.dragFeature = new DragFeatureBehavior(\n\t\t\tconfig,\n\t\t\tthis.featuresAtMouseEvent,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.midPoints,\n\t\t\tthis.coordinatePoints,\n\t\t);\n\t\tthis.dragCoordinate = new DragCoordinateBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.midPoints,\n\t\t\tthis.coordinatePoints,\n\t\t\tthis.coordinateSnap,\n\t\t\tthis.lineSnap,\n\t\t);\n\t\tthis.dragCoordinateResizeFeature = new DragCoordinateResizeBehavior(\n\t\t\tconfig,\n\t\t\tthis.pixelDistance,\n\t\t\tthis.selectionPoints,\n\t\t\tthis.midPoints,\n\t\t\tthis.coordinatePoints,\n\t\t);\n\t\tthis.scaleFeature = new ScaleFeatureBehavior(\n\t\t\tconfig,\n\t\t\tthis.dragCoordinateResizeFeature,\n\t\t);\n\t}\n\n\tpublic deselectFeature() {\n\t\tthis.deselect();\n\t}\n\n\tprivate deselect() {\n\t\tconst updateSelectedFeatures = this.selected\n\t\t\t.filter((id) => this.store.has(id))\n\t\t\t.map((id) => ({\n\t\t\t\tid,\n\t\t\t\tproperty: SELECT_PROPERTIES.SELECTED,\n\t\t\t\tvalue: false,\n\t\t\t}));\n\n\t\tthis.store.updateProperty(updateSelectedFeatures);\n\n\t\tthis.onDeselect(this.selected[0]);\n\t\tthis.selected = [];\n\t\tthis.selectionPoints.delete();\n\t\tthis.midPoints.delete();\n\t}\n\n\tprivate deleteSelected() {\n\t\t// Delete all selected features\n\t\t// from the store and clear selected\n\t\t// We don't need to set selected false\n\t\t// as we're going to delete the feature\n\n\t\tthis.store.delete(this.selected);\n\t\tthis.selected = [];\n\t}\n\n\tprivate onRightClick(event: TerraDrawMouseEvent) {\n\t\tif (!this.selectionPoints.ids.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet clickedSelectionPointProps: SelectionPointProperties | undefined;\n\n\t\tlet clickedFeatureDistance = Infinity;\n\n\t\tthis.selectionPoints.ids.forEach((id) => {\n\t\t\tconst geometry = this.store.getGeometryCopy<Point>(id);\n\t\t\tconst distance = this.pixelDistance.measure(event, geometry.coordinates);\n\n\t\t\tif (\n\t\t\t\tdistance < this.pointerDistance &&\n\t\t\t\tdistance < clickedFeatureDistance\n\t\t\t) {\n\t\t\t\tclickedFeatureDistance = distance;\n\t\t\t\tclickedSelectionPointProps = this.store.getPropertiesCopy(\n\t\t\t\t\tid,\n\t\t\t\t) as SelectionPointProperties;\n\t\t\t}\n\t\t});\n\n\t\tif (!clickedSelectionPointProps) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst featureId = clickedSelectionPointProps.selectionPointFeatureId;\n\t\tconst coordinateIndex = clickedSelectionPointProps.index;\n\n\t\t// We allow for preventing deleting coordinates via flags\n\t\tconst properties = this.store.getPropertiesCopy(featureId);\n\t\tconst modeFlags = this.flags[properties.mode as string];\n\t\tconst validation = this.validations[properties.mode as string];\n\n\t\t// Check if we can actually delete the coordinate\n\t\tconst cannotDelete =\n\t\t\t!modeFlags ||\n\t\t\t!modeFlags.feature ||\n\t\t\t!modeFlags.feature.coordinates ||\n\t\t\t!modeFlags.feature.coordinates.deletable;\n\n\t\tif (cannotDelete) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst geometry = this.store.getGeometryCopy(featureId);\n\n\t\tlet coordinates;\n\t\tif (geometry.type === \"Polygon\") {\n\t\t\tcoordinates = geometry.coordinates[0];\n\n\t\t\t// Prevent creating an invalid polygon\n\t\t\tif (coordinates.length <= 4) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (geometry.type === \"LineString\") {\n\t\t\tcoordinates = geometry.coordinates;\n\n\t\t\t// Prevent creating an invalid linestring\n\t\t\tif (coordinates.length <= 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Geometry is not Polygon or LineString\n\t\tif (!coordinates) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isFinalPolygonCoordinate =\n\t\t\tgeometry.type === \"Polygon\" &&\n\t\t\t(coordinateIndex === 0 || coordinateIndex === coordinates.length - 1);\n\n\t\tif (isFinalPolygonCoordinate) {\n\t\t\t// Deleting the final coordinate in a polygon breaks it\n\t\t\t// because GeoJSON expects a duplicate, so we need to fix\n\t\t\t// it by adding the new first coordinate to the end\n\t\t\tcoordinates.shift();\n\t\t\tcoordinates.pop();\n\t\t\tcoordinates.push([coordinates[0][0], coordinates[0][1]]);\n\t\t} else {\n\t\t\t// Remove coordinate from array\n\t\t\tcoordinates.splice(coordinateIndex, 1);\n\t\t}\n\n\t\t// Validate the new geometry\n\t\tif (validation) {\n\t\t\tconst validationResult = validation(\n\t\t\t\t{\n\t\t\t\t\tid: featureId,\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry,\n\t\t\t\t\tproperties,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Commit,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst deletePoints = [...this.midPoints.ids, ...this.selectionPoints.ids];\n\n\t\tthis.store.delete(deletePoints);\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: featureId,\n\t\t\t\tgeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (properties.coordinatePointIds) {\n\t\t\tthis.coordinatePoints.createOrUpdate(featureId);\n\t\t}\n\n\t\tthis.selectionPoints.create(\n\t\t\tcoordinates,\n\t\t\tgeometry.type as \"Polygon\" | \"LineString\",\n\t\t\tfeatureId,\n\t\t);\n\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.coordinates &&\n\t\t\tmodeFlags.feature.coordinates.midpoints\n\t\t) {\n\t\t\tthis.midPoints.create(coordinates, featureId, this.coordinatePrecision);\n\t\t}\n\t}\n\n\tprivate select(featureId: FeatureId, fromCursor = true) {\n\t\tif (this.selected[0] === featureId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { mode } = this.store.getPropertiesCopy(featureId);\n\n\t\t// This will be undefined for points\n\t\tconst modeFlags = this.flags[mode as string];\n\n\t\t// If feature is not selectable then return\n\t\tif (!modeFlags || !modeFlags.feature) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst previouslySelectedId = this.selected[0];\n\n\t\t// If we have something currently selected\n\t\tif (previouslySelectedId) {\n\t\t\t// If it matches the current selected feature id, do nothing\n\t\t\tif (previouslySelectedId === featureId) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// If it's a different feature set selected\n\t\t\t\t// to false on previously selected feature\n\t\t\t\tthis.deselect();\n\t\t\t}\n\t\t}\n\n\t\tif (fromCursor) {\n\t\t\tthis.setCursor(this.cursors.pointerOver);\n\t\t}\n\n\t\t// Select feature\n\t\tthis.selected = [featureId];\n\n\t\tthis.store.updateProperty([\n\t\t\t{ id: featureId, property: SELECT_PROPERTIES.SELECTED, value: true },\n\t\t]);\n\t\tthis.onSelect(featureId);\n\n\t\t// Get the clicked feature\n\t\tconst { type, coordinates } = this.store.getGeometryCopy(featureId);\n\n\t\tif (type !== \"LineString\" && type !== \"Polygon\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// LineString does not have nesting so we can just take 'coordinates'\n\t\t// directly. Polygon is nested so we need to take [0] item in the array\n\t\tconst selectedCoords: Position[] =\n\t\t\ttype === \"LineString\" ? coordinates : coordinates[0];\n\n\t\tif (selectedCoords && modeFlags && modeFlags.feature.coordinates) {\n\t\t\tthis.selectionPoints.create(selectedCoords, type, featureId);\n\n\t\t\tif (modeFlags.feature.coordinates.midpoints) {\n\t\t\t\tthis.midPoints.create(\n\t\t\t\t\tselectedCoords,\n\t\t\t\t\tfeatureId,\n\t\t\t\t\tthis.coordinatePrecision,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onLeftClick(event: TerraDrawMouseEvent) {\n\t\tconst { clickedFeature, clickedMidPoint } = this.featuresAtMouseEvent.find(\n\t\t\tevent,\n\t\t\tthis.selected.length > 0,\n\t\t);\n\n\t\tif (this.selected.length && clickedMidPoint) {\n\t\t\t// TODO: We probably want to make sure the midpoint\n\t\t\t// is visible?\n\n\t\t\tthis.midPoints.insert(\n\t\t\t\tthis.selected[0],\n\t\t\t\tclickedMidPoint.id as string,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (clickedFeature && clickedFeature.id) {\n\t\t\tthis.select(clickedFeature.id, true);\n\t\t} else if (this.selected.length && this.allowManualDeselection) {\n\t\t\tthis.deselect();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setSelecting();\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStarted();\n\t\tthis.setStopped();\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tthis.onRightClick(event);\n\t\t} else if (\n\t\t\tevent.button === \"left\" &&\n\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)\n\t\t) {\n\t\t\tthis.onLeftClick(event);\n\t\t}\n\t}\n\n\tprivate canScale(event: TerraDrawKeyboardEvent | TerraDrawMouseEvent) {\n\t\treturn (\n\t\t\tthis.keyEvents.scale &&\n\t\t\tthis.keyEvents.scale.every((key) => event.heldKeys.includes(key))\n\t\t);\n\t}\n\n\tprivate canRotate(event: TerraDrawKeyboardEvent | TerraDrawMouseEvent) {\n\t\treturn (\n\t\t\tthis.keyEvents.rotate &&\n\t\t\tthis.keyEvents.rotate.every((key) => event.heldKeys.includes(key))\n\t\t);\n\t}\n\n\tprivate preventDefaultKeyEvent(event: TerraDrawKeyboardEvent) {\n\t\tconst isRotationKeys = this.canRotate(event);\n\t\tconst isScaleKeys = this.canScale(event);\n\n\t\t// If we are deliberately rotating or scaling then prevent default\n\t\tif (isRotationKeys || isScaleKeys) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown(event: TerraDrawKeyboardEvent) {\n\t\tthis.preventDefaultKeyEvent(event);\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tthis.preventDefaultKeyEvent(event);\n\n\t\tif (this.keyEvents.delete && event.key === this.keyEvents.delete) {\n\t\t\tif (!this.selected.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedId = this.selected[0];\n\n\t\t\t// We are technically deselecting\n\t\t\t// because the selected feature is deleted\n\t\t\t// and will no longer exist or be selected\n\t\t\tconst previouslySelected = this.selected[0];\n\t\t\tthis.onDeselect(previouslySelected);\n\n\t\t\t// Delete coordinate point first if they are present, this needs\n\t\t\t// to be done before deleting the feature\n\t\t\tthis.coordinatePoints.deletePointsByFeatureIds([selectedId]);\n\n\t\t\t// Delete all selected features\n\t\t\tthis.deleteSelected();\n\n\t\t\t// Remove all selection points\n\t\t\tthis.selectionPoints.delete();\n\t\t\tthis.midPoints.delete();\n\t\t} else if (\n\t\t\tthis.keyEvents.deselect &&\n\t\t\tevent.key === this.keyEvents.deselect\n\t\t) {\n\t\t\tthis.cleanUp();\n\t\t}\n\t}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tif (this.selected.length) {\n\t\t\tthis.deselect();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragStart, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We only need to stop the map dragging if\n\t\t// we actually have something selected\n\t\tif (!this.selected.length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the selected feature is not draggable\n\t\t// don't do anything\n\t\tconst properties = this.store.getPropertiesCopy(this.selected[0]);\n\t\tconst modeFlags = this.flags[properties.mode as string];\n\t\tconst draggable =\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\t(modeFlags.feature.draggable ||\n\t\t\t\t(modeFlags.feature.coordinates &&\n\t\t\t\t\tmodeFlags.feature.coordinates.draggable) ||\n\t\t\t\t(modeFlags.feature.coordinates &&\n\t\t\t\t\tmodeFlags.feature.coordinates.resizable) ||\n\t\t\t\t(modeFlags.feature.coordinates &&\n\t\t\t\t\ttypeof modeFlags.feature.coordinates.midpoints === \"object\" &&\n\t\t\t\t\tmodeFlags.feature.coordinates.midpoints.draggable));\n\n\t\tif (!draggable) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.dragEventCount = 0;\n\n\t\tconst selectedId = this.selected[0];\n\t\tconst draggableCoordinateIndex = this.dragCoordinate.getDraggableIndex(\n\t\t\tevent,\n\t\t\tselectedId,\n\t\t);\n\n\t\t// Drag Coordinate\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.coordinates &&\n\t\t\t(modeFlags.feature.coordinates.draggable ||\n\t\t\t\tmodeFlags.feature.coordinates.resizable) &&\n\t\t\tdraggableCoordinateIndex !== -1\n\t\t) {\n\t\t\tthis.setCursor(this.cursors.dragStart);\n\n\t\t\t// With resizable\n\t\t\tif (modeFlags.feature.coordinates.resizable) {\n\t\t\t\tthis.dragCoordinateResizeFeature.startDragging(\n\t\t\t\t\tselectedId,\n\t\t\t\t\tdraggableCoordinateIndex,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Without with resizable being set\n\t\t\t\tthis.dragCoordinate.startDragging(selectedId, draggableCoordinateIndex);\n\t\t\t}\n\n\t\t\tsetMapDraggability(false);\n\t\t\treturn;\n\t\t}\n\n\t\t// Dragging Midpoint\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.coordinates &&\n\t\t\ttypeof modeFlags.feature.coordinates.midpoints === \"object\" &&\n\t\t\tmodeFlags.feature.coordinates.midpoints.draggable\n\t\t) {\n\t\t\tconst { clickedMidPoint: draggedMidPoint } =\n\t\t\t\tthis.featuresAtMouseEvent.find(event, this.selected.length > 0);\n\n\t\t\tif (this.selected.length && draggedMidPoint) {\n\t\t\t\t// We insert the midpoint first\n\t\t\t\tthis.midPoints.insert(\n\t\t\t\t\tselectedId,\n\t\t\t\t\tdraggedMidPoint.id as string,\n\t\t\t\t\tthis.coordinatePrecision,\n\t\t\t\t);\n\n\t\t\t\tconst draggableCoordinateIndexAfterInsert =\n\t\t\t\t\tthis.dragCoordinate.getDraggableIndex(event, selectedId);\n\n\t\t\t\tthis.dragCoordinate.startDragging(\n\t\t\t\t\tselectedId,\n\t\t\t\t\tdraggableCoordinateIndexAfterInsert,\n\t\t\t\t);\n\n\t\t\t\tsetMapDraggability(false);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Drag Feature\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.draggable &&\n\t\t\tthis.dragFeature.canDrag(event, selectedId)\n\t\t) {\n\t\t\tthis.setCursor(this.cursors.dragStart);\n\t\t\tthis.dragFeature.startDragging(event, selectedId);\n\t\t\tsetMapDraggability(false);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDrag(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDrag, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst selectedId = this.selected[0];\n\n\t\t// If nothing selected we can return early\n\t\tif (!selectedId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst properties = this.store.getPropertiesCopy(selectedId);\n\t\tconst modeFlags = this.flags[properties.mode as string];\n\t\tconst canSelfIntersect: boolean =\n\t\t\t(modeFlags &&\n\t\t\t\tmodeFlags.feature &&\n\t\t\t\tmodeFlags.feature.selfIntersectable) === true;\n\n\t\t// Ensure drag count is incremented\n\t\tthis.dragEventCount++;\n\n\t\t// Return if we haven't hit the drag throttle limit\n\t\t// (i.e. we only want to drag every nth event)\n\t\tif (this.dragEventCount % this.dragEventThrottle === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst validation = this.validations[properties.mode as string];\n\n\t\t// Check if should rotate\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.rotateable &&\n\t\t\tthis.canRotate(event)\n\t\t) {\n\t\t\tsetMapDraggability(false);\n\t\t\tthis.rotateFeature.rotate(event, selectedId, validation);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if should scale\n\t\tif (\n\t\t\tmodeFlags &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.scaleable &&\n\t\t\tthis.canScale(event)\n\t\t) {\n\t\t\tsetMapDraggability(false);\n\n\t\t\tthis.scaleFeature.scale(event, selectedId, validation);\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tthis.dragCoordinateResizeFeature.isDragging() &&\n\t\t\tmodeFlags.feature &&\n\t\t\tmodeFlags.feature.coordinates &&\n\t\t\tmodeFlags.feature.coordinates.resizable\n\t\t) {\n\t\t\tif (this.projection === \"globe\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Globe is currently unsupported projection for resizable\",\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tsetMapDraggability(false);\n\t\t\tthis.dragCoordinateResizeFeature.drag(\n\t\t\t\tevent,\n\t\t\t\tmodeFlags.feature.coordinates.resizable,\n\t\t\t\tvalidation,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if coordinate is draggable and is dragged\n\t\tif (this.dragCoordinate.isDragging()) {\n\t\t\tconst snappable = modeFlags.feature?.coordinates?.snappable;\n\n\t\t\tlet snapOptions: Snapping = { toCoordinate: false };\n\t\t\tif (snappable === true) {\n\t\t\t\tsnapOptions = { toCoordinate: true };\n\t\t\t} else if (typeof snappable === \"object\") {\n\t\t\t\tsnapOptions = snappable;\n\t\t\t}\n\n\t\t\tthis.dragCoordinate.drag(\n\t\t\t\tevent,\n\t\t\t\tcanSelfIntersect,\n\t\t\t\tvalidation,\n\t\t\t\tsnapOptions,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if feature is draggable and is dragged\n\t\tif (this.dragFeature.isDragging()) {\n\t\t\tthis.dragFeature.drag(event, validation);\n\t\t\treturn;\n\t\t}\n\n\t\tsetMapDraggability(true);\n\t}\n\n\t/** @internal */\n\tonDragEnd(\n\t\tevent: TerraDrawMouseEvent,\n\t\tsetMapDraggability: (enabled: boolean) => void,\n\t) {\n\t\tif (!this.allowPointerEvent(this.pointerEvents.onDragEnd, event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setCursor(this.cursors.dragEnd);\n\n\t\t// If we have finished dragging a coordinate or a feature\n\t\t// lets fire an onFinish event which can be listened to\n\t\tif (this.dragCoordinate.isDragging()) {\n\t\t\tthis.onFinish(this.selected[0], {\n\t\t\t\tmode: this.mode,\n\t\t\t\taction: \"dragCoordinate\",\n\t\t\t});\n\t\t} else if (this.dragFeature.isDragging()) {\n\t\t\tthis.onFinish(this.selected[0], {\n\t\t\t\tmode: this.mode,\n\t\t\t\taction: \"dragFeature\",\n\t\t\t});\n\t\t} else if (this.dragCoordinateResizeFeature.isDragging()) {\n\t\t\tthis.onFinish(this.selected[0], {\n\t\t\t\tmode: this.mode,\n\t\t\t\taction: \"dragCoordinateResize\",\n\t\t\t});\n\t\t}\n\n\t\tthis.dragCoordinate.stopDragging();\n\t\tthis.dragFeature.stopDragging();\n\t\tthis.dragCoordinateResizeFeature.stopDragging();\n\t\tthis.rotateFeature.reset();\n\t\tthis.scaleFeature.reset();\n\t\tsetMapDraggability(true);\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tif (!this.selected.length) {\n\t\t\tthis.setCursor(\"unset\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.dragFeature.isDragging()) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet nearbyMidPoint = false;\n\t\tthis.midPoints.ids.forEach((id: string) => {\n\t\t\tif (nearbyMidPoint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst geometry = this.store.getGeometryCopy<Point>(id);\n\t\t\tconst distance = this.pixelDistance.measure(event, geometry.coordinates);\n\n\t\t\tif (distance < this.pointerDistance) {\n\t\t\t\tnearbyMidPoint = true;\n\t\t\t}\n\t\t});\n\n\t\tlet nearbySelectionPoint = false;\n\t\t// TODO: Is there a cleaner way to handle prioritising\n\t\t// dragging selection points?\n\t\tthis.selectionPoints.ids.forEach((id: FeatureId) => {\n\t\t\tconst geometry = this.store.getGeometryCopy<Point>(id);\n\t\t\tconst distance = this.pixelDistance.measure(event, geometry.coordinates);\n\t\t\tif (distance < this.pointerDistance) {\n\t\t\t\tnearbyMidPoint = false;\n\t\t\t\tnearbySelectionPoint = true;\n\t\t\t}\n\t\t});\n\n\t\tif (nearbyMidPoint) {\n\t\t\tthis.setCursor(this.cursors.insertMidpoint);\n\t\t\treturn;\n\t\t}\n\n\t\t// If we have a feature under the pointer then show the pointer over cursor\n\t\tconst { clickedFeature: featureUnderPointer } =\n\t\t\tthis.featuresAtMouseEvent.find(event, true);\n\n\t\tif (\n\t\t\tthis.selected.length > 0 &&\n\t\t\t((featureUnderPointer && featureUnderPointer.id === this.selected[0]) ||\n\t\t\t\tnearbySelectionPoint)\n\t\t) {\n\t\t\tthis.setCursor(this.cursors.pointerOver);\n\t\t} else {\n\t\t\t// Set it back to whatever the default cursor is\n\t\t\tthis.setCursor(\"unset\");\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.properties.mode === this.mode &&\n\t\t\tfeature.geometry.type === \"Point\"\n\t\t) {\n\t\t\tif (feature.properties.selectionPoint) {\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectionPointColor,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectionPointOutlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectionPointWidth,\n\t\t\t\t\tstyles.pointWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectionPointOutlineWidth,\n\t\t\t\t\t2,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_THREE;\n\n\t\t\t\treturn styles;\n\t\t\t}\n\n\t\t\tif (feature.properties.midPoint) {\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.midPointColor,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.midPointOutlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.midPointWidth,\n\t\t\t\t\t4,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.midPointOutlineWidth,\n\t\t\t\t\t2,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_FIVE;\n\n\t\t\t\treturn styles;\n\t\t\t}\n\t\t} else if (feature.properties[SELECT_PROPERTIES.SELECTED]) {\n\t\t\t// Select mode shortcuts the styling of a feature if it is selected\n\t\t\t// A selected feature from another mode will end up in this block\n\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedPolygonColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedPolygonOutlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedPolygonOutlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedPolygonFillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t\treturn styles;\n\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\tstyles.lineStringColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedLineStringColor,\n\t\t\t\t\tstyles.lineStringColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.lineStringWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedLineStringWidth,\n\t\t\t\t\tstyles.lineStringWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t\treturn styles;\n\t\t\t} else if (feature.geometry.type === \"Point\") {\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedPointWidth,\n\t\t\t\t\tstyles.pointWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedPointColor,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.selectedPointOutlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.selectedPointOutlineWidth,\n\t\t\t\t\tstyles.pointOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t\treturn styles;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// If we have a selected feature and it has been updated\n\t\t// we need to update the selection points and midpoints\n\t\tif (this.selected.length && feature.id === this.selected[0]) {\n\t\t\tconst flags = this.flags[feature.properties.mode as string];\n\n\t\t\tif (!flags?.feature?.coordinates) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst type = feature.geometry.type as \"Polygon\" | \"LineString\";\n\t\t\tconst id = feature.id as FeatureId;\n\n\t\t\tthis.selectionPoints.delete();\n\t\t\tthis.midPoints.delete();\n\n\t\t\tlet coordinates: Position[] | undefined;\n\t\t\tif (type === \"Polygon\") {\n\t\t\t\t// For Polygon we need to take the first item in the coordinates array\n\t\t\t\tcoordinates = feature.geometry.coordinates[0] as Position[];\n\t\t\t} else if (type === \"LineString\") {\n\t\t\t\t// For LineString we can take the coordinates directly\n\t\t\t\tcoordinates = feature.geometry.coordinates as Position[];\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.selectionPoints.create(coordinates, type, id);\n\n\t\t\tif (flags?.feature?.coordinates?.midpoints) {\n\t\t\t\tthis.midPoints.create(\n\t\t\t\t\t(type === \"Polygon\"\n\t\t\t\t\t\t? feature.geometry.coordinates[0]\n\t\t\t\t\t\t: feature.geometry.coordinates) as Position[],\n\t\t\t\t\tid,\n\t\t\t\t\tthis.coordinatePrecision,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n","import { TerraDrawAdapterStyling } from \"../../common\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport { ModeTypes, TerraDrawBaseDrawMode } from \"../base.mode\";\n\ntype StaticModeStylingExt<T extends TerraDrawAdapterStyling> = {};\ntype StaticModeStyling = StaticModeStylingExt<TerraDrawAdapterStyling>;\n\nexport class TerraDrawStaticMode extends TerraDrawBaseDrawMode<StaticModeStyling> {\n\ttype = ModeTypes.Static;\n\tmode = \"static\" as const;\n\tstart() {}\n\tstop() {}\n\tonKeyUp() {}\n\tonKeyDown() {}\n\tonClick() {}\n\tonDragStart() {}\n\tonDrag() {}\n\tonDragEnd() {}\n\tonMouseMove() {}\n\tcleanUp() {}\n\tstyleFeature() {\n\t\treturn { ...getDefaultStyling() };\n\t}\n}\n","// ISC License\n// Copyright (c) 2018, Vladimir Agafonkin\n\nexport type CompareFunction<T> = (a: T, b: T) => number;\n\nexport function quickselect<T>(\n\tarr: T[],\n\tk: number,\n\tleft: number,\n\tright: number,\n\tcompare: CompareFunction<T>,\n) {\n\twhile (right > left) {\n\t\tif (right - left > 600) {\n\t\t\tconst n = right - left + 1;\n\t\t\tconst m = k - left + 1;\n\t\t\tconst z = Math.log(n);\n\t\t\tconst s = 0.5 * Math.exp((2 * z) / 3);\n\t\t\tconst sd =\n\t\t\t\t0.5 * Math.sqrt((z * s * (n - s)) / n) * (m - n / 2 < 0 ? -1 : 1);\n\t\t\tconst newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));\n\t\t\tconst newRight = Math.min(right, Math.floor(k + ((n - m) * s) / n + sd));\n\t\t\tquickselect(arr, k, newLeft, newRight, compare);\n\t\t}\n\n\t\tconst t = arr[k];\n\t\tlet i = left;\n\t\tlet j = right;\n\n\t\tswap(arr, left, k);\n\t\tif (compare(arr[right], t) > 0) swap(arr, left, right);\n\n\t\twhile (i < j) {\n\t\t\tswap(arr, i, j);\n\t\t\ti++;\n\t\t\tj--;\n\t\t\twhile (compare(arr[i], t) < 0) i++;\n\t\t\twhile (compare(arr[j], t) > 0) j--;\n\t\t}\n\n\t\tif (compare(arr[left], t) === 0) {\n\t\t\tswap(arr, left, j);\n\t\t} else {\n\t\t\tj++;\n\t\t\tswap(arr, j, right);\n\t\t}\n\n\t\tif (j <= k) left = j + 1;\n\t\tif (k <= j) right = j - 1;\n\t}\n}\n\nfunction swap<T>(arr: T[], i: number, j: number) {\n\tconst tmp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = tmp;\n}\n","// Base on Rbush - https://github.com/mourner/rbush\n// MIT License\n// Copyright (c) 2016 Vladimir Agafonkin\n\nimport { CompareFunction, quickselect } from \"./quickselect\";\n\nexport type Node = {\n\tchildren: Node[];\n\theight: number;\n\tleaf: boolean;\n\tminX: number;\n\tminY: number;\n\tmaxX: number;\n\tmaxY: number;\n};\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node: Node, toBBox: (node: Node) => any) {\n\tdistBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(\n\tnode: Node,\n\tk: number,\n\tp: number,\n\ttoBBox: (node: Node) => Node,\n\tdestNode?: Node,\n) {\n\tif (!destNode) destNode = createNode([]);\n\tdestNode.minX = Infinity;\n\tdestNode.minY = Infinity;\n\tdestNode.maxX = -Infinity;\n\tdestNode.maxY = -Infinity;\n\n\tfor (let i = k; i < p; i++) {\n\t\tconst child = node.children[i];\n\t\textend(destNode, node.leaf ? toBBox(child) : child);\n\t}\n\n\treturn destNode;\n}\n\nfunction extend(a: Node, b: Node) {\n\ta.minX = Math.min(a.minX, b.minX);\n\ta.minY = Math.min(a.minY, b.minY);\n\ta.maxX = Math.max(a.maxX, b.maxX);\n\ta.maxY = Math.max(a.maxY, b.maxY);\n\treturn a;\n}\n\nfunction compareNodeMinX(a: Node, b: Node) {\n\treturn a.minX - b.minX;\n}\nfunction compareNodeMinY(a: Node, b: Node) {\n\treturn a.minY - b.minY;\n}\n\nfunction bboxArea(a: Node) {\n\treturn (a.maxX - a.minX) * (a.maxY - a.minY);\n}\nfunction bboxMargin(a: {\n\tminX: number;\n\tminY: number;\n\tmaxX: number;\n\tmaxY: number;\n}) {\n\treturn a.maxX - a.minX + (a.maxY - a.minY);\n}\n\nfunction enlargedArea(a: Node, b: Node) {\n\treturn (\n\t\t(Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n\t\t(Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY))\n\t);\n}\n\nfunction intersectionArea(a: Node, b: Node) {\n\tconst minX = Math.max(a.minX, b.minX);\n\tconst minY = Math.max(a.minY, b.minY);\n\tconst maxX = Math.min(a.maxX, b.maxX);\n\tconst maxY = Math.min(a.maxY, b.maxY);\n\n\treturn Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\n\nfunction contains(a: Node, b: Node) {\n\treturn (\n\t\ta.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY\n\t);\n}\n\nfunction intersects(a: Node, b: Node) {\n\treturn (\n\t\tb.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY\n\t);\n}\n\nfunction createNode(children: Node[]) {\n\treturn {\n\t\tchildren,\n\t\theight: 1,\n\t\tleaf: true,\n\t\tminX: Infinity,\n\t\tminY: Infinity,\n\t\tmaxX: -Infinity,\n\t\tmaxY: -Infinity,\n\t};\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect<T>(\n\tarr: T[],\n\tleft: number,\n\tright: number,\n\tn: number,\n\tcompare: CompareFunction<T>,\n) {\n\tconst stack = [left, right];\n\n\twhile (stack.length) {\n\t\tright = stack.pop() as number;\n\t\tleft = stack.pop() as number;\n\n\t\tif (right - left <= n) continue;\n\n\t\tconst mid = left + Math.ceil((right - left) / n / 2) * n;\n\t\tquickselect(arr, mid, left, right, compare);\n\n\t\tstack.push(left, mid, mid, right);\n\t}\n}\n\nexport class RBush {\n\tprivate _maxEntries: number;\n\tprivate _minEntries: number;\n\tprivate data!: Node;\n\n\tconstructor(maxEntries: number) {\n\t\t// max entries in a node is 9 by default; min node fill is 40% for best performance\n\t\tthis._maxEntries = Math.max(4, maxEntries);\n\t\tthis._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\t\tthis.clear();\n\t}\n\n\tsearch(bbox: Node): Node[] {\n\t\tlet node = this.data;\n\t\tconst result: Node[] = [];\n\n\t\tif (!intersects(bbox, node)) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst toBBox = this.toBBox;\n\t\tconst nodesToSearch = [];\n\n\t\twhile (node) {\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\t\t\t\tconst childBBox = node.leaf ? toBBox(child) : child;\n\n\t\t\t\tif (intersects(bbox, childBBox)) {\n\t\t\t\t\tif (node.leaf) result.push(child);\n\t\t\t\t\telse if (contains(bbox, childBBox)) this._all(child, result);\n\t\t\t\t\telse nodesToSearch.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = nodesToSearch.pop() as Node;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tcollides(bbox: Node) {\n\t\tlet node = this.data;\n\n\t\tconst intersect = intersects(bbox, node);\n\t\tif (intersect) {\n\t\t\tconst nodesToSearch = [];\n\t\t\twhile (node) {\n\t\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\t\tconst child = node.children[i];\n\t\t\t\t\tconst childBBox = node.leaf ? this.toBBox(child) : child;\n\n\t\t\t\t\tif (intersects(bbox, childBBox)) {\n\t\t\t\t\t\tif (node.leaf || contains(bbox, childBBox)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnodesToSearch.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode = nodesToSearch.pop() as Node;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tload(data: Node[]): void {\n\t\tif (data.length < this._minEntries) {\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tthis.insert(data[i]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// recursively build the tree with the given data from scratch using OMT algorithm\n\t\tlet node = this._build(data.slice(), 0, data.length - 1, 0);\n\n\t\tif (!this.data.children.length) {\n\t\t\t// save as is if tree is empty\n\t\t\tthis.data = node;\n\t\t} else if (this.data.height === node.height) {\n\t\t\t// split root if trees have the same height\n\t\t\tthis._splitRoot(this.data, node);\n\t\t} else {\n\t\t\tif (this.data.height < node.height) {\n\t\t\t\t// swap trees if inserted one is bigger\n\t\t\t\tconst tmpNode = this.data;\n\t\t\t\tthis.data = node;\n\t\t\t\tnode = tmpNode;\n\t\t\t}\n\n\t\t\t// insert the small tree into the large tree at appropriate level\n\t\t\tthis._insert(node, this.data.height - node.height - 1, true);\n\t\t}\n\t}\n\n\tinsert(item: Node): void {\n\t\tthis._insert(item, this.data.height - 1);\n\t}\n\n\tclear(): void {\n\t\tthis.data = createNode([]);\n\t}\n\n\tremove(item: Node): void {\n\t\tlet node: Node | null = this.data;\n\t\tconst bbox = this.toBBox(item);\n\t\tconst path = [];\n\t\tconst indexes: number[] = [];\n\t\tlet i: number | undefined;\n\t\tlet parent: Node | undefined;\n\t\tlet goingUp = false;\n\n\t\t// depth-first iterative tree traversal\n\t\twhile (node || path.length) {\n\t\t\tif (!node) {\n\t\t\t\t// go up\n\t\t\t\tnode = path.pop() as Node;\n\t\t\t\tparent = path[path.length - 1];\n\t\t\t\ti = indexes.pop() as number;\n\t\t\t\tgoingUp = true;\n\t\t\t}\n\n\t\t\tif (node.leaf) {\n\t\t\t\t// check current node\n\n\t\t\t\tconst index = node.children.indexOf(item);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\t// item found, remove the item and condense tree upwards\n\t\t\t\t\tnode.children.splice(index, 1);\n\t\t\t\t\tpath.push(node);\n\t\t\t\t\tthis._condense(path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!goingUp && !node.leaf && contains(node, bbox)) {\n\t\t\t\t// go down\n\t\t\t\tpath.push(node);\n\t\t\t\tindexes.push(i as number);\n\t\t\t\ti = 0;\n\t\t\t\tparent = node;\n\t\t\t\tnode = node.children[0];\n\t\t\t} else if (parent) {\n\t\t\t\t// go right\n\t\t\t\t(i as number)++;\n\t\t\t\tnode = parent.children[i as number];\n\t\t\t\tgoingUp = false;\n\t\t\t} else {\n\t\t\t\tnode = null; // nothing found\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate toBBox<T>(item: T): T {\n\t\treturn item;\n\t}\n\n\tprivate compareMinX(a: Node, b: Node) {\n\t\treturn a.minX - b.minX;\n\t}\n\tprivate compareMinY(a: Node, b: Node) {\n\t\treturn a.minY - b.minY;\n\t}\n\n\tprivate _all(node: Node, result: Node[]) {\n\t\tconst nodesToSearch = [];\n\t\twhile (node) {\n\t\t\tif (node.leaf) result.push(...node.children);\n\t\t\telse nodesToSearch.push(...node.children);\n\n\t\t\tnode = nodesToSearch.pop() as Node;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _build(items: Node[], left: number, right: number, height: number) {\n\t\tconst N = right - left + 1;\n\t\tlet M = this._maxEntries;\n\t\tlet node;\n\n\t\tif (N <= M) {\n\t\t\t// reached leaf level; return leaf\n\t\t\tnode = createNode(items.slice(left, right + 1));\n\t\t\tcalcBBox(node, this.toBBox);\n\t\t\treturn node;\n\t\t}\n\n\t\tif (!height) {\n\t\t\t// target height of the bulk-loaded tree\n\t\t\theight = Math.ceil(Math.log(N) / Math.log(M));\n\n\t\t\t// target number of root entries to maximize storage utilization\n\t\t\tM = Math.ceil(N / Math.pow(M, height - 1));\n\t\t}\n\n\t\tnode = createNode([]);\n\t\tnode.leaf = false;\n\t\tnode.height = height;\n\n\t\t// split the items into M mostly square tiles\n\n\t\tconst N2 = Math.ceil(N / M);\n\t\tconst N1 = N2 * Math.ceil(Math.sqrt(M));\n\n\t\tmultiSelect(items, left, right, N1, this.compareMinX);\n\n\t\tfor (let i = left; i <= right; i += N1) {\n\t\t\tconst right2 = Math.min(i + N1 - 1, right);\n\n\t\t\tmultiSelect(items, i, right2, N2, this.compareMinY);\n\n\t\t\tfor (let j = i; j <= right2; j += N2) {\n\t\t\t\tconst right3 = Math.min(j + N2 - 1, right2);\n\n\t\t\t\t// pack each entry recursively\n\t\t\t\tnode.children.push(this._build(items, j, right3, height - 1));\n\t\t\t}\n\t\t}\n\n\t\tcalcBBox(node, this.toBBox);\n\n\t\treturn node;\n\t}\n\n\tprivate _chooseSubtree(bbox: Node, node: Node, level: number, path: Node[]) {\n\t\twhile (true) {\n\t\t\tpath.push(node);\n\n\t\t\tif (node.leaf || path.length - 1 === level) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet minArea = Infinity;\n\t\t\tlet minEnlargement = Infinity;\n\t\t\tlet targetNode;\n\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\n\t\t\t\tconst area = bboxArea(child);\n\t\t\t\tconst enlargement = enlargedArea(bbox, child) - area;\n\n\t\t\t\t// choose entry with the least area enlargement\n\n\t\t\t\tif (enlargement < minEnlargement) {\n\t\t\t\t\tminEnlargement = enlargement;\n\t\t\t\t\tminArea = area < minArea ? area : minArea;\n\t\t\t\t\ttargetNode = child;\n\t\t\t\t} else if (enlargement === minEnlargement) {\n\t\t\t\t\t// otherwise choose one with the smallest area\n\t\t\t\t\tif (area < minArea) {\n\t\t\t\t\t\tminArea = area;\n\t\t\t\t\t\ttargetNode = child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode = targetNode || node.children[0];\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate _insert(item: Node, level: number, isNode?: boolean) {\n\t\tconst bbox = isNode ? item : this.toBBox(item);\n\t\tconst insertPath: Node[] = [];\n\n\t\t// find the best node for accommodating the item, saving all nodes along the path too\n\t\tconst node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n\t\t// put the item into the node\n\t\tnode.children.push(item);\n\t\textend(node, bbox);\n\n\t\t// split on node overflow; propagate upwards if necessary\n\t\twhile (level >= 0) {\n\t\t\tif (insertPath[level].children.length > this._maxEntries) {\n\t\t\t\tthis._split(insertPath, level);\n\t\t\t\tlevel--;\n\t\t\t} else break;\n\t\t}\n\n\t\t// adjust bboxes along the insertion path\n\t\tthis._adjustParentBBoxes(bbox, insertPath, level);\n\t}\n\n\t// split overflowed node into two\n\tprivate _split(insertPath: Node[], level: number) {\n\t\tconst node = insertPath[level];\n\t\tconst M = node.children.length;\n\t\tconst m = this._minEntries;\n\n\t\tthis._chooseSplitAxis(node, m, M);\n\n\t\tconst splitIndex = this._chooseSplitIndex(node, m, M);\n\n\t\tconst newNode = createNode(\n\t\t\tnode.children.splice(splitIndex, node.children.length - splitIndex),\n\t\t);\n\t\tnewNode.height = node.height;\n\t\tnewNode.leaf = node.leaf;\n\n\t\tcalcBBox(node, this.toBBox);\n\t\tcalcBBox(newNode, this.toBBox);\n\n\t\tif (level) insertPath[level - 1].children.push(newNode);\n\t\telse this._splitRoot(node, newNode);\n\t}\n\n\tprivate _splitRoot(node: Node, newNode: Node) {\n\t\t// split root node\n\t\tthis.data = createNode([node, newNode]);\n\t\tthis.data.height = node.height + 1;\n\t\tthis.data.leaf = false;\n\t\tcalcBBox(this.data, this.toBBox);\n\t}\n\n\tprivate _chooseSplitIndex(node: Node, m: number, M: number) {\n\t\tlet index;\n\t\tlet minOverlap = Infinity;\n\t\tlet minArea = Infinity;\n\n\t\tfor (let i = m; i <= M - m; i++) {\n\t\t\tconst bbox1 = distBBox(node, 0, i, this.toBBox);\n\t\t\tconst bbox2 = distBBox(node, i, M, this.toBBox);\n\n\t\t\tconst overlap = intersectionArea(bbox1, bbox2);\n\t\t\tconst area = bboxArea(bbox1) + bboxArea(bbox2);\n\n\t\t\t// choose distribution with minimum overlap\n\t\t\tif (overlap < minOverlap) {\n\t\t\t\tminOverlap = overlap;\n\t\t\t\tindex = i;\n\n\t\t\t\tminArea = area < minArea ? area : minArea;\n\t\t\t} else if (overlap === minOverlap) {\n\t\t\t\t// otherwise choose distribution with minimum area\n\t\t\t\tif (area < minArea) {\n\t\t\t\t\tminArea = area;\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn index || M - m;\n\t}\n\n\t// sorts node children by the best axis for split\n\tprivate _chooseSplitAxis(node: Node, m: number, M: number) {\n\t\tconst compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n\t\tconst compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n\t\tconst xMargin = this._allDistMargin(node, m, M, compareMinX);\n\t\tconst yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n\t\t// if total distributions margin value is minimal for x, sort by minX,\n\t\t// otherwise it's already sorted by minY\n\t\tif (xMargin < yMargin) {\n\t\t\tnode.children.sort(compareMinX);\n\t\t}\n\t}\n\n\t// total margin of all possible split distributions where each node is at least m full\n\tprivate _allDistMargin(\n\t\tnode: Node,\n\t\tm: number,\n\t\tM: number,\n\t\tcompare: CompareFunction<Node>,\n\t) {\n\t\tnode.children.sort(compare);\n\n\t\tconst toBBox = this.toBBox;\n\t\tconst leftBBox = distBBox(node, 0, m, toBBox);\n\t\tconst rightBBox = distBBox(node, M - m, M, toBBox);\n\t\tlet margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n\t\tfor (let i = m; i < M - m; i++) {\n\t\t\tconst child = node.children[i];\n\t\t\textend(leftBBox, node.leaf ? toBBox(child) : child);\n\t\t\tmargin += bboxMargin(leftBBox);\n\t\t}\n\n\t\tfor (let i = M - m - 1; i >= m; i--) {\n\t\t\tconst child = node.children[i];\n\t\t\textend(rightBBox, node.leaf ? toBBox(child) : child);\n\t\t\tmargin += bboxMargin(rightBBox);\n\t\t}\n\n\t\treturn margin;\n\t}\n\n\tprivate _adjustParentBBoxes(bbox: Node, path: Node[], level: number) {\n\t\t// adjust bboxes along the given tree path\n\t\tfor (let i = level; i >= 0; i--) {\n\t\t\textend(path[i], bbox);\n\t\t}\n\t}\n\n\tprivate _condense(path: Node[]) {\n\t\t// go through the path, removing empty nodes and updating bboxes\n\t\tfor (let i = path.length - 1, siblings; i >= 0; i--) {\n\t\t\tif (path[i].children.length === 0) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsiblings = path[i - 1].children;\n\t\t\t\t\tsiblings.splice(siblings.indexOf(path[i]), 1);\n\t\t\t\t} else this.clear();\n\t\t\t} else {\n\t\t\t\tcalcBBox(path[i], this.toBBox);\n\t\t\t}\n\t\t}\n\t}\n}\n","import { Position } from \"geojson\";\nimport { FeatureId, GeoJSONStoreFeatures } from \"../store\";\nimport { RBush, Node } from \"./rbush\";\n\nexport class SpatialIndex {\n\tprivate tree: RBush;\n\tprivate idToNode: Map<FeatureId, Node>;\n\tprivate nodeToId: Map<Node, FeatureId>;\n\n\tconstructor(options?: { maxEntries: number }) {\n\t\tthis.tree = new RBush(\n\t\t\toptions && options.maxEntries ? options.maxEntries : 9,\n\t\t);\n\t\tthis.idToNode = new Map();\n\t\tthis.nodeToId = new Map();\n\t}\n\n\tprivate setMaps(feature: GeoJSONStoreFeatures, bbox: Node) {\n\t\tthis.idToNode.set(feature.id as FeatureId, bbox);\n\t\tthis.nodeToId.set(bbox, feature.id as FeatureId);\n\t}\n\n\tprivate toBBox(feature: GeoJSONStoreFeatures) {\n\t\tconst longitudes: number[] = [];\n\t\tconst latitudes: number[] = [];\n\n\t\tlet coordinates: Position[];\n\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t} else if (feature.geometry.type === \"Point\") {\n\t\t\tcoordinates = [feature.geometry.coordinates];\n\t\t} else {\n\t\t\tthrow new Error(\"Not a valid feature to turn into a bounding box\");\n\t\t}\n\n\t\tfor (let i = 0; i < coordinates.length; i++) {\n\t\t\tlatitudes.push(coordinates[i][1]);\n\t\t\tlongitudes.push(coordinates[i][0]);\n\t\t}\n\n\t\tconst minLat = Math.min(...latitudes);\n\t\tconst maxLat = Math.max(...latitudes);\n\t\tconst minLng = Math.min(...longitudes);\n\t\tconst maxLng = Math.max(...longitudes);\n\n\t\treturn {\n\t\t\tminX: minLng,\n\t\t\tminY: minLat,\n\t\t\tmaxX: maxLng,\n\t\t\tmaxY: maxLat,\n\t\t} as Node;\n\t}\n\n\tinsert(feature: GeoJSONStoreFeatures): void {\n\t\tif (this.idToNode.get(String(feature.id))) {\n\t\t\tthrow new Error(\"Feature already exists\");\n\t\t}\n\t\tconst bbox = this.toBBox(feature);\n\t\tthis.setMaps(feature, bbox);\n\t\tthis.tree.insert(bbox);\n\t}\n\n\tload(features: GeoJSONStoreFeatures[]): void {\n\t\tconst load: Node[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\t\tfeatures.forEach((feature) => {\n\t\t\tconst bbox = this.toBBox(feature);\n\t\t\tthis.setMaps(feature, bbox);\n\t\t\tif (seenIds.has(String(feature.id))) {\n\t\t\t\tthrow new Error(`Duplicate feature ID found ${feature.id}`);\n\t\t\t}\n\t\t\tseenIds.add(String(feature.id));\n\t\t\tload.push(bbox);\n\t\t});\n\t\tthis.tree.load(load);\n\t}\n\n\tupdate(feature: GeoJSONStoreFeatures): void {\n\t\tthis.remove(feature.id as FeatureId);\n\t\tconst bbox = this.toBBox(feature);\n\t\tthis.setMaps(feature, bbox);\n\t\tthis.tree.insert(bbox);\n\t}\n\n\tremove(featureId: FeatureId): void {\n\t\tconst node = this.idToNode.get(featureId);\n\t\tif (!node) {\n\t\t\tthrow new Error(`${featureId} not inserted into the spatial index`);\n\t\t}\n\n\t\tthis.tree.remove(node);\n\t}\n\n\tclear(): void {\n\t\tthis.tree.clear();\n\t}\n\n\tsearch(feature: GeoJSONStoreFeatures): FeatureId[] {\n\t\tconst found = this.tree.search(this.toBBox(feature));\n\t\treturn found.map((node) => {\n\t\t\treturn this.nodeToId.get(node) as FeatureId;\n\t\t});\n\t}\n\n\tcollides(feature: GeoJSONStoreFeatures): boolean {\n\t\treturn this.tree.collides(this.toBBox(feature));\n\t}\n}\n","import { Feature, Point, Polygon, LineString } from \"geojson\";\nimport { uuid4 } from \"../util/id\";\nimport { SpatialIndex } from \"./spatial-index/spatial-index\";\nimport { isValidTimestamp } from \"./store-feature-validation\";\nimport { Validation } from \"../common\";\n\nexport type JSON = string | number | boolean | null | JSONArray | JSONObject;\n\nexport interface JSONObject {\n\t[member: string]: JSON;\n}\ntype JSONArray = Array<JSON>;\n\ntype DefinedProperties = Record<string, JSON>;\n\nexport type GeoJSONStoreGeometries = Polygon | LineString | Point;\n\nexport type BBoxPolygon = Feature<Polygon, DefinedProperties>;\n\nexport type GeoJSONStoreFeatures = Feature<\n\tGeoJSONStoreGeometries,\n\tDefinedProperties\n>;\n\nexport type StoreValidation = {\n\tid?: FeatureId;\n} & ReturnType<Validation>;\n\ntype StoreChangeEvents = \"delete\" | \"create\" | \"update\" | \"styling\";\n\nexport type StoreChangeHandler<OnChangeContext> = (\n\tids: FeatureId[],\n\tchange: StoreChangeEvents,\n\tcontext?: OnChangeContext,\n) => void;\n\nexport type FeatureId = string | number;\n\nexport type IdStrategy<Id extends FeatureId> = {\n\tisValidId: (id: Id) => boolean;\n\tgetId: () => Id;\n};\n\ntype GeoJSONStoreConfig<Id extends FeatureId> = {\n\tidStrategy?: IdStrategy<Id>;\n\ttracked?: boolean;\n};\n\nexport const defaultIdStrategy = {\n\tgetId: <FeatureId>() => uuid4() as FeatureId,\n\tisValidId: (id: FeatureId) => typeof id === \"string\" && id.length === 36,\n};\n\nexport class GeoJSONStore<\n\tOnChangeContext extends Record<string, JSON> | undefined,\n\tId extends FeatureId = FeatureId,\n> {\n\tconstructor(config?: GeoJSONStoreConfig<Id>) {\n\t\tthis.store = {};\n\t\tthis.spatialIndex = new SpatialIndex();\n\n\t\t// Setting tracked has to happen first\n\t\t// because we use it in featureValidation\n\t\tthis.tracked = config && config.tracked === false ? false : true;\n\t\tthis.idStrategy =\n\t\t\tconfig && config.idStrategy ? config.idStrategy : defaultIdStrategy;\n\t}\n\n\tpublic idStrategy: IdStrategy<Id>;\n\n\tprivate tracked: boolean;\n\n\tprivate spatialIndex: SpatialIndex;\n\n\tprivate store: {\n\t\t[key: FeatureId]: GeoJSONStoreFeatures;\n\t};\n\n\t// Default to no-op\n\tprivate _onChange: StoreChangeHandler<OnChangeContext | undefined> = () => {};\n\n\tprivate clone<T>(obj: T): T {\n\t\treturn JSON.parse(JSON.stringify(obj));\n\t}\n\n\tgetId(): FeatureId {\n\t\treturn this.idStrategy.getId();\n\t}\n\n\thas(id: FeatureId): boolean {\n\t\treturn Boolean(this.store[id]);\n\t}\n\n\tload(\n\t\tdata: GeoJSONStoreFeatures[],\n\t\tfeatureValidation?: (\n\t\t\tfeature: unknown,\n\t\t\ttracked?: boolean,\n\t\t) => StoreValidation,\n\t\tafterFeatureAdded?: (feature: GeoJSONStoreFeatures) => void,\n\t\tcontext?: OnChangeContext,\n\t): StoreValidation[] {\n\t\tif (data.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// We don't want to update the original data\n\t\tlet clonedInputFeatures = this.clone(data);\n\n\t\tconst validations: StoreValidation[] = []; // The list of validations that we will return\n\t\tconst createdFeatures: GeoJSONStoreFeatures[] = []; // Keep track of the features we created\n\n\t\t// We filter out the features that are not valid and do not add them to the store\n\t\tclonedInputFeatures = clonedInputFeatures.filter((feature) => {\n\t\t\tif (feature.id === undefined || feature.id === null) {\n\t\t\t\tfeature.id = this.idStrategy.getId();\n\t\t\t}\n\n\t\t\tconst id = feature.id as FeatureId;\n\t\t\tif (featureValidation) {\n\t\t\t\tconst validation = featureValidation(feature);\n\n\t\t\t\t// Generic error handling if the featureValidation function\n\t\t\t\t// does not throw something more specific itself\n\t\t\t\tif (!validation.valid) {\n\t\t\t\t\tvalidations.push({ id, valid: false, reason: validation.reason });\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.tracked) {\n\t\t\t\tif (!feature.properties.createdAt) {\n\t\t\t\t\tfeature.properties.createdAt = +new Date();\n\t\t\t\t} else {\n\t\t\t\t\tconst valid = isValidTimestamp(feature.properties.createdAt);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\tvalidations.push({\n\t\t\t\t\t\t\tid: feature.id as FeatureId,\n\t\t\t\t\t\t\tvalid: false,\n\t\t\t\t\t\t\treason: \"createdAt is not a valid numeric timestamp\",\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!feature.properties.updatedAt) {\n\t\t\t\t\tfeature.properties.updatedAt = +new Date();\n\t\t\t\t} else {\n\t\t\t\t\tconst valid = isValidTimestamp(feature.properties.updatedAt);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\tvalidations.push({\n\t\t\t\t\t\t\tid: feature.id as FeatureId,\n\t\t\t\t\t\t\tvalid: false,\n\t\t\t\t\t\t\treason: \"updatedAt is not a valid numeric timestamp\",\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We have to be sure that the feature does not already exist with this ID\n\t\t\tif (this.has(id)) {\n\t\t\t\tvalidations.push({\n\t\t\t\t\tid,\n\t\t\t\t\tvalid: false,\n\t\t\t\t\treason: `Feature already exists with this id: ${id}`,\n\t\t\t\t});\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.store[id] = feature;\n\n\t\t\tcreatedFeatures.push(feature);\n\n\t\t\tvalidations.push({ id, valid: true });\n\n\t\t\t// Feature is valid so keep it in the list\n\t\t\treturn true;\n\t\t});\n\n\t\tthis.spatialIndex.load(clonedInputFeatures);\n\n\t\t// The list of changes that we will trigger to onChange\n\t\tconst changes = createdFeatures.map(({ id }) => id as FeatureId);\n\n\t\t// Only trigger onChange with a 'create' change type if we have actually created features\n\t\tif (changes.length > 0) {\n\t\t\tthis._onChange(changes, \"create\", context);\n\n\t\t\tif (afterFeatureAdded) {\n\t\t\t\tcreatedFeatures.forEach((feature) => {\n\t\t\t\t\tafterFeatureAdded(feature);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn validations;\n\t}\n\n\tsearch(\n\t\tbbox: BBoxPolygon,\n\t\tfilter?: (feature: GeoJSONStoreFeatures) => boolean,\n\t) {\n\t\tconst features = this.spatialIndex.search(bbox).map((id) => this.store[id]);\n\t\tif (filter) {\n\t\t\treturn this.clone(features.filter(filter));\n\t\t} else {\n\t\t\treturn this.clone(features);\n\t\t}\n\t}\n\n\tregisterOnChange(onChange: StoreChangeHandler<OnChangeContext | undefined>) {\n\t\tthis._onChange = (ids, change, context) => {\n\t\t\tonChange(ids, change, context);\n\t\t};\n\t}\n\n\tgetGeometryCopy<T extends GeoJSONStoreGeometries>(id: FeatureId): T {\n\t\tconst feature = this.store[id];\n\t\tif (!feature) {\n\t\t\tthrow new Error(\n\t\t\t\t`No feature with this id (${id}), can not get geometry copy`,\n\t\t\t);\n\t\t}\n\t\treturn this.clone(feature.geometry as T);\n\t}\n\n\tgetPropertiesCopy(id: FeatureId) {\n\t\tconst feature = this.store[id];\n\t\tif (!feature) {\n\t\t\tthrow new Error(\n\t\t\t\t`No feature with this id (${id}), can not get properties copy`,\n\t\t\t);\n\t\t}\n\t\treturn this.clone(feature.properties);\n\t}\n\n\tupdateProperty(\n\t\tpropertiesToUpdate: {\n\t\t\tid: FeatureId;\n\t\t\tproperty: string;\n\t\t\tvalue: JSON | undefined;\n\t\t}[],\n\t\tcontext?: OnChangeContext,\n\t): void {\n\t\tconst ids: FeatureId[] = [];\n\t\tpropertiesToUpdate.forEach(({ id, property, value }) => {\n\t\t\tconst feature = this.store[id];\n\n\t\t\tif (!feature) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No feature with this (${id}), can not update geometry`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tids.push(id);\n\n\t\t\tif (value === undefined) {\n\t\t\t\tdelete feature.properties[property];\n\t\t\t} else {\n\t\t\t\tfeature.properties[property] = value;\n\t\t\t}\n\n\t\t\t// Update the time the feature was updated\n\t\t\tif (this.tracked) {\n\t\t\t\tfeature.properties.updatedAt = +new Date();\n\t\t\t}\n\t\t});\n\n\t\tif (this._onChange) {\n\t\t\tthis._onChange(ids, \"update\", context);\n\t\t}\n\t}\n\n\tupdateGeometry(\n\t\tgeometriesToUpdate: { id: FeatureId; geometry: GeoJSONStoreGeometries }[],\n\t\tcontext?: OnChangeContext,\n\t): void {\n\t\tconst ids: FeatureId[] = [];\n\t\tgeometriesToUpdate.forEach(({ id, geometry }) => {\n\t\t\tids.push(id);\n\n\t\t\tconst feature = this.store[id];\n\n\t\t\tif (!feature) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No feature with this (${id}), can not update geometry`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfeature.geometry = this.clone(geometry);\n\n\t\t\tthis.spatialIndex.update(feature);\n\n\t\t\t// Update the time the feature was updated\n\t\t\tif (this.tracked) {\n\t\t\t\tfeature.properties.updatedAt = +new Date();\n\t\t\t}\n\t\t});\n\n\t\tif (this._onChange) {\n\t\t\tthis._onChange(ids, \"update\", context);\n\t\t}\n\t}\n\n\tcreate<Id extends FeatureId>(\n\t\tfeatures: {\n\t\t\tgeometry: GeoJSONStoreGeometries;\n\t\t\tproperties?: JSONObject;\n\t\t}[],\n\t\tcontext?: OnChangeContext,\n\t): Id[] {\n\t\tconst ids: FeatureId[] = [];\n\t\tfeatures.forEach(({ geometry, properties }) => {\n\t\t\tlet createdAt;\n\t\t\tlet createdProperties = { ...properties };\n\n\t\t\tif (this.tracked) {\n\t\t\t\tcreatedAt = +new Date();\n\n\t\t\t\tif (properties) {\n\t\t\t\t\tcreatedProperties.createdAt =\n\t\t\t\t\t\ttypeof properties.createdAt === \"number\"\n\t\t\t\t\t\t\t? properties.createdAt\n\t\t\t\t\t\t\t: createdAt;\n\t\t\t\t\tcreatedProperties.updatedAt =\n\t\t\t\t\t\ttypeof properties.updatedAt === \"number\"\n\t\t\t\t\t\t\t? properties.updatedAt\n\t\t\t\t\t\t\t: createdAt;\n\t\t\t\t} else {\n\t\t\t\t\tcreatedProperties = { createdAt, updatedAt: createdAt };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst id = this.getId();\n\t\t\tconst feature = {\n\t\t\t\tid,\n\t\t\t\ttype: \"Feature\",\n\t\t\t\tgeometry,\n\t\t\t\tproperties: createdProperties,\n\t\t\t} as GeoJSONStoreFeatures;\n\n\t\t\tthis.store[id] = feature;\n\t\t\tthis.spatialIndex.insert(feature);\n\n\t\t\tids.push(id);\n\t\t});\n\n\t\tif (this._onChange) {\n\t\t\tthis._onChange([...ids], \"create\", context);\n\t\t}\n\n\t\treturn ids as Id[];\n\t}\n\n\tdelete(ids: FeatureId[], context?: OnChangeContext): void {\n\t\tids.forEach((id) => {\n\t\t\tif (this.store[id]) {\n\t\t\t\tdelete this.store[id];\n\t\t\t\tthis.spatialIndex.remove(id as FeatureId);\n\t\t\t} else {\n\t\t\t\tthrow new Error(`No feature with id ${id}, can not delete`);\n\t\t\t}\n\t\t});\n\n\t\tif (this._onChange) {\n\t\t\tthis._onChange([...ids], \"delete\", context);\n\t\t}\n\t}\n\n\tcopy(id: FeatureId): GeoJSONStoreFeatures {\n\t\treturn this.clone(this.store[id]);\n\t}\n\n\tcopyAll(): GeoJSONStoreFeatures[] {\n\t\treturn this.clone(Object.keys(this.store).map((id) => this.store[id]));\n\t}\n\n\tcopyAllWhere(\n\t\tequals: (properties: JSONObject) => boolean,\n\t): GeoJSONStoreFeatures[] {\n\t\treturn this.clone(\n\t\t\tObject.keys(this.store)\n\t\t\t\t.map((id) => this.store[id])\n\t\t\t\t.filter((feature) => {\n\t\t\t\t\treturn feature.properties && equals(feature.properties);\n\t\t\t\t}),\n\t\t);\n\t}\n\n\tclear(): void {\n\t\tthis.store = {};\n\t\tthis.spatialIndex.clear();\n\t}\n\n\tsize(): number {\n\t\treturn Object.keys(this.store).length;\n\t}\n}\n","export const uuid4 = function (): string {\n\treturn \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n\t\tconst r = (Math.random() * 16) | 0,\n\t\t\tv = c == \"x\" ? r : (r & 0x3) | 0x8;\n\t\treturn v.toString(16);\n\t});\n};\n","import { Polygon } from \"geojson\";\nimport { earthRadius } from \"../helpers\";\n\n// Adapted from @turf/area is MIT Licensed licensed https://github.com/Turfjs/turf/blob/master/packages/turf-area/index.ts\n// In turn adapted from NASA: https://dataverse.jpl.nasa.gov/file.xhtml?fileId=47998&version=2.0\n\nexport function polygonAreaSquareMeters(polygon: Polygon) {\n\tconst coords = polygon.coordinates;\n\tlet total = 0;\n\tif (coords && coords.length > 0) {\n\t\ttotal += Math.abs(ringArea(coords[0]));\n\t\tfor (let i = 1; i < coords.length; i++) {\n\t\t\ttotal -= Math.abs(ringArea(coords[i]));\n\t\t}\n\t}\n\treturn total;\n}\n\nconst FACTOR = (earthRadius * earthRadius) / 2;\nconst PI_OVER_180 = Math.PI / 180;\n\nfunction ringArea(coords: number[][]): number {\n\tconst coordsLength = coords.length;\n\n\tif (coordsLength <= 2) {\n\t\treturn 0;\n\t}\n\n\tlet total = 0;\n\n\tlet i = 0;\n\twhile (i < coordsLength) {\n\t\tconst lower = coords[i];\n\t\tconst middle = coords[i + 1 === coordsLength ? 0 : i + 1];\n\t\tconst upper =\n\t\t\tcoords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];\n\n\t\tconst lowerX = lower[0] * PI_OVER_180;\n\t\tconst middleY = middle[1] * PI_OVER_180;\n\t\tconst upperX = upper[0] * PI_OVER_180;\n\n\t\ttotal += (upperX - lowerX) * Math.sin(middleY);\n\n\t\ti++;\n\t}\n\n\treturn total * FACTOR;\n}\n","import { Validation } from \"../common\";\nimport { polygonAreaSquareMeters } from \"../geometry/measure/area\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport { ValidationReasonFeatureNotPolygon } from \"./common-validations\";\n\nexport const ValidationReasonFeatureLessThanMinSize =\n\t\"Feature is smaller than the minimum area\";\n\nexport const ValidateMinAreaSquareMeters = (\n\tfeature: GeoJSONStoreFeatures,\n\tminSize: number,\n): ReturnType<Validation> => {\n\tif (feature.geometry.type !== \"Polygon\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPolygon,\n\t\t};\n\t}\n\n\tif (polygonAreaSquareMeters(feature.geometry) < minSize) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureLessThanMinSize,\n\t\t};\n\t}\n\n\treturn { valid: true };\n};\n","import { Validation } from \"../common\";\nimport { polygonAreaSquareMeters } from \"../geometry/measure/area\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport { ValidationReasonFeatureNotPolygon } from \"./common-validations\";\n\nexport const ValidationMaxAreaSquareMetersReason =\n\t\"Feature is larger than the maximum area\";\n\nexport const ValidateMaxAreaSquareMeters = (\n\tfeature: GeoJSONStoreFeatures,\n\tmaxSize: number,\n): ReturnType<Validation> => {\n\tif (feature.geometry.type !== \"Polygon\") {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPolygon,\n\t\t};\n\t}\n\n\tconst size = polygonAreaSquareMeters(feature.geometry);\n\n\tif (size > maxSize) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationMaxAreaSquareMetersReason,\n\t\t};\n\t}\n\n\treturn { valid: true };\n};\n","import { Feature, LineString, Polygon } from \"geojson\";\nimport { selfIntersects } from \"../geometry/boolean/self-intersects\";\nimport { GeoJSONStoreFeatures } from \"../terra-draw\";\nimport { Validation } from \"../common\";\n\nexport const ValidationReasonFeatureNotPolygonOrLineString =\n\t\"Feature is not a Polygon or LineString\";\nexport const ValidationReasonFeatureSelfIntersects =\n\t\"Feature intersects itself\";\n\nexport const ValidateNotSelfIntersecting = (\n\tfeature: GeoJSONStoreFeatures,\n): ReturnType<Validation> => {\n\tif (\n\t\tfeature.geometry.type !== \"Polygon\" &&\n\t\tfeature.geometry.type !== \"LineString\"\n\t) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureNotPolygonOrLineString,\n\t\t};\n\t}\n\n\tconst hasSelfIntersections = selfIntersects(\n\t\tfeature as Feature<LineString> | Feature<Polygon>,\n\t);\n\n\tif (hasSelfIntersections) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\treason: ValidationReasonFeatureSelfIntersects,\n\t\t};\n\t}\n\n\treturn { valid: true };\n};\n","import { CartesianPoint } from \"../common\";\nimport { webMercatorBearing } from \"./measure/bearing\";\n\n/**\n * Calculate the relative angle between two lines\n * @param A The first point of the first line\n * @param B The second point of the first line and the first point of the second line\n * @param C The second point of the second line\n * @returns The relative angle between the two lines\n */\nexport function calculateRelativeAngle(\n\tA: CartesianPoint,\n\tB: CartesianPoint,\n\tC: CartesianPoint,\n): number {\n\tconst bearingAB = webMercatorBearing(A, B); // Bearing from A to B\n\tconst bearingBC = webMercatorBearing(B, C); // Bearing from B to C\n\n\t// Calculate the relative angle (bearingBC relative to bearingAB)\n\tlet relativeAngle = bearingBC - bearingAB;\n\n\t// Normalize the relative angle to 0-360 range\n\tif (relativeAngle < 0) {\n\t\trelativeAngle += 360;\n\t}\n\n\t// Normalise to 0 - 90\n\tconst angle = relativeAngle - 90;\n\n\treturn 180 - Math.abs(-90 + angle);\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { Polygon } from \"geojson\";\nimport {\n\tTerraDrawBaseDrawMode,\n\tBaseModeOptions,\n\tCustomStyling,\n} from \"../base.mode\";\nimport { coordinatesIdentical } from \"../../geometry/coordinates-identical\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { webMercatorDestination } from \"../../geometry/measure/destination\";\nimport { webMercatorBearing } from \"../../geometry/measure/bearing\";\nimport { midpointCoordinate } from \"../../geometry/midpoint-coordinate\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../geometry/project/web-mercator\";\nimport { degreesToRadians } from \"../../geometry/helpers\";\nimport { determineHalfPlane } from \"../../geometry/determine-halfplane\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { calculateRelativeAngle } from \"../../geometry/calculate-relative-angle\";\n\ntype TerraDrawPolygonModeKeyEvents = {\n\tcancel?: KeyboardEvent[\"key\"] | null;\n\tfinish?: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype PolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawPolygonModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawPolygonModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawAngledRectangleMode extends TerraDrawBaseDrawMode<PolygonStyling> {\n\tmode = \"angled-rectangle\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawPolygonModeKeyEvents = defaultKeyEvents;\n\n\t// Behaviors\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\n\tconstructor(options?: TerraDrawPolygonModeOptions<PolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawPolygonModeOptions<PolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\tvalue: undefined,\n\t\t\t},\n\t\t]);\n\n\t\tconst finishedId = this.currentId;\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentId = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\n\t\tif (this.currentId === undefined || this.currentCoordinate === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t).coordinates[0];\n\n\t\tlet updatedCoordinates;\n\n\t\tif (this.currentCoordinate === 1) {\n\t\t\t// We must add a very small epsilon value so that Mapbox GL\n\t\t\t// renders the polygon - There might be a cleaner solution?\n\t\t\tconst epsilon = 1 / Math.pow(10, this.coordinatePrecision - 1);\n\t\t\tconst offset = Math.max(0.000001, epsilon);\n\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\t[event.lng, event.lat - offset],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t} else if (this.currentCoordinate === 2) {\n\t\t\tconst firstCoordinate = currentPolygonCoordinates[0];\n\t\t\tconst secondCoordinate = currentPolygonCoordinates[1];\n\t\t\tconst midpoint = midpointCoordinate(\n\t\t\t\tfirstCoordinate,\n\t\t\t\tsecondCoordinate,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t\tthis.project,\n\t\t\t\tthis.unproject,\n\t\t\t);\n\n\t\t\tconst A = lngLatToWebMercatorXY(firstCoordinate[0], firstCoordinate[1]);\n\t\t\tconst B = lngLatToWebMercatorXY(midpoint[0], midpoint[1]);\n\t\t\tconst C = lngLatToWebMercatorXY(secondCoordinate[0], secondCoordinate[1]);\n\t\t\tconst D = lngLatToWebMercatorXY(event.lng, event.lat);\n\n\t\t\t// Determine if the cursor is closer to A or C\n\t\t\tconst distanceToA = cartesianDistance(D, A);\n\t\t\tconst distanceToB = cartesianDistance(D, C);\n\t\t\tconst ACloserThanC = distanceToA < distanceToB ? true : false;\n\n\t\t\t// We need to work out if the cursor is closer to A or C and then calculate the angle\n\t\t\t// between the cursor and the opposing midpoint\n\t\t\tconst relativeAngle = calculateRelativeAngle(A, B, D);\n\t\t\tconst theta = ACloserThanC\n\t\t\t\t? 90 - relativeAngle\n\t\t\t\t: calculateRelativeAngle(A, B, D) - 90;\n\n\t\t\t// We want to calculate the adjacent i.e. the calculated distance\n\t\t\t// between the cursor and the opposing midpoint\n\t\t\tconst hypotenuse = cartesianDistance(B, D);\n\t\t\tconst adjacent = Math.cos(degreesToRadians(theta)) * hypotenuse;\n\n\t\t\t// Calculate the bearing between the first and second point\n\t\t\tconst firstAndSecondPointBearing = webMercatorBearing(A, C);\n\n\t\t\t// Determine which side of the line the cursor is on\n\t\t\tconst side = determineHalfPlane(A, C, D);\n\n\t\t\t// Determine which direction to draw the rectangle\n\t\t\tconst angle = side === \"right\" ? -90 : 90;\n\n\t\t\t// Calculate the third and fourth coordinates based on the cursor position\n\t\t\tconst rectangleAngle = firstAndSecondPointBearing + angle;\n\t\t\tconst thirdCoordinateXY = webMercatorDestination(\n\t\t\t\tA,\n\t\t\t\tadjacent,\n\t\t\t\trectangleAngle,\n\t\t\t);\n\t\t\tconst fourthCoordinateXY = webMercatorDestination(\n\t\t\t\tC,\n\t\t\t\tadjacent,\n\t\t\t\trectangleAngle,\n\t\t\t);\n\n\t\t\t// Convert the third and fourth coordinates back to lng/lat\n\t\t\tconst thirdCoordinate = webMercatorXYToLngLat(\n\t\t\t\tthirdCoordinateXY.x,\n\t\t\t\tthirdCoordinateXY.y,\n\t\t\t);\n\t\t\tconst fourthCoordinate = webMercatorXYToLngLat(\n\t\t\t\tfourthCoordinateXY.x,\n\t\t\t\tfourthCoordinateXY.y,\n\t\t\t);\n\n\t\t\t// The final coordinates\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\tcurrentPolygonCoordinates[1],\n\t\t\t\t[fourthCoordinate.lng, fourthCoordinate.lat],\n\t\t\t\t[thirdCoordinate.lng, thirdCoordinate.lat],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t}\n\n\t\tif (updatedCoordinates) {\n\t\t\tthis.updatePolygonGeometry(\n\t\t\t\tthis.currentId,\n\t\t\t\tupdatedCoordinates,\n\t\t\t\tUpdateTypes.Provisional,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate updatePolygonGeometry(\n\t\tid: FeatureId,\n\t\tcoordinates: Polygon[\"coordinates\"][0],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [coordinates],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([{ id, geometry: updatedGeometry }]);\n\n\t\treturn true;\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\t// We want pointer devices (mobile/tablet) to have\n\t\t\t// similar behaviour to mouse based devices so we\n\t\t\t// trigger a mousemove event before every click\n\t\t\t// if one has not been triggered to emulate this\n\t\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\t\tthis.onMouseMove(event);\n\t\t\t}\n\t\t\tthis.mouseMove = false;\n\n\t\t\tif (this.currentCoordinate === 0) {\n\t\t\t\tconst [newId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentId = newId;\n\t\t\t\tthis.currentCoordinate++;\n\n\t\t\t\t// Ensure the state is updated to reflect drawing has started\n\t\t\t\tthis.setDrawing();\n\t\t\t} else if (this.currentCoordinate === 1 && this.currentId) {\n\t\t\t\tconst currentPolygonGeometry = this.store.getGeometryCopy<Polygon>(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\n\t\t\t\tconst previousCoordinate = currentPolygonGeometry.coordinates[0][0];\n\t\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tpreviousCoordinate,\n\t\t\t\t);\n\n\t\t\t\tif (isIdentical) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t\t[\n\t\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t],\n\t\t\t\t\tUpdateTypes.Commit,\n\t\t\t\t);\n\n\t\t\t\tif (!updated) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.currentCoordinate++;\n\t\t\t} else if (this.currentCoordinate === 2 && this.currentId) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\t// We don't want to close a unfinished polygon\n\t\t\tif (this.currentCoordinate < 2) {\n\t\t\t\tthis.cleanUp();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\ttry {\n\t\t\tif (this.currentId) {\n\t\t\t\tthis.store.delete([this.currentId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t\tthis.currentId = undefined;\n\t\tthis.currentCoordinate = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (feature.properties.mode === this.mode) {\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.fillColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a rectangle and the feature being updated is the current rectangle,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentId === feature.id) {\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.currentCoordinate = 0;\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { CartesianPoint } from \"../common\";\n\n// Function to determine the relative position of a point to a line segment\nexport function determineHalfPlane(\n\tpoint: CartesianPoint,\n\tlineStart: CartesianPoint,\n\tlineEnd: CartesianPoint,\n): string {\n\t// Calculate the vectors\n\tconst vectorLine = { x: lineEnd.x - lineStart.x, y: lineEnd.y - lineStart.y };\n\tconst vectorPoint = { x: point.x - lineStart.x, y: point.y - lineStart.y };\n\n\t// Calculate the cross product\n\tconst crossProduct =\n\t\tvectorLine.x * vectorPoint.y - vectorLine.y * vectorPoint.x;\n\n\t// Use a small epsilon value to handle floating-point precision errors\n\tconst epsilon = 1e-10;\n\n\tif (crossProduct > epsilon) {\n\t\treturn \"left\";\n\t} else if (crossProduct < -epsilon) {\n\t\treturn \"right\";\n\t} else {\n\t\t// Technically on the line but we treat it as left\n\t\treturn \"left\";\n\t}\n}\n","import { CartesianPoint } from \"../common\";\n\nexport function isClockwiseWebMercator(\n\tcenter: CartesianPoint,\n\tsecondCoord: CartesianPoint,\n\tthirdCoord: CartesianPoint,\n): boolean {\n\t// Calculate the vectors\n\tconst vector1 = { x: secondCoord.x - center.x, y: secondCoord.y - center.y };\n\tconst vector2 = { x: thirdCoord.x - center.x, y: thirdCoord.y - center.y };\n\n\t// Calculate the cross product\n\tconst cross = vector1.x * vector2.y - vector1.y * vector2.x;\n\n\t// If the cross product is negative, the third point is on the right (clockwise)\n\t// If the cross product is positive, the third point is on the left (anticlockwise)\n\treturn cross <= 0;\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { Polygon, Position } from \"geojson\";\nimport {\n\tTerraDrawBaseDrawMode,\n\tBaseModeOptions,\n\tCustomStyling,\n} from \"../base.mode\";\nimport { coordinatesIdentical } from \"../../geometry/coordinates-identical\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { webMercatorDestination } from \"../../geometry/measure/destination\";\nimport {\n\tnormalizeBearing,\n\twebMercatorBearing,\n} from \"../../geometry/measure/bearing\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../geometry/project/web-mercator\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { isClockwiseWebMercator } from \"../../geometry/clockwise\";\nimport { limitPrecision } from \"../../geometry/limit-decimal-precision\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\n\ntype TerraDrawSectorModeKeyEvents = {\n\tcancel?: KeyboardEvent[\"key\"] | null;\n\tfinish?: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype SectorPolygonStyling = {\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawSectorModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tarcPoints?: number;\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawSectorModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawSectorMode extends TerraDrawBaseDrawMode<SectorPolygonStyling> {\n\tmode = \"sector\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawSectorModeKeyEvents = defaultKeyEvents;\n\tprivate direction: \"clockwise\" | \"anticlockwise\" | undefined;\n\tprivate arcPoints: number = 64;\n\n\t// Behaviors\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\n\tconstructor(options?: TerraDrawSectorModeOptions<SectorPolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawSectorModeOptions<SectorPolygonStyling>,\n\t) {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.arcPoints) {\n\t\t\tthis.arcPoints = options.arcPoints;\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fix right hand rule if necessary\n\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId),\n\t\t);\n\t\tif (correctedGeometry) {\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{ id: this.currentId, geometry: correctedGeometry },\n\t\t\t]);\n\t\t}\n\t\tthis.store.updateProperty([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\tvalue: undefined,\n\t\t\t},\n\t\t]);\n\n\t\tconst finishedId = this.currentId;\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentId = undefined;\n\t\tthis.direction = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\n\t\tif (this.currentId === undefined || this.currentCoordinate === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<Polygon>(\n\t\t\tthis.currentId,\n\t\t).coordinates[0];\n\n\t\tlet updatedCoordinates: Polygon[\"coordinates\"][0] | undefined;\n\n\t\tif (this.currentCoordinate === 1) {\n\t\t\t// We must add a very small epsilon value so that Mapbox GL\n\t\t\t// renders the polygon - There might be a cleaner solution?\n\t\t\tconst epsilon = 1 / Math.pow(10, this.coordinatePrecision - 1);\n\t\t\tconst offset = Math.max(0.000001, epsilon);\n\n\t\t\tupdatedCoordinates = [\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t\t[event.lng, event.lat],\n\t\t\t\t[event.lng, event.lat - offset],\n\t\t\t\tcurrentPolygonCoordinates[0],\n\t\t\t];\n\t\t} else if (this.currentCoordinate === 2) {\n\t\t\tconst center = currentPolygonCoordinates[0];\n\t\t\tconst arcCoordOne = currentPolygonCoordinates[1];\n\t\t\tconst arcCoordTwo = [event.lng, event.lat];\n\n\t\t\t// Convert coordinates to Web Mercator\n\t\t\tconst webMercatorCenter = lngLatToWebMercatorXY(center[0], center[1]);\n\t\t\tconst webMercatorArcCoordOne = lngLatToWebMercatorXY(\n\t\t\t\tarcCoordOne[0],\n\t\t\t\tarcCoordOne[1],\n\t\t\t);\n\t\t\tconst webMercatorArcCoordTwo = lngLatToWebMercatorXY(\n\t\t\t\tarcCoordTwo[0],\n\t\t\t\tarcCoordTwo[1],\n\t\t\t);\n\n\t\t\t// We want to determine the direction of the sector, whether\n\t\t\t// it is clockwise or anticlockwise\n\t\t\tif (this.direction === undefined) {\n\t\t\t\tconst clockwise = isClockwiseWebMercator(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\twebMercatorArcCoordOne,\n\t\t\t\t\twebMercatorArcCoordTwo,\n\t\t\t\t);\n\t\t\t\tthis.direction = clockwise ? \"clockwise\" : \"anticlockwise\";\n\t\t\t}\n\n\t\t\t// Calculate the radius (distance from center to second point in Web Mercator)\n\t\t\tconst radius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordOne,\n\t\t\t);\n\n\t\t\t// Calculate bearings for the second and third points in Web Mercator\n\t\t\tconst startBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordOne,\n\t\t\t);\n\t\t\tconst endBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordTwo,\n\t\t\t);\n\n\t\t\t// Generate points along the arc in Web Mercator\n\t\t\tconst numberOfPoints = this.arcPoints; // Number of points to approximate the arc\n\t\t\tconst coordinates: Position[] = [center]; // Start with the center (in WGS84)\n\n\t\t\t// Corrected version to calculate deltaBearing\n\t\t\tconst normalizedStart = normalizeBearing(startBearing);\n\t\t\tconst normalizedEnd = normalizeBearing(endBearing);\n\n\t\t\t// Calculate the delta bearing based on the direction\n\t\t\tlet deltaBearing;\n\t\t\tif (this.direction === \"anticlockwise\") {\n\t\t\t\tdeltaBearing = normalizedEnd - normalizedStart;\n\t\t\t\tif (deltaBearing < 0) {\n\t\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdeltaBearing = normalizedStart - normalizedEnd;\n\t\t\t\tif (deltaBearing < 0) {\n\t\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst bearingStep =\n\t\t\t\t((this.direction === \"anticlockwise\" ? 1 : -1) * deltaBearing) /\n\t\t\t\tnumberOfPoints;\n\n\t\t\t// Add the first coordinate to the polygon\n\t\t\tcoordinates.push(arcCoordOne);\n\n\t\t\t// Add all the arc points\n\t\t\tfor (let i = 0; i <= numberOfPoints; i++) {\n\t\t\t\tconst currentBearing = normalizedStart + i * bearingStep;\n\t\t\t\tconst pointOnArc = webMercatorDestination(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\tradius,\n\t\t\t\t\tcurrentBearing,\n\t\t\t\t);\n\t\t\t\tconst { lng, lat } = webMercatorXYToLngLat(pointOnArc.x, pointOnArc.y);\n\n\t\t\t\tconst nextCoord = [\n\t\t\t\t\tlimitPrecision(lng, this.coordinatePrecision),\n\t\t\t\t\tlimitPrecision(lat, this.coordinatePrecision),\n\t\t\t\t];\n\n\t\t\t\tconst notIdentical =\n\t\t\t\t\tnextCoord[0] !== coordinates[coordinates.length - 1][0] &&\n\t\t\t\t\tnextCoord[1] !== coordinates[coordinates.length - 1][1];\n\t\t\t\tif (notIdentical) {\n\t\t\t\t\tcoordinates.push(nextCoord);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Close the polygon\n\t\t\tcoordinates.push(center);\n\n\t\t\tupdatedCoordinates = [...coordinates];\n\t\t}\n\n\t\tif (updatedCoordinates) {\n\t\t\tthis.updatePolygonGeometry(\n\t\t\t\tthis.currentId,\n\t\t\t\tupdatedCoordinates,\n\t\t\t\tUpdateTypes.Provisional,\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate updatePolygonGeometry(\n\t\tid: FeatureId,\n\t\tcoordinates: Polygon[\"coordinates\"][0],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [coordinates],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([{ id, geometry: updatedGeometry }]);\n\n\t\treturn true;\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\t// We want pointer devices (mobile/tablet) to have\n\t\t\t// similar behaviour to mouse based devices so we\n\t\t\t// trigger a mousemove event before every click\n\t\t\t// if one has not been triggered to emulate this\n\t\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\t\tthis.onMouseMove(event);\n\t\t\t}\n\t\t\tthis.mouseMove = false;\n\n\t\t\tif (this.currentCoordinate === 0) {\n\t\t\t\tconst [newId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentId = newId;\n\t\t\t\tthis.currentCoordinate++;\n\n\t\t\t\t// Ensure the state is updated to reflect drawing has started\n\t\t\t\tthis.setDrawing();\n\t\t\t} else if (this.currentCoordinate === 1 && this.currentId) {\n\t\t\t\tconst currentPolygonGeometry = this.store.getGeometryCopy<Polygon>(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t);\n\n\t\t\t\tconst previousCoordinate = currentPolygonGeometry.coordinates[0][0];\n\t\t\t\tconst isIdentical = coordinatesIdentical(\n\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\tpreviousCoordinate,\n\t\t\t\t);\n\n\t\t\t\tif (isIdentical) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst updated = this.updatePolygonGeometry(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t\t[\n\t\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\tcurrentPolygonGeometry.coordinates[0][0],\n\t\t\t\t\t],\n\t\t\t\t\tUpdateTypes.Commit,\n\t\t\t\t);\n\n\t\t\t\tif (!updated) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.currentCoordinate++;\n\t\t\t} else if (this.currentCoordinate === 2 && this.currentId) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\ttry {\n\t\t\tif (this.currentId) {\n\t\t\t\tthis.store.delete([this.currentId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t\tthis.currentId = undefined;\n\t\tthis.direction = undefined;\n\t\tthis.currentCoordinate = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (feature.properties.mode === this.mode) {\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.fillColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a sector and the feature being updated is the current sector,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentId === feature.id) {\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.direction = undefined;\n\t\t\tthis.currentCoordinate = 0;\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tZ_INDEX,\n\tCOMMON_PROPERTIES,\n} from \"../../common\";\nimport { LineString, Point, Polygon, Position } from \"geojson\";\nimport {\n\tTerraDrawBaseDrawMode,\n\tBaseModeOptions,\n\tCustomStyling,\n} from \"../base.mode\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { ValidateNonIntersectingPolygonFeature } from \"../../validations/polygon.validation\";\nimport { webMercatorDestination } from \"../../geometry/measure/destination\";\nimport {\n\tnormalizeBearing,\n\twebMercatorBearing,\n} from \"../../geometry/measure/bearing\";\nimport {\n\tlngLatToWebMercatorXY,\n\twebMercatorXYToLngLat,\n} from \"../../geometry/project/web-mercator\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { isClockwiseWebMercator } from \"../../geometry/clockwise\";\nimport { limitPrecision } from \"../../geometry/limit-decimal-precision\";\nimport { ensureRightHandRule } from \"../../geometry/ensure-right-hand-rule\";\n\ntype TerraDrawSensorModeKeyEvents = {\n\tcancel?: KeyboardEvent[\"key\"] | null;\n\tfinish?: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype SensorPolygonStyling = {\n\tcenterPointColor: HexColorStyling;\n\tcenterPointWidth: NumericStyling;\n\tcenterPointOutlineColor: HexColorStyling;\n\tcenterPointOutlineWidth: NumericStyling;\n\tfillColor: HexColorStyling;\n\toutlineColor: HexColorStyling;\n\toutlineWidth: NumericStyling;\n\tfillOpacity: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawSensorModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tarcPoints?: number;\n\tpointerDistance?: number;\n\tkeyEvents?: TerraDrawSensorModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawSensorMode extends TerraDrawBaseDrawMode<SensorPolygonStyling> {\n\tmode = \"sensor\" as const;\n\n\tprivate currentCoordinate = 0;\n\tprivate currentId: FeatureId | undefined;\n\tprivate currentInitialArcId: FeatureId | undefined;\n\tprivate currentStartingPointId: FeatureId | undefined;\n\tprivate keyEvents: TerraDrawSensorModeKeyEvents = defaultKeyEvents;\n\tprivate direction: \"clockwise\" | \"anticlockwise\" | undefined;\n\tprivate arcPoints: number = 64;\n\n\t// Behaviors\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate mouseMove = false;\n\n\tconstructor(options?: TerraDrawSensorModeOptions<SensorPolygonStyling>) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\toverride updateOptions(\n\t\toptions?: TerraDrawSensorModeOptions<SensorPolygonStyling>,\n\t): void {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.arcPoints) {\n\t\t\tthis.arcPoints = options.arcPoints;\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentStartingPointId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst finishedCurrentStartingPointId = this.currentStartingPointId;\n\t\tconst finishedInitialArcId = this.currentInitialArcId;\n\t\tconst finishedCurrentId = this.currentId;\n\n\t\tif (finishedCurrentStartingPointId) {\n\t\t\tthis.store.delete([finishedCurrentStartingPointId]);\n\t\t}\n\n\t\tif (finishedInitialArcId) {\n\t\t\tthis.store.delete([finishedInitialArcId]);\n\t\t}\n\n\t\t// Fix right hand rule if necessary\n\t\tif (this.currentId) {\n\t\t\tconst correctedGeometry = ensureRightHandRule(\n\t\t\t\tthis.store.getGeometryCopy<Polygon>(this.currentId),\n\t\t\t);\n\t\t\tif (correctedGeometry) {\n\t\t\t\tthis.store.updateGeometry([\n\t\t\t\t\t{ id: this.currentId, geometry: correctedGeometry },\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentStartingPointId = undefined;\n\t\tthis.currentInitialArcId = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.direction = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\tif (finishedCurrentId) {\n\t\t\tthis.onFinish(finishedCurrentId, { mode: this.mode, action: \"draw\" });\n\t\t}\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tthis.mouseMove = true;\n\t\tthis.setCursor(this.cursors.start);\n\n\t\tif (\n\t\t\tthis.currentInitialArcId === undefined ||\n\t\t\tthis.currentStartingPointId === undefined ||\n\t\t\tthis.currentCoordinate === 0\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.currentCoordinate === 2) {\n\t\t\tconst currentPolygonCoordinates = this.store.getGeometryCopy<LineString>(\n\t\t\t\tthis.currentInitialArcId,\n\t\t\t).coordinates;\n\t\t\tconst center = this.store.getGeometryCopy<Point>(\n\t\t\t\tthis.currentStartingPointId,\n\t\t\t).coordinates;\n\n\t\t\tconst arcCoordOne = currentPolygonCoordinates[0];\n\t\t\tconst arcCoordTwo = [event.lng, event.lat];\n\n\t\t\tconst webMercatorArcCoordOne = lngLatToWebMercatorXY(\n\t\t\t\tarcCoordOne[0],\n\t\t\t\tarcCoordOne[1],\n\t\t\t);\n\t\t\tconst webMercatorArcCoordTwo = lngLatToWebMercatorXY(\n\t\t\t\tarcCoordTwo[0],\n\t\t\t\tarcCoordTwo[1],\n\t\t\t);\n\t\t\tconst webMercatorCenter = lngLatToWebMercatorXY(center[0], center[1]);\n\n\t\t\tconst radius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordOne,\n\t\t\t);\n\n\t\t\t// We want to determine the direction of the sector, whether\n\t\t\t// it is clockwise or anticlockwise\n\t\t\tif (this.direction === undefined) {\n\t\t\t\tconst clockwise = isClockwiseWebMercator(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\twebMercatorArcCoordOne,\n\t\t\t\t\twebMercatorArcCoordTwo,\n\t\t\t\t);\n\t\t\t\tthis.direction = clockwise ? \"clockwise\" : \"anticlockwise\";\n\t\t\t}\n\n\t\t\t// Calculate bearings for the second and third points in Web Mercator\n\t\t\tconst startBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordOne,\n\t\t\t);\n\t\t\tconst endBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorArcCoordTwo,\n\t\t\t);\n\n\t\t\t// Generate points along the arc in Web Mercator\n\t\t\tconst numberOfPoints = this.arcPoints; // Number of points to approximate the arc\n\t\t\tconst coordinates: Position[] = [arcCoordOne];\n\n\t\t\t// Corrected version to calculate deltaBearing\n\t\t\tconst normalizedStart = normalizeBearing(startBearing);\n\t\t\tconst normalizedEnd = normalizeBearing(endBearing);\n\n\t\t\t// Calculate the delta bearing based on the direction\n\t\t\tlet deltaBearing;\n\t\t\tif (this.direction === \"anticlockwise\") {\n\t\t\t\tdeltaBearing = normalizedEnd - normalizedStart;\n\t\t\t\tif (deltaBearing < 0) {\n\t\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdeltaBearing = normalizedStart - normalizedEnd;\n\t\t\t\tif (deltaBearing < 0) {\n\t\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst bearingStep =\n\t\t\t\t((this.direction === \"anticlockwise\" ? 1 : -1) * deltaBearing) /\n\t\t\t\tnumberOfPoints;\n\n\t\t\t// Add all the arc points\n\t\t\tfor (let i = 0; i <= numberOfPoints; i++) {\n\t\t\t\tconst currentBearing = normalizedStart + i * bearingStep;\n\t\t\t\tconst pointOnArc = webMercatorDestination(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\tradius,\n\t\t\t\t\tcurrentBearing,\n\t\t\t\t);\n\t\t\t\tconst { lng, lat } = webMercatorXYToLngLat(pointOnArc.x, pointOnArc.y);\n\n\t\t\t\tconst nextCoord = [\n\t\t\t\t\tlimitPrecision(lng, this.coordinatePrecision),\n\t\t\t\t\tlimitPrecision(lat, this.coordinatePrecision),\n\t\t\t\t];\n\n\t\t\t\tconst notIdentical =\n\t\t\t\t\tnextCoord[0] !== coordinates[coordinates.length - 1][0] &&\n\t\t\t\t\tnextCoord[1] !== coordinates[coordinates.length - 1][1];\n\t\t\t\tif (notIdentical) {\n\t\t\t\t\tcoordinates.push(nextCoord);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateLineStringGeometry(\n\t\t\t\tthis.currentInitialArcId,\n\t\t\t\tcoordinates,\n\t\t\t\tUpdateTypes.Provisional,\n\t\t\t);\n\t\t} else if (this.currentCoordinate === 3) {\n\t\t\tconst coordinates = this.store.getGeometryCopy<LineString>(\n\t\t\t\tthis.currentInitialArcId,\n\t\t\t).coordinates;\n\n\t\t\tif (coordinates.length < 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// This shouldn't happen but we protect against it in case as we can't calculate if the cursor\n\t\t\t// is in the sector otherwise\n\t\t\tif (!this.direction) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst center = this.store.getGeometryCopy<Point>(\n\t\t\t\tthis.currentStartingPointId,\n\t\t\t).coordinates;\n\n\t\t\tconst firstCoord = coordinates[0];\n\t\t\tconst lastCoord = coordinates[coordinates.length - 1];\n\n\t\t\tconst webMercatorCursor = lngLatToWebMercatorXY(event.lng, event.lat);\n\t\t\tconst webMercatorCoordOne = lngLatToWebMercatorXY(\n\t\t\t\tfirstCoord[0],\n\t\t\t\tfirstCoord[1],\n\t\t\t);\n\t\t\tconst webMercatorCoordTwo = lngLatToWebMercatorXY(\n\t\t\t\tlastCoord[0],\n\t\t\t\tlastCoord[1],\n\t\t\t);\n\n\t\t\tconst webMercatorCenter = lngLatToWebMercatorXY(center[0], center[1]);\n\n\t\t\tconst innerRadius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCoordOne,\n\t\t\t);\n\n\t\t\tconst outerRadius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCursor,\n\t\t\t);\n\n\t\t\tconst hasLessThanZeroSize = outerRadius < innerRadius;\n\n\t\t\t// If the cursor is inside the inner radius, the depth of the sensor is always 0\n\t\t\tconst radiusCalculationPosition = hasLessThanZeroSize\n\t\t\t\t? webMercatorCoordOne\n\t\t\t\t: webMercatorCursor;\n\n\t\t\tconst cursorBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCursor,\n\t\t\t);\n\n\t\t\tconst startBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCoordOne,\n\t\t\t);\n\t\t\tconst endBearing = webMercatorBearing(\n\t\t\t\twebMercatorCenter,\n\t\t\t\twebMercatorCoordTwo,\n\t\t\t);\n\n\t\t\tconst normalizedStart = normalizeBearing(startBearing);\n\t\t\tconst normalizedEnd = normalizeBearing(endBearing);\n\t\t\tconst normalizedCursor = normalizeBearing(cursorBearing);\n\n\t\t\tconst notInSector = this.notInSector({\n\t\t\t\tnormalizedCursor,\n\t\t\t\tnormalizedStart,\n\t\t\t\tnormalizedEnd,\n\t\t\t\tdirection: this.direction,\n\t\t\t});\n\n\t\t\t// If it's not a valid cursor movement then we don't update\n\t\t\tif (notInSector) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate the delta bearing based on the direction\n\t\t\tconst deltaBearing = this.getDeltaBearing(\n\t\t\t\tthis.direction,\n\t\t\t\tnormalizedStart,\n\t\t\t\tnormalizedEnd,\n\t\t\t);\n\n\t\t\t// Number of points to approximate the arc\n\t\t\tconst numberOfPoints = this.arcPoints;\n\n\t\t\t// Calculate bearing step\n\t\t\tconst multiplier = this.direction === \"anticlockwise\" ? 1 : -1;\n\t\t\tconst bearingStep = (multiplier * deltaBearing) / numberOfPoints;\n\n\t\t\tconst radius = cartesianDistance(\n\t\t\t\twebMercatorCenter,\n\t\t\t\tradiusCalculationPosition,\n\t\t\t);\n\n\t\t\t// Add all the arc points\n\t\t\tconst finalArc = [];\n\t\t\tfor (let i = 0; i <= numberOfPoints; i++) {\n\t\t\t\tconst currentBearing = normalizedStart + i * bearingStep;\n\t\t\t\tconst pointOnArc = webMercatorDestination(\n\t\t\t\t\twebMercatorCenter,\n\t\t\t\t\tradius,\n\t\t\t\t\tcurrentBearing,\n\t\t\t\t);\n\t\t\t\tconst { lng, lat } = webMercatorXYToLngLat(pointOnArc.x, pointOnArc.y);\n\n\t\t\t\tconst nextCoord = [\n\t\t\t\t\tlimitPrecision(lng, this.coordinatePrecision),\n\t\t\t\t\tlimitPrecision(lat, this.coordinatePrecision),\n\t\t\t\t];\n\n\t\t\t\tconst notIdentical =\n\t\t\t\t\tnextCoord[0] !== coordinates[coordinates.length - 1][0] &&\n\t\t\t\t\tnextCoord[1] !== coordinates[coordinates.length - 1][1];\n\t\t\t\tif (notIdentical) {\n\t\t\t\t\tfinalArc.unshift(nextCoord);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoordinates.push(...finalArc);\n\n\t\t\t// Close the polygon\n\t\t\tcoordinates.push(coordinates[0]);\n\n\t\t\t// If the polygon doesn't exist, create it\n\t\t\t// else update the existing geometry\n\t\t\tif (!this.currentId) {\n\t\t\t\t[this.currentId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Polygon\",\n\t\t\t\t\t\t\tcoordinates: [coordinates],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tthis.updatePolygonGeometry(\n\t\t\t\t\tthis.currentId,\n\t\t\t\t\tcoordinates,\n\t\t\t\t\tUpdateTypes.Provisional,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate updateLineStringGeometry(\n\t\tid: FeatureId,\n\t\tcoordinates: LineString[\"coordinates\"],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"LineString\",\n\t\t\tcoordinates,\n\t\t} as LineString;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([{ id, geometry: updatedGeometry }]);\n\n\t\treturn true;\n\t}\n\n\tprivate updatePolygonGeometry(\n\t\tid: FeatureId,\n\t\tcoordinates: Polygon[\"coordinates\"][0],\n\t\tupdateType: UpdateTypes,\n\t) {\n\t\tconst updatedGeometry = {\n\t\t\ttype: \"Polygon\",\n\t\t\tcoordinates: [coordinates],\n\t\t} as Polygon;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tgeometry: updatedGeometry,\n\t\t\t\t} as GeoJSONStoreFeatures,\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([{ id, geometry: updatedGeometry }]);\n\n\t\treturn true;\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\t// We want pointer devices (mobile/tablet) to have\n\t\t\t// similar behaviour to mouse based devices so we\n\t\t\t// trigger a mousemove event before every click\n\t\t\t// if one has not been triggered to emulate this\n\t\t\tif (this.currentCoordinate > 0 && !this.mouseMove) {\n\t\t\t\tthis.onMouseMove(event);\n\t\t\t}\n\t\t\tthis.mouseMove = false;\n\n\t\t\tif (this.currentCoordinate === 0) {\n\t\t\t\tconst [newId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: { type: \"Point\", coordinates: [event.lng, event.lat] },\n\t\t\t\t\t\tproperties: { mode: this.mode },\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentStartingPointId = newId;\n\t\t\t\tthis.currentCoordinate++;\n\n\t\t\t\t// Ensure the state is updated to reflect drawing has started\n\t\t\t\tthis.setDrawing();\n\t\t\t} else if (this.currentCoordinate === 1 && this.currentStartingPointId) {\n\t\t\t\tconst [newId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"LineString\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: { mode: this.mode },\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t\tthis.currentInitialArcId = newId;\n\t\t\t\tthis.currentCoordinate++;\n\t\t\t} else if (this.currentCoordinate === 2 && this.currentStartingPointId) {\n\t\t\t\tthis.currentCoordinate++;\n\t\t\t\t// pass\n\t\t\t} else if (this.currentCoordinate === 3 && this.currentStartingPointId) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\ttry {\n\t\t\tif (this.currentStartingPointId) {\n\t\t\t\tthis.store.delete([this.currentStartingPointId]);\n\t\t\t}\n\t\t\tif (this.currentInitialArcId) {\n\t\t\t\tthis.store.delete([this.currentInitialArcId]);\n\t\t\t}\n\t\t\tif (this.currentId) {\n\t\t\t\tthis.store.delete([this.currentId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t\tthis.currentStartingPointId = undefined;\n\t\tthis.direction = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.currentCoordinate = 0;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (feature.properties.mode === this.mode) {\n\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\tstyles.polygonFillColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.fillColor,\n\t\t\t\t\tstyles.polygonFillColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.polygonFillOpacity = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.fillOpacity,\n\t\t\t\t\tstyles.polygonFillOpacity,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\tstyles.lineStringColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.outlineColor,\n\t\t\t\t\tstyles.polygonOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.lineStringWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.outlineWidth,\n\t\t\t\t\tstyles.polygonOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\t\t\t} else if (feature.geometry.type === \"Point\") {\n\t\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.centerPointColor,\n\t\t\t\t\tstyles.pointColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.centerPointWidth,\n\t\t\t\t\tstyles.pointWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\t\tthis.styles.centerPointOutlineColor,\n\t\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\t\tthis.styles.centerPointOutlineWidth,\n\t\t\t\t\tstyles.pointOutlineWidth,\n\t\t\t\t\tfeature,\n\t\t\t\t);\n\n\t\t\t\tstyles.zIndex = Z_INDEX.LAYER_TWO;\n\t\t\t}\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateNonIntersectingPolygonFeature(\n\t\t\t\tbaseValidatedFeature,\n\t\t\t\tthis.coordinatePrecision,\n\t\t\t),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures): void {\n\t\t// If we are in the middle of drawing a sensor and the feature being updated is the current sensor,\n\t\t// we need to reset the drawing state\n\t\tif (this.currentId === feature.id) {\n\t\t\tif (this.currentStartingPointId) {\n\t\t\t\tthis.store.delete([this.currentStartingPointId]);\n\t\t\t}\n\t\t\tif (this.currentInitialArcId) {\n\t\t\t\tthis.store.delete([this.currentInitialArcId]);\n\t\t\t}\n\n\t\t\tthis.currentStartingPointId = undefined;\n\t\t\tthis.direction = undefined;\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.currentCoordinate = 0;\n\n\t\t\tif (this.state === \"drawing\") {\n\t\t\t\tthis.setStarted();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getDeltaBearing(\n\t\tdirection: \"anticlockwise\" | \"clockwise\",\n\t\tnormalizedStart: number,\n\t\tnormalizedEnd: number,\n\t) {\n\t\tlet deltaBearing;\n\t\tif (direction === \"anticlockwise\") {\n\t\t\tdeltaBearing = normalizedEnd - normalizedStart;\n\t\t\tif (deltaBearing < 0) {\n\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t}\n\t\t} else {\n\t\t\tdeltaBearing = normalizedStart - normalizedEnd;\n\t\t\tif (deltaBearing < 0) {\n\t\t\t\tdeltaBearing += 360; // Adjust for wrap-around\n\t\t\t}\n\t\t}\n\t\treturn deltaBearing;\n\t}\n\n\tprivate notInSector({\n\t\tnormalizedCursor,\n\t\tnormalizedStart,\n\t\tnormalizedEnd,\n\t\tdirection,\n\t}: {\n\t\tnormalizedCursor: number;\n\t\tnormalizedStart: number;\n\t\tnormalizedEnd: number;\n\t\tdirection: \"clockwise\" | \"anticlockwise\";\n\t}) {\n\t\tif (direction === \"clockwise\") {\n\t\t\t// Handle clockwise direction\n\t\t\tif (normalizedStart <= normalizedEnd) {\n\t\t\t\t// Standard case (no wrap-around)\n\t\t\t\treturn (\n\t\t\t\t\tnormalizedCursor >= normalizedStart &&\n\t\t\t\t\tnormalizedCursor <= normalizedEnd\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Handle wrap-around across 360 degrees\n\t\t\t\treturn (\n\t\t\t\t\tnormalizedCursor >= normalizedStart ||\n\t\t\t\t\tnormalizedCursor <= normalizedEnd\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\t// Handle anticlockwise direction\n\t\t\tif (normalizedStart >= normalizedEnd) {\n\t\t\t\t// Standard case (no wrap-around)\n\t\t\t\treturn (\n\t\t\t\t\tnormalizedCursor <= normalizedStart &&\n\t\t\t\t\tnormalizedCursor >= normalizedEnd\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Handle wrap-around across 360 degrees\n\t\t\t\treturn (\n\t\t\t\t\tnormalizedCursor <= normalizedStart ||\n\t\t\t\t\tnormalizedCursor >= normalizedEnd\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n","export class AdapterListener<Callback extends (...args: any[]) => any> {\n\tpublic name: string;\n\tpublic callback: (...args: any[]) => any;\n\tpublic registered = false;\n\tpublic register: any;\n\tpublic unregister: any;\n\n\t/**\n\t * Creates a new AdapterListener instance with the provided configuration.\n\t *\n\t * @param {Object} config - The configuration object for the listener.\n\t * @param {string} config.name - The name of the event listener.\n\t * @param {Function} config.callback - The callback function to be called when the event is triggered.\n\t * @param {Function} config.unregister - The function to unregister the event listeners.\n\t * @param {Function} config.register - The function to register the event listeners.\n\t */\n\tconstructor({\n\t\tname,\n\t\tcallback,\n\t\tunregister,\n\t\tregister,\n\t}: {\n\t\tname: string;\n\t\tcallback: Callback;\n\t\tunregister: (callbacks: Callback) => void;\n\t\tregister: (callback: Callback) => void;\n\t}) {\n\t\tthis.name = name;\n\n\t\t// Function to register the event listeners\n\t\tthis.register = () => {\n\t\t\tif (!this.registered) {\n\t\t\t\tthis.registered = true;\n\t\t\t\tregister(callback);\n\t\t\t}\n\t\t};\n\n\t\t// Function to unregister the event listeners\n\t\tthis.unregister = () => {\n\t\t\tif (this.register) {\n\t\t\t\tthis.registered = false;\n\t\t\t\tunregister(callback);\n\t\t\t}\n\t\t};\n\n\t\tthis.callback = callback;\n\t}\n}\n","import {\n\tProject,\n\tUnproject,\n\tTerraDrawCallbacks,\n\tTerraDrawChanges,\n\tTerraDrawMouseEvent,\n\tSetCursor,\n\tTerraDrawStylingFunction,\n\tGetLngLatFromEvent,\n\tTerraDrawAdapter,\n} from \"../common\";\nimport { limitPrecision } from \"../geometry/limit-decimal-precision\";\nimport { cartesianDistance } from \"../geometry/measure/pixel-distance\";\nimport { AdapterListener } from \"./adapter-listener\";\n\ntype BasePointerListener = (event: PointerEvent) => void;\ntype BaseKeyboardListener = (event: KeyboardEvent) => void;\ntype BaseMouseListener = (event: MouseEvent) => void;\n\nexport type BaseAdapterConfig = {\n\tcoordinatePrecision?: number;\n\tminPixelDragDistanceDrawing?: number;\n\tminPixelDragDistance?: number;\n\tminPixelDragDistanceSelecting?: number;\n};\n\nexport abstract class TerraDrawBaseAdapter implements TerraDrawAdapter {\n\tconstructor(config: BaseAdapterConfig) {\n\t\tthis._minPixelDragDistance =\n\t\t\ttypeof config.minPixelDragDistance === \"number\"\n\t\t\t\t? config.minPixelDragDistance\n\t\t\t\t: 1;\n\n\t\tthis._minPixelDragDistanceSelecting =\n\t\t\ttypeof config.minPixelDragDistanceSelecting === \"number\"\n\t\t\t\t? config.minPixelDragDistanceSelecting\n\t\t\t\t: 1;\n\n\t\tthis._minPixelDragDistanceDrawing =\n\t\t\ttypeof config.minPixelDragDistanceDrawing === \"number\"\n\t\t\t\t? config.minPixelDragDistanceDrawing\n\t\t\t\t: 8;\n\n\t\tthis._coordinatePrecision =\n\t\t\ttypeof config.coordinatePrecision === \"number\"\n\t\t\t\t? config.coordinatePrecision\n\t\t\t\t: 9;\n\t}\n\n\tprivate _nextKeyUpIsContextMenu = false;\n\n\tprotected _minPixelDragDistance: number;\n\tprotected _minPixelDragDistanceDrawing: number;\n\tprotected _minPixelDragDistanceSelecting: number;\n\tprotected _lastDrawEvent: TerraDrawMouseEvent | undefined;\n\tprotected _coordinatePrecision: number;\n\tprotected _heldKeys: Set<string> = new Set();\n\tprotected _listeners: AdapterListener<\n\t\tBasePointerListener | BaseKeyboardListener | BaseMouseListener\n\t>[] = [];\n\tprotected _dragState: \"not-dragging\" | \"pre-dragging\" | \"dragging\" =\n\t\t\"not-dragging\";\n\tprotected _currentModeCallbacks: TerraDrawCallbacks | undefined;\n\n\tpublic abstract getMapEventElement(): HTMLElement;\n\n\tprotected getButton(event: PointerEvent | MouseEvent) {\n\t\tif (event.button === -1) {\n\t\t\treturn \"neither\";\n\t\t} else if (event.button === 0) {\n\t\t\treturn \"left\";\n\t\t} else if (event.button === 1) {\n\t\t\treturn \"middle\";\n\t\t} else if (event.button === 2) {\n\t\t\treturn \"right\";\n\t\t}\n\n\t\t// This shouldn't happen (?)\n\t\treturn \"neither\";\n\t}\n\n\tprotected getMapElementXYPosition(event: PointerEvent | MouseEvent) {\n\t\tconst mapElement = this.getMapEventElement();\n\t\tconst { left, top } = mapElement.getBoundingClientRect();\n\n\t\treturn {\n\t\t\tcontainerX: event.clientX - left,\n\t\t\tcontainerY: event.clientY - top,\n\t\t};\n\t}\n\n\tprotected getDrawEventFromEvent(\n\t\tevent: PointerEvent | MouseEvent,\n\t\tisContextMenu = false,\n\t): TerraDrawMouseEvent | null {\n\t\tconst latLng = this.getLngLatFromEvent(event);\n\n\t\tif (!latLng) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { lng, lat } = latLng;\n\t\tconst { containerX, containerY } = this.getMapElementXYPosition(event);\n\t\tconst button = this.getButton(event);\n\t\tconst heldKeys = Array.from(this._heldKeys);\n\n\t\treturn {\n\t\t\tlng: limitPrecision(lng, this._coordinatePrecision),\n\t\t\tlat: limitPrecision(lat, this._coordinatePrecision),\n\t\t\tcontainerX,\n\t\t\tcontainerY,\n\t\t\tbutton,\n\t\t\theldKeys,\n\t\t\tisContextMenu,\n\t\t};\n\t}\n\n\t/**\n\t * Registers the provided callbacks for the current drawing mode and attaches\n\t * the necessary event listeners.\n\t * @param {TerraDrawCallbacks} callbacks - An object containing callback functions\n\t * for handling various drawing events in the current mode.\n\t */\n\tpublic register(callbacks: TerraDrawCallbacks) {\n\t\tthis._currentModeCallbacks = callbacks;\n\n\t\tthis._listeners = this.getAdapterListeners();\n\n\t\tthis._listeners.forEach((listener) => {\n\t\t\tlistener.register();\n\t\t});\n\t}\n\n\t/**\n\t * Gets the coordinate precision. The coordinate precision is the number of decimal places in geometry\n\t * coordinates stored in the store.\n\t * @returns {number} The coordinate precision.\n\t */\n\tpublic getCoordinatePrecision() {\n\t\treturn this._coordinatePrecision;\n\t}\n\n\tprotected getAdapterListeners() {\n\t\treturn [\n\t\t\tnew AdapterListener<BasePointerListener>({\n\t\t\t\tname: \"pointerdown\",\n\t\t\t\tcallback: (event) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We don't support multitouch as this point in time\n\t\t\t\t\tif (!event.isPrimary) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst drawEvent = this.getDrawEventFromEvent(event);\n\t\t\t\t\tif (!drawEvent) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._dragState = \"pre-dragging\";\n\n\t\t\t\t\t// On pointer devices pointer mouse move events won't be\n\t\t\t\t\t// triggered so this._lastDrawEvent will not get set in\n\t\t\t\t\t// pointermove listener, so we must set it here.\n\t\t\t\t\tthis._lastDrawEvent = drawEvent;\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tthis.getMapEventElement().addEventListener(\"pointerdown\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tthis.getMapEventElement().removeEventListener(\n\t\t\t\t\t\t\"pointerdown\",\n\t\t\t\t\t\tcallback,\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener<BasePointerListener>({\n\t\t\t\tname: \"pointermove\",\n\t\t\t\tcallback: (event) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) return;\n\n\t\t\t\t\t// We don't support multitouch as this point in time\n\t\t\t\t\tif (!event.isPrimary) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\tconst drawEvent = this.getDrawEventFromEvent(event);\n\t\t\t\t\tif (!drawEvent) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._dragState === \"not-dragging\") {\n\t\t\t\t\t\t// If we're not dragging we can trigger the onMouseMove event\n\t\t\t\t\t\tthis._currentModeCallbacks.onMouseMove(drawEvent);\n\t\t\t\t\t\tthis._lastDrawEvent = drawEvent;\n\t\t\t\t\t} else if (this._dragState === \"pre-dragging\") {\n\t\t\t\t\t\t// This should always be set because of pointerdown event\n\t\t\t\t\t\tif (!this._lastDrawEvent) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst lastEventXY = {\n\t\t\t\t\t\t\tx: this._lastDrawEvent.containerX,\n\t\t\t\t\t\t\ty: this._lastDrawEvent.containerY,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst currentEventXY = {\n\t\t\t\t\t\t\tx: drawEvent.containerX,\n\t\t\t\t\t\t\ty: drawEvent.containerY,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// We only want to prevent micro drags when we are\n\t\t\t\t\t\t// drawing as doing in on selection can cause janky\n\t\t\t\t\t\t// behaviours\n\t\t\t\t\t\tconst modeState = this._currentModeCallbacks.getState();\n\n\t\t\t\t\t\tconst pixelDistanceToCheck = cartesianDistance(\n\t\t\t\t\t\t\tlastEventXY,\n\t\t\t\t\t\t\tcurrentEventXY,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// We start off assuming it is not a microdrag\n\t\t\t\t\t\tlet isMicroDrag = false;\n\n\t\t\t\t\t\tif (modeState === \"drawing\") {\n\t\t\t\t\t\t\t// We want to ignore very small pointer movements when holding\n\t\t\t\t\t\t\t// the map down as these are normally done by accident when\n\t\t\t\t\t\t\t// drawing and is not an intended drag\n\t\t\t\t\t\t\tisMicroDrag =\n\t\t\t\t\t\t\t\tpixelDistanceToCheck < this._minPixelDragDistanceDrawing;\n\t\t\t\t\t\t} else if (modeState === \"selecting\") {\n\t\t\t\t\t\t\t// Similarly when selecting, we want to ignore very small pointer\n\t\t\t\t\t\t\t// movements when holding the map down as these are normally done\n\t\t\t\t\t\t\t// by accident when drawing and is not an intended drag\n\t\t\t\t\t\t\tisMicroDrag =\n\t\t\t\t\t\t\t\tpixelDistanceToCheck < this._minPixelDragDistanceSelecting;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Same as above, but when not drawing we generally want a much lower tolerance\n\t\t\t\t\t\t\tisMicroDrag = pixelDistanceToCheck < this._minPixelDragDistance;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If it is a microdrag we do not register it by returning early\n\t\t\t\t\t\tif (isMicroDrag) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If we are dragging it is not a context menu key up event any more\n\t\t\t\t\t\tthis._nextKeyUpIsContextMenu = false;\n\n\t\t\t\t\t\tthis._dragState = \"dragging\";\n\t\t\t\t\t\tthis._currentModeCallbacks.onDragStart(\n\t\t\t\t\t\t\tdrawEvent,\n\t\t\t\t\t\t\t(enabled: boolean) => {\n\t\t\t\t\t\t\t\tthis.setDraggability.bind(this)(enabled);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (this._dragState === \"dragging\") {\n\t\t\t\t\t\tthis._currentModeCallbacks.onDrag(drawEvent, (enabled: boolean) => {\n\t\t\t\t\t\t\tthis.setDraggability.bind(this)(enabled);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"pointermove\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"pointermove\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener<BaseMouseListener>({\n\t\t\t\tname: \"contextmenu\",\n\t\t\t\tcallback: (event) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) return;\n\n\t\t\t\t\t// We do not want the context menu to open\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t// We signify that the next keyup event is related to the context menu\n\t\t\t\t\t// and we want to set isContextMenu to true\n\t\t\t\t\tthis._nextKeyUpIsContextMenu = true;\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"contextmenu\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"contextmenu\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener<BasePointerListener>({\n\t\t\t\tname: \"pointerup\",\n\t\t\t\tcallback: (event) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (event.target !== this.getMapEventElement()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We don't support multitouch as this point in time\n\t\t\t\t\tif (!event.isPrimary) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst drawEvent = this.getDrawEventFromEvent(event);\n\n\t\t\t\t\tif (!drawEvent) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._dragState === \"dragging\") {\n\t\t\t\t\t\tthis._currentModeCallbacks.onDragEnd(drawEvent, (enabled) => {\n\t\t\t\t\t\t\tthis.setDraggability.bind(this)(enabled);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tthis._dragState === \"not-dragging\" ||\n\t\t\t\t\t\tthis._dragState === \"pre-dragging\"\n\t\t\t\t\t) {\n\t\t\t\t\t\t// If we're not dragging or about to drag we\n\t\t\t\t\t\t// can trigger the onClick event\n\t\t\t\t\t\t// We want to reset it to false after we have used it\n\t\t\t\t\t\tif (this._nextKeyUpIsContextMenu) {\n\t\t\t\t\t\t\tdrawEvent.isContextMenu = true;\n\t\t\t\t\t\t\tthis._nextKeyUpIsContextMenu = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._currentModeCallbacks.onClick(drawEvent);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensure we go back to the regular behaviour\n\t\t\t\t\t// not dragging and re-enable dragging on the actual map\n\t\t\t\t\tthis._dragState = \"not-dragging\";\n\t\t\t\t\tthis.setDraggability(true);\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"pointerup\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"pointerup\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener({\n\t\t\t\tname: \"keyup\",\n\t\t\t\tcallback: (event: KeyboardEvent) => {\n\t\t\t\t\t// map has no keypress event, so we add one to the canvas itself\n\n\t\t\t\t\tif (!this._currentModeCallbacks) return;\n\n\t\t\t\t\tthis._heldKeys.delete(event.key);\n\n\t\t\t\t\tthis._currentModeCallbacks.onKeyUp({\n\t\t\t\t\t\tkey: event.key,\n\t\t\t\t\t\theldKeys: Array.from(this._heldKeys),\n\t\t\t\t\t\tpreventDefault: () => event.preventDefault(),\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"keyup\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"keyup\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew AdapterListener({\n\t\t\t\tname: \"keydown\",\n\t\t\t\tcallback: (event: KeyboardEvent) => {\n\t\t\t\t\tif (!this._currentModeCallbacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._heldKeys.add(event.key);\n\n\t\t\t\t\tthis._currentModeCallbacks.onKeyDown({\n\t\t\t\t\t\tkey: event.key,\n\t\t\t\t\t\theldKeys: Array.from(this._heldKeys),\n\t\t\t\t\t\tpreventDefault: () => event.preventDefault(),\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.addEventListener(\"keydown\", callback);\n\t\t\t\t},\n\t\t\t\tunregister: (callback) => {\n\t\t\t\t\tconst mapElement = this.getMapEventElement();\n\t\t\t\t\tmapElement.removeEventListener(\"keydown\", callback);\n\t\t\t\t},\n\t\t\t}),\n\t\t];\n\t}\n\n\t/**\n\t * Unregisters the event listeners for the current drawing mode.\n\t * This is typically called when switching between drawing modes or\n\t * stopping the drawing process.\n\t */\n\tpublic unregister() {\n\t\tthis._listeners.forEach((listener) => {\n\t\t\tlistener.unregister();\n\t\t});\n\n\t\tthis.clear();\n\n\t\t// This has to come last because we call this._currentModeCallbacks.onClear()\n\t\tthis._currentModeCallbacks = undefined;\n\t}\n\n\tpublic abstract clear(): void;\n\n\tpublic abstract project(...args: Parameters<Project>): ReturnType<Project>;\n\n\tpublic abstract unproject(\n\t\t...args: Parameters<Unproject>\n\t): ReturnType<Unproject>;\n\n\tpublic abstract setCursor(\n\t\t...args: Parameters<SetCursor>\n\t): ReturnType<SetCursor>;\n\n\tpublic abstract getLngLatFromEvent(\n\t\t...event: Parameters<GetLngLatFromEvent>\n\t): ReturnType<GetLngLatFromEvent>;\n\n\tpublic abstract setDraggability(enabled: boolean): void;\n\n\tpublic abstract setDoubleClickToZoom(enabled: boolean): void;\n\n\tpublic abstract render(\n\t\tchanges: TerraDrawChanges,\n\t\tstyling: TerraDrawStylingFunction,\n\t): void;\n}\n","import {\n\tValidationReasonModeMismatch,\n\tValidationReasonFeatureNotPolygon,\n} from \"./validations/common-validations\";\nimport { ValidationReasonFeatureLessThanMinSize } from \"./validations/min-size.validation\";\nimport {\n\tValidationReasonFeatureNotPolygonOrLineString,\n\tValidationReasonFeatureSelfIntersects,\n} from \"./validations/not-self-intersecting.validation\";\nimport {\n\tValidationReasonFeatureInvalidCoordinates,\n\tValidationReasonFeatureNotPoint,\n\tValidationReasonFeatureInvalidCoordinatePrecision,\n} from \"./validations/point.validation\";\nimport {\n\tValidationReasonFeatureHasHoles,\n\tValidationReasonFeatureLessThanFourCoordinates,\n\tValidationReasonFeatureHasInvalidCoordinates,\n\tValidationReasonFeatureCoordinatesNotClosed,\n} from \"./validations/polygon.validation\";\n\nexport const ValidationReasons = {\n\tValidationReasonFeatureNotPoint,\n\tValidationReasonFeatureInvalidCoordinates,\n\tValidationReasonFeatureInvalidCoordinatePrecision,\n\tValidationReasonFeatureNotPolygon,\n\tValidationReasonFeatureHasHoles,\n\tValidationReasonFeatureLessThanFourCoordinates,\n\tValidationReasonFeatureHasInvalidCoordinates,\n\tValidationReasonFeatureCoordinatesNotClosed,\n\tValidationReasonFeatureNotPolygonOrLineString,\n\tValidationReasonFeatureSelfIntersects,\n\tValidationReasonFeatureLessThanMinSize,\n\tValidationReasonModeMismatch,\n};\n","import {\n\tTerraDrawMouseEvent,\n\tTerraDrawAdapterStyling,\n\tTerraDrawKeyboardEvent,\n\tHexColorStyling,\n\tNumericStyling,\n\tCursor,\n\tUpdateTypes,\n\tCOMMON_PROPERTIES,\n\tZ_INDEX,\n} from \"../../common\";\nimport { LineString } from \"geojson\";\n\nimport {\n\tBaseModeOptions,\n\tCustomStyling,\n\tTerraDrawBaseDrawMode,\n} from \"../base.mode\";\nimport { getDefaultStyling } from \"../../util/styling\";\nimport {\n\tFeatureId,\n\tGeoJSONStoreFeatures,\n\tStoreValidation,\n} from \"../../store/store\";\nimport { cartesianDistance } from \"../../geometry/measure/pixel-distance\";\nimport { ValidateLineStringFeature } from \"../../validations/linestring.validation\";\n\ntype TerraDrawFreehandLineStringModeKeyEvents = {\n\tcancel: KeyboardEvent[\"key\"] | null;\n\tfinish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ntype FreehandLineStringStyling = {\n\tlineStringWidth: NumericStyling;\n\tlineStringColor: HexColorStyling;\n\tclosingPointColor: HexColorStyling;\n\tclosingPointWidth: NumericStyling;\n\tclosingPointOutlineColor: HexColorStyling;\n\tclosingPointOutlineWidth: NumericStyling;\n};\n\ninterface Cursors {\n\tstart?: Cursor;\n\tclose?: Cursor;\n}\n\nconst defaultCursors = {\n\tstart: \"crosshair\",\n\tclose: \"pointer\",\n} as Required<Cursors>;\n\ninterface TerraDrawFreehandLineStringModeOptions<T extends CustomStyling>\n\textends BaseModeOptions<T> {\n\tminDistance?: number;\n\tkeyEvents?: TerraDrawFreehandLineStringModeKeyEvents | null;\n\tcursors?: Cursors;\n}\n\nexport class TerraDrawFreehandLineStringMode extends TerraDrawBaseDrawMode<FreehandLineStringStyling> {\n\tmode = \"freehand-linestring\" as const;\n\n\tprivate startingClick = false;\n\tprivate currentId: FeatureId | undefined;\n\tprivate closingPointId: FeatureId | undefined;\n\tprivate minDistance: number = 20;\n\tprivate keyEvents: TerraDrawFreehandLineStringModeKeyEvents =\n\t\tdefaultKeyEvents;\n\tprivate cursors: Required<Cursors> = defaultCursors;\n\tprivate preventNewFeature = false;\n\n\tconstructor(\n\t\toptions?: TerraDrawFreehandLineStringModeOptions<FreehandLineStringStyling>,\n\t) {\n\t\tsuper(options, true);\n\t\tthis.updateOptions(options);\n\t}\n\n\tpublic updateOptions(\n\t\toptions?:\n\t\t\t| TerraDrawFreehandLineStringModeOptions<FreehandLineStringStyling>\n\t\t\t| undefined,\n\t): void {\n\t\tsuper.updateOptions(options);\n\n\t\tif (options?.minDistance) {\n\t\t\tthis.minDistance = options.minDistance;\n\t\t}\n\n\t\tif (options?.keyEvents === null) {\n\t\t\tthis.keyEvents = { cancel: null, finish: null };\n\t\t} else if (options?.keyEvents) {\n\t\t\tthis.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n\t\t}\n\n\t\tif (options?.cursors) {\n\t\t\tthis.cursors = { ...this.cursors, ...options.cursors };\n\t\t}\n\t}\n\n\tprivate close() {\n\t\tif (this.currentId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fix right hand rule if necessary\n\t\tif (this.currentId) {\n\t\t\tthis.store.updateProperty([\n\t\t\t\t{\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tproperty: COMMON_PROPERTIES.CURRENTLY_DRAWING,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tconst finishedId = this.currentId;\n\n\t\tif (this.validate && finishedId) {\n\t\t\tconst currentGeometry =\n\t\t\t\tthis.store.getGeometryCopy<LineString>(finishedId);\n\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: finishedId,\n\t\t\t\t\tgeometry: currentGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Finish,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.closingPointId) {\n\t\t\tthis.store.delete([this.closingPointId]);\n\t\t}\n\t\tthis.startingClick = false;\n\t\tthis.currentId = undefined;\n\t\tthis.closingPointId = undefined;\n\n\t\t// Go back to started state\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\t// Ensure that any listerers are triggered with the main created geometry\n\t\tthis.onFinish(finishedId, { mode: this.mode, action: \"draw\" });\n\t}\n\n\t/** @internal */\n\tstart() {\n\t\tthis.setStarted();\n\t\tthis.setCursor(this.cursors.start);\n\t}\n\n\t/** @internal */\n\tstop() {\n\t\tthis.cleanUp();\n\t\tthis.setStopped();\n\t\tthis.setCursor(\"unset\");\n\t}\n\n\t/** @internal */\n\tonMouseMove(event: TerraDrawMouseEvent) {\n\t\tif (this.currentId === undefined || this.startingClick === false) {\n\t\t\tthis.setCursor(this.cursors.start);\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentLineGeometry = this.store.getGeometryCopy<LineString>(\n\t\t\tthis.currentId,\n\t\t);\n\n\t\tconst previousIndex = currentLineGeometry.coordinates.length - 2;\n\t\tconst [previousLng, previousLat] =\n\t\t\tcurrentLineGeometry.coordinates[previousIndex];\n\t\tconst { x, y } = this.project(previousLng, previousLat);\n\t\tconst distance = cartesianDistance(\n\t\t\t{ x, y },\n\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t);\n\n\t\tconst [closingLng, closingLat] =\n\t\t\tcurrentLineGeometry.coordinates[\n\t\t\t\tcurrentLineGeometry.coordinates.length - 1\n\t\t\t];\n\t\tconst { x: closingX, y: closingY } = this.project(closingLng, closingLat);\n\t\tconst closingDistance = cartesianDistance(\n\t\t\t{ x: closingX, y: closingY },\n\t\t\t{ x: event.containerX, y: event.containerY },\n\t\t);\n\n\t\tif (closingDistance < this.pointerDistance) {\n\t\t\tthis.setCursor(this.cursors.close);\n\t\t} else {\n\t\t\tthis.setCursor(this.cursors.start);\n\t\t}\n\n\t\t// The cusor must have moved a minimum distance\n\t\t// before we add another coordinate\n\t\tif (distance < this.minDistance) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst newGeometry = {\n\t\t\ttype: \"LineString\",\n\t\t\tcoordinates: [...currentLineGeometry.coordinates, [event.lng, event.lat]],\n\t\t} as LineString;\n\n\t\tif (this.validate) {\n\t\t\tconst validationResult = this.validate(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Feature\",\n\t\t\t\t\tid: this.currentId,\n\t\t\t\t\tgeometry: newGeometry,\n\t\t\t\t\tproperties: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tproject: this.project,\n\t\t\t\t\tunproject: this.unproject,\n\t\t\t\t\tcoordinatePrecision: this.coordinatePrecision,\n\t\t\t\t\tupdateType: UpdateTypes.Provisional,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!validationResult.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.store.updateGeometry([\n\t\t\t{\n\t\t\t\tid: this.currentId,\n\t\t\t\tgeometry: newGeometry,\n\t\t\t},\n\t\t]);\n\n\t\tif (this.closingPointId) {\n\t\t\tthis.store.updateGeometry([\n\t\t\t\t{\n\t\t\t\t\tid: this.closingPointId,\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\t}\n\n\t/** @internal */\n\tonClick(event: TerraDrawMouseEvent) {\n\t\tif (\n\t\t\t(event.button === \"right\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.rightClick, event)) ||\n\t\t\t(event.button === \"left\" &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.leftClick, event)) ||\n\t\t\t(event.isContextMenu &&\n\t\t\t\tthis.allowPointerEvent(this.pointerEvents.contextMenu, event))\n\t\t) {\n\t\t\tif (this.preventNewFeature) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.startingClick === false) {\n\t\t\t\tconst [createdId, closingPointId] = this.store.create([\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"LineString\",\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t\t[event.lng, event.lat],\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CURRENTLY_DRAWING]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\ttype: \"Point\",\n\t\t\t\t\t\t\tcoordinates: [event.lng, event.lat],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmode: this.mode,\n\t\t\t\t\t\t\t[COMMON_PROPERTIES.CLOSING_POINT]: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\tthis.currentId = createdId;\n\t\t\t\tthis.closingPointId = closingPointId;\n\t\t\t\tthis.startingClick = true;\n\n\t\t\t\t// We could already be in drawing due to updating the existing linestring\n\t\t\t\t// via afterFeatureUpdated\n\t\t\t\tif (this.state !== \"drawing\") {\n\t\t\t\t\tthis.setDrawing();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.close();\n\t\t}\n\t}\n\n\t/** @internal */\n\tonKeyDown() {}\n\n\t/** @internal */\n\tonKeyUp(event: TerraDrawKeyboardEvent) {\n\t\tif (event.key === this.keyEvents.cancel) {\n\t\t\tthis.cleanUp();\n\t\t} else if (event.key === this.keyEvents.finish) {\n\t\t\tif (this.startingClick === true) {\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tonDragStart() {}\n\n\t/** @internal */\n\tonDrag() {}\n\n\t/** @internal */\n\tonDragEnd() {}\n\n\t/** @internal */\n\tcleanUp() {\n\t\tconst cleanUpId = this.currentId;\n\t\tconst cleanUpClosingPointId = this.closingPointId;\n\n\t\tthis.closingPointId = undefined;\n\t\tthis.currentId = undefined;\n\t\tthis.startingClick = false;\n\t\tif (this.state === \"drawing\") {\n\t\t\tthis.setStarted();\n\t\t}\n\n\t\ttry {\n\t\t\tif (cleanUpId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpId]);\n\t\t\t}\n\t\t\tif (cleanUpClosingPointId !== undefined) {\n\t\t\t\tthis.store.delete([cleanUpClosingPointId]);\n\t\t\t}\n\t\t} catch (error) {}\n\t}\n\n\t/** @internal */\n\tstyleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n\t\tconst styles = { ...getDefaultStyling() };\n\n\t\tif (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"LineString\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.lineStringColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.lineStringColor,\n\t\t\t\tstyles.lineStringColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.lineStringWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.lineStringWidth,\n\t\t\t\tstyles.lineStringWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_ONE;\n\n\t\t\treturn styles;\n\t\t} else if (\n\t\t\tfeature.type === \"Feature\" &&\n\t\t\tfeature.geometry.type === \"Point\" &&\n\t\t\tfeature.properties.mode === this.mode\n\t\t) {\n\t\t\tstyles.pointWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.closingPointWidth,\n\t\t\t\tstyles.pointWidth,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.closingPointColor,\n\t\t\t\tstyles.pointColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineColor = this.getHexColorStylingValue(\n\t\t\t\tthis.styles.closingPointOutlineColor,\n\t\t\t\tstyles.pointOutlineColor,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.pointOutlineWidth = this.getNumericStylingValue(\n\t\t\t\tthis.styles.closingPointOutlineWidth,\n\t\t\t\t2,\n\t\t\t\tfeature,\n\t\t\t);\n\n\t\t\tstyles.zIndex = Z_INDEX.LAYER_FIVE;\n\n\t\t\treturn styles;\n\t\t}\n\n\t\treturn styles;\n\t}\n\n\tvalidateFeature(feature: unknown): StoreValidation {\n\t\treturn this.validateModeFeature(feature, (baseValidatedFeature) =>\n\t\t\tValidateLineStringFeature(baseValidatedFeature, this.coordinatePrecision),\n\t\t);\n\t}\n\n\tafterFeatureUpdated(feature: GeoJSONStoreFeatures) {\n\t\t// NOTE: This handles the case we are currently drawing a linestring\n\t\t// We need to reset the drawing state because it is very complicated (impossible?)\n\t\t// to recover the drawing state after a feature update\n\t\tif (this.currentId === feature.id) {\n\t\t\tif (this.closingPointId) {\n\t\t\t\tthis.store.delete([this.closingPointId]);\n\t\t\t}\n\t\t\tthis.startingClick = false;\n\t\t\tthis.currentId = undefined;\n\t\t\tthis.closingPointId = undefined;\n\t\t}\n\t}\n}\n","/**\n * Checks if a value is a valid JSON value.\n * @param value - The value to check\n * @returns true if the value is valid JSON, false otherwise\n */\nexport function isValidJSONValue(value: unknown): value is JSON {\n\t// null is valid JSON\n\tif (value === null) {\n\t\treturn true;\n\t}\n\n\t// boolean is valid JSON\n\tif (typeof value === \"boolean\") {\n\t\treturn true;\n\t}\n\n\t// string is valid JSON\n\tif (typeof value === \"string\") {\n\t\treturn true;\n\t}\n\n\t// undefined is not valid JSON\n\tif (value === undefined) {\n\t\treturn false;\n\t}\n\n\t// number must be finite to be valid JSON\n\tif (typeof value === \"number\") {\n\t\treturn Number.isFinite(value);\n\t}\n\n\t// BigInt is not a valid JSON type\n\tif (typeof value === \"bigint\") {\n\t\treturn false;\n\t}\n\n\t// Symbols are not valid JSON types\n\tif (typeof value === \"symbol\") {\n\t\treturn false;\n\t}\n\n\t// Functions are not valid JSON types\n\tif (typeof value === \"function\") {\n\t\treturn false;\n\t}\n\n\t// Regular expressions are not valid JSON types\n\tif (value instanceof RegExp) {\n\t\treturn false;\n\t}\n\n\t// Maps are not valid JSON types\n\tif (value instanceof Map) {\n\t\treturn false;\n\t}\n\n\t// Sets are not valid JSON types\n\tif (value instanceof Set) {\n\t\treturn false;\n\t}\n\n\t// Dates are not valid JSON types\n\tif (value instanceof Date) {\n\t\treturn false;\n\t}\n\n\t// Class instances are not valid JSON types (only plain objects)\n\tif (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n\t\tconst proto = Object.getPrototypeOf(value);\n\t\tif (proto !== Object.prototype && proto !== null) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Typed Arrays are not valid JSON types\n\tif (ArrayBuffer.isView(value) && !(value instanceof DataView)) {\n\t\treturn false;\n\t}\n\n\t// Array: all elements must be valid JSON\n\tif (Array.isArray(value)) {\n\t\tfor (const item of value) {\n\t\t\tif (!isValidJSONValue(item)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Object: must be plain object with string keys\n\tif (typeof value === \"object\") {\n\t\treturn Object.keys(value).every(\n\t\t\t(key) =>\n\t\t\t\ttypeof key === \"string\" &&\n\t\t\t\tisValidJSONValue(value[key as keyof typeof value] as unknown),\n\t\t);\n\t}\n\n\t// Other types (shouldn't reach here) are not valid JSON\n\treturn false;\n}\n","/**\n * @module terra-draw\n */\nimport {\n\tTerraDrawAdapter,\n\tTerraDrawAdapterStyling,\n\tGetLngLatFromEvent,\n\tProject,\n\tSetCursor,\n\tTerraDrawChanges,\n\tTerraDrawStylingFunction,\n\tUnproject,\n\tHexColor,\n\tTerraDrawKeyboardEvent,\n\tTerraDrawMouseEvent,\n\tSELECT_PROPERTIES,\n\tOnFinishContext,\n\tCOMMON_PROPERTIES,\n\tTerraDrawGeoJSONStore,\n\tOnChangeContext,\n\tProjection,\n} from \"./common\";\nimport {\n\tModeTypes,\n\tTerraDrawBaseDrawMode,\n\tTerraDrawBaseSelectMode,\n} from \"./modes/base.mode\";\nimport { TerraDrawCircleMode } from \"./modes/circle/circle.mode\";\nimport { TerraDrawFreehandMode } from \"./modes/freehand/freehand.mode\";\nimport { TerraDrawLineStringMode } from \"./modes/linestring/linestring.mode\";\nimport { TerraDrawPointMode } from \"./modes/point/point.mode\";\nimport { TerraDrawPolygonMode } from \"./modes/polygon/polygon.mode\";\nimport { TerraDrawRectangleMode } from \"./modes/rectangle/rectangle.mode\";\nimport { TerraDrawRenderMode } from \"./modes/render/render.mode\";\nimport { TerraDrawSelectMode } from \"./modes/select/select.mode\";\nimport { TerraDrawStaticMode } from \"./modes/static/static.mode\";\nimport {\n\tBBoxPolygon,\n\tFeatureId,\n\tGeoJSONStore,\n\tGeoJSONStoreFeatures,\n\tGeoJSONStoreGeometries,\n\tIdStrategy,\n\tJSON,\n\tJSONObject,\n\tStoreChangeHandler,\n\tStoreValidation,\n} from \"./store/store\";\nimport { BehaviorConfig } from \"./modes/base.behavior\";\nimport { cartesianDistance } from \"./geometry/measure/pixel-distance\";\nimport { pixelDistanceToLine } from \"./geometry/measure/pixel-distance-to-line\";\nimport { Feature, LineString, Polygon, Position } from \"geojson\";\nimport { pointInPolygon } from \"./geometry/boolean/point-in-polygon\";\nimport { createBBoxFromPoint } from \"./geometry/shape/create-bbox\";\nimport { ValidateMinAreaSquareMeters } from \"./validations/min-size.validation\";\nimport { ValidateMaxAreaSquareMeters } from \"./validations/max-size.validation\";\nimport { ValidateNotSelfIntersecting } from \"./validations/not-self-intersecting.validation\";\nimport { TerraDrawAngledRectangleMode } from \"./modes/angled-rectangle/angled-rectangle.mode\";\nimport { TerraDrawSectorMode } from \"./modes/sector/sector.mode\";\nimport { TerraDrawSensorMode } from \"./modes/sensor/sensor.mode\";\nimport * as TerraDrawExtend from \"./extend\";\nimport { hasModeProperty } from \"./store/store-feature-validation\";\nimport { ValidationReasons } from \"./validation-reasons\";\nimport { TerraDrawFreehandLineStringMode } from \"./modes/freehand-linestring/freehand-linestring.mode\";\nimport { lngLatToWebMercatorXY } from \"./geometry/project/web-mercator\";\nimport { transformRotateWebMercator } from \"./geometry/transform/rotate\";\nimport { transformScaleWebMercatorCoordinates } from \"./geometry/transform/scale\";\nimport { limitPrecision } from \"./geometry/limit-decimal-precision\";\nimport { isValidJSONValue } from \"./store/valid-json\";\nimport { haversineDistanceKilometers } from \"./geometry/measure/haversine-distance\";\n\n// Helper type to determine the instance type of a class\ntype InstanceType<T extends new (...args: any[]) => any> = T extends new (\n\t...args: any[]\n) => infer R\n\t? R\n\t: never;\n\ntype FinishListener = (id: FeatureId, context: OnFinishContext) => void;\ntype ChangeListener = (\n\tids: FeatureId[],\n\ttype: string,\n\tcontext?: OnChangeContext,\n) => void;\ntype SelectListener = (id: FeatureId) => void;\ntype DeselectListener = () => void;\n\ninterface TerraDrawEventListeners {\n\tready: () => void;\n\tfinish: FinishListener;\n\tchange: ChangeListener;\n\tselect: SelectListener;\n\tdeselect: DeselectListener;\n}\n\ntype GetFeatureOptions = {\n\tpointerDistance?: number;\n\tincludePolygonsWithinPointerDistance?: boolean;\n\tignoreSelectFeatures?: boolean;\n\tignoreCoordinatePoints?: boolean;\n\tignoreCurrentlyDrawing?: boolean;\n\tignoreClosingPoints?: boolean;\n\taddClosestCoordinateInfoToProperties?: boolean;\n};\n\ntype TerraDrawEvents = keyof TerraDrawEventListeners;\n\nclass TerraDraw {\n\tprivate _modes: {\n\t\t[mode: string]: TerraDrawBaseDrawMode<any> | TerraDrawBaseSelectMode<any>;\n\t};\n\tprivate _mode: TerraDrawBaseDrawMode<any> | TerraDrawBaseSelectMode<any>;\n\tprivate _adapter: TerraDrawAdapter;\n\tprivate _enabled = false;\n\tprivate _store: TerraDrawGeoJSONStore;\n\tprivate _eventListeners: {\n\t\tready: (() => void)[];\n\t\tchange: ChangeListener[];\n\t\tfinish: FinishListener[];\n\t\tselect: SelectListener[];\n\t\tdeselect: DeselectListener[];\n\t};\n\t// This is the select mode that is assigned in the instance.\n\t// There can only be 1 select mode active per instance\n\tprivate _instanceSelectMode: undefined | string;\n\n\tconstructor(options: {\n\t\tadapter: TerraDrawAdapter;\n\t\tmodes: TerraDrawBaseDrawMode<any>[];\n\t\tidStrategy?: IdStrategy<FeatureId>;\n\t\ttracked?: boolean;\n\t}) {\n\t\tthis._adapter = options.adapter;\n\n\t\tthis._mode = new TerraDrawStaticMode();\n\n\t\t// Keep track of if there are duplicate modes\n\t\tconst duplicateModeTracker = new Set();\n\n\t\t// Construct a map of the mode name to the mode\n\t\tconst modesMap = options.modes.reduce<{\n\t\t\t[mode: string]: TerraDrawBaseDrawMode<any>;\n\t\t}>((modeMap, currentMode) => {\n\t\t\tif (duplicateModeTracker.has(currentMode.mode)) {\n\t\t\t\tthrow new Error(`There is already a ${currentMode.mode} mode provided`);\n\t\t\t}\n\t\t\tduplicateModeTracker.add(currentMode.mode);\n\t\t\tmodeMap[currentMode.mode] = currentMode;\n\t\t\treturn modeMap;\n\t\t}, {});\n\n\t\t// Construct an array of the mode keys (names)\n\t\tconst modeKeys = Object.keys(modesMap);\n\n\t\t// Ensure at least one draw mode is provided\n\t\tif (modeKeys.length === 0) {\n\t\t\tthrow new Error(\"No modes provided\");\n\t\t}\n\n\t\t// Ensure only one select mode can be present\n\t\tmodeKeys.forEach((mode) => {\n\t\t\tif (modesMap[mode].type !== ModeTypes.Select) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._instanceSelectMode) {\n\t\t\t\tthrow new Error(\"only one type of select mode can be provided\");\n\t\t\t} else {\n\t\t\t\tthis._instanceSelectMode = mode;\n\t\t\t}\n\t\t});\n\n\t\tthis._modes = { ...modesMap, static: this._mode };\n\t\tthis._eventListeners = {\n\t\t\tchange: [],\n\t\t\tselect: [],\n\t\t\tdeselect: [],\n\t\t\tfinish: [],\n\t\t\tready: [],\n\t\t};\n\t\tthis._store = new GeoJSONStore<OnChangeContext | undefined, FeatureId>({\n\t\t\ttracked: options.tracked ? true : false,\n\t\t\tidStrategy: options.idStrategy ? options.idStrategy : undefined,\n\t\t});\n\n\t\tconst getChanged = (\n\t\t\tids: FeatureId[],\n\t\t): {\n\t\t\tchanged: GeoJSONStoreFeatures[];\n\t\t\tunchanged: GeoJSONStoreFeatures[];\n\t\t} => {\n\t\t\tconst changed: GeoJSONStoreFeatures[] = [];\n\n\t\t\tconst unchanged = this._store.copyAll().filter((f) => {\n\t\t\t\tif (ids.includes(f.id as string)) {\n\t\t\t\t\tchanged.push(f);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t\treturn { changed, unchanged };\n\t\t};\n\n\t\tconst onFinish = (finishedId: FeatureId, context: OnFinishContext) => {\n\t\t\tif (!this._enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._eventListeners.finish.forEach((listener) => {\n\t\t\t\tlistener(finishedId, context);\n\t\t\t});\n\t\t};\n\n\t\tconst onChange: StoreChangeHandler<OnChangeContext | undefined> = (\n\t\t\tids,\n\t\t\tevent,\n\t\t\tcontext,\n\t\t) => {\n\t\t\tif (!this._enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._eventListeners.change.forEach((listener) => {\n\t\t\t\tlistener(ids, event, context);\n\t\t\t});\n\n\t\t\tconst { changed, unchanged } = getChanged(ids);\n\n\t\t\tif (event === \"create\") {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{\n\t\t\t\t\t\tcreated: changed,\n\t\t\t\t\t\tdeletedIds: [],\n\t\t\t\t\t\tunchanged,\n\t\t\t\t\t\tupdated: [],\n\t\t\t\t\t},\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t} else if (event === \"update\") {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{\n\t\t\t\t\t\tcreated: [],\n\t\t\t\t\t\tdeletedIds: [],\n\t\t\t\t\t\tunchanged,\n\t\t\t\t\t\tupdated: changed,\n\t\t\t\t\t},\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t} else if (event === \"delete\") {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{ created: [], deletedIds: ids, unchanged, updated: [] },\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t} else if (event === \"styling\") {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{ created: [], deletedIds: [], unchanged, updated: [] },\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\tconst onSelect = (selectedId: string) => {\n\t\t\tif (!this._enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._eventListeners.select.forEach((listener) => {\n\t\t\t\tlistener(selectedId);\n\t\t\t});\n\n\t\t\tconst { changed, unchanged } = getChanged([selectedId]);\n\n\t\t\tthis._adapter.render(\n\t\t\t\t{ created: [], deletedIds: [], unchanged, updated: changed },\n\t\t\t\tthis.getModeStyles(),\n\t\t\t);\n\t\t};\n\n\t\tconst onDeselect = (deselectedId: string) => {\n\t\t\tif (!this._enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._eventListeners.deselect.forEach((listener) => {\n\t\t\t\tlistener();\n\t\t\t});\n\n\t\t\tconst { changed, unchanged } = getChanged([deselectedId]);\n\n\t\t\t// onDeselect can be called after a delete call which means that\n\t\t\t// you are deselecting a feature that has been deleted. We\n\t\t\t// double check here to ensure that the feature still exists.\n\t\t\tif (changed) {\n\t\t\t\tthis._adapter.render(\n\t\t\t\t\t{\n\t\t\t\t\t\tcreated: [],\n\t\t\t\t\t\tdeletedIds: [],\n\t\t\t\t\t\tunchanged,\n\t\t\t\t\t\tupdated: changed,\n\t\t\t\t\t},\n\t\t\t\t\tthis.getModeStyles(),\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\t// Register stores and callbacks\n\t\tObject.keys(this._modes).forEach((modeId) => {\n\t\t\tthis._modes[modeId].register({\n\t\t\t\tmode: modeId,\n\t\t\t\tstore: this._store,\n\t\t\t\tsetCursor: this._adapter.setCursor.bind(this._adapter),\n\t\t\t\tproject: this._adapter.project.bind(this._adapter),\n\t\t\t\tunproject: this._adapter.unproject.bind(this._adapter),\n\t\t\t\tsetDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(\n\t\t\t\t\tthis._adapter,\n\t\t\t\t),\n\t\t\t\tonChange: onChange,\n\t\t\t\tonSelect: onSelect,\n\t\t\t\tonDeselect: onDeselect,\n\t\t\t\tonFinish: onFinish,\n\t\t\t\tcoordinatePrecision: this._adapter.getCoordinatePrecision(),\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate checkEnabled() {\n\t\tif (!this._enabled) {\n\t\t\tthrow new Error(\"Terra Draw is not enabled\");\n\t\t}\n\t}\n\n\tprivate getModeStyles() {\n\t\tconst modeStyles: {\n\t\t\t[key: string]: (feature: GeoJSONStoreFeatures) => TerraDrawAdapterStyling;\n\t\t} = {};\n\n\t\tObject.keys(this._modes).forEach((mode) => {\n\t\t\tmodeStyles[mode] = (feature: GeoJSONStoreFeatures) => {\n\t\t\t\t// If the feature is selected, we want to use the select mode styling\n\t\t\t\tif (\n\t\t\t\t\tthis._instanceSelectMode &&\n\t\t\t\t\tfeature.properties[SELECT_PROPERTIES.SELECTED]\n\t\t\t\t) {\n\t\t\t\t\treturn this._modes[this._instanceSelectMode].styleFeature.bind(\n\t\t\t\t\t\tthis._modes[this._instanceSelectMode],\n\t\t\t\t\t)(feature);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise use regular styling\n\t\t\t\treturn this._modes[mode].styleFeature.bind(this._modes[mode])(feature);\n\t\t\t};\n\t\t});\n\t\treturn modeStyles;\n\t}\n\n\tprivate featuresAtLocation(\n\t\t{\n\t\t\tlng,\n\t\t\tlat,\n\t\t}: {\n\t\t\tlng: number;\n\t\t\tlat: number;\n\t\t},\n\t\toptions?: GetFeatureOptions,\n\t) {\n\t\tconst pointerDistance =\n\t\t\toptions && options.pointerDistance !== undefined\n\t\t\t\t? options.pointerDistance\n\t\t\t\t: 30; // default is 30px\n\n\t\tconst ignoreSelectFeatures =\n\t\t\toptions && options.ignoreSelectFeatures !== undefined\n\t\t\t\t? options.ignoreSelectFeatures\n\t\t\t\t: true;\n\n\t\tconst ignoreCoordinatePoints =\n\t\t\toptions && options.ignoreCoordinatePoints !== undefined\n\t\t\t\t? options.ignoreCoordinatePoints\n\t\t\t\t: false;\n\n\t\tconst ignoreCurrentlyDrawing =\n\t\t\toptions && options.ignoreCurrentlyDrawing !== undefined\n\t\t\t\t? options.ignoreCurrentlyDrawing\n\t\t\t\t: false;\n\n\t\tconst ignoreClosingPoints =\n\t\t\toptions && options.ignoreClosingPoints !== undefined\n\t\t\t\t? options.ignoreClosingPoints\n\t\t\t\t: false;\n\n\t\tconst unproject = this._adapter.unproject.bind(this._adapter);\n\t\tconst project = this._adapter.project.bind(this._adapter);\n\n\t\tconst inputPoint = project(lng, lat);\n\n\t\tconst bbox = createBBoxFromPoint({\n\t\t\tunproject,\n\t\t\tpoint: inputPoint,\n\t\t\tpointerDistance,\n\t\t});\n\n\t\tconst features = this._store.search(bbox as BBoxPolygon);\n\n\t\treturn features\n\t\t\t.filter((feature) => {\n\t\t\t\tif (\n\t\t\t\t\tignoreSelectFeatures &&\n\t\t\t\t\t(feature.properties[SELECT_PROPERTIES.MID_POINT] ||\n\t\t\t\t\t\tfeature.properties[SELECT_PROPERTIES.SELECTION_POINT])\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tignoreCoordinatePoints &&\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.COORDINATE_POINT]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tignoreClosingPoints &&\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.CLOSING_POINT]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tignoreCurrentlyDrawing &&\n\t\t\t\t\tfeature.properties[COMMON_PROPERTIES.CURRENTLY_DRAWING]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (feature.geometry.type === \"Point\") {\n\t\t\t\t\tconst pointCoordinates = feature.geometry.coordinates;\n\t\t\t\t\tconst pointXY = project(pointCoordinates[0], pointCoordinates[1]);\n\t\t\t\t\tconst distance = cartesianDistance(inputPoint, pointXY);\n\t\t\t\t\treturn distance < pointerDistance;\n\t\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\t\tconst coordinates: Position[] = feature.geometry.coordinates;\n\n\t\t\t\t\tfor (let i = 0; i < coordinates.length - 1; i++) {\n\t\t\t\t\t\tconst coord = coordinates[i];\n\t\t\t\t\t\tconst nextCoord = coordinates[i + 1];\n\t\t\t\t\t\tconst distanceToLine = pixelDistanceToLine(\n\t\t\t\t\t\t\tinputPoint,\n\t\t\t\t\t\t\tproject(coord[0], coord[1]),\n\t\t\t\t\t\t\tproject(nextCoord[0], nextCoord[1]),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (distanceToLine < pointerDistance) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tconst lngLatInsidePolygon = pointInPolygon(\n\t\t\t\t\t\t[lng, lat],\n\t\t\t\t\t\tfeature.geometry.coordinates,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (lngLatInsidePolygon) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (options?.includePolygonsWithinPointerDistance) {\n\t\t\t\t\t\tconst rings: Position[][] = feature.geometry.coordinates;\n\n\t\t\t\t\t\tfor (const ring of rings) {\n\t\t\t\t\t\t\tfor (let i = 0; i < ring.length - 1; i++) {\n\t\t\t\t\t\t\t\tconst coord = ring[i];\n\t\t\t\t\t\t\t\tconst nextCoord = ring[i + 1];\n\n\t\t\t\t\t\t\t\tconst projectedStart = project(coord[0], coord[1]);\n\t\t\t\t\t\t\t\tconst projectedEnd = project(nextCoord[0], nextCoord[1]);\n\n\t\t\t\t\t\t\t\tconst distanceToEdge = pixelDistanceToLine(\n\t\t\t\t\t\t\t\t\tinputPoint,\n\t\t\t\t\t\t\t\t\tprojectedStart,\n\t\t\t\t\t\t\t\t\tprojectedEnd,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (distanceToEdge < pointerDistance) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.map((feature) => {\n\t\t\t\tif (!options?.addClosestCoordinateInfoToProperties) {\n\t\t\t\t\treturn feature;\n\t\t\t\t}\n\n\t\t\t\tlet coordinates;\n\t\t\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t\t\t\tcoordinates.pop(); // Remove duplicate end coordinate\n\t\t\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t\t\t} else {\n\t\t\t\t\t// Ignore points\n\t\t\t\t\treturn feature;\n\t\t\t\t}\n\n\t\t\t\tlet closestIndex = -1;\n\t\t\t\tlet closestDistance = Infinity;\n\t\t\t\tlet closestCoordinate;\n\n\t\t\t\t// Find the closest coordinate in the polygon/linestring to the pointer event\n\t\t\t\tfor (let i = 0; i < coordinates.length; i++) {\n\t\t\t\t\tconst coordinate = coordinates[i];\n\t\t\t\t\tconst distance = cartesianDistance(\n\t\t\t\t\t\tproject(coordinate[0], coordinate[1]),\n\t\t\t\t\t\tinputPoint,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (distance < closestDistance) {\n\t\t\t\t\t\tclosestIndex = i;\n\t\t\t\t\t\tclosestDistance = distance;\n\t\t\t\t\t\tclosestCoordinate = coordinate;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfeature.properties.closestCoordinateIndexToEvent = closestIndex;\n\t\t\t\tfeature.properties.closestCoordinatePixelDistanceToEvent =\n\t\t\t\t\tclosestDistance;\n\t\t\t\tfeature.properties.closestCoordinateDistanceKmToEvent =\n\t\t\t\t\thaversineDistanceKilometers(closestCoordinate!, [lng, lat]);\n\n\t\t\t\treturn feature;\n\t\t\t});\n\t}\n\n\tprivate getSelectModeOrThrow() {\n\t\tconst selectMode = this.getSelectMode({ switchToSelectMode: true });\n\n\t\tif (!selectMode) {\n\t\t\tthrow new Error(\"No select mode defined in instance\");\n\t\t}\n\n\t\treturn selectMode;\n\t}\n\n\tprivate getSelectMode({\n\t\tswitchToSelectMode,\n\t}: {\n\t\tswitchToSelectMode: boolean;\n\t}) {\n\t\tthis.checkEnabled();\n\n\t\tif (!this._instanceSelectMode) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currentMode = this.getMode();\n\n\t\t// If we're not already in the select mode, we switch to it\n\t\tif (switchToSelectMode && currentMode !== this._instanceSelectMode) {\n\t\t\tthis.setMode(this._instanceSelectMode);\n\t\t}\n\n\t\tconst selectMode = this._modes[\n\t\t\tthis._instanceSelectMode\n\t\t] as TerraDrawBaseSelectMode<any>;\n\n\t\treturn selectMode;\n\t}\n\n\tprivate isGuidanceFeature(feature: GeoJSONStoreFeatures): boolean {\n\t\treturn Boolean(\n\t\t\tfeature.properties[SELECT_PROPERTIES.MID_POINT] ||\n\t\t\t\tfeature.properties[SELECT_PROPERTIES.SELECTION_POINT] ||\n\t\t\t\tfeature.properties[COMMON_PROPERTIES.COORDINATE_POINT] ||\n\t\t\t\tfeature.properties[COMMON_PROPERTIES.SNAPPING_POINT],\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated This method is scheduled for removal in the next major version. Instead use the 'updateModeOptions' method passing the\n\t * styles property in the options object, and this will dynamically update the styles for the mode.\n\t *\n\t * Allows the setting of a style for a given mode\n\t *\n\t * @param mode - The mode you wish to set a style for\n\t * @param styles - The styles you wish to set for the mode - this is\n\t * the same as the initialisation style schema\n\t */\n\tsetModeStyles<Styling extends Record<string, number | HexColor>>(\n\t\tmode: string,\n\t\tstyles: Styling,\n\t) {\n\t\tthis.checkEnabled();\n\t\tif (!this._modes[mode]) {\n\t\t\tthrow new Error(\"No mode with this name present\");\n\t\t}\n\n\t\t// TODO: Not sure why this fails TypeScript with TerraDrawBaseSelectMode?\n\t\t(this._modes[mode] as TerraDrawBaseDrawMode<any>).styles = styles;\n\t}\n\n\t/**\n\t * Allow updating of the current options passed to the mode dynamically\n\t * after the mode has been started. You can also use this method to update styles\n\t * as these are passed from the options object.\n\t * @param mode - the mode name you wish to update (the mode name is the public 'mode' property of the mode class)\n\t * @param options - the options object - this allows _partial_ updating of the modes options (i.e. you do not need to pass the whole options object)\n\t */\n\tupdateModeOptions<Mode extends { new (...args: any[]): any }>(\n\t\tmode: InstanceType<Mode>[\"mode\"],\n\t\toptions: ConstructorParameters<Mode>[0],\n\t) {\n\t\tthis.checkEnabled();\n\t\tif (!this._modes[mode]) {\n\t\t\tthrow new Error(\"No mode with this name present\");\n\t\t}\n\n\t\tthis._modes[mode].updateOptions(\n\t\t\toptions as TerraDrawExtend.BaseModeOptions<any>,\n\t\t);\n\t}\n\n\t/**\n\t * Allows the user to get a snapshot (copy) of all given features\n\t *\n\t * @returns An array of all given Feature Geometries in the instances store\n\t */\n\tgetSnapshot() {\n\t\t// This is a read only method so we do not need to check if enabled\n\t\treturn this._store.copyAll();\n\t}\n\n\t/**\n\t * Allows the user to get a snapshot (copy) of a given feature by id\n\t *\n\t * @returns A copy of the feature geometry in the instances store\n\t */\n\tgetSnapshotFeature(id: FeatureId) {\n\t\tif (!this._store.has(id)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._store.copy(id);\n\t}\n\n\t/**\n\t * Removes all data from the current store and ensures any rendered data is cleared\n\t * from the map.\n\t */\n\tclear() {\n\t\tthis.checkEnabled();\n\t\tthis._adapter.clear();\n\t}\n\n\t/**\n\t * A property used to determine whether the instance is active or not. You\n\t * can use the start method to set this to true, and stop method to set this to false.\n\t * This is a read only property.\n\t *\n\t * @return true or false depending on if the instance is stopped or started\n\t * @readonly\n\t */\n\tget enabled(): boolean {\n\t\treturn this._enabled;\n\t}\n\n\t/**\n\t * enabled is a read only property and will throw and error if you try and set it.\n\t */\n\tset enabled(_) {\n\t\tthrow new Error(\"Enabled is read only\");\n\t}\n\n\t/**\n\t * A method for getting the current mode name\n\t * @return the current mode name\n\t */\n\tgetMode(): string {\n\t\t// This is a read only method so we do not need to check if enabled\n\t\treturn this._mode.mode;\n\t}\n\n\t/**\n\t * Get the state of the mode i.e. if we are currently unregistered, registered, drawing etc. This can\n\t * be used to make decisions based on what the current mode is doing.\n\t * @returns the current mode state as a string\n\t */\n\tgetModeState() {\n\t\treturn this._mode.state;\n\t}\n\n\t/**\n\t * A method for setting the current mode by name. Under the hood this will stop\n\t * the previous mode and start the new one.\n\t * @param mode - The mode name you wish to start\n\t */\n\tsetMode(mode: string) {\n\t\tthis.checkEnabled();\n\n\t\tif (this._modes[mode]) {\n\t\t\t// Before we swap modes we want to\n\t\t\t// clean up any state that has been left behind,\n\t\t\t// for example current drawing geometries\n\t\t\t// and mode state\n\t\t\tthis._mode.stop();\n\n\t\t\t// Swap the mode to the new mode\n\t\t\tthis._mode = this._modes[mode];\n\n\t\t\t// Start the new mode\n\t\t\tthis._mode.start();\n\t\t} else {\n\t\t\t// If the mode doesn't exist, we throw an error\n\t\t\tthrow new Error(\"No mode with this name present\");\n\t\t}\n\t}\n\n\t/**\n\t * A method for removing features to the store\n\t * @param ids\n\t * @returns\n\t */\n\tremoveFeatures(ids: FeatureId[]) {\n\t\tthis.checkEnabled();\n\n\t\tconst coordinatePointsToDelete: FeatureId[] = [];\n\n\t\tids.forEach((id) => {\n\t\t\t// Deselect any passed features - this removes all selection points and midpoints\n\t\t\tif (!this._store.has(id)) {\n\t\t\t\tthrow new Error(`No feature with id ${id}, can not delete`);\n\t\t\t}\n\n\t\t\tconst feature = this._store.copy(id);\n\t\t\tif (feature.properties[SELECT_PROPERTIES.SELECTED]) {\n\t\t\t\tthis.deselectFeature(id);\n\t\t\t}\n\n\t\t\t// If the feature has coordinate points, we want to remove them as well\n\t\t\tif (feature.properties[COMMON_PROPERTIES.COORDINATE_POINT_IDS]) {\n\t\t\t\tcoordinatePointsToDelete.push(\n\t\t\t\t\t...(feature.properties[\n\t\t\t\t\t\tCOMMON_PROPERTIES.COORDINATE_POINT_IDS\n\t\t\t\t\t] as FeatureId[]),\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tthis._store.delete([...ids, ...coordinatePointsToDelete], {\n\t\t\torigin: \"api\",\n\t\t});\n\t}\n\n\t/**\n\t * Provides the ability to programmatically select a feature using the instances provided select mode.\n\t * If not select mode is provided in the instance, an error will be thrown. If the instance is not currently\n\t * in the select mode, it will switch to it.\n\t * @param id - the id of the feature to select\n\t */\n\tselectFeature(id: FeatureId) {\n\t\tconst selectMode = this.getSelectModeOrThrow();\n\t\tselectMode.selectFeature(id);\n\t}\n\n\t/**\n\t * Provides the ability to programmatically deselect a feature using the instances provided select mode.\n\t * If not select mode is provided in the instance, an error will be thrown. If the instance is not currently\n\t * in the select mode, it will switch to it.\n\t * @param id  - the id of the feature to deselect\n\t */\n\tdeselectFeature(id: FeatureId) {\n\t\tconst selectMode = this.getSelectModeOrThrow();\n\t\tselectMode.deselectFeature(id);\n\t}\n\n\t/**\n\t * Returns the next feature id from the store - defaults to UUID4 unless you have\n\t * set a custom idStrategy. This method can be useful if you are needing creating features\n\t * outside of the Terra Draw instance but want to add them in to the store.\n\t * @returns a id, either number of string based on whatever the configured idStrategy is\n\t *\n\t */\n\tgetFeatureId(): FeatureId {\n\t\treturn this._store.getId();\n\t}\n\n\t/**\n\t * Returns true or false depending on if the Terra Draw instance has a feature with a given id\n\t * @returns a boolean determining if the instance has a feature with the given id\n\t */\n\thasFeature(id: FeatureId): boolean {\n\t\treturn this._store.has(id);\n\t}\n\n\t/**\n\t * Checks if a property name is reserved and cannot be used.\n\t * @param propertyName - the property name to check\n\t * @returns\n\t */\n\tprivate checkIsReservedProperty(propertyName: string) {\n\t\tconst UNAVAILABLE_PROPERTIES = [\n\t\t\t...Object.values(SELECT_PROPERTIES),\n\t\t\t...Object.values(COMMON_PROPERTIES),\n\t\t] as const;\n\n\t\treturn !UNAVAILABLE_PROPERTIES.includes(\n\t\t\tpropertyName as unknown as (typeof UNAVAILABLE_PROPERTIES)[number],\n\t\t);\n\t}\n\n\t/**\n\t * Updates a features properties. This can be used to programmatically change the properties of a feature.\n\t * The update is a shallow merge so only the properties you provide will be updated. Certain internal properties\n\t * are reserved and cannot be updated.\n\t * @param id - the id of the feature to update the property for\n\t * @param properties - an object of key value pairs that will be shallowly merged in to the features properties\n\t */\n\tupdateFeatureProperties(\n\t\tid: FeatureId,\n\t\tproperties: Record<string, JSON | undefined>,\n\t) {\n\t\tif (!this._store.has(id)) {\n\t\t\tthrow new Error(`No feature with id ${id} present in store`);\n\t\t}\n\n\t\tconst feature = this._store.copy(id);\n\n\t\t// We don't want users to be able to update guidance features directly\n\t\tif (this.isGuidanceFeature(feature)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Guidance features are not allowed to be updated directly.`,\n\t\t\t);\n\t\t}\n\n\t\tconst mode = feature.properties.mode;\n\t\tconst modeToUpdate = this._modes[mode as string];\n\n\t\tif (!modeToUpdate) {\n\t\t\tthrow new Error(`No mode with name ${mode} present in instance`);\n\t\t}\n\n\t\tconst entries = Object.entries(properties);\n\n\t\t// Check that none of the properties are reserved\n\t\tentries.forEach(([propertyName, value]) => {\n\t\t\tconst isReservedProperty = this.checkIsReservedProperty(propertyName);\n\n\t\t\tif (!isReservedProperty) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`You are trying to update a reserved property name: ${propertyName}. Please choose another name.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (value !== undefined && !isValidJSONValue(value)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid JSON value provided for property ${propertyName}`,\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tthis._store.updateProperty(\n\t\t\tentries.map(([propertyName, value]) => ({\n\t\t\t\tid: feature.id as FeatureId,\n\t\t\t\tproperty: propertyName,\n\t\t\t\tvalue,\n\t\t\t})),\n\t\t\t{ origin: \"api\" }, // origin is used to indicate that this update has come from an API call\n\t\t);\n\t}\n\n\t/**\n\t * Updates a features geometry. This an be used to programmatically change the coordinates of a feature. This\n\t * can be useful for if you want to modify a geometry via a button or some similar user interaction.\n\t * @param id - the id of the feature to update the geometry for\n\t * @param geometry - the new geometry that will replace the existing geometry\n\t */\n\tupdateFeatureGeometry(id: FeatureId, geometry: GeoJSONStoreGeometries) {\n\t\tif (!this._store.has(id)) {\n\t\t\tthrow new Error(`No feature with id ${id} present in store`);\n\t\t}\n\n\t\tconst feature = this._store.copy(id);\n\n\t\t// We don't want users to be able to update guidance features directly\n\t\tif (this.isGuidanceFeature(feature)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Guidance features are not allowed to be updated directly.`,\n\t\t\t);\n\t\t}\n\n\t\t// Ensure that the geometry is valid\n\t\tif (!feature || !geometry || !geometry.type || !geometry.coordinates) {\n\t\t\tthrow new Error(\"Invalid geometry provided\");\n\t\t}\n\t\tif (geometry.type !== feature.geometry.type) {\n\t\t\tthrow new Error(\n\t\t\t\t`Geometry type mismatch: expected ${feature.geometry.type}, got ${geometry.type}`,\n\t\t\t);\n\t\t}\n\n\t\tconst mode = feature.properties.mode;\n\t\tconst modeToUpdate = this._modes[mode as string];\n\n\t\tif (!modeToUpdate) {\n\t\t\tthrow new Error(`No mode with name ${mode} present in instance`);\n\t\t}\n\n\t\tconst updatedFeature = { ...feature, geometry };\n\n\t\tconst validationResult = modeToUpdate.validateFeature(updatedFeature);\n\n\t\tif (!validationResult.valid) {\n\t\t\tthrow new Error(\n\t\t\t\t`Feature validation failed: ${validationResult.reason || \"Unknown reason\"}`,\n\t\t\t);\n\t\t}\n\n\t\tthis._store.updateGeometry(\n\t\t\t[{ id: feature.id as FeatureId, geometry }],\n\t\t\t{ origin: \"api\" }, // origin is used to indicate that this update has come from an API call\n\t\t);\n\n\t\t// If the mode has an afterFeatureUpdated method, we call it\n\t\tif (modeToUpdate.afterFeatureUpdated) {\n\t\t\tmodeToUpdate.afterFeatureUpdated(updatedFeature);\n\n\t\t\tconst featureIsSelected =\n\t\t\t\tupdatedFeature.properties[SELECT_PROPERTIES.SELECTED];\n\t\t\tconst selectModePresent = this.getSelectMode({\n\t\t\t\tswitchToSelectMode: false,\n\t\t\t});\n\n\t\t\tif (selectModePresent && featureIsSelected) {\n\t\t\t\tselectModePresent.afterFeatureUpdated(updatedFeature);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A method for transforming a feature's geometry. This can be used to rotate or scale a feature's geometry.\n\t * This matches the functionality of the scale and rotate behaviors in the select mode.\n\t * @param id - the id of the feature to transform\n\t * @param transformation - the transformation to apply to the feature's geometry\n\t */\n\ttransformFeatureGeometry(\n\t\tid: FeatureId,\n\t\ttransformation:\n\t\t\t| {\n\t\t\t\t\tprojection?: Exclude<Projection, \"globe\">;\n\t\t\t\t\torigin: Position;\n\t\t\t\t\ttype: \"rotate\";\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tangle: number;\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\tprojection?: Exclude<Projection, \"globe\">;\n\t\t\t\t\torigin: Position;\n\t\t\t\t\ttype: \"scale\";\n\t\t\t\t\toptions: {\n\t\t\t\t\t\txScale: number;\n\t\t\t\t\t\tyScale: number;\n\t\t\t\t\t};\n\t\t\t  },\n\t) {\n\t\tif (!this._store.has(id)) {\n\t\t\tthrow new Error(`No feature with id ${id} present in store`);\n\t\t}\n\n\t\tlet feature = this._store.copy(id);\n\n\t\t// We don't want users to be able to update guidance features directly\n\t\tif (this.isGuidanceFeature(feature)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Guidance features are not allowed to be updated directly.`,\n\t\t\t);\n\t\t}\n\n\t\tconst mode = feature.properties.mode;\n\t\tconst modeToUpdate = this._modes[mode as string];\n\n\t\tif (!modeToUpdate) {\n\t\t\tthrow new Error(`No mode with name ${mode} present in instance`);\n\t\t}\n\n\t\tlet coordinates: Position[];\n\t\tif (feature.geometry.type === \"Polygon\") {\n\t\t\tcoordinates = feature.geometry.coordinates[0];\n\t\t} else if (feature.geometry.type === \"LineString\") {\n\t\t\tcoordinates = feature.geometry.coordinates;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`Feature geometry type ${feature.geometry.type} is not supported for transformation`,\n\t\t\t);\n\t\t}\n\n\t\tif (transformation.projection == \"web-mercator\") {\n\t\t\tif (transformation.type === \"scale\") {\n\t\t\t\tconst { x: originX, y: originY } = lngLatToWebMercatorXY(\n\t\t\t\t\ttransformation.origin[0],\n\t\t\t\t\ttransformation.origin[1],\n\t\t\t\t);\n\n\t\t\t\tconst xScale = transformation.options.xScale || 1;\n\t\t\t\tconst yScale = transformation.options.yScale || 1;\n\n\t\t\t\ttransformScaleWebMercatorCoordinates({\n\t\t\t\t\tcoordinates,\n\t\t\t\t\toriginX,\n\t\t\t\t\toriginY,\n\t\t\t\t\txScale,\n\t\t\t\t\tyScale,\n\t\t\t\t});\n\t\t\t} else if (transformation.type === \"rotate\") {\n\t\t\t\tconst angle = transformation.options.angle || 0;\n\t\t\t\tfeature = transformRotateWebMercator(\n\t\t\t\t\tfeature as Feature<Polygon> | Feature<LineString>,\n\t\t\t\t\tangle,\n\t\t\t\t) as GeoJSONStoreFeatures;\n\n\t\t\t\tcoordinates =\n\t\t\t\t\tfeature.geometry.type === \"Polygon\"\n\t\t\t\t\t\t? (feature.geometry as Polygon).coordinates[0]\n\t\t\t\t\t\t: (feature.geometry as LineString).coordinates;\n\t\t\t}\n\n\t\t\tcoordinates = coordinates.map((coord) => [\n\t\t\t\tlimitPrecision(coord[0], this._adapter.getCoordinatePrecision()),\n\t\t\t\tlimitPrecision(coord[1], this._adapter.getCoordinatePrecision()),\n\t\t\t]);\n\n\t\t\tfeature.geometry.coordinates =\n\t\t\t\tfeature.geometry.type === \"Polygon\" ? [coordinates] : coordinates;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`Projection ${transformation.projection} is not currently supported for transformation`,\n\t\t\t);\n\t\t}\n\n\t\tthis._store.updateGeometry(\n\t\t\t[{ id: feature.id as FeatureId, geometry: feature.geometry }],\n\t\t\t{ origin: \"api\" }, // origin is used to indicate that this update has come from an API call\n\t\t);\n\n\t\tif (modeToUpdate.afterFeatureUpdated) {\n\t\t\tmodeToUpdate.afterFeatureUpdated(feature);\n\t\t\tconst featureIsSelected = feature.properties[SELECT_PROPERTIES.SELECTED];\n\t\t\tconst selectModePresent = this.getSelectMode({\n\t\t\t\tswitchToSelectMode: false,\n\t\t\t});\n\n\t\t\tif (selectModePresent && featureIsSelected) {\n\t\t\t\tselectModePresent.afterFeatureUpdated(feature);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A method for adding features to the store. This method will validate the features\n\t * returning an array of validation results. Features must match one of the modes enabled\n\t * in the instance.\n\t * @param features - an array of GeoJSON features\n\t * @returns an array of validation results\n\t */\n\taddFeatures(features: GeoJSONStoreFeatures[]): StoreValidation[] {\n\t\tthis.checkEnabled();\n\n\t\tif (features.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this._store.load(\n\t\t\tfeatures,\n\t\t\t(feature) => {\n\t\t\t\t// If the feature has a mode property, we use that to validate the feature\n\t\t\t\tif (hasModeProperty(feature)) {\n\t\t\t\t\tconst featureMode = feature.properties.mode;\n\t\t\t\t\tconst modeToAddTo = this._modes[featureMode];\n\n\t\t\t\t\t// if the mode does not exist, we return false\n\t\t\t\t\tif (!modeToAddTo) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tid: (feature as { id?: FeatureId }).id,\n\t\t\t\t\t\t\tvalid: false,\n\t\t\t\t\t\t\treason: `${featureMode} mode is not in the list of instantiated modes`,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// use the inbuilt validation of the mode\n\t\t\t\t\tconst validation = modeToAddTo.validateFeature.bind(modeToAddTo);\n\t\t\t\t\tconst validationResult = validation(feature);\n\t\t\t\t\tconst valid = validationResult.valid;\n\t\t\t\t\tconst reason = validationResult.reason\n\t\t\t\t\t\t? validationResult.reason\n\t\t\t\t\t\t: !validationResult.valid\n\t\t\t\t\t\t\t? \"Feature is invalid\"\n\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: (feature as { id?: FeatureId }).id,\n\t\t\t\t\t\tvalid,\n\t\t\t\t\t\treason,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// If the feature does not have a mode property, we return false\n\t\t\t\treturn {\n\t\t\t\t\tid: (feature as { id?: FeatureId }).id,\n\t\t\t\t\tvalid: false,\n\t\t\t\t\treason: \"Mode property does not exist\",\n\t\t\t\t};\n\t\t\t},\n\t\t\t(feature) => {\n\t\t\t\tif (hasModeProperty(feature)) {\n\t\t\t\t\tconst featureMode = feature.properties.mode;\n\t\t\t\t\tconst modeToAddTo = this._modes[featureMode];\n\t\t\t\t\tif (modeToAddTo && modeToAddTo.afterFeatureAdded) {\n\t\t\t\t\t\tmodeToAddTo.afterFeatureAdded(feature);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ origin: \"api\" },\n\t\t);\n\t}\n\n\t/**\n\t * A method starting Terra Draw. It put the instance into a started state, and\n\t * in registers the passed adapter giving it all the callbacks required to operate.\n\t */\n\tstart() {\n\t\t// If the instance is already enabled, we do nothing\n\t\tif (this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._enabled = true;\n\t\tthis._adapter.register({\n\t\t\tonReady: () => {\n\t\t\t\tthis._eventListeners.ready.forEach((listener) => {\n\t\t\t\t\tlistener();\n\t\t\t\t});\n\t\t\t},\n\t\t\tgetState: () => {\n\t\t\t\treturn this._mode.state;\n\t\t\t},\n\t\t\tonClick: (event) => {\n\t\t\t\tthis._mode.onClick(event);\n\t\t\t},\n\t\t\tonMouseMove: (event) => {\n\t\t\t\tthis._mode.onMouseMove(event);\n\t\t\t},\n\t\t\tonKeyDown: (event) => {\n\t\t\t\tthis._mode.onKeyDown(event);\n\t\t\t},\n\t\t\tonKeyUp: (event) => {\n\t\t\t\tthis._mode.onKeyUp(event);\n\t\t\t},\n\t\t\tonDragStart: (event, setMapDraggability) => {\n\t\t\t\tthis._mode.onDragStart(event, setMapDraggability);\n\t\t\t},\n\t\t\tonDrag: (event, setMapDraggability) => {\n\t\t\t\tthis._mode.onDrag(event, setMapDraggability);\n\t\t\t},\n\t\t\tonDragEnd: (event, setMapDraggability) => {\n\t\t\t\tthis._mode.onDragEnd(event, setMapDraggability);\n\t\t\t},\n\t\t\tonClear: () => {\n\t\t\t\t// Ensure that the mode resets its state\n\t\t\t\t// as it may be storing feature ids internally in it's instance\n\t\t\t\tthis._mode.cleanUp();\n\n\t\t\t\t// Remove all features from the store\n\t\t\t\tthis._store.clear();\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Gets the features at a given longitude and latitude.\n\t * Will return point and linestrings that are a given pixel distance\n\t * away from the lng/lat and any polygons which contain it.\n\t */\n\tgetFeaturesAtLngLat(\n\t\tlngLat: { lng: number; lat: number },\n\t\toptions?: GetFeatureOptions,\n\t) {\n\t\tconst { lng, lat } = lngLat;\n\n\t\treturn this.featuresAtLocation(\n\t\t\t{\n\t\t\t\tlng,\n\t\t\t\tlat,\n\t\t\t},\n\t\t\toptions,\n\t\t);\n\t}\n\n\t/**\n\t * Takes a given pointer event and will return point and linestrings that are\n\t * a given pixel distance away from the longitude/latitude, and any polygons which contain it.\n\t */\n\tgetFeaturesAtPointerEvent(\n\t\tevent: PointerEvent | MouseEvent,\n\t\toptions?: GetFeatureOptions,\n\t) {\n\t\tconst getLngLatFromEvent = this._adapter.getLngLatFromEvent.bind(\n\t\t\tthis._adapter,\n\t\t);\n\n\t\tconst lngLat = getLngLatFromEvent(event);\n\n\t\t// If the pointer event is outside the container or the underlying library is\n\t\t// not ready we can get null as a returned value\n\t\tif (lngLat === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.featuresAtLocation(lngLat, options);\n\t}\n\n\t/**\n\t * A method for stopping Terra Draw. Will clear the store, deregister the adapter and\n\t * remove any rendered layers in the process.\n\t */\n\tstop() {\n\t\t// If the instance is already stopped, we do nothing\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._enabled = false;\n\t\tthis._adapter.unregister();\n\t}\n\n\t/**\n\t * Registers a Terra Draw event\n\t *\n\t * @param event - The name of the event you wish to listen for\n\t * @param callback - The callback with you wish to be called when this event occurs\n\t *\n\t */\n\ton<T extends TerraDrawEvents>(\n\t\tevent: T,\n\t\tcallback: TerraDrawEventListeners[T],\n\t) {\n\t\tconst listeners = this._eventListeners[\n\t\t\tevent\n\t\t] as TerraDrawEventListeners[T][];\n\t\tif (!listeners.includes(callback)) {\n\t\t\tlisteners.push(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Unregisters a Terra Draw event\n\t *\n\t * @param event - The name of the event you wish to unregister\n\t * @param callback - The callback you originally provided to the 'on' method\n\t *\n\t */\n\toff<T extends TerraDrawEvents>(\n\t\tevent: TerraDrawEvents,\n\t\tcallback: TerraDrawEventListeners[T],\n\t) {\n\t\tconst listeners = this._eventListeners[\n\t\t\tevent\n\t\t] as TerraDrawEventListeners[T][];\n\t\tif (listeners.includes(callback)) {\n\t\t\tlisteners.splice(listeners.indexOf(callback), 1);\n\t\t}\n\t}\n}\n\nexport {\n\tTerraDraw,\n\ttype IdStrategy,\n\ttype TerraDrawEvents,\n\ttype TerraDrawEventListeners,\n\n\t// Modes\n\tTerraDrawSelectMode,\n\tTerraDrawPointMode,\n\tTerraDrawLineStringMode,\n\tTerraDrawPolygonMode,\n\tTerraDrawCircleMode,\n\tTerraDrawFreehandMode,\n\tTerraDrawFreehandLineStringMode,\n\tTerraDrawRenderMode,\n\tTerraDrawRectangleMode,\n\tTerraDrawAngledRectangleMode,\n\tTerraDrawSectorMode,\n\tTerraDrawSensorMode,\n\n\t// Types that are required for 3rd party developers to extend\n\tTerraDrawExtend,\n\n\t// TerraDrawBaseMode\n\ttype BehaviorConfig,\n\ttype GeoJSONStoreFeatures,\n\ttype GeoJSONStoreGeometries,\n\ttype HexColor,\n\ttype TerraDrawMouseEvent,\n\ttype TerraDrawAdapterStyling,\n\ttype TerraDrawKeyboardEvent,\n\n\t// TerraDrawBaseAdapter\n\ttype TerraDrawChanges,\n\ttype TerraDrawStylingFunction,\n\ttype Project,\n\ttype Unproject,\n\ttype SetCursor,\n\ttype GetLngLatFromEvent,\n\n\t// Validations\n\tValidateMinAreaSquareMeters,\n\tValidateMaxAreaSquareMeters,\n\tValidateNotSelfIntersecting,\n\tValidationReasons,\n};\n"],"names":["UpdateTypes","SELECT_PROPERTIES","SELECTED","MID_POINT","SELECTION_POINT_FEATURE_ID","SELECTION_POINT","COMMON_PROPERTIES","MODE","CURRENTLY_DRAWING","EDITED","CLOSING_POINT","SNAPPING_POINT","COORDINATE_POINT","COORDINATE_POINT_FEATURE_ID","COORDINATE_POINT_IDS","PROVISIONAL_COORDINATE_COUNT","COMMITTED_COORDINATE_COUNT","Z_INDEX","isObject","feature","Boolean","Array","isArray","hasModeProperty","properties","isValidTimestamp","timestamp","isNaN","Date","valueOf","dateIsValid","ModeTypes","ValidationReasonFeatureNotPolygon","ValidationReasonModeMismatch","DefaultPointerEvents","rightClick","contextMenu","leftClick","onDragStart","onDrag","onDragEnd","TerraDrawBaseDrawMode","options","willCallUpdateOptionsInParentClass","_state","this","_styles","pointerEvents","behaviors","validate","pointerDistance","coordinatePrecision","onStyleChange","store","projection","setDoubleClickToZoom","unproject","project","setCursor","type","Drawing","mode","updateOptions","_proto","prototype","_createClass","registerBehaviors","behaviorConfig","styles","_extends","validation","undefined","allowPointerEvent","pointerEvent","event","setDrawing","Error","setStarted","setStopped","register","config","registerOnChange","onChange","onSelect","onDeselect","onFinish","validateFeature","performFeatureValidation","afterFeatureAdded","afterFeatureUpdated","validStoreFeature","isValidId","error","id","geometry","includes","coordinates","valid","reason","isValidStoreFeature","idStrategy","updateType","Provisional","validateModeFeature","modeValidationFn","finishedId","context","deselectedId","selectedId","onKeyDown","onKeyUp","onMouseMove","onClick","setMapDraggability","getHexColorStylingValue","value","defaultValue","getStylingValue","getNumericStylingValue","key","get","set","_","styling","TerraDrawBaseSelectMode","_TerraDrawBaseDrawMod","_this","_len","arguments","length","args","_key","call","apply","concat","Select","_inheritsLoose","haversineDistanceKilometers","pointOne","pointTwo","toRadians","latOrLng","Math","PI","phiOne","lambdaOne","phiTwo","deltaPhi","deltalambda","a","sin","cos","atan2","sqrt","earthRadius","degreesToRadians","degrees","lengthToRadians","distance","radiansToDegrees","radians","limitPrecision","num","decimalLimit","decimals","pow","round","RADIANS_TO_DEGREES","DEGREES_TO_RADIANS","R","lngLatToWebMercatorXY","lng","lat","x","y","log","tan","webMercatorXYToLngLat","atan","exp","destination","origin","bearing","longitude1","latitude1","bearingRad","latitude2","asin","circle","center","radiusKilometers","steps","i","circleCoordinate","push","selfIntersects","coord","output","ring0","edge0","ring1","edge1","ifInteresctionAddToOutput","isOutside","frac","frac1","start0","end0","start1","end1","intersection","equalArrays","x0","y0","x1","y1","x2","y2","x3","y3","denom","intersect","toString","array1","array2","coordinatePrecisionIsValid","coordinate","getDecimalPlaces","coordinateIsValid","Infinity","current","precision","ValidationReasonFeatureHasHoles","ValidationReasonFeatureLessThanFourCoordinates","ValidationReasonFeatureHasInvalidCoordinates","ValidationReasonFeatureCoordinatesNotClosed","ValidatePolygonFeature","coordinateOne","coordinateTwo","ValidateNonIntersectingPolygonFeature","validatePolygonFeature","defaultKeyEvents","cancel","finish","defaultCursors","start","TerraDrawCircleMode","clickCount","currentCircleId","keyEvents","cursors","startingRadiusKilometers","cursorMovedAfterInitialCursorDown","close","updateProperty","property","currentGeometry","getGeometryCopy","Finish","state","action","stop","cleanUp","button","isContextMenu","_properties","startingCircle","_this$store$create","create","updateCircle","cleanUpId","_unused","styleFeature","getDefaultStyling","polygonFillColor","polygonOutlineColor","polygonOutlineWidth","polygonFillOpacity","pointColor","pointOutlineColor","pointOutlineWidth","pointWidth","lineStringColor","lineStringWidth","zIndex","fillColor","outlineColor","outlineWidth","fillOpacity","_this2","baseValidatedFeature","updatedCircle","newRadius","distortion","source","target","geodesicDistance","_lngLatToWebMercatorX","_lngLatToWebMercatorX2","calculateWebMercatorDistortion","radiusMeters","angle","dx","dy","_webMercatorXYToLngLa","circleWebMercator","updateGeometry","cartesianDistance","ensureRightHandRule","polygon","isFollowingRightHandRule","outerRing","sum","_outerRing$i","_outerRing","followsRightHandRule","reverse","TerraDrawFreehandMode","startingClick","currentId","closingPointId","minDistance","preventPointsNearClose","autoClose","autoCloseTimeout","hasLeftStartingPoint","preventNewFeature","correctedGeometry","currentLineGeometry","_currentLineGeometry$","_this$project","previousLat","containerX","containerY","_currentLineGeometry$2","_this$project2","setTimeout","pop","newGeometry","_properties2","cleanUpClosingPointId","closingPointWidth","closingPointColor","closingPointOutlineColor","closingPointOutlineWidth","_this3","TerraDrawModeBehavior","_ref","createBBoxFromPoint","point","halfDist","map","c","ClickBoundingBoxBehavior","_TerraDrawModeBehavio","PixelDistanceBehavior","measure","clickEvent","secondCoordinate","CoordinateSnappingBehavior","pixelDistance","clickBoundingBox","getSnappableCoordinateFirstClick","getSnappable","getSnappableCoordinate","currentFeatureId","filter","bbox","features","search","closest","featureId","featureCoordinateIndex","minDist","forEach","coordIndex","dist","webMercatorDestination","end","lon1","lon2","lat1","lat2","b","webMercatorBearing","_ref2","deltaX","deltaY","normalizeBearing","lineSliceAlong","coords","startDist","stopDist","overshot","direction","interpolated","slice","origCoordsLength","travelled","last","toDegrees","InsertCoordinatesBehavior","generateInsertionCoordinates","segmentLength","line","lineLength","numberOfSegments","Number","isInteger","floor","segments","outline","limitCoordinates","generateInsertionGeodesicCoordinates","numberOfPoints","points","d","f","A","B","z","lon","generateGreatCircleCoordinates","coordinatesIdentical","ValidateLineStringFeature","magnitude","v","v1","v2","theta","v2y","v1z","dot","acos","min","max","lngLatToVector","vectorToLngLat","LineSnappingBehavior","snappable","boundingBox","nearest","lines","lngLat","inputCoordinate","_step","pointA","pointB","lineVector","targetVector","dotProduct","t","closestPoint","closestDistance","lineIndex","_iterator","_createForOfIteratorHelperLoose","done","startPosition","stopPosition","intersectPosition","intersectDistance","_findNearestPointOnLi","indexOf","webMercatorNearestPointOnLine","posA","posB","posC","C","Cx","Cy","Cz","_cross","v1y","v2z","v2x","v1x","D","E","F","g","h","I1","I2","angleAB","angleAI1","angleBI1","angleAI2","angleBI2","I","nearestPointOnLine","dragStart","dragEnd","TerraDrawLineStringMode","currentCoordinate","snapping","mouseMove","insertCoordinates","lastCommittedCoordinates","snappedPointId","lastMouseMoveEvent","editable","editedFeatureId","editedFeatureCoordinateIndex","editedSnapType","editedInsertIndex","editedPointId","coordinateSnapping","insertPoint","lineSnapping","updateSnappedCoordinate","snappedCoordinate","snapCoordinate","updateGeometries","Commit","closingPointCoordinate","updatedGeometry","geometries","generateInsertCoordinates","startCoord","endCoord","strategy","segmentDistance","insertedCoordinates","createLine","startingCoord","createdId","firstUpdateToLine","updatedCoord","_properties3","currentCoordinates","_this$store$create3","initialLineCoordinates","updateToLine","cursorXY","updatedLineCoordinates","_currentCoordinates","onRightClick","_this$coordinateSnapp","lineStringFilter","coordinateIndex","splice","onLeftClick","updatedCoordinate","lineSnapped","coordinateSnapped","_properties4","_this$store$create4","featureCopy","newLineStringGeometry","getPropertiesCopy","cleanupClosingPointId","isClosingPoint","snappingPointColor","snappingPointWidth","snappingPointOutlineColor","snappingPointOutlineWidth","_this4","_this$snapping","_this$snapping2","_this$snapping3","snapped","_this5","toLine","toCoordinate","toCustom","getCurrentGeometrySnapshot","ValidationReasonFeatureNotPoint","ValidationReasonFeatureInvalidCoordinates","ValidationReasonFeatureInvalidCoordinatePrecision","ValidatePointFeature","TerraDrawPointMode","nearestPointFeature","getNearestPointFeature","isEdited","editedPointWidth","editedPointColor","editedPointOutlineColor","editedPointOutlineWidth","clickedFeature","distanceToFeature","ClosingPointsBehavior","_startEndPoints","selectedCoords","ids","update","updatedCoordinates","opening","closing","distancePrevious","isClosing","isPreviousClosing","CoordinatePointBehavior","createOrUpdate","existingFeature","existingProperties","existingFeatureProps","existingCoordinatePointIds","coordinatePointIds","every","has","existingCoordinates","existingCoordinatePoints","deleteCoordinatePoints","createPoints","setFeatureCoordinatePoints","existingPoints","deletePointsByFeatureIds","deleteIfPresent","getUpdated","featureProperties","index","coordinatePoints","TerraDrawPolygonMode","showCoordinatePoints","closingPoints","copyAllWhere","featuresWithCoordinates","currentPolygonCoordinates","updatePolygonGeometry","epsilon","offset","_this$closingPoints$i","polygonFilter","shift","newId","currentPolygonGeometry","_this$closingPoints$i2","updatedPolygon","featureCoordinates","newPolygonGeometry","editedPoint","coordinatePoint","pointType","styleMap","width","color","closingPoint","snappingPoint","coordinatePointWidth","coordinatePointColor","coordinatePointOutlineColor","coordinatePointOutlineWidth","_this6","TerraDrawRectangleMode","currentRectangleId","updateRectangle","firstCoord","TerraDrawRenderMode","modeName","Render","validationResult","validatedFeature","featureIsValid","rhumbBearing","from","to","phi1","phi2","deltaLambda","deltaPsi","bear360","rhumbDestination","distanceMeters","distanceInMeters","abs","delta","lambda1","DeltaPhi","DeltaPsi","q","midpointCoordinate","coordinates1","coordinates2","projectedCoordinateOne","projectedCoordinateTwo","_unproject","geodesicMidpointCoordinate","midpoint","getMidPointCoordinates","featureCoords","midPointCoords","mid","MidPointBehavior","selectionPointBehavior","coordinatePointBehavior","_midPoints","insert","midPointId","midPoint","_this$store$getProper","midPointFeatureId","midPointSegment","getMidPoints","updatedMidPointCoord","SelectionPointBehavior","_selectionPoints","geometryType","selectionPoints","getCoordinatesAsPoints","getOneUpdated","pointInPolygon","rings","p","p1","p2","inside","len","ring","j","len2","k","pixelDistanceToLine","linePointOne","linePointTwo","square","dist2","w","l2","distToSegmentSquared","FeatureAtPointerEventBehavior","createClickBoundingBox","find","hasSelection","clickedPoint","clickedPointDistance","clickedLineString","clickedLineStringDistance","clickedMidPoint","clickedMidPointDistance","clickedPolygon","selectionPoint","nextCoord","distanceToLine","DragFeatureBehavior","featuresAtCursorEvent","midPoints","draggedFeatureId","dragPosition","startDragging","stopDragging","isDragging","canDrag","drag","cursorCoord","updatedCoords","upToCoord","updatedLng","updatedLat","webMercatorDragPosition","webMercatorCursorCoord","webMercatorCoordinate","updatedSelectionPoints","updatedMidPoints","updatedCoordinatePoints","DragCoordinateBehavior","draggedCoordinate","getClosestCoordinate","geomCoordinates","closestCoordinate","isFirstOrLastPolygonCoord","getDraggableIndex","draggedFeature","allowSelfIntersection","lastCoordIndex","updatedSelectionPoint","centroid","geojson","xSum","ySum","transformRotateWebMercator","angleRad","webMercatorCoords","reduce","acc","rotatedCoordinates","webMercatorCentroid","webMercatorCoordinates","area","centroidX","centroidY","n","_webMercatorCoordinat","_webMercatorCoordinat2","crossProduct","calculatePolygonCentroid","lineString","totalX","totalY","_lineString$i","calculateLineStringMidpoint","RotateFeatureBehavior","lastBearing","selectedGeometry","selectedGeometryCentroid","selectedGeometryWebMercatorCentroid","reset","rotate","mouseCoord","cursorWebMercator","pivot","pointCoords","finalAngle","DeltaLambda","rhumbDistance","newCoords","transformRotate","ScaleFeatureBehavior","dragCoordinateResizeBehavior","scale","transformScaleWebMercatorCoordinates","originX","originY","xScale","yScale","DragCoordinateResizeBehavior","minimumScale","boundingBoxMaps","opposite","isValidDragWebMercator","distanceX","distanceY","getSelectedFeatureDataWebMercator","getFeature","getNormalisedCoordinates","getBBoxWebMercator","selectedCoordinate","centerWebMercatorDrag","featureData","webMercatorOrigin","webMercatorSelected","closestBBoxIndex","getIndexesWebMercator","webMercatorCursor","scaleWebMercator","centerFixedWebMercatorDrag","scaleFixedWebMercator","oppositeFixedWebMercatorDrag","_this$getIndexesWebMe3","oppositeBboxIndex","oppositeWebMercatorDrag","_this$getIndexesWebMe4","cursorDistanceX","cursorDistanceY","validateScale","performWebMercatorScale","validX","MAX_SAFE_INTEGER","validY","_ref3","west","south","east","north","selectedXY","closestIndex","resizeOption","deselect","delete","pointerOver","insertMidpoint","TerraDrawSelectMode","_TerraDrawBaseSelectM","allowManualDeselection","dragEventThrottle","dragEventCount","selected","flags","validations","coordinateSnap","featuresAtMouseEvent","dragFeature","dragCoordinate","rotateFeature","scaleFeature","dragCoordinateResizeFeature","lineSnap","selectFeature","select","setSelecting","deselectFeature","updateSelectedFeatures","deleteSelected","clickedSelectionPointProps","clickedFeatureDistance","selectionPointFeatureId","modeFlags","deletable","deletePoints","midpoints","fromCursor","previouslySelectedId","_this$store$getGeomet","_this$featuresAtMouse","canScale","heldKeys","canRotate","preventDefaultKeyEvent","isRotationKeys","isScaleKeys","preventDefault","draggable","resizable","draggableCoordinateIndex","draggedMidPoint","draggableCoordinateIndexAfterInsert","canSelfIntersect","selfIntersectable","rotateable","scaleable","_modeFlags$feature","snapOptions","nearbyMidPoint","nearbySelectionPoint","featureUnderPointer","selectionPointColor","selectionPointOutlineColor","selectionPointWidth","selectionPointOutlineWidth","midPointColor","midPointOutlineColor","midPointWidth","midPointOutlineWidth","selectedPolygonColor","selectedPolygonOutlineWidth","selectedPolygonOutlineColor","selectedPolygonFillOpacity","selectedLineStringColor","selectedLineStringWidth","selectedPointWidth","selectedPointColor","selectedPointOutlineColor","selectedPointOutlineWidth","_flags$feature","_flags$feature2","TerraDrawStaticMode","Static","quickselect","arr","left","right","compare","m","s","sd","swap","tmp","calcBBox","node","toBBox","distBBox","children","destNode","createNode","minX","minY","maxX","maxY","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","intersects","height","multiSelect","stack","ceil","RBush","maxEntries","_maxEntries","_minEntries","data","clear","result","nodesToSearch","childBBox","_all","collides","load","_build","_splitRoot","tmpNode","_insert","item","remove","parent","path","indexes","goingUp","_condense","compareMinX","compareMinY","items","N","M","N2","N1","right2","right3","_chooseSubtree","level","minArea","minEnlargement","targetNode","enlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","bbox2","overlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","SpatialIndex","tree","idToNode","nodeToId","Map","setMaps","longitudes","latitudes","minLat","maxLat","String","seenIds","Set","add","defaultIdStrategy","getId","replace","r","random","GeoJSONStore","tracked","spatialIndex","_onChange","clone","obj","JSON","parse","stringify","featureValidation","clonedInputFeatures","createdFeatures","createdAt","updatedAt","changes","change","propertiesToUpdate","geometriesToUpdate","_ref4","createdProperties","copy","copyAll","_this7","Object","keys","equals","_this8","size","polygonAreaSquareMeters","total","ringArea","FACTOR","PI_OVER_180","coordsLength","ValidationReasonFeatureLessThanMinSize","ValidateMinAreaSquareMeters","minSize","ValidateMaxAreaSquareMeters","maxSize","ValidationReasonFeatureNotPolygonOrLineString","ValidationReasonFeatureSelfIntersects","ValidateNotSelfIntersecting","calculateRelativeAngle","bearingAB","relativeAngle","TerraDrawAngledRectangleMode","lineStart","lineEnd","firstCoordinate","ACloserThanC","hypotenuse","adjacent","rectangleAngle","thirdCoordinateXY","fourthCoordinateXY","thirdCoordinate","fourthCoordinate","isClockwiseWebMercator","secondCoord","thirdCoord","TerraDrawSectorMode","arcPoints","arcCoordOne","arcCoordTwo","webMercatorCenter","webMercatorArcCoordOne","webMercatorArcCoordTwo","clockwise","deltaBearing","radius","startBearing","endBearing","normalizedStart","normalizedEnd","bearingStep","pointOnArc","TerraDrawSensorMode","currentInitialArcId","currentStartingPointId","finishedCurrentStartingPointId","finishedInitialArcId","finishedCurrentId","updateLineStringGeometry","lastCoord","webMercatorCoordOne","webMercatorCoordTwo","innerRadius","radiusCalculationPosition","cursorBearing","normalizedCursor","notInSector","getDeltaBearing","finalArc","_webMercatorXYToLngLa2","unshift","_this$store$create2","centerPointColor","centerPointWidth","centerPointOutlineColor","centerPointOutlineWidth","AdapterListener","name","callback","unregister","registered","TerraDrawBaseAdapter","_nextKeyUpIsContextMenu","_minPixelDragDistance","_minPixelDragDistanceDrawing","_minPixelDragDistanceSelecting","_lastDrawEvent","_coordinatePrecision","_heldKeys","_listeners","_dragState","_currentModeCallbacks","minPixelDragDistance","minPixelDragDistanceSelecting","minPixelDragDistanceDrawing","getButton","getMapElementXYPosition","_mapElement$getBoundi","getMapEventElement","getBoundingClientRect","clientX","clientY","top","getDrawEventFromEvent","latLng","getLngLatFromEvent","_this$getMapElementXY","callbacks","getAdapterListeners","listener","getCoordinatePrecision","isPrimary","drawEvent","addEventListener","removeEventListener","lastEventXY","currentEventXY","modeState","getState","pixelDistanceToCheck","enabled","setDraggability","bind","ValidationReasons","TerraDrawFreehandLineStringMode","closingDistance","isValidJSONValue","isFinite","RegExp","proto","getPrototypeOf","ArrayBuffer","isView","DataView","TerraDraw","_modes","_mode","_adapter","_enabled","_store","_eventListeners","_instanceSelectMode","adapter","duplicateModeTracker","modesMap","modes","modeMap","currentMode","modeKeys","static","ready","getChanged","changed","unchanged","_getChanged","render","created","deletedIds","updated","getModeStyles","_getChanged2","_getChanged3","modeId","checkEnabled","modeStyles","featuresAtLocation","ignoreSelectFeatures","ignoreCoordinatePoints","ignoreCurrentlyDrawing","ignoreClosingPoints","inputPoint","pointCoordinates","pointXY","includePolygonsWithinPointerDistance","projectedStart","projectedEnd","addClosestCoordinateInfoToProperties","closestCoordinateIndexToEvent","closestCoordinatePixelDistanceToEvent","closestCoordinateDistanceKmToEvent","getSelectModeOrThrow","selectMode","getSelectMode","switchToSelectMode","getMode","setMode","isGuidanceFeature","setModeStyles","updateModeOptions","getSnapshot","getSnapshotFeature","getModeState","removeFeatures","coordinatePointsToDelete","getFeatureId","hasFeature","checkIsReservedProperty","propertyName","values","updateFeatureProperties","entries","updateFeatureGeometry","modeToUpdate","updatedFeature","featureIsSelected","selectModePresent","transformFeatureGeometry","transformation","addFeatures","featureMode","modeToAddTo","onReady","onClear","getFeaturesAtLngLat","getFeaturesAtPointerEvent","on","listeners","off"],"mappings":"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"}